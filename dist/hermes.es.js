import xge, { useState as nr, useEffect as Pg, useRef as Yr, useMemo as cE, Component as RE, createRef as zp, forwardRef as TAe } from "react";
import { BufferGeometry as Qp, Float32BufferAttribute as bc, OrthographicCamera as SO, Texture as IV, Scene as _ge, MeshBasicMaterial as Tg, Mesh as Dt, LinearSRGBColorSpace as xE, ObjectLoader as CAe, AnimationMixer as PAe, AnimationClip as AAe, Matrix4 as IE, AlwaysStencilFunc as wpe, ReplaceStencilOp as Wv, NotEqualStencilFunc as Epe, EqualStencilFunc as Tpe, KeepStencilOp as Kv, NormalBlending as Sge, AddEquation as NE, SrcAlphaFactor as $O, OneMinusSrcAlphaFactor as WO, CustomBlending as KO, OneFactor as YO, DstColorFactor as x6, OneMinusDstColorFactor as _6, WebGLRenderTarget as wge, RGBAFormat as kAe, EventDispatcher as Ege, RepeatWrapping as Cpe, Color as Ag, ColorManagement as _b, FrontSide as MAe, BackSide as Tge, DoubleSide as S6, ZeroFactor as Cge, SrcColorFactor as Pge, OneMinusSrcColorFactor as Age, DstAlphaFactor as kge, OneMinusDstAlphaFactor as Mge, SrcAlphaSaturateFactor as RAe, ConstantColorFactor as Rge, OneMinusConstantColorFactor as Ige, ConstantAlphaFactor as Nge, OneMinusConstantAlphaFactor as Oge, SubtractEquation as IAe, ReverseSubtractEquation as NAe, MinEquation as OAe, MaxEquation as DAe, NoBlending as FAe, AdditiveBlending as BAe, SubtractiveBlending as LAe, MultiplyBlending as jAe, Line as mc, LineBasicMaterial as w6, Controls as Dge, Vector3 as Vt, MOUSE as kb, TOUCH as Sb, Quaternion as xa, Spherical as NV, Vector2 as As, Ray as UAe, Plane as zAe, MathUtils as VAe, ShaderMaterial as Fge, GLSL3 as GAe, PlaneGeometry as Bge, Raycaster as _E, Object3D as jb, CylinderGeometry as Vo, BoxGeometry as Ys, OctahedronGeometry as gN, TorusGeometry as ww, SphereGeometry as Lge, Euler as jge, CatmullRomCurve3 as Ppe, Group as qAe, AxesHelper as HAe, MeshDepthMaterial as $Ae, MeshNormalMaterial as WAe, Sphere as KAe, Box3 as YAe, Vector4 as XAe, WebGLRenderer as Zw, PerspectiveCamera as Ape, CameraHelper as QAe, SkinnedMesh as ZAe, SpotLightHelper as JAe, PointLightHelper as eke, HemisphereLightHelper as tke, DirectionalLightHelper as nke, Clock as rke, SkeletonHelper as ike, SRGBColorSpace as kpe, NoToneMapping as Mpe, NoColorSpace as ske, LinearToneMapping as oke, ReinhardToneMapping as ake, CineonToneMapping as lke, ACESFilmicToneMapping as uke, AgXToneMapping as cke, NeutralToneMapping as dke, CustomToneMapping as hke } from "three";
function pke(c, e) {
  for (var t = 0; t < e.length; t++) {
    const n = e[t];
    if (typeof n != "string" && !Array.isArray(n)) {
      for (const i in n)
        if (i !== "default" && !(i in c)) {
          const o = Object.getOwnPropertyDescriptor(n, i);
          o && Object.defineProperty(c, i, o.get ? o : {
            enumerable: !0,
            get: () => n[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(c, Symbol.toStringTag, { value: "Module" }));
}
const wO = () => {
}, PUe = () => {
};
function EO(c) {
  return c.substring(0, 1).toUpperCase() + c.substring(1);
}
function fke(c) {
  const e = JSON.stringify(c);
  return navigator.clipboard.writeText(e), e;
}
function cs() {
  return Math.round(Math.random() * 1e6).toString();
}
function mke(c) {
  return c.r !== void 0 && c.g !== void 0 && c.b !== void 0;
}
function Rpe(c) {
  const e = Math.round(c.r * 255), t = Math.round(c.g * 255), n = Math.round(c.b * 255), i = (f) => {
    const v = f.toString(16);
    return v.length === 1 ? "0" + v : v;
  }, o = i(e), l = i(t), p = i(n);
  return "#" + o + l + p;
}
function r5(c, e, t, n) {
  return new (t || (t = Promise))(function(i, o) {
    function l(v) {
      try {
        f(n.next(v));
      } catch (_) {
        o(_);
      }
    }
    function p(v) {
      try {
        f(n.throw(v));
      } catch (_) {
        o(_);
      }
    }
    function f(v) {
      var _;
      v.done ? i(v.value) : (_ = v.value, _ instanceof t ? _ : new t(function(E) {
        E(_);
      })).then(l, p);
    }
    f((n = n.apply(c, [])).next());
  });
}
const gke = ["geforce 320m", "geforce 8600", "geforce 8600m gt", "geforce 8800 gs", "geforce 8800 gt", "geforce 9400", "geforce 9400m g", "geforce 9400m", "geforce 9600m gt", "geforce 9600m", "geforce fx go5200", "geforce gt 120", "geforce gt 130", "geforce gt 330m", "geforce gtx 285", "google swiftshader", "intel g41", "intel g45", "intel gma 4500mhd", "intel gma x3100", "intel hd 3000", "intel q45", "legacy", "mali-2", "mali-3", "mali-4", "quadro fx 1500", "quadro fx 4", "quadro fx 5", "radeon hd 2400", "radeon hd 2600", "radeon hd 4670", "radeon hd 4850", "radeon hd 4870", "radeon hd 5670", "radeon hd 5750", "radeon hd 6290", "radeon hd 6300", "radeon hd 6310", "radeon hd 6320", "radeon hd 6490m", "radeon hd 6630m", "radeon hd 6750m", "radeon hd 6770m", "radeon hd 6970m", "sgx 543", "sgx543"];
function Ipe(c) {
  return c = c.toLowerCase().replace(/.*angle ?\((.+)\)(?: on vulkan [0-9.]+)?$/i, "$1").replace(/\s(\d{1,2}gb|direct3d.+$)|\(r\)| \([^)]+\)$/g, "").replace(/(?:vulkan|opengl) \d+\.\d+(?:\.\d+)?(?: \((.*)\))?/, "$1");
}
const Uge = typeof window > "u", gc = (() => {
  if (Uge) return;
  const { userAgent: c, platform: e, maxTouchPoints: t } = window.navigator, n = /(iphone|ipod|ipad)/i.test(c), i = e === "iPad" || e === "MacIntel" && t > 0 && !window.MSStream;
  return { isIpad: i, isMobile: /android/i.test(c) || n || i, isSafari12: /Version\/12.+Safari/.test(c), isFirefox: /Firefox/.test(c) };
})();
function yke(c, e, t) {
  if (!t) return [e];
  const n = function(v) {
    const _ = `
    precision highp float;
    attribute vec3 aPosition;
    varying float vvv;
    void main() {
      vvv = 0.31622776601683794;
      gl_Position = vec4(aPosition, 1.0);
    }
  `, E = `
    precision highp float;
    varying float vvv;
    void main() {
      vec4 enc = vec4(1.0, 255.0, 65025.0, 16581375.0) * vvv;
      enc = fract(enc);
      enc -= enc.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);
      gl_FragColor = enc;
    }
  `, A = v.createShader(35633), I = v.createShader(35632), j = v.createProgram();
    if (!(I && A && j)) return;
    v.shaderSource(A, _), v.shaderSource(I, E), v.compileShader(A), v.compileShader(I), v.attachShader(j, A), v.attachShader(j, I), v.linkProgram(j), v.detachShader(j, A), v.detachShader(j, I), v.deleteShader(A), v.deleteShader(I), v.useProgram(j);
    const q = v.createBuffer();
    v.bindBuffer(34962, q), v.bufferData(34962, new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), 35044);
    const L = v.getAttribLocation(j, "aPosition");
    v.vertexAttribPointer(L, 3, 5126, !1, 0, 0), v.enableVertexAttribArray(L), v.clearColor(1, 1, 1, 1), v.clear(16384), v.viewport(0, 0, 1, 1), v.drawArrays(4, 0, 3);
    const V = new Uint8Array(4);
    return v.readPixels(0, 0, 1, 1, 6408, 5121, V), v.deleteProgram(j), v.deleteBuffer(q), V.join("");
  }(c), i = "801621810", o = "8016218135", l = "80162181161", p = gc?.isIpad ? [["a7", l, 12], ["a8", o, 15], ["a8x", o, 15], ["a9", o, 15], ["a9x", o, 15], ["a10", o, 15], ["a10x", o, 15], ["a12", i, 15], ["a12x", i, 15], ["a12z", i, 15], ["a14", i, 15], ["a15", i, 15], ["m1", i, 15], ["m2", i, 15]] : [["a7", l, 12], ["a8", o, 12], ["a9", o, 15], ["a10", o, 15], ["a11", i, 15], ["a12", i, 15], ["a13", i, 15], ["a14", i, 15], ["a15", i, 15], ["a16", i, 15], ["a17", i, 15]];
  let f;
  return n === "80162181255" ? f = p.filter(([, , v]) => v >= 14) : (f = p.filter(([, v]) => v === n), f.length || (f = p)), f.map(([v]) => `apple ${v} gpu`);
}
class Npe extends Error {
  constructor(e) {
    super(e), Object.setPrototypeOf(this, new.target.prototype);
  }
}
const i5 = [], Ope = [];
function vke(c, e) {
  if (c === e) return 0;
  const t = c;
  c.length > e.length && (c = e, e = t);
  let n = c.length, i = e.length;
  for (; n > 0 && c.charCodeAt(~-n) === e.charCodeAt(~-i); ) n--, i--;
  let o, l = 0;
  for (; l < n && c.charCodeAt(l) === e.charCodeAt(l); ) l++;
  if (n -= l, i -= l, n === 0) return i;
  let p, f, v = 0, _ = 0, E = 0;
  for (; _ < n; ) Ope[_] = c.charCodeAt(l + _), i5[_] = ++_;
  for (; E < i; ) for (o = e.charCodeAt(l + E), p = E++, v = E, _ = 0; _ < n; _++) f = o === Ope[_] ? p : p + 1, p = i5[_], v = i5[_] = p > v ? f > v ? v + 1 : f : f > p ? p + 1 : f;
  return v;
}
function bke(c) {
  return c != null;
}
const xke = ({ mobileTiers: c = [0, 15, 30, 60], desktopTiers: e = [0, 15, 30, 60], override: t = {}, glContext: n, failIfMajorPerformanceCaveat: i = !1, benchmarksURL: o = "https://unpkg.com/detect-gpu@5.0.70/dist/benchmarks" } = {}) => r5(void 0, void 0, void 0, function* () {
  const l = {};
  if (Uge) return { tier: 0, type: "SSR" };
  const { isIpad: p = !!gc?.isIpad, isMobile: f = !!gc?.isMobile, screenSize: v = window.screen, loadBenchmarks: _ = (ge) => r5(void 0, void 0, void 0, function* () {
    const _e = yield fetch(`${o}/${ge}`).then((Y) => Y.json());
    if (parseInt(_e.shift().split(".")[0], 10) < 4) throw new Npe("Detect GPU benchmark data is out of date. Please update to version 4x");
    return _e;
  }) } = t;
  let { renderer: E } = t;
  const A = (ge, _e, Y, Fe, Me) => ({ device: Me, fps: Fe, gpu: Y, isMobile: f, tier: ge, type: _e });
  let I, j = "";
  if (E) E = Ipe(E), I = [E];
  else {
    const ge = n || function(Y, Fe = !1) {
      const Me = { alpha: !1, antialias: !1, depth: !1, failIfMajorPerformanceCaveat: Fe, powerPreference: "high-performance", stencil: !1 };
      Y && delete Me.powerPreference;
      const $ = window.document.createElement("canvas"), dt = $.getContext("webgl", Me) || $.getContext("experimental-webgl", Me);
      return dt ?? void 0;
    }(gc?.isSafari12, i);
    if (!ge) return A(0, "WEBGL_UNSUPPORTED");
    const _e = gc?.isFirefox ? null : ge.getExtension("WEBGL_debug_renderer_info");
    if (E = _e ? ge.getParameter(_e.UNMASKED_RENDERER_WEBGL) : ge.getParameter(ge.RENDERER), !E) return A(1, "FALLBACK");
    j = E, E = Ipe(E), I = function(Y, Fe, Me) {
      return Fe === "apple gpu" ? yke(Y, Fe, Me) : [Fe];
    }(ge, E, f);
  }
  const q = (yield Promise.all(I.map(function(ge) {
    var _e;
    return r5(this, void 0, void 0, function* () {
      const Y = ((An) => {
        const pr = f ? ["adreno", "apple", "mali-t", "mali", "nvidia", "powervr", "samsung"] : ["intel", "apple", "amd", "radeon", "nvidia", "geforce", "adreno"];
        for (const Kn of pr) if (An.includes(Kn)) return Kn;
      })(ge);
      if (!Y) return;
      const Fe = `${f ? "m" : "d"}-${Y}${p ? "-ipad" : ""}.json`, Me = l[Fe] = (_e = l[Fe]) !== null && _e !== void 0 ? _e : _(Fe);
      let $;
      try {
        $ = yield Me;
      } catch (An) {
        if (An instanceof Npe) throw An;
        return;
      }
      const dt = function(An) {
        var pr;
        const Kn = (An = An.replace(/\([^)]+\)/, "")).match(/\d+/) || An.match(/(\W|^)([A-Za-z]{1,3})(\W|$)/g);
        return (pr = Kn?.join("").replace(/\W|amd/g, "")) !== null && pr !== void 0 ? pr : "";
      }(ge);
      let wt = $.filter(([, An]) => An === dt);
      wt.length || (wt = $.filter(([An]) => An.includes(ge)));
      const St = wt.length;
      if (St === 0) return;
      const Ct = ge.split(/[.,()\[\]/\s]/g).sort().filter((An, pr, Kn) => pr === 0 || An !== Kn[pr - 1]).join(" ");
      let pe, [Tt, , , , st] = St > 1 ? wt.map((An) => [An, vke(Ct, An[2])]).sort(([, An], [, pr]) => An - pr)[0][0] : wt[0], Zt = Number.MAX_VALUE;
      const { devicePixelRatio: $t } = window, Ht = v.width * $t * v.height * $t;
      for (const An of st) {
        const [pr, Kn] = An, Qo = pr * Kn, _r = Math.abs(Ht - Qo);
        _r < Zt && (Zt = _r, pe = An);
      }
      if (!pe) return;
      const [, , Gn, an] = pe;
      return [Zt, Gn, Tt, an];
    });
  }))).filter(bke).sort(([ge = Number.MAX_VALUE, _e], [Y = Number.MAX_VALUE, Fe]) => ge === Y ? _e - Fe : ge - Y);
  if (!q.length) {
    const ge = gke.find((_e) => E.includes(_e));
    return ge ? A(0, "BLOCKLISTED", ge) : A(1, "FALLBACK", `${E} (${j})`);
  }
  const [, L, V, re] = q[0];
  if (L === -1) return A(0, "BLOCKLISTED", V, L, re);
  const R = f ? c : e;
  let J = 0;
  for (let ge = 0; ge < R.length; ge++) L >= R[ge] && (J = ge);
  return A(J, "BENCHMARK", V, L, re);
});
function _ke(c) {
  let e = 0;
  const t = performance.now();
  function n() {
    e++;
    const i = performance.now();
    if (i - t >= 100) {
      const o = e / ((i - t) / 1e3), l = Math.round(o / 30) * 30;
      c(l);
    } else
      requestAnimationFrame(n);
  }
  requestAnimationFrame(n);
}
function Ske(c = !1, e = !1) {
  return new Promise((t) => {
    xke().then((n) => {
      let i = !1;
      const o = document.createElement("canvas"), l = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      if (i = "transferControlToOffscreen" in o, l) {
        const f = navigator.userAgent.match(/version\/(\d+)/i);
        i = (f ? parseInt(f[1]) : 0) >= 17;
      }
      const p = {
        dpr: devicePixelRatio,
        fps: 30,
        width: innerWidth,
        height: innerHeight,
        mobile: n.isMobile !== void 0 ? n.isMobile : !1,
        supportOffScreenCanvas: i,
        supportWebGPU: !!navigator.gpu,
        quality: "Low",
        dev: c,
        editor: e
      };
      n.tier === 3 ? p.quality = "High" : n.tier === 2 && (p.quality = "Medium"), _ke((f) => {
        p.fps = f, t(p);
      });
    });
  });
}
function dg(c, e, t) {
  return Math.min(e, Math.max(c, t));
}
function OV(c, e, t) {
  return (t - c) / (e - c);
}
function SE(c, e, t) {
  return c * (1 - t) + e * t;
}
function AUe(c, e, t, n, i) {
  return SE(t, n, OV(c, e, i));
}
function kUe(c, e) {
  const t = c - e;
  return Math.sqrt(t * t);
}
function MUe(c, e, t, n) {
  return SE(c, e, 1 - Math.exp(-t * n));
}
function au(c, e = 1) {
  return Number(c.toFixed(e));
}
function RUe(c, e, t, n) {
  return Math.atan2(n - e, t - c);
}
function wke(c, e, t, n) {
  return c === e && t === n;
}
function Eke(c, e, t, n) {
  return 1 / (3 * e * c * c + 2 * t * c + n);
}
function Tke(c, e, t, n, i) {
  return e * (c * c * c) + t * (c * c) + n * c + i;
}
function Cke(c, e, t, n, i) {
  const o = c * c;
  return e * (o * c) + t * o + n * c + i;
}
function IUe(c, e, t, n, i) {
  if (c <= 0) return 0;
  if (c >= 1) return 1;
  if (wke(e, t, n, i)) return c;
  const o = 0, l = 0, p = e, f = t, v = n, _ = i, E = 1, A = 1, I = E - 3 * v + 3 * p - o, j = 3 * v - 6 * p + 3 * o, q = 3 * p - 3 * o, L = o, V = A - 3 * _ + 3 * f - l, re = 3 * _ - 6 * f + 3 * l, R = 3 * f - 3 * l, J = l;
  let ge = c;
  for (let _e = 0; _e < 5; _e++) {
    const Y = Tke(ge, I, j, q, L);
    let Fe = Eke(ge, I, j, q);
    Fe === 1 / 0 && (Fe = c), ge -= (Y - c) * Fe, ge = Math.min(Math.max(ge, 0), 1);
  }
  return Cke(ge, V, re, R, J);
}
const yN = (c) => Math.round(Math.min(1, Math.max(0, c)) * 255).toString(16).padStart(2, "0");
function NUe({ r: c, g: e, b: t, a: n = 1 }) {
  const i = `#${yN(c)}${yN(e)}${yN(t)}`;
  return n < 1 ? `${i}${yN(n)}` : i;
}
var ks = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Pke(c) {
  return c && c.__esModule && Object.prototype.hasOwnProperty.call(c, "default") ? c.default : c;
}
var Jw = { exports: {} }, s5 = {}, Dpe;
function ut() {
  return Dpe || (Dpe = 1, function(c) {
    var e = Object.defineProperty, t = Object.defineProperties, n = Object.getOwnPropertyDescriptors, i = Object.getOwnPropertySymbols, o = Object.prototype.hasOwnProperty, l = Object.prototype.propertyIsEnumerable, p = (K, ae, Pe) => ae in K ? e(K, ae, { enumerable: !0, configurable: !0, writable: !0, value: Pe }) : K[ae] = Pe, f = (K, ae) => {
      for (var Pe in ae || (ae = {}))
        o.call(ae, Pe) && p(K, Pe, ae[Pe]);
      if (i)
        for (var Pe of i(ae))
          l.call(ae, Pe) && p(K, Pe, ae[Pe]);
      return K;
    }, v = (K, ae) => t(K, n(ae)), _ = (K) => e(K, "__esModule", { value: !0 }), E = (K, ae) => {
      _(K);
      for (var Pe in ae)
        e(K, Pe, { get: ae[Pe], enumerable: !0 });
    };
    E(c, {
      Atom: () => my,
      PointerProxy: () => Tf,
      Ticker: () => Au,
      getPointerParts: () => Eu,
      isPointer: () => Oa,
      isPrism: () => Dc,
      iterateAndCountTicks: () => px,
      iterateOver: () => fx,
      pointer: () => vf,
      pointerToPrism: () => xl,
      prism: () => Fc,
      val: () => jc
    });
    var A = Array.isArray, I = A, j = typeof ks == "object" && ks && ks.Object === Object && ks, q = j, L = typeof self == "object" && self && self.Object === Object && self, V = q || L || Function("return this")(), re = V, R = re.Symbol, J = R, ge = Object.prototype, _e = ge.hasOwnProperty, Y = ge.toString, Fe = J ? J.toStringTag : void 0;
    function Me(K) {
      var ae = _e.call(K, Fe), Pe = K[Fe];
      try {
        K[Fe] = void 0;
        var Ye = !0;
      } catch {
      }
      var Kt = Y.call(K);
      return Ye && (ae ? K[Fe] = Pe : delete K[Fe]), Kt;
    }
    var $ = Me, dt = Object.prototype, wt = dt.toString;
    function St(K) {
      return wt.call(K);
    }
    var Ct = St, pe = "[object Null]", Tt = "[object Undefined]", st = J ? J.toStringTag : void 0;
    function Zt(K) {
      return K == null ? K === void 0 ? Tt : pe : st && st in Object(K) ? $(K) : Ct(K);
    }
    var $t = Zt;
    function Ht(K) {
      return K != null && typeof K == "object";
    }
    var Gn = Ht, an = "[object Symbol]";
    function An(K) {
      return typeof K == "symbol" || Gn(K) && $t(K) == an;
    }
    var pr = An, Kn = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Qo = /^\w*$/;
    function _r(K, ae) {
      if (I(K))
        return !1;
      var Pe = typeof K;
      return Pe == "number" || Pe == "symbol" || Pe == "boolean" || K == null || pr(K) ? !0 : Qo.test(K) || !Kn.test(K) || ae != null && K in Object(ae);
    }
    var Ta = _r;
    function fl(K) {
      var ae = typeof K;
      return K != null && (ae == "object" || ae == "function");
    }
    var Ca = fl, Pa = "[object AsyncFunction]", Cc = "[object Function]", Fi = "[object GeneratorFunction]", Ki = "[object Proxy]";
    function ml(K) {
      if (!Ca(K))
        return !1;
      var ae = $t(K);
      return ae == Cc || ae == Fi || ae == Pa || ae == Ki;
    }
    var Qr = ml, Zo = re["__core-js_shared__"], fu = Zo, Jo = function() {
      var K = /[^.]+$/.exec(fu && fu.keys && fu.keys.IE_PROTO || "");
      return K ? "Symbol(src)_1." + K : "";
    }();
    function Pc(K) {
      return !!Jo && Jo in K;
    }
    var Jd = Pc, Si = Function.prototype, eh = Si.toString;
    function to(K) {
      if (K != null) {
        try {
          return eh.call(K);
        } catch {
        }
        try {
          return K + "";
        } catch {
        }
      }
      return "";
    }
    var th = to, Ac = /[\\^$.*+?()[\]{}|]/g, Aa = /^\[object .+?Constructor\]$/, nh = Function.prototype, rh = Object.prototype, ih = nh.toString, mu = rh.hasOwnProperty, sh = RegExp("^" + ih.call(mu).replace(Ac, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function Bi(K) {
      if (!Ca(K) || Jd(K))
        return !1;
      var ae = Qr(K) ? sh : Aa;
      return ae.test(th(K));
    }
    var _o = Bi;
    function ka(K, ae) {
      return K?.[ae];
    }
    var of = ka;
    function Ms(K, ae) {
      var Pe = of(K, ae);
      return _o(Pe) ? Pe : void 0;
    }
    var ds = Ms, kc = ds(Object, "create"), hs = kc;
    function ps() {
      this.__data__ = hs ? hs(null) : {}, this.size = 0;
    }
    var So = ps;
    function oh(K) {
      var ae = this.has(K) && delete this.__data__[K];
      return this.size -= ae ? 1 : 0, ae;
    }
    var Ma = oh, gu = "__lodash_hash_undefined__", ah = Object.prototype, ci = ah.hasOwnProperty;
    function Or(K) {
      var ae = this.__data__;
      if (hs) {
        var Pe = ae[K];
        return Pe === gu ? void 0 : Pe;
      }
      return ci.call(ae, K) ? ae[K] : void 0;
    }
    var lh = Or, uh = Object.prototype, yu = uh.hasOwnProperty;
    function vu(K) {
      var ae = this.__data__;
      return hs ? ae[K] !== void 0 : yu.call(ae, K);
    }
    var ch = vu, af = "__lodash_hash_undefined__";
    function lf(K, ae) {
      var Pe = this.__data__;
      return this.size += this.has(K) ? 0 : 1, Pe[K] = hs && ae === void 0 ? af : ae, this;
    }
    var dh = lf;
    function be(K) {
      var ae = -1, Pe = K == null ? 0 : K.length;
      for (this.clear(); ++ae < Pe; ) {
        var Ye = K[ae];
        this.set(Ye[0], Ye[1]);
      }
    }
    be.prototype.clear = So, be.prototype.delete = Ma, be.prototype.get = lh, be.prototype.has = ch, be.prototype.set = dh;
    var ht = be;
    function Pt() {
      this.__data__ = [], this.size = 0;
    }
    var Wt = Pt;
    function vn(K, ae) {
      return K === ae || K !== K && ae !== ae;
    }
    var qn = vn;
    function fn(K, ae) {
      for (var Pe = K.length; Pe--; )
        if (qn(K[Pe][0], ae))
          return Pe;
      return -1;
    }
    var Gt = fn, rr = Array.prototype, Sr = rr.splice;
    function fr(K) {
      var ae = this.__data__, Pe = Gt(ae, K);
      if (Pe < 0)
        return !1;
      var Ye = ae.length - 1;
      return Pe == Ye ? ae.pop() : Sr.call(ae, Pe, 1), --this.size, !0;
    }
    var Li = fr;
    function ea(K) {
      var ae = this.__data__, Pe = Gt(ae, K);
      return Pe < 0 ? void 0 : ae[Pe][1];
    }
    var wo = ea;
    function di(K) {
      return Gt(this.__data__, K) > -1;
    }
    var fs = di;
    function gl(K, ae) {
      var Pe = this.__data__, Ye = Gt(Pe, K);
      return Ye < 0 ? (++this.size, Pe.push([K, ae])) : Pe[Ye][1] = ae, this;
    }
    var uf = gl;
    function Ra(K) {
      var ae = -1, Pe = K == null ? 0 : K.length;
      for (this.clear(); ++ae < Pe; ) {
        var Ye = K[ae];
        this.set(Ye[0], Ye[1]);
      }
    }
    Ra.prototype.clear = Wt, Ra.prototype.delete = Li, Ra.prototype.get = wo, Ra.prototype.has = fs, Ra.prototype.set = uf;
    var Ng = Ra, hh = ds(re, "Map"), Og = hh;
    function Jb() {
      this.size = 0, this.__data__ = {
        hash: new ht(),
        map: new (Og || Ng)(),
        string: new ht()
      };
    }
    var Eo = Jb;
    function Mc(K) {
      var ae = typeof K;
      return ae == "string" || ae == "number" || ae == "symbol" || ae == "boolean" ? K !== "__proto__" : K === null;
    }
    var ex = Mc;
    function Rc(K, ae) {
      var Pe = K.__data__;
      return ex(ae) ? Pe[typeof ae == "string" ? "string" : "hash"] : Pe.map;
    }
    var yl = Rc;
    function cf(K) {
      var ae = yl(this, K).delete(K);
      return this.size -= ae ? 1 : 0, ae;
    }
    var Dg = cf;
    function Ic(K) {
      return yl(this, K).get(K);
    }
    var Fg = Ic;
    function Bg(K) {
      return yl(this, K).has(K);
    }
    var df = Bg;
    function Lg(K, ae) {
      var Pe = yl(this, K), Ye = Pe.size;
      return Pe.set(K, ae), this.size += Pe.size == Ye ? 0 : 1, this;
    }
    var jg = Lg;
    function ta(K) {
      var ae = -1, Pe = K == null ? 0 : K.length;
      for (this.clear(); ++ae < Pe; ) {
        var Ye = K[ae];
        this.set(Ye[0], Ye[1]);
      }
    }
    ta.prototype.clear = Eo, ta.prototype.delete = Dg, ta.prototype.get = Fg, ta.prototype.has = df, ta.prototype.set = jg;
    var Ug = ta, tx = "Expected a function";
    function Nc(K, ae) {
      if (typeof K != "function" || ae != null && typeof ae != "function")
        throw new TypeError(tx);
      var Pe = function() {
        var Ye = arguments, Kt = ae ? ae.apply(this, Ye) : Ye[0], zn = Pe.cache;
        if (zn.has(Kt))
          return zn.get(Kt);
        var Ei = K.apply(this, Ye);
        return Pe.cache = zn.set(Kt, Ei) || zn, Ei;
      };
      return Pe.cache = new (Nc.Cache || Ug)(), Pe;
    }
    Nc.Cache = Ug;
    var zg = Nc, bu = 500;
    function ph(K) {
      var ae = zg(K, function(Ye) {
        return Pe.size === bu && Pe.clear(), Ye;
      }), Pe = ae.cache;
      return ae;
    }
    var Vg = ph, xu = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ia = /\\(\\)?/g, Gg = Vg(function(K) {
      var ae = [];
      return K.charCodeAt(0) === 46 && ae.push(""), K.replace(xu, function(Pe, Ye, Kt, zn) {
        ae.push(Kt ? zn.replace(Ia, "$1") : Ye || Pe);
      }), ae;
    }), nx = Gg;
    function qg(K, ae) {
      for (var Pe = -1, Ye = K == null ? 0 : K.length, Kt = Array(Ye); ++Pe < Ye; )
        Kt[Pe] = ae(K[Pe], Pe, K);
      return Kt;
    }
    var Hg = qg, _u = J ? J.prototype : void 0, hf = _u ? _u.toString : void 0;
    function pf(K) {
      if (typeof K == "string")
        return K;
      if (I(K))
        return Hg(K, pf) + "";
      if (pr(K))
        return hf ? hf.call(K) : "";
      var ae = K + "";
      return ae == "0" && 1 / K == -1 / 0 ? "-0" : ae;
    }
    var $g = pf;
    function Wg(K) {
      return K == null ? "" : $g(K);
    }
    var Kg = Wg;
    function rx(K, ae) {
      return I(K) ? K : Ta(K, ae) ? [K] : nx(Kg(K));
    }
    var ix = rx;
    function Yg(K) {
      if (typeof K == "string" || pr(K))
        return K;
      var ae = K + "";
      return ae == "0" && 1 / K == -1 / 0 ? "-0" : ae;
    }
    var Su = Yg;
    function fh(K, ae) {
      ae = ix(ae, K);
      for (var Pe = 0, Ye = ae.length; K != null && Pe < Ye; )
        K = K[Su(ae[Pe++])];
      return Pe && Pe == Ye ? K : void 0;
    }
    var Na = fh;
    function na(K, ae, Pe) {
      var Ye = K == null ? void 0 : Na(K, ae);
      return Ye === void 0 ? Pe : Ye;
    }
    var Xg = na;
    function mh(K, ae) {
      return function(Pe) {
        return K(ae(Pe));
      };
    }
    var sx = mh, ff = sx(Object.getPrototypeOf, Object), Qg = ff, Zg = "[object Object]", ox = Function.prototype, ax = Object.prototype, mf = ox.toString, lx = ax.hasOwnProperty, Jg = mf.call(Object);
    function gf(K) {
      if (!Gn(K) || $t(K) != Zg)
        return !1;
      var ae = Qg(K);
      if (ae === null)
        return !0;
      var Pe = lx.call(ae, "constructor") && ae.constructor;
      return typeof Pe == "function" && Pe instanceof Pe && mf.call(Pe) == Jg;
    }
    var ey = gf;
    function ty(K) {
      var ae = K == null ? 0 : K.length;
      return ae ? K[ae - 1] : void 0;
    }
    var yf = ty, Oc = /* @__PURE__ */ new WeakMap(), ny = /* @__PURE__ */ new WeakMap(), wu = Symbol("pointerMeta"), ry = {
      get(K, ae) {
        if (ae === wu)
          return Oc.get(K);
        let Pe = ny.get(K);
        Pe || (Pe = /* @__PURE__ */ new Map(), ny.set(K, Pe));
        const Ye = Pe.get(ae);
        if (Ye !== void 0)
          return Ye;
        const Kt = Oc.get(K), zn = gh({ root: Kt.root, path: [...Kt.path, ae] });
        return Pe.set(ae, zn), zn;
      }
    }, To = (K) => K[wu], Eu = (K) => {
      const { root: ae, path: Pe } = To(K);
      return { root: ae, path: Pe };
    };
    function gh(K) {
      var ae;
      const Pe = {
        root: K.root,
        path: (ae = K.path) != null ? ae : []
      }, Ye = {};
      return Oc.set(Ye, Pe), new Proxy(Ye, ry);
    }
    var vf = gh, Oa = (K) => K && !!To(K);
    function iy(K, ae, Pe) {
      return ae.length === 0 ? Pe(K) : vl(K, ae, Pe);
    }
    var vl = (K, ae, Pe) => {
      if (ae.length === 0)
        return Pe(K);
      if (Array.isArray(K)) {
        let [Ye, ...Kt] = ae;
        Ye = parseInt(String(Ye), 10), isNaN(Ye) && (Ye = 0);
        const zn = K[Ye], Ei = vl(zn, Kt, Pe);
        if (zn === Ei)
          return K;
        const ms = [...K];
        return ms.splice(Ye, 1, Ei), ms;
      } else if (typeof K == "object" && K !== null) {
        const [Ye, ...Kt] = ae, zn = K[Ye], Ei = vl(zn, Kt, Pe);
        return zn === Ei ? K : v(f({}, K), { [Ye]: Ei });
      } else {
        const [Ye, ...Kt] = ae;
        return { [Ye]: vl(void 0, Kt, Pe) };
      }
    }, Dr = class {
      constructor() {
        this._head = void 0;
      }
      peek() {
        return this._head && this._head.data;
      }
      pop() {
        const K = this._head;
        if (K)
          return this._head = K.next, K.data;
      }
      push(K) {
        const ae = { next: this._head, data: K };
        this._head = ae;
      }
    };
    function Dc(K) {
      return !!(K && K.isPrism && K.isPrism === !0);
    }
    function yh() {
      const K = () => {
      }, ae = new Dr(), Pe = K;
      return {
        type: "Dataverse_discoveryMechanism",
        startIgnoringDependencies: () => {
          ae.push(Pe);
        },
        stopIgnoringDependencies: () => {
          ae.peek() !== Pe ? process.env.NODE_ENV === "development" && console.warn("This should never happen") : ae.pop();
        },
        reportResolutionStart: (ku) => {
          const Co = ae.peek();
          Co && Co(ku), ae.push(Pe);
        },
        reportResolutionEnd: (ku) => {
          ae.pop();
        },
        pushCollector: (ku) => {
          ae.push(ku);
        },
        popCollector: (ku) => {
          if (ae.peek() !== ku)
            throw new Error("Popped collector is not on top of the stack");
          ae.pop();
        }
      };
    }
    function sy() {
      const K = "__dataverse_discoveryMechanism_sharedStack", ae = typeof window < "u" ? window : typeof ks < "u" ? ks : {};
      if (ae) {
        const Pe = ae[K];
        if (Pe && typeof Pe == "object" && Pe.type === "Dataverse_discoveryMechanism")
          return Pe;
        {
          const Ye = yh();
          return ae[K] = Ye, Ye;
        }
      } else
        return yh();
    }
    var {
      startIgnoringDependencies: bl,
      stopIgnoringDependencies: Tu,
      reportResolutionEnd: oy,
      reportResolutionStart: ux,
      pushCollector: bf,
      popCollector: ay
    } = sy(), ly = () => {
    }, cx = class {
      constructor(K, ae) {
        this._fn = K, this._prismInstance = ae, this._didMarkDependentsAsStale = !1, this._isFresh = !1, this._cacheOfDendencyValues = /* @__PURE__ */ new Map(), this._dependents = /* @__PURE__ */ new Set(), this._dependencies = /* @__PURE__ */ new Set(), this._possiblyStaleDeps = /* @__PURE__ */ new Set(), this._scope = new uy(this), this._lastValue = void 0, this._forciblySetToStale = !1, this._reactToDependencyGoingStale = (Pe) => {
          this._possiblyStaleDeps.add(Pe), this._markAsStale();
        };
        for (const Pe of this._dependencies)
          Pe._addDependent(this._reactToDependencyGoingStale);
        bl(), this.getValue(), Tu();
      }
      get hasDependents() {
        return this._dependents.size > 0;
      }
      removeDependent(K) {
        this._dependents.delete(K);
      }
      addDependent(K) {
        this._dependents.add(K);
      }
      destroy() {
        for (const K of this._dependencies)
          K._removeDependent(this._reactToDependencyGoingStale);
        _f(this._scope);
      }
      getValue() {
        if (!this._isFresh) {
          const K = this._recalculate();
          this._lastValue = K, this._isFresh = !0, this._didMarkDependentsAsStale = !1, this._forciblySetToStale = !1;
        }
        return this._lastValue;
      }
      _recalculate() {
        let K;
        if (!this._forciblySetToStale && this._possiblyStaleDeps.size > 0) {
          let Ye = !1;
          bl();
          for (const Kt of this._possiblyStaleDeps)
            if (this._cacheOfDendencyValues.get(Kt) !== Kt.getValue()) {
              Ye = !0;
              break;
            }
          if (Tu(), this._possiblyStaleDeps.clear(), !Ye)
            return this._lastValue;
        }
        const ae = /* @__PURE__ */ new Set();
        this._cacheOfDendencyValues.clear();
        const Pe = (Ye) => {
          ae.add(Ye), this._addDependency(Ye);
        };
        bf(Pe), wi.push(this._scope);
        try {
          K = this._fn();
        } catch (Ye) {
          console.error(Ye);
        } finally {
          wi.pop() !== this._scope && console.warn("The Prism hook stack has slipped. This is a bug.");
        }
        ay(Pe);
        for (const Ye of this._dependencies)
          ae.has(Ye) || this._removeDependency(Ye);
        this._dependencies = ae, bl();
        for (const Ye of ae)
          this._cacheOfDendencyValues.set(Ye, Ye.getValue());
        return Tu(), K;
      }
      forceStale() {
        this._forciblySetToStale = !0, this._markAsStale();
      }
      _markAsStale() {
        if (!this._didMarkDependentsAsStale) {
          this._didMarkDependentsAsStale = !0, this._isFresh = !1;
          for (const K of this._dependents)
            K(this._prismInstance);
        }
      }
      _addDependency(K) {
        this._dependencies.has(K) || (this._dependencies.add(K), K._addDependent(this._reactToDependencyGoingStale));
      }
      _removeDependency(K) {
        this._dependencies.has(K) && (this._dependencies.delete(K), K._removeDependent(this._reactToDependencyGoingStale));
      }
    }, Cu = {}, xf = class {
      constructor(K) {
        this._fn = K, this.isPrism = !0, this._state = {
          hot: !1,
          handle: void 0
        };
      }
      get isHot() {
        return this._state.hot;
      }
      onChange(K, ae, Pe = !1) {
        const Ye = () => {
          K.onThisOrNextTick(zn);
        };
        let Kt = Cu;
        const zn = () => {
          const ms = this.getValue();
          ms !== Kt && (Kt = ms, ae(ms));
        };
        return this._addDependent(Ye), Pe && (Kt = this.getValue(), ae(Kt)), () => {
          this._removeDependent(Ye), K.offThisOrNextTick(zn), K.offNextTick(zn);
        };
      }
      onStale(K) {
        const ae = () => {
          this._removeDependent(Pe);
        }, Pe = () => K();
        return this._addDependent(Pe), ae;
      }
      keepHot() {
        return this.onStale(() => {
        });
      }
      _addDependent(K) {
        this._state.hot || this._goHot(), this._state.handle.addDependent(K);
      }
      _goHot() {
        const K = new cx(this._fn, this);
        this._state = {
          hot: !0,
          handle: K
        };
      }
      _removeDependent(K) {
        const ae = this._state;
        if (!ae.hot)
          return;
        const Pe = ae.handle;
        Pe.removeDependent(K), Pe.hasDependents || (this._state = { hot: !1, handle: void 0 }, Pe.destroy());
      }
      getValue() {
        ux(this);
        const K = this._state;
        let ae;
        return K.hot ? ae = K.handle.getValue() : ae = Da(this._fn), oy(this), ae;
      }
    }, uy = class {
      constructor(K) {
        this._hotHandle = K, this._refs = /* @__PURE__ */ new Map(), this.isPrismScope = !0, this.subs = {}, this.effects = /* @__PURE__ */ new Map(), this.memos = /* @__PURE__ */ new Map();
      }
      ref(K, ae) {
        let Pe = this._refs.get(K);
        if (Pe !== void 0)
          return Pe;
        {
          const Ye = {
            current: ae
          };
          return this._refs.set(K, Ye), Ye;
        }
      }
      effect(K, ae, Pe) {
        let Ye = this.effects.get(K);
        Ye === void 0 && (Ye = {
          cleanup: ly,
          deps: void 0
        }, this.effects.set(K, Ye)), dy(Ye.deps, Pe) && (Ye.cleanup(), bl(), Ye.cleanup = vh(ae, ly).value, Tu(), Ye.deps = Pe);
      }
      memo(K, ae, Pe) {
        let Ye = this.memos.get(K);
        return Ye === void 0 && (Ye = {
          cachedValue: null,
          deps: void 0
        }, this.memos.set(K, Ye)), dy(Ye.deps, Pe) && (bl(), Ye.cachedValue = vh(ae, void 0).value, Tu(), Ye.deps = Pe), Ye.cachedValue;
      }
      state(K, ae) {
        const { value: Pe, setValue: Ye } = this.memo("state/" + K, () => {
          const Kt = { current: ae };
          return { value: Kt, setValue: (Ei) => {
            Kt.current = Ei, this._hotHandle.forceStale();
          } };
        }, []);
        return [Pe.current, Ye];
      }
      sub(K) {
        return this.subs[K] || (this.subs[K] = new uy(this._hotHandle)), this.subs[K];
      }
      cleanupEffects() {
        for (const K of this.effects.values())
          vh(K.cleanup, void 0);
        this.effects.clear();
      }
      source(K, ae) {
        return this.effect("$$source/blah", () => K(() => {
          this._hotHandle.forceStale();
        }), [K]), ae();
      }
    };
    function _f(K) {
      for (const ae of Object.values(K.subs))
        _f(ae);
      K.cleanupEffects();
    }
    function vh(K, ae) {
      try {
        return { value: K(), ok: !0 };
      } catch (Pe) {
        return setTimeout(function() {
          throw Pe;
        }), { value: ae, ok: !1 };
      }
    }
    var wi = new Dr();
    function cy(K, ae) {
      const Pe = wi.peek();
      if (!Pe)
        throw new Error("prism.ref() is called outside of a prism() call.");
      return Pe.ref(K, ae);
    }
    function Sf(K, ae, Pe) {
      const Ye = wi.peek();
      if (!Ye)
        throw new Error("prism.effect() is called outside of a prism() call.");
      return Ye.effect(K, ae, Pe);
    }
    function dy(K, ae) {
      if (K === void 0 || ae === void 0)
        return !0;
      const Pe = K.length;
      if (Pe !== ae.length)
        return !0;
      for (let Ye = 0; Ye < Pe; Ye++)
        if (K[Ye] !== ae[Ye])
          return !0;
      return !1;
    }
    function bh(K, ae, Pe) {
      const Ye = wi.peek();
      if (!Ye)
        throw new Error("prism.memo() is called outside of a prism() call.");
      return Ye.memo(K, ae, Pe);
    }
    function Yi(K, ae) {
      const Pe = wi.peek();
      if (!Pe)
        throw new Error("prism.state() is called outside of a prism() call.");
      return Pe.state(K, ae);
    }
    function dx() {
      if (!wi.peek())
        throw new Error("The parent function is called outside of a prism() call.");
    }
    function hy(K, ae) {
      const Pe = wi.peek();
      if (!Pe)
        throw new Error("prism.scope() is called outside of a prism() call.");
      const Ye = Pe.sub(K);
      wi.push(Ye);
      const Kt = vh(ae, void 0).value;
      return wi.pop(), Kt;
    }
    function hx(K, ae, Pe) {
      return bh(K, () => si(ae), Pe).getValue();
    }
    function py() {
      return !!wi.peek();
    }
    function fy(K, ae) {
      const Pe = wi.peek();
      if (!Pe)
        throw new Error("prism.source() is called outside of a prism() call.");
      return Pe.source(K, ae);
    }
    var si = (K) => new xf(K), ra = class {
      effect(K, ae, Pe) {
        console.warn("prism.effect() does not run in cold prisms");
      }
      memo(K, ae, Pe) {
        return ae();
      }
      state(K, ae) {
        return [ae, () => {
        }];
      }
      ref(K, ae) {
        return { current: ae };
      }
      sub(K) {
        return new ra();
      }
      source(K, ae) {
        return ae();
      }
    };
    function Da(K) {
      const ae = new ra();
      wi.push(ae);
      let Pe;
      try {
        Pe = K();
      } catch (Ye) {
        console.error(Ye);
      } finally {
        wi.pop() !== ae && console.warn("The Prism hook stack has slipped. This is a bug.");
      }
      return Pe;
    }
    si.ref = cy, si.effect = Sf, si.memo = bh, si.ensurePrism = dx, si.state = Yi, si.scope = hy, si.sub = hx, si.inPrism = py, si.source = fy;
    var Fc = si, Pu;
    (function(K) {
      K[K.Dict = 0] = "Dict", K[K.Array = 1] = "Array", K[K.Other = 2] = "Other";
    })(Pu || (Pu = {}));
    var Un = (K) => Array.isArray(K) ? 1 : ey(K) ? 0 : 2, wf = (K, ae, Pe = Un(K)) => Pe === 0 && typeof ae == "string" || Pe === 1 && Bc(ae) ? K[ae] : void 0, Bc = (K) => {
      const ae = typeof K == "number" ? K : parseInt(K, 10);
      return !isNaN(ae) && ae >= 0 && ae < 1 / 0 && (ae | 0) === ae;
    }, Lc = class {
      constructor(K, ae) {
        this._parent = K, this._path = ae, this.children = /* @__PURE__ */ new Map(), this.identityChangeListeners = /* @__PURE__ */ new Set();
      }
      addIdentityChangeListener(K) {
        this.identityChangeListeners.add(K);
      }
      removeIdentityChangeListener(K) {
        this.identityChangeListeners.delete(K), this._checkForGC();
      }
      removeChild(K) {
        this.children.delete(K), this._checkForGC();
      }
      getChild(K) {
        return this.children.get(K);
      }
      getOrCreateChild(K) {
        let ae = this.children.get(K);
        return ae || (ae = ae = new Lc(this, this._path.concat([K])), this.children.set(K, ae)), ae;
      }
      _checkForGC() {
        this.identityChangeListeners.size > 0 || this.children.size > 0 || this._parent && this._parent.removeChild(yf(this._path));
      }
    }, my = class {
      constructor(K) {
        this.$$isPointerToPrismProvider = !0, this.pointer = vf({ root: this, path: [] }), this.prism = this.pointerToPrism(this.pointer), this._onPointerValueChange = (ae, Pe) => {
          const { path: Ye } = Eu(ae), Kt = this._getOrCreateScopeForPath(Ye);
          return Kt.identityChangeListeners.add(Pe), () => {
            Kt.identityChangeListeners.delete(Pe);
          };
        }, this._currentState = K, this._rootScope = new Lc(void 0, []);
      }
      set(K) {
        const ae = this._currentState;
        this._currentState = K, this._checkUpdates(this._rootScope, ae, K);
      }
      get() {
        return this._currentState;
      }
      getByPointer(K) {
        const ae = Oa(K) ? K : K(this.pointer), Pe = Eu(ae).path;
        return this._getIn(Pe);
      }
      _getIn(K) {
        return K.length === 0 ? this.get() : Xg(this.get(), K);
      }
      reduce(K) {
        this.set(K(this.get()));
      }
      reduceByPointer(K, ae) {
        const Pe = Oa(K) ? K : K(this.pointer), Ye = Eu(Pe).path, Kt = iy(this.get(), Ye, ae);
        this.set(Kt);
      }
      setByPointer(K, ae) {
        this.reduceByPointer(K, () => ae);
      }
      _checkUpdates(K, ae, Pe) {
        if (ae === Pe)
          return;
        for (const zn of K.identityChangeListeners)
          zn(Pe);
        if (K.children.size === 0)
          return;
        const Ye = Un(ae), Kt = Un(Pe);
        if (!(Ye === 2 && Ye === Kt))
          for (const [zn, Ei] of K.children) {
            const ms = wf(ae, zn, Ye), xh = wf(Pe, zn, Kt);
            this._checkUpdates(Ei, ms, xh);
          }
      }
      _getOrCreateScopeForPath(K) {
        let ae = this._rootScope;
        for (const Pe of K)
          ae = ae.getOrCreateChild(Pe);
        return ae;
      }
      pointerToPrism(K) {
        const { path: ae } = Eu(K), Pe = (Kt) => this._onPointerValueChange(K, Kt), Ye = () => this._getIn(ae);
        return Fc(() => Fc.source(Pe, Ye));
      }
    }, Ef = /* @__PURE__ */ new WeakMap();
    function gy(K) {
      return typeof K == "object" && K !== null && K.$$isPointerToPrismProvider === !0;
    }
    var xl = (K) => {
      const ae = To(K);
      let Pe = Ef.get(ae);
      if (!Pe) {
        const Ye = ae.root;
        if (!gy(Ye))
          throw new Error("Cannot run pointerToPrism() on a pointer whose root is not an PointerToPrismProvider");
        Pe = Ye.pointerToPrism(K), Ef.set(ae, Pe);
      }
      return Pe;
    }, jc = (K) => Oa(K) ? xl(K).getValue() : Dc(K) ? K.getValue() : K;
    function* px(K) {
      let ae;
      if (Oa(K))
        ae = xl(K);
      else if (Dc(K))
        ae = K;
      else
        throw new Error("Only pointers and prisms are supported");
      let Pe = 0;
      const Ye = ae.onStale(() => {
        Pe++;
      });
      try {
        for (; ; ) {
          const Kt = Pe;
          Pe = 0, yield { value: ae.getValue(), ticks: Kt };
        }
      } finally {
        Ye();
      }
    }
    var Uc = 60 * 3, Au = class {
      constructor(K) {
        this._conf = K, this._ticking = !1, this._dormant = !0, this._numberOfDormantTicks = 0, this.__ticks = 0, this._scheduledForThisOrNextTick = /* @__PURE__ */ new Set(), this._scheduledForNextTick = /* @__PURE__ */ new Set(), this._timeAtCurrentTick = 0;
      }
      get dormant() {
        return this._dormant;
      }
      onThisOrNextTick(K) {
        this._scheduledForThisOrNextTick.add(K), this._dormant && this._goActive();
      }
      onNextTick(K) {
        this._scheduledForNextTick.add(K), this._dormant && this._goActive();
      }
      offThisOrNextTick(K) {
        this._scheduledForThisOrNextTick.delete(K);
      }
      offNextTick(K) {
        this._scheduledForNextTick.delete(K);
      }
      get time() {
        return this._ticking ? this._timeAtCurrentTick : performance.now();
      }
      _goActive() {
        var K, ae;
        this._dormant && (this._dormant = !1, (ae = (K = this._conf) == null ? void 0 : K.onActive) == null || ae.call(K));
      }
      _goDormant() {
        var K, ae;
        this._dormant || (this._dormant = !0, this._numberOfDormantTicks = 0, (ae = (K = this._conf) == null ? void 0 : K.onDormant) == null || ae.call(K));
      }
      tick(K = performance.now()) {
        if (process.env.NODE_ENV === "development" && !(this instanceof Au))
          throw new Error('ticker.tick must be called while bound to the ticker. As in, "ticker.tick(time)" or "requestAnimationFrame((t) => ticker.tick(t))" for performance.');
        if (this.__ticks++, !this._dormant && this._scheduledForNextTick.size === 0 && this._scheduledForThisOrNextTick.size === 0 && (this._numberOfDormantTicks++, this._numberOfDormantTicks >= Uc)) {
          this._goDormant();
          return;
        }
        this._ticking = !0, this._timeAtCurrentTick = K;
        for (const ae of this._scheduledForNextTick)
          this._scheduledForThisOrNextTick.add(ae);
        this._scheduledForNextTick.clear(), this._tick(0), this._ticking = !1;
      }
      _tick(K) {
        const ae = this.time;
        if (K > 10 && console.warn("_tick() recursing for 10 times"), K > 100)
          throw new Error("Maximum recursion limit for _tick()");
        const Pe = this._scheduledForThisOrNextTick;
        this._scheduledForThisOrNextTick = /* @__PURE__ */ new Set();
        for (const Ye of Pe)
          Ye(ae);
        if (this._scheduledForThisOrNextTick.size > 0)
          return this._tick(K + 1);
      }
    };
    function* fx(K) {
      let ae;
      if (Oa(K))
        ae = xl(K);
      else if (Dc(K))
        ae = K;
      else
        throw new Error("Only pointers and prisms are supported");
      const Pe = new Au(), Ye = ae.onChange(Pe, (Kt) => {
      });
      try {
        for (; ; )
          Pe.tick(), yield ae.getValue();
      } finally {
        Ye();
      }
    }
    var Tf = class {
      constructor(K) {
        this.$$isPointerToPrismProvider = !0, this._currentPointerBox = new my(K), this.pointer = vf({ root: this, path: [] });
      }
      setPointer(K) {
        this._currentPointerBox.set(K);
      }
      pointerToPrism(K) {
        const { path: ae } = To(K);
        return Fc(() => {
          const Pe = this._currentPointerBox.prism.getValue(), Ye = ae.reduce((Kt, zn) => Kt[zn], Pe);
          return jc(Ye);
        });
      }
    };
  }(s5)), s5;
}
Jw.exports;
var Fpe;
function zge() {
  return Fpe || (Fpe = 1, function(c, e) {
    var t = Object.create, n = Object.defineProperty, i = Object.defineProperties, o = Object.getOwnPropertyDescriptor, l = Object.getOwnPropertyDescriptors, p = Object.getOwnPropertyNames, f = Object.getOwnPropertySymbols, v = Object.getPrototypeOf, _ = Object.prototype.hasOwnProperty, E = Object.prototype.propertyIsEnumerable, A = (g, S, k) => S in g ? n(g, S, { enumerable: !0, configurable: !0, writable: !0, value: k }) : g[S] = k, I = (g, S) => {
      for (var k in S || (S = {}))
        _.call(S, k) && A(g, k, S[k]);
      if (f)
        for (var k of f(S))
          E.call(S, k) && A(g, k, S[k]);
      return g;
    }, j = (g, S) => i(g, l(S)), q = (g, S) => function() {
      return S || (0, g[p(g)[0]])((S = { exports: {} }).exports, S), S.exports;
    }, L = (g, S) => {
      for (var k in S)
        n(g, k, { get: S[k], enumerable: !0 });
    }, V = (g, S, k, z) => {
      if (S && typeof S == "object" || typeof S == "function")
        for (let X of p(S))
          !_.call(g, X) && X !== k && n(g, X, { get: () => S[X], enumerable: !(z = o(S, X)) || z.enumerable });
      return g;
    }, re = (g, S, k) => (k = g != null ? t(v(g)) : {}, V(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      !g || !g.__esModule ? n(k, "default", { value: g, enumerable: !0 }) : k,
      g
    )), R = (g) => V(n({}, "__esModule", { value: !0 }), g), J = (g, S, k) => (A(g, typeof S != "symbol" ? S + "" : S, k), k), ge = q({
      "../node_modules/timing-function/lib/UnitBezier.js"(g, S) {
        S.exports = function() {
          function k(z, X, te, fe) {
            this.set(z, X, te, fe);
          }
          return k.prototype.set = function(z, X, te, fe) {
            this._cx = 3 * z, this._bx = 3 * (te - z) - this._cx, this._ax = 1 - this._cx - this._bx, this._cy = 3 * X, this._by = 3 * (fe - X) - this._cy, this._ay = 1 - this._cy - this._by;
          }, k.epsilon = 1e-6, k.prototype._sampleCurveX = function(z) {
            return ((this._ax * z + this._bx) * z + this._cx) * z;
          }, k.prototype._sampleCurveY = function(z) {
            return ((this._ay * z + this._by) * z + this._cy) * z;
          }, k.prototype._sampleCurveDerivativeX = function(z) {
            return (3 * this._ax * z + 2 * this._bx) * z + this._cx;
          }, k.prototype._solveCurveX = function(z, X) {
            var te, fe, Re, Le, We, ot;
            for (Re = void 0, Le = void 0, We = void 0, ot = void 0, te = void 0, fe = void 0, We = z, fe = 0; fe < 8; ) {
              if (ot = this._sampleCurveX(We) - z, Math.abs(ot) < X)
                return We;
              if (te = this._sampleCurveDerivativeX(We), Math.abs(te) < X)
                break;
              We = We - ot / te, fe++;
            }
            if (Re = 0, Le = 1, We = z, We < Re)
              return Re;
            if (We > Le)
              return Le;
            for (; Re < Le; ) {
              if (ot = this._sampleCurveX(We), Math.abs(ot - z) < X)
                return We;
              z > ot ? Re = We : Le = We, We = (Le - Re) * 0.5 + Re;
            }
            return We;
          }, k.prototype.solve = function(z, X) {
            return this._sampleCurveY(this._solveCurveX(z, X));
          }, k.prototype.solveSimple = function(z) {
            return this._sampleCurveY(this._solveCurveX(z, 1e-6));
          }, k;
        }();
      }
    }), _e = q({
      "../node_modules/levenshtein-edit-distance/index.js"(g, S) {
        var k, z;
        k = [], z = [];
        function X(te, fe, Re) {
          var Le, We, ot, pt, _t, Rt, Mt, ln;
          if (te === fe)
            return 0;
          if (Le = te.length, We = fe.length, Le === 0)
            return We;
          if (We === 0)
            return Le;
          for (Re && (te = te.toLowerCase(), fe = fe.toLowerCase()), Mt = 0; Mt < Le; )
            z[Mt] = te.charCodeAt(Mt), k[Mt] = ++Mt;
          for (ln = 0; ln < We; )
            for (ot = fe.charCodeAt(ln), pt = _t = ln++, Mt = -1; ++Mt < Le; )
              Rt = ot === z[Mt] ? _t : _t + 1, _t = k[Mt], k[Mt] = pt = _t > pt ? Rt > pt ? pt + 1 : Rt : Rt > _t ? _t + 1 : Rt;
          return pt;
        }
        S.exports = X;
      }
    }), Y = q({
      "../node_modules/propose/propose.js"(g, S) {
        var k = _e();
        function z() {
          var X, te, fe, Re, Le, We = 0, ot = arguments[0], pt = arguments[1], _t = pt.length, Rt = arguments[2];
          Rt && (Re = Rt.threshold, Le = Rt.ignoreCase), Re === void 0 && (Re = 0);
          for (var Mt = 0; Mt < _t; ++Mt)
            Le ? te = k(ot, pt[Mt], !0) : te = k(ot, pt[Mt]), te > ot.length ? X = 1 - te / pt[Mt].length : X = 1 - te / ot.length, X > We && (We = X, fe = pt[Mt]);
          return We >= Re ? fe : null;
        }
        S.exports = z;
      }
    }), Fe = q({
      "../node_modules/fast-deep-equal/index.js"(g, S) {
        S.exports = function k(z, X) {
          if (z === X)
            return !0;
          if (z && X && typeof z == "object" && typeof X == "object") {
            if (z.constructor !== X.constructor)
              return !1;
            var te, fe, Re;
            if (Array.isArray(z)) {
              if (te = z.length, te != X.length)
                return !1;
              for (fe = te; fe-- !== 0; )
                if (!k(z[fe], X[fe]))
                  return !1;
              return !0;
            }
            if (z.constructor === RegExp)
              return z.source === X.source && z.flags === X.flags;
            if (z.valueOf !== Object.prototype.valueOf)
              return z.valueOf() === X.valueOf();
            if (z.toString !== Object.prototype.toString)
              return z.toString() === X.toString();
            if (Re = Object.keys(z), te = Re.length, te !== Object.keys(X).length)
              return !1;
            for (fe = te; fe-- !== 0; )
              if (!Object.prototype.hasOwnProperty.call(X, Re[fe]))
                return !1;
            for (fe = te; fe-- !== 0; ) {
              var Le = Re[fe];
              if (!k(z[Le], X[Le]))
                return !1;
            }
            return !0;
          }
          return z !== z && X !== X;
        };
      }
    }), Me = {};
    L(Me, {
      createRafDriver: () => Wf,
      getProject: () => y1,
      notify: () => Po,
      onChange: () => v1,
      types: () => t1,
      val: () => b1
    }), c.exports = R(Me);
    var $ = {};
    L($, {
      createRafDriver: () => Wf,
      getProject: () => y1,
      notify: () => Po,
      onChange: () => v1,
      types: () => t1,
      val: () => b1
    });
    var dt = ut(), wt = class {
      constructor() {
        J(this, "atom", new dt.Atom({ projects: {} }));
      }
      /**
       * We're trusting here that each project id is unique
       */
      add(g, S) {
        this.atom.setByPointer((k) => k.projects[g], S);
      }
      get(g) {
        return this.atom.get().projects[g];
      }
      has(g) {
        return !!this.get(g);
      }
    }, St = new wt(), Ct = St, pe = /* @__PURE__ */ new WeakMap();
    function Tt(g) {
      return pe.get(g);
    }
    function st(g, S) {
      pe.set(g, S);
    }
    var Zt = [], $t = Array.isArray, Ht = $t, Gn = typeof ks == "object" && ks && ks.Object === Object && ks, an = Gn, An = typeof self == "object" && self && self.Object === Object && self, pr = an || An || Function("return this")(), Kn = pr, Qo = Kn.Symbol, _r = Qo, Ta = Object.prototype, fl = Ta.hasOwnProperty, Ca = Ta.toString, Pa = _r ? _r.toStringTag : void 0;
    function Cc(g) {
      var S = fl.call(g, Pa), k = g[Pa];
      try {
        g[Pa] = void 0;
        var z = !0;
      } catch {
      }
      var X = Ca.call(g);
      return z && (S ? g[Pa] = k : delete g[Pa]), X;
    }
    var Fi = Cc, Ki = Object.prototype, ml = Ki.toString;
    function Qr(g) {
      return ml.call(g);
    }
    var Zo = Qr, fu = "[object Null]", Jo = "[object Undefined]", Pc = _r ? _r.toStringTag : void 0;
    function Jd(g) {
      return g == null ? g === void 0 ? Jo : fu : Pc && Pc in Object(g) ? Fi(g) : Zo(g);
    }
    var Si = Jd;
    function eh(g) {
      return g != null && typeof g == "object";
    }
    var to = eh, th = "[object Symbol]";
    function Ac(g) {
      return typeof g == "symbol" || to(g) && Si(g) == th;
    }
    var Aa = Ac, nh = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, rh = /^\w*$/;
    function ih(g, S) {
      if (Ht(g))
        return !1;
      var k = typeof g;
      return k == "number" || k == "symbol" || k == "boolean" || g == null || Aa(g) ? !0 : rh.test(g) || !nh.test(g) || S != null && g in Object(S);
    }
    var mu = ih;
    function sh(g) {
      var S = typeof g;
      return g != null && (S == "object" || S == "function");
    }
    var Bi = sh, _o = "[object AsyncFunction]", ka = "[object Function]", of = "[object GeneratorFunction]", Ms = "[object Proxy]";
    function ds(g) {
      if (!Bi(g))
        return !1;
      var S = Si(g);
      return S == ka || S == of || S == _o || S == Ms;
    }
    var kc = ds, hs = Kn["__core-js_shared__"], ps = hs, So = function() {
      var g = /[^.]+$/.exec(ps && ps.keys && ps.keys.IE_PROTO || "");
      return g ? "Symbol(src)_1." + g : "";
    }();
    function oh(g) {
      return !!So && So in g;
    }
    var Ma = oh, gu = Function.prototype, ah = gu.toString;
    function ci(g) {
      if (g != null) {
        try {
          return ah.call(g);
        } catch {
        }
        try {
          return g + "";
        } catch {
        }
      }
      return "";
    }
    var Or = ci, lh = /[\\^$.*+?()[\]{}|]/g, uh = /^\[object .+?Constructor\]$/, yu = Function.prototype, vu = Object.prototype, ch = yu.toString, af = vu.hasOwnProperty, lf = RegExp(
      "^" + ch.call(af).replace(lh, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function dh(g) {
      if (!Bi(g) || Ma(g))
        return !1;
      var S = kc(g) ? lf : uh;
      return S.test(Or(g));
    }
    var be = dh;
    function ht(g, S) {
      return g?.[S];
    }
    var Pt = ht;
    function Wt(g, S) {
      var k = Pt(g, S);
      return be(k) ? k : void 0;
    }
    var vn = Wt, qn = vn(Object, "create"), fn = qn;
    function Gt() {
      this.__data__ = fn ? fn(null) : {}, this.size = 0;
    }
    var rr = Gt;
    function Sr(g) {
      var S = this.has(g) && delete this.__data__[g];
      return this.size -= S ? 1 : 0, S;
    }
    var fr = Sr, Li = "__lodash_hash_undefined__", ea = Object.prototype, wo = ea.hasOwnProperty;
    function di(g) {
      var S = this.__data__;
      if (fn) {
        var k = S[g];
        return k === Li ? void 0 : k;
      }
      return wo.call(S, g) ? S[g] : void 0;
    }
    var fs = di, gl = Object.prototype, uf = gl.hasOwnProperty;
    function Ra(g) {
      var S = this.__data__;
      return fn ? S[g] !== void 0 : uf.call(S, g);
    }
    var Ng = Ra, hh = "__lodash_hash_undefined__";
    function Og(g, S) {
      var k = this.__data__;
      return this.size += this.has(g) ? 0 : 1, k[g] = fn && S === void 0 ? hh : S, this;
    }
    var Jb = Og;
    function Eo(g) {
      var S = -1, k = g == null ? 0 : g.length;
      for (this.clear(); ++S < k; ) {
        var z = g[S];
        this.set(z[0], z[1]);
      }
    }
    Eo.prototype.clear = rr, Eo.prototype.delete = fr, Eo.prototype.get = fs, Eo.prototype.has = Ng, Eo.prototype.set = Jb;
    var Mc = Eo;
    function ex() {
      this.__data__ = [], this.size = 0;
    }
    var Rc = ex;
    function yl(g, S) {
      return g === S || g !== g && S !== S;
    }
    var cf = yl;
    function Dg(g, S) {
      for (var k = g.length; k--; )
        if (cf(g[k][0], S))
          return k;
      return -1;
    }
    var Ic = Dg, Fg = Array.prototype, Bg = Fg.splice;
    function df(g) {
      var S = this.__data__, k = Ic(S, g);
      if (k < 0)
        return !1;
      var z = S.length - 1;
      return k == z ? S.pop() : Bg.call(S, k, 1), --this.size, !0;
    }
    var Lg = df;
    function jg(g) {
      var S = this.__data__, k = Ic(S, g);
      return k < 0 ? void 0 : S[k][1];
    }
    var ta = jg;
    function Ug(g) {
      return Ic(this.__data__, g) > -1;
    }
    var tx = Ug;
    function Nc(g, S) {
      var k = this.__data__, z = Ic(k, g);
      return z < 0 ? (++this.size, k.push([g, S])) : k[z][1] = S, this;
    }
    var zg = Nc;
    function bu(g) {
      var S = -1, k = g == null ? 0 : g.length;
      for (this.clear(); ++S < k; ) {
        var z = g[S];
        this.set(z[0], z[1]);
      }
    }
    bu.prototype.clear = Rc, bu.prototype.delete = Lg, bu.prototype.get = ta, bu.prototype.has = tx, bu.prototype.set = zg;
    var ph = bu, Vg = vn(Kn, "Map"), xu = Vg;
    function Ia() {
      this.size = 0, this.__data__ = {
        hash: new Mc(),
        map: new (xu || ph)(),
        string: new Mc()
      };
    }
    var Gg = Ia;
    function nx(g) {
      var S = typeof g;
      return S == "string" || S == "number" || S == "symbol" || S == "boolean" ? g !== "__proto__" : g === null;
    }
    var qg = nx;
    function Hg(g, S) {
      var k = g.__data__;
      return qg(S) ? k[typeof S == "string" ? "string" : "hash"] : k.map;
    }
    var _u = Hg;
    function hf(g) {
      var S = _u(this, g).delete(g);
      return this.size -= S ? 1 : 0, S;
    }
    var pf = hf;
    function $g(g) {
      return _u(this, g).get(g);
    }
    var Wg = $g;
    function Kg(g) {
      return _u(this, g).has(g);
    }
    var rx = Kg;
    function ix(g, S) {
      var k = _u(this, g), z = k.size;
      return k.set(g, S), this.size += k.size == z ? 0 : 1, this;
    }
    var Yg = ix;
    function Su(g) {
      var S = -1, k = g == null ? 0 : g.length;
      for (this.clear(); ++S < k; ) {
        var z = g[S];
        this.set(z[0], z[1]);
      }
    }
    Su.prototype.clear = Gg, Su.prototype.delete = pf, Su.prototype.get = Wg, Su.prototype.has = rx, Su.prototype.set = Yg;
    var fh = Su, Na = "Expected a function";
    function na(g, S) {
      if (typeof g != "function" || S != null && typeof S != "function")
        throw new TypeError(Na);
      var k = function() {
        var z = arguments, X = S ? S.apply(this, z) : z[0], te = k.cache;
        if (te.has(X))
          return te.get(X);
        var fe = g.apply(this, z);
        return k.cache = te.set(X, fe) || te, fe;
      };
      return k.cache = new (na.Cache || fh)(), k;
    }
    na.Cache = fh;
    var Xg = na, mh = 500;
    function sx(g) {
      var S = Xg(g, function(z) {
        return k.size === mh && k.clear(), z;
      }), k = S.cache;
      return S;
    }
    var ff = sx, Qg = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Zg = /\\(\\)?/g, ox = ff(function(g) {
      var S = [];
      return g.charCodeAt(0) === 46 && S.push(""), g.replace(Qg, function(k, z, X, te) {
        S.push(X ? te.replace(Zg, "$1") : z || k);
      }), S;
    }), ax = ox;
    function mf(g, S) {
      for (var k = -1, z = g == null ? 0 : g.length, X = Array(z); ++k < z; )
        X[k] = S(g[k], k, g);
      return X;
    }
    var lx = mf, Jg = _r ? _r.prototype : void 0, gf = Jg ? Jg.toString : void 0;
    function ey(g) {
      if (typeof g == "string")
        return g;
      if (Ht(g))
        return lx(g, ey) + "";
      if (Aa(g))
        return gf ? gf.call(g) : "";
      var S = g + "";
      return S == "0" && 1 / g == -1 / 0 ? "-0" : S;
    }
    var ty = ey;
    function yf(g) {
      return g == null ? "" : ty(g);
    }
    var Oc = yf;
    function ny(g, S) {
      return Ht(g) ? g : mu(g, S) ? [g] : ax(Oc(g));
    }
    var wu = ny;
    function ry(g) {
      if (typeof g == "string" || Aa(g))
        return g;
      var S = g + "";
      return S == "0" && 1 / g == -1 / 0 ? "-0" : S;
    }
    var To = ry;
    function Eu(g, S) {
      S = wu(S, g);
      for (var k = 0, z = S.length; g != null && k < z; )
        g = g[To(S[k++])];
      return k && k == z ? g : void 0;
    }
    var gh = Eu;
    function vf(g, S, k) {
      var z = g == null ? void 0 : gh(g, S);
      return z === void 0 ? k : z;
    }
    var Oa = vf;
    function iy(g, S) {
      return S.length === 0 ? g : Oa(g, S);
    }
    var vl = class {
      constructor() {
        J(this, "_values", {});
      }
      /**
       * get the cache item at `key` or produce it using `producer` and cache _that_.
       *
       * Note that this won't work if you change the producer, like `get(key, producer1); get(key, producer2)`.
       */
      get(g, S) {
        if (this.has(g))
          return this._values[g];
        {
          const k = S();
          return this._values[g] = k, k;
        }
      }
      /**
       * Returns true if the cache has an item at `key`.
       */
      has(g) {
        return this._values.hasOwnProperty(g);
      }
    }, Dr = ut(), Dc = function() {
      try {
        var g = vn(Object, "defineProperty");
        return g({}, "", {}), g;
      } catch {
      }
    }(), yh = Dc;
    function sy(g, S, k) {
      S == "__proto__" && yh ? yh(g, S, {
        configurable: !0,
        enumerable: !0,
        value: k,
        writable: !0
      }) : g[S] = k;
    }
    var bl = sy, Tu = Object.prototype, oy = Tu.hasOwnProperty;
    function ux(g, S, k) {
      var z = g[S];
      (!(oy.call(g, S) && cf(z, k)) || k === void 0 && !(S in g)) && bl(g, S, k);
    }
    var bf = ux, ay = 9007199254740991, ly = /^(?:0|[1-9]\d*)$/;
    function cx(g, S) {
      var k = typeof g;
      return S = S ?? ay, !!S && (k == "number" || k != "symbol" && ly.test(g)) && g > -1 && g % 1 == 0 && g < S;
    }
    var Cu = cx;
    function xf(g, S, k, z) {
      if (!Bi(g))
        return g;
      S = wu(S, g);
      for (var X = -1, te = S.length, fe = te - 1, Re = g; Re != null && ++X < te; ) {
        var Le = To(S[X]), We = k;
        if (Le === "__proto__" || Le === "constructor" || Le === "prototype")
          return g;
        if (X != fe) {
          var ot = Re[Le];
          We = z ? z(ot, Le, Re) : void 0, We === void 0 && (We = Bi(ot) ? ot : Cu(S[X + 1]) ? [] : {});
        }
        bf(Re, Le, We), Re = Re[Le];
      }
      return g;
    }
    var uy = xf;
    function _f(g, S, k) {
      return g == null ? g : uy(g, S, k);
    }
    var vh = _f, wi = /* @__PURE__ */ new WeakMap();
    function cy(g) {
      return Sf(g);
    }
    function Sf(g) {
      if (wi.has(g))
        return wi.get(g);
      const S = g.type === "compound" ? bh(g) : g.type === "enum" ? dy(g) : g.default;
      return wi.set(g, S), S;
    }
    function dy(g) {
      const S = {
        $case: g.defaultCase
      };
      for (const [k, z] of Object.entries(g.cases))
        S[k] = Sf(z);
      return S;
    }
    function bh(g) {
      const S = {};
      for (const [k, z] of Object.entries(g.props))
        S[k] = Sf(z);
      return S;
    }
    var Yi = ut(), dx = re(ge());
    function hy(g, S, k) {
      return (0, Yi.prism)(() => {
        const z = (0, Yi.val)(S);
        return Yi.prism.memo(
          "driver",
          () => z ? z.type === "BasicKeyframedTrack" ? hx(g, z, k) : (g.logger.error("Track type not yet supported."), (0, Yi.prism)(() => {
          })) : (0, Yi.prism)(() => {
          }),
          [z]
        ).getValue();
      });
    }
    function hx(g, S, k) {
      return (0, Yi.prism)(() => {
        let z = Yi.prism.ref("state", { started: !1 }), X = z.current;
        const te = k.getValue();
        return (!X.started || te < X.validFrom || X.validTo <= te) && (z.current = X = fy(g, k, S)), X.der.getValue();
      });
    }
    var py = (0, Yi.prism)(() => {
    });
    function fy(g, S, k) {
      const z = S.getValue();
      if (k.keyframes.length === 0)
        return {
          started: !0,
          validFrom: -1 / 0,
          validTo: 1 / 0,
          der: py
        };
      let X = 0;
      for (; ; ) {
        const te = k.keyframes[X];
        if (!te)
          return process.env.NODE_ENV !== "production" && g.logger.error("Bug here"), si.error;
        const fe = X === k.keyframes.length - 1;
        if (z < te.position)
          return X === 0 ? si.beforeFirstKeyframe(te) : (process.env.NODE_ENV !== "production" && g.logger.error("Bug here"), si.error);
        if (te.position === z)
          return fe ? si.lastKeyframe(te) : si.between(
            te,
            k.keyframes[X + 1],
            S
          );
        if (X === k.keyframes.length - 1)
          return si.lastKeyframe(te);
        {
          const Re = X + 1;
          if (k.keyframes[Re].position <= z) {
            X = Re;
            continue;
          } else
            return si.between(
              te,
              k.keyframes[X + 1],
              S
            );
        }
      }
    }
    var si = {
      beforeFirstKeyframe(g) {
        return {
          started: !0,
          validFrom: -1 / 0,
          validTo: g.position,
          der: (0, Yi.prism)(() => ({ left: g.value, progression: 0 }))
        };
      },
      lastKeyframe(g) {
        return {
          started: !0,
          validFrom: g.position,
          validTo: 1 / 0,
          der: (0, Yi.prism)(() => ({ left: g.value, progression: 0 }))
        };
      },
      between(g, S, k) {
        if (!g.connectedRight)
          return {
            started: !0,
            validFrom: g.position,
            validTo: S.position,
            der: (0, Yi.prism)(() => ({ left: g.value, progression: 0 }))
          };
        const z = (te) => (te - g.position) / (S.position - g.position);
        if (!g.type || g.type === "bezier") {
          const te = new dx.default(
            g.handles[2],
            g.handles[3],
            S.handles[0],
            S.handles[1]
          ), fe = (0, Yi.prism)(() => {
            const Re = z(
              k.getValue()
            ), Le = te.solveSimple(Re);
            return {
              left: g.value,
              right: S.value,
              progression: Le
            };
          });
          return {
            started: !0,
            validFrom: g.position,
            validTo: S.position,
            der: fe
          };
        }
        const X = (0, Yi.prism)(() => {
          const te = z(
            k.getValue()
          ), fe = Math.floor(te);
          return {
            left: g.value,
            right: S.value,
            progression: fe
          };
        });
        return {
          started: !0,
          validFrom: g.position,
          validTo: S.position,
          der: X
        };
      },
      error: {
        started: !0,
        validFrom: -1 / 0,
        validTo: 1 / 0,
        der: py
      }
    };
    function ra(g, S, k) {
      const X = k.get(g);
      if (X && X.override === S)
        return X.merged;
      const te = I({}, g);
      for (const fe of Object.keys(S)) {
        const Re = S[fe], Le = g[fe];
        te[fe] = typeof Re == "object" && typeof Le == "object" ? ra(
          Le,
          Re,
          k
        ) : Re === void 0 ? Le : Re;
      }
      return k.set(g, { override: S, merged: te }), te;
    }
    function Da(g, S) {
      let k = g;
      for (const z of S)
        k = k[z];
      return k;
    }
    var Fc = ut(), Pu = (g, S) => {
      const k = Fc.prism.memo(g, () => new Fc.Atom(S), []);
      return k.set(S), k;
    }, Un = ut(), wf = ut(), Bc = /\s/;
    function Lc(g) {
      for (var S = g.length; S-- && Bc.test(g.charAt(S)); )
        ;
      return S;
    }
    var my = Lc, Ef = /^\s+/;
    function gy(g) {
      return g && g.slice(0, my(g) + 1).replace(Ef, "");
    }
    var xl = gy, jc = NaN, px = /^[-+]0x[0-9a-f]+$/i, Uc = /^0b[01]+$/i, Au = /^0o[0-7]+$/i, fx = parseInt;
    function Tf(g) {
      if (typeof g == "number")
        return g;
      if (Aa(g))
        return jc;
      if (Bi(g)) {
        var S = typeof g.valueOf == "function" ? g.valueOf() : g;
        g = Bi(S) ? S + "" : S;
      }
      if (typeof g != "string")
        return g === 0 ? g : +g;
      g = xl(g);
      var k = Uc.test(g);
      return k || Au.test(g) ? fx(g.slice(2), k ? 2 : 8) : px.test(g) ? jc : +g;
    }
    var K = Tf, ae = 1 / 0, Pe = 17976931348623157e292;
    function Ye(g) {
      if (!g)
        return g === 0 ? g : 0;
      if (g = K(g), g === ae || g === -ae) {
        var S = g < 0 ? -1 : 1;
        return S * Pe;
      }
      return g === g ? g : 0;
    }
    var Kt = Ye;
    function zn(g) {
      var S = Kt(g), k = S % 1;
      return S === S ? k ? S - k : S : 0;
    }
    var Ei = zn;
    function ms(g) {
      return g;
    }
    var xh = ms, ku = vn(Kn, "WeakMap"), Co = ku, _h = Object.create, y2 = /* @__PURE__ */ function() {
      function g() {
      }
      return function(S) {
        if (!Bi(S))
          return {};
        if (_h)
          return _h(S);
        g.prototype = S;
        var k = new g();
        return g.prototype = void 0, k;
      };
    }(), mx = y2;
    function v2(g, S) {
      var k = -1, z = g.length;
      for (S || (S = Array(z)); ++k < z; )
        S[k] = g[k];
      return S;
    }
    var b2 = v2;
    function jE(g, S) {
      for (var k = -1, z = g == null ? 0 : g.length; ++k < z && S(g[k], k, g) !== !1; )
        ;
      return g;
    }
    var yy = jE;
    function gx(g, S, k, z) {
      var X = !k;
      k || (k = {});
      for (var te = -1, fe = S.length; ++te < fe; ) {
        var Re = S[te], Le = z ? z(k[Re], g[Re], Re, k, g) : void 0;
        Le === void 0 && (Le = g[Re]), X ? bl(k, Re, Le) : bf(k, Re, Le);
      }
      return k;
    }
    var vy = gx, UE = 9007199254740991;
    function x2(g) {
      return typeof g == "number" && g > -1 && g % 1 == 0 && g <= UE;
    }
    var yx = x2;
    function zE(g) {
      return g != null && yx(g.length) && !kc(g);
    }
    var by = zE, _2 = Object.prototype;
    function vx(g) {
      var S = g && g.constructor, k = typeof S == "function" && S.prototype || _2;
      return g === k;
    }
    var xy = vx;
    function VE(g, S) {
      for (var k = -1, z = Array(g); ++k < g; )
        z[k] = S(k);
      return z;
    }
    var GE = VE, _y = "[object Arguments]";
    function bx(g) {
      return to(g) && Si(g) == _y;
    }
    var qE = bx, xx = Object.prototype, S2 = xx.hasOwnProperty, _x = xx.propertyIsEnumerable, Sx = qE(/* @__PURE__ */ function() {
      return arguments;
    }()) ? qE : function(g) {
      return to(g) && S2.call(g, "callee") && !_x.call(g, "callee");
    }, wx = Sx;
    function Ex() {
      return !1;
    }
    var HE = Ex, Tx = e && !e.nodeType && e, Sh = Tx && !0 && c && !c.nodeType && c, Cx = Sh && Sh.exports === Tx, $E = Cx ? Kn.Buffer : void 0, WE = $E ? $E.isBuffer : void 0, KE = WE || HE, Cf = KE, YE = "[object Arguments]", XE = "[object Array]", QE = "[object Boolean]", ZE = "[object Date]", JE = "[object Error]", eT = "[object Function]", tT = "[object Map]", nT = "[object Number]", rT = "[object Object]", iT = "[object RegExp]", sT = "[object Set]", oT = "[object String]", aT = "[object WeakMap]", lT = "[object ArrayBuffer]", uT = "[object DataView]", cT = "[object Float32Array]", dT = "[object Float64Array]", hT = "[object Int8Array]", pT = "[object Int16Array]", fT = "[object Int32Array]", mT = "[object Uint8Array]", mr = "[object Uint8ClampedArray]", gT = "[object Uint16Array]", w2 = "[object Uint32Array]", wr = {};
    wr[cT] = wr[dT] = wr[hT] = wr[pT] = wr[fT] = wr[mT] = wr[mr] = wr[gT] = wr[w2] = !0, wr[YE] = wr[XE] = wr[lT] = wr[QE] = wr[uT] = wr[ZE] = wr[JE] = wr[eT] = wr[tT] = wr[nT] = wr[rT] = wr[iT] = wr[sT] = wr[oT] = wr[aT] = !1;
    function wh(g) {
      return to(g) && yx(g.length) && !!wr[Si(g)];
    }
    var Pf = wh;
    function Px(g) {
      return function(S) {
        return g(S);
      };
    }
    var Mu = Px, Ax = e && !e.nodeType && e, Ru = Ax && !0 && c && !c.nodeType && c, yT = Ru && Ru.exports === Ax, _l = yT && an.process, kx = function() {
      try {
        var g = Ru && Ru.require && Ru.require("util").types;
        return g || _l && _l.binding && _l.binding("util");
      } catch {
      }
    }(), Iu = kx, Mx = Iu && Iu.isTypedArray, Rx = Mx ? Mu(Mx) : Pf, Ix = Rx, E2 = Object.prototype, vT = E2.hasOwnProperty;
    function bT(g, S) {
      var k = Ht(g), z = !k && wx(g), X = !k && !z && Cf(g), te = !k && !z && !X && Ix(g), fe = k || z || X || te, Re = fe ? GE(g.length, String) : [], Le = Re.length;
      for (var We in g)
        (S || vT.call(g, We)) && !(fe && // Safari 9 has enumerable `arguments.length` in strict mode.
        (We == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        X && (We == "offset" || We == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        te && (We == "buffer" || We == "byteLength" || We == "byteOffset") || // Skip index properties.
        Cu(We, Le))) && Re.push(We);
      return Re;
    }
    var Sy = bT;
    function xT(g, S) {
      return function(k) {
        return g(S(k));
      };
    }
    var _T = xT, Nx = _T(Object.keys, Object), ST = Nx, wT = Object.prototype, ET = wT.hasOwnProperty;
    function T2(g) {
      if (!xy(g))
        return ST(g);
      var S = [];
      for (var k in Object(g))
        ET.call(g, k) && k != "constructor" && S.push(k);
      return S;
    }
    var C2 = T2;
    function TT(g) {
      return by(g) ? Sy(g) : C2(g);
    }
    var Eh = TT;
    function CT(g) {
      var S = [];
      if (g != null)
        for (var k in Object(g))
          S.push(k);
      return S;
    }
    var P2 = CT, A2 = Object.prototype, Th = A2.hasOwnProperty;
    function Af(g) {
      if (!Bi(g))
        return P2(g);
      var S = xy(g), k = [];
      for (var z in g)
        z == "constructor" && (S || !Th.call(g, z)) || k.push(z);
      return k;
    }
    var k2 = Af;
    function PT(g) {
      return by(g) ? Sy(g, !0) : k2(g);
    }
    var Ox = PT;
    function M2(g, S) {
      for (var k = -1, z = S.length, X = g.length; ++k < z; )
        g[X + k] = S[k];
      return g;
    }
    var Dx = M2, AT = _T(Object.getPrototypeOf, Object), wy = AT, R2 = "[object Object]", I2 = Function.prototype, Ey = Object.prototype, Ty = I2.toString, N2 = Ey.hasOwnProperty, kT = Ty.call(Object);
    function MT(g) {
      if (!to(g) || Si(g) != R2)
        return !1;
      var S = wy(g);
      if (S === null)
        return !0;
      var k = N2.call(S, "constructor") && S.constructor;
      return typeof k == "function" && k instanceof k && Ty.call(k) == kT;
    }
    var Cy = MT;
    function Fx(g, S, k) {
      var z = -1, X = g.length;
      S < 0 && (S = -S > X ? 0 : X + S), k = k > X ? X : k, k < 0 && (k += X), X = S > k ? 0 : k - S >>> 0, S >>>= 0;
      for (var te = Array(X); ++z < X; )
        te[z] = g[z + S];
      return te;
    }
    var Bx = Fx;
    function Ch(g, S, k) {
      var z = g.length;
      return k = k === void 0 ? z : k, !S && k >= z ? g : Bx(g, S, k);
    }
    var Py = Ch, O2 = "\\ud800-\\udfff", RT = "\\u0300-\\u036f", D2 = "\\ufe20-\\ufe2f", F2 = "\\u20d0-\\u20ff", IT = RT + D2 + F2, B2 = "\\ufe0e\\ufe0f", L2 = "\\u200d", NT = RegExp("[" + L2 + O2 + IT + B2 + "]");
    function OT(g) {
      return NT.test(g);
    }
    var Ay = OT;
    function DT(g) {
      return g.split("");
    }
    var j2 = DT, FT = "\\ud800-\\udfff", BT = "\\u0300-\\u036f", LT = "\\ufe20-\\ufe2f", jT = "\\u20d0-\\u20ff", U2 = BT + LT + jT, z2 = "\\ufe0e\\ufe0f", UT = "[" + FT + "]", ky = "[" + U2 + "]", Lx = "\\ud83c[\\udffb-\\udfff]", Ph = "(?:" + ky + "|" + Lx + ")", My = "[^" + FT + "]", zT = "(?:\\ud83c[\\udde6-\\uddff]){2}", VT = "[\\ud800-\\udbff][\\udc00-\\udfff]", GT = "\\u200d", qT = Ph + "?", HT = "[" + z2 + "]?", kf = "(?:" + GT + "(?:" + [My, zT, VT].join("|") + ")" + HT + qT + ")*", Ry = HT + qT + kf, V2 = "(?:" + [My + ky + "?", ky, zT, VT, UT].join("|") + ")", $T = RegExp(Lx + "(?=" + Lx + ")|" + V2 + Ry, "g");
    function WT(g) {
      return g.match($T) || [];
    }
    var KT = WT;
    function G2(g) {
      return Ay(g) ? KT(g) : j2(g);
    }
    var q2 = G2;
    function YT(g, S, k) {
      return g === g && (k !== void 0 && (g = g <= k ? g : k), S !== void 0 && (g = g >= S ? g : S)), g;
    }
    var H2 = YT;
    function $2(g, S, k) {
      return k === void 0 && (k = S, S = void 0), k !== void 0 && (k = K(k), k = k === k ? k : 0), S !== void 0 && (S = K(S), S = S === S ? S : 0), H2(K(g), S, k);
    }
    var jx = $2;
    function W2() {
      this.__data__ = new ph(), this.size = 0;
    }
    var K2 = W2;
    function XT(g) {
      var S = this.__data__, k = S.delete(g);
      return this.size = S.size, k;
    }
    var Y2 = XT;
    function Ah(g) {
      return this.__data__.get(g);
    }
    var Mf = Ah;
    function Iy(g) {
      return this.__data__.has(g);
    }
    var QT = Iy, kh = 200;
    function Ux(g, S) {
      var k = this.__data__;
      if (k instanceof ph) {
        var z = k.__data__;
        if (!xu || z.length < kh - 1)
          return z.push([g, S]), this.size = ++k.size, this;
        k = this.__data__ = new fh(z);
      }
      return k.set(g, S), this.size = k.size, this;
    }
    var X2 = Ux;
    function zc(g) {
      var S = this.__data__ = new ph(g);
      this.size = S.size;
    }
    zc.prototype.clear = K2, zc.prototype.delete = Y2, zc.prototype.get = Mf, zc.prototype.has = QT, zc.prototype.set = X2;
    var Rf = zc;
    function Q2(g, S) {
      return g && vy(S, Eh(S), g);
    }
    var ZT = Q2;
    function Z2(g, S) {
      return g && vy(S, Ox(S), g);
    }
    var J2 = Z2, Mh = e && !e.nodeType && e, If = Mh && !0 && c && !c.nodeType && c, eD = If && If.exports === Mh, zx = eD ? Kn.Buffer : void 0, JT = zx ? zx.allocUnsafe : void 0;
    function tD(g, S) {
      if (S)
        return g.slice();
      var k = g.length, z = JT ? JT(k) : new g.constructor(k);
      return g.copy(z), z;
    }
    var eC = tD;
    function nD(g, S) {
      for (var k = -1, z = g == null ? 0 : g.length, X = 0, te = []; ++k < z; ) {
        var fe = g[k];
        S(fe, k, g) && (te[X++] = fe);
      }
      return te;
    }
    var rD = nD;
    function tC() {
      return [];
    }
    var nC = tC, iD = Object.prototype, rC = iD.propertyIsEnumerable, iC = Object.getOwnPropertySymbols, Rh = iC ? function(g) {
      return g == null ? [] : (g = Object(g), rD(iC(g), function(S) {
        return rC.call(g, S);
      }));
    } : nC, Vc = Rh;
    function Vx(g, S) {
      return vy(g, Vc(g), S);
    }
    var Gx = Vx, sC = Object.getOwnPropertySymbols, qx = sC ? function(g) {
      for (var S = []; g; )
        Dx(S, Vc(g)), g = wy(g);
      return S;
    } : nC, Hx = qx;
    function sD(g, S) {
      return vy(g, Hx(g), S);
    }
    var oC = sD;
    function aC(g, S, k) {
      var z = S(g);
      return Ht(g) ? z : Dx(z, k(g));
    }
    var lC = aC;
    function uC(g) {
      return lC(g, Eh, Vc);
    }
    var Ny = uC;
    function cC(g) {
      return lC(g, Ox, Hx);
    }
    var dC = cC, oD = vn(Kn, "DataView"), $x = oD, Oy = vn(Kn, "Promise"), Dy = Oy, aD = vn(Kn, "Set"), Ih = aD, Fy = "[object Map]", lD = "[object Object]", Wx = "[object Promise]", Gc = "[object Set]", Nh = "[object WeakMap]", hC = "[object DataView]", By = Or($x), Kx = Or(xu), uD = Or(Dy), qc = Or(Ih), Nf = Or(Co), Hc = Si;
    ($x && Hc(new $x(new ArrayBuffer(1))) != hC || xu && Hc(new xu()) != Fy || Dy && Hc(Dy.resolve()) != Wx || Ih && Hc(new Ih()) != Gc || Co && Hc(new Co()) != Nh) && (Hc = function(g) {
      var S = Si(g), k = S == lD ? g.constructor : void 0, z = k ? Or(k) : "";
      if (z)
        switch (z) {
          case By:
            return hC;
          case Kx:
            return Fy;
          case uD:
            return Wx;
          case qc:
            return Gc;
          case Nf:
            return Nh;
        }
      return S;
    });
    var Nu = Hc, Yx = Object.prototype, cD = Yx.hasOwnProperty;
    function Xx(g) {
      var S = g.length, k = new g.constructor(S);
      return S && typeof g[0] == "string" && cD.call(g, "index") && (k.index = g.index, k.input = g.input), k;
    }
    var pC = Xx, dD = Kn.Uint8Array, Of = dD;
    function fC(g) {
      var S = new g.constructor(g.byteLength);
      return new Of(S).set(new Of(g)), S;
    }
    var Qx = fC;
    function mC(g, S) {
      var k = S ? Qx(g.buffer) : g.buffer;
      return new g.constructor(k, g.byteOffset, g.byteLength);
    }
    var Ly = mC, Zx = /\w*$/;
    function hD(g) {
      var S = new g.constructor(g.source, Zx.exec(g));
      return S.lastIndex = g.lastIndex, S;
    }
    var gC = hD, Jx = _r ? _r.prototype : void 0, e_ = Jx ? Jx.valueOf : void 0;
    function t_(g) {
      return e_ ? Object(e_.call(g)) : {};
    }
    var yC = t_;
    function vC(g, S) {
      var k = S ? Qx(g.buffer) : g.buffer;
      return new g.constructor(k, g.byteOffset, g.length);
    }
    var jy = vC, bC = "[object Boolean]", pD = "[object Date]", xC = "[object Map]", _C = "[object Number]", SC = "[object RegExp]", fD = "[object Set]", mD = "[object String]", wC = "[object Symbol]", gD = "[object ArrayBuffer]", yD = "[object DataView]", ir = "[object Float32Array]", Df = "[object Float64Array]", vD = "[object Int8Array]", EC = "[object Int16Array]", bD = "[object Int32Array]", xD = "[object Uint8Array]", TC = "[object Uint8ClampedArray]", _D = "[object Uint16Array]", SD = "[object Uint32Array]";
    function CC(g, S, k) {
      var z = g.constructor;
      switch (S) {
        case gD:
          return Qx(g);
        case bC:
        case pD:
          return new z(+g);
        case yD:
          return Ly(g, k);
        case ir:
        case Df:
        case vD:
        case EC:
        case bD:
        case xD:
        case TC:
        case _D:
        case SD:
          return jy(g, k);
        case xC:
          return new z();
        case _C:
        case mD:
          return new z(g);
        case SC:
          return gC(g);
        case fD:
          return new z();
        case wC:
          return yC(g);
      }
    }
    var wD = CC;
    function ED(g) {
      return typeof g.constructor == "function" && !xy(g) ? mx(wy(g)) : {};
    }
    var PC = ED, TD = "[object Map]";
    function CD(g) {
      return to(g) && Nu(g) == TD;
    }
    var AC = CD, n_ = Iu && Iu.isMap, PD = n_ ? Mu(n_) : AC, Oh = PD, Dh = "[object Set]";
    function r_(g) {
      return to(g) && Nu(g) == Dh;
    }
    var AD = r_, i_ = Iu && Iu.isSet, kD = i_ ? Mu(i_) : AD, MD = kD, kC = 1, RD = 2, ID = 4, Uy = "[object Arguments]", s_ = "[object Array]", MC = "[object Boolean]", o_ = "[object Date]", a_ = "[object Error]", l_ = "[object Function]", ND = "[object GeneratorFunction]", OD = "[object Map]", RC = "[object Number]", IC = "[object Object]", DD = "[object RegExp]", u_ = "[object Set]", NC = "[object String]", OC = "[object Symbol]", DC = "[object WeakMap]", c_ = "[object ArrayBuffer]", FC = "[object DataView]", zy = "[object Float32Array]", d_ = "[object Float64Array]", FD = "[object Int8Array]", BC = "[object Int16Array]", BD = "[object Int32Array]", LC = "[object Uint8Array]", jC = "[object Uint8ClampedArray]", h_ = "[object Uint16Array]", UC = "[object Uint32Array]", gr = {};
    gr[Uy] = gr[s_] = gr[c_] = gr[FC] = gr[MC] = gr[o_] = gr[zy] = gr[d_] = gr[FD] = gr[BC] = gr[BD] = gr[OD] = gr[RC] = gr[IC] = gr[DD] = gr[u_] = gr[NC] = gr[OC] = gr[LC] = gr[jC] = gr[h_] = gr[UC] = !0, gr[a_] = gr[l_] = gr[DC] = !1;
    function Ff(g, S, k, z, X, te) {
      var fe, Re = S & kC, Le = S & RD, We = S & ID;
      if (k && (fe = X ? k(g, z, X, te) : k(g)), fe !== void 0)
        return fe;
      if (!Bi(g))
        return g;
      var ot = Ht(g);
      if (ot) {
        if (fe = pC(g), !Re)
          return b2(g, fe);
      } else {
        var pt = Nu(g), _t = pt == l_ || pt == ND;
        if (Cf(g))
          return eC(g, Re);
        if (pt == IC || pt == Uy || _t && !X) {
          if (fe = Le || _t ? {} : PC(g), !Re)
            return Le ? oC(g, J2(fe, g)) : Gx(g, ZT(fe, g));
        } else {
          if (!gr[pt])
            return X ? g : {};
          fe = wD(g, pt, Re);
        }
      }
      te || (te = new Rf());
      var Rt = te.get(g);
      if (Rt)
        return Rt;
      te.set(g, fe), MD(g) ? g.forEach(function(mn) {
        fe.add(Ff(mn, S, k, mn, g, te));
      }) : Oh(g) && g.forEach(function(mn, Jt) {
        fe.set(Jt, Ff(mn, S, k, Jt, g, te));
      });
      var Mt = We ? Le ? dC : Ny : Le ? Ox : Eh, ln = ot ? void 0 : Mt(g);
      return yy(ln || g, function(mn, Jt) {
        ln && (Jt = mn, mn = g[Jt]), bf(fe, Jt, Ff(mn, S, k, Jt, g, te));
      }), fe;
    }
    var LD = Ff, jD = 1, p_ = 4;
    function zC(g) {
      return LD(g, jD | p_);
    }
    var UD = zC, Vy = "__lodash_hash_undefined__";
    function VC(g) {
      return this.__data__.set(g, Vy), this;
    }
    var zD = VC;
    function GC(g) {
      return this.__data__.has(g);
    }
    var VD = GC;
    function Bf(g) {
      var S = -1, k = g == null ? 0 : g.length;
      for (this.__data__ = new fh(); ++S < k; )
        this.add(g[S]);
    }
    Bf.prototype.add = Bf.prototype.push = zD, Bf.prototype.has = VD;
    var Gy = Bf;
    function GD(g, S) {
      for (var k = -1, z = g == null ? 0 : g.length; ++k < z; )
        if (S(g[k], k, g))
          return !0;
      return !1;
    }
    var qC = GD;
    function qy(g, S) {
      return g.has(S);
    }
    var qD = qy, HC = 1, $c = 2;
    function $C(g, S, k, z, X, te) {
      var fe = k & HC, Re = g.length, Le = S.length;
      if (Re != Le && !(fe && Le > Re))
        return !1;
      var We = te.get(g), ot = te.get(S);
      if (We && ot)
        return We == S && ot == g;
      var pt = -1, _t = !0, Rt = k & $c ? new Gy() : void 0;
      for (te.set(g, S), te.set(S, g); ++pt < Re; ) {
        var Mt = g[pt], ln = S[pt];
        if (z)
          var mn = fe ? z(ln, Mt, pt, S, g, te) : z(Mt, ln, pt, g, S, te);
        if (mn !== void 0) {
          if (mn)
            continue;
          _t = !1;
          break;
        }
        if (Rt) {
          if (!qC(S, function(Jt, Dn) {
            if (!qD(Rt, Dn) && (Mt === Jt || X(Mt, Jt, k, z, te)))
              return Rt.push(Dn);
          })) {
            _t = !1;
            break;
          }
        } else if (!(Mt === ln || X(Mt, ln, k, z, te))) {
          _t = !1;
          break;
        }
      }
      return te.delete(g), te.delete(S), _t;
    }
    var Hy = $C;
    function WC(g) {
      var S = -1, k = Array(g.size);
      return g.forEach(function(z, X) {
        k[++S] = [X, z];
      }), k;
    }
    var f_ = WC;
    function m_(g) {
      var S = -1, k = Array(g.size);
      return g.forEach(function(z) {
        k[++S] = z;
      }), k;
    }
    var g_ = m_, y_ = 1, KC = 2, YC = "[object Boolean]", XC = "[object Date]", QC = "[object Error]", ZC = "[object Map]", Ou = "[object Number]", Fh = "[object RegExp]", $y = "[object Set]", HD = "[object String]", JC = "[object Symbol]", eP = "[object ArrayBuffer]", tP = "[object DataView]", nP = _r ? _r.prototype : void 0, Wy = nP ? nP.valueOf : void 0;
    function Lf(g, S, k, z, X, te, fe) {
      switch (k) {
        case tP:
          if (g.byteLength != S.byteLength || g.byteOffset != S.byteOffset)
            return !1;
          g = g.buffer, S = S.buffer;
        case eP:
          return !(g.byteLength != S.byteLength || !te(new Of(g), new Of(S)));
        case YC:
        case XC:
        case Ou:
          return cf(+g, +S);
        case QC:
          return g.name == S.name && g.message == S.message;
        case Fh:
        case HD:
          return g == S + "";
        case ZC:
          var Re = f_;
        case $y:
          var Le = z & y_;
          if (Re || (Re = g_), g.size != S.size && !Le)
            return !1;
          var We = fe.get(g);
          if (We)
            return We == S;
          z |= KC, fe.set(g, S);
          var ot = Hy(Re(g), Re(S), z, X, te, fe);
          return fe.delete(g), ot;
        case JC:
          if (Wy)
            return Wy.call(g) == Wy.call(S);
      }
      return !1;
    }
    var rP = Lf, $D = 1, Ky = Object.prototype, v_ = Ky.hasOwnProperty;
    function WD(g, S, k, z, X, te) {
      var fe = k & $D, Re = Ny(g), Le = Re.length, We = Ny(S), ot = We.length;
      if (Le != ot && !fe)
        return !1;
      for (var pt = Le; pt--; ) {
        var _t = Re[pt];
        if (!(fe ? _t in S : v_.call(S, _t)))
          return !1;
      }
      var Rt = te.get(g), Mt = te.get(S);
      if (Rt && Mt)
        return Rt == S && Mt == g;
      var ln = !0;
      te.set(g, S), te.set(S, g);
      for (var mn = fe; ++pt < Le; ) {
        _t = Re[pt];
        var Jt = g[_t], Dn = S[_t];
        if (z)
          var hi = fe ? z(Dn, Jt, _t, S, g, te) : z(Jt, Dn, _t, g, S, te);
        if (!(hi === void 0 ? Jt === Dn || X(Jt, Dn, k, z, te) : hi)) {
          ln = !1;
          break;
        }
        mn || (mn = _t == "constructor");
      }
      if (ln && !mn) {
        var ar = g.constructor, pi = S.constructor;
        ar != pi && "constructor" in g && "constructor" in S && !(typeof ar == "function" && ar instanceof ar && typeof pi == "function" && pi instanceof pi) && (ln = !1);
      }
      return te.delete(g), te.delete(S), ln;
    }
    var iP = WD, KD = 1, sP = "[object Arguments]", b_ = "[object Array]", jf = "[object Object]", YD = Object.prototype, oP = YD.hasOwnProperty;
    function x_(g, S, k, z, X, te) {
      var fe = Ht(g), Re = Ht(S), Le = fe ? b_ : Nu(g), We = Re ? b_ : Nu(S);
      Le = Le == sP ? jf : Le, We = We == sP ? jf : We;
      var ot = Le == jf, pt = We == jf, _t = Le == We;
      if (_t && Cf(g)) {
        if (!Cf(S))
          return !1;
        fe = !0, ot = !1;
      }
      if (_t && !ot)
        return te || (te = new Rf()), fe || Ix(g) ? Hy(g, S, k, z, X, te) : rP(g, S, Le, k, z, X, te);
      if (!(k & KD)) {
        var Rt = ot && oP.call(g, "__wrapped__"), Mt = pt && oP.call(S, "__wrapped__");
        if (Rt || Mt) {
          var ln = Rt ? g.value() : g, mn = Mt ? S.value() : S;
          return te || (te = new Rf()), X(ln, mn, k, z, te);
        }
      }
      return _t ? (te || (te = new Rf()), iP(g, S, k, z, X, te)) : !1;
    }
    var __ = x_;
    function S_(g, S, k, z, X) {
      return g === S ? !0 : g == null || S == null || !to(g) && !to(S) ? g !== g && S !== S : __(g, S, k, z, S_, X);
    }
    var aP = S_, XD = 1, lP = 2;
    function QD(g, S, k, z) {
      var X = k.length, te = X, fe = !z;
      if (g == null)
        return !te;
      for (g = Object(g); X--; ) {
        var Re = k[X];
        if (fe && Re[2] ? Re[1] !== g[Re[0]] : !(Re[0] in g))
          return !1;
      }
      for (; ++X < te; ) {
        Re = k[X];
        var Le = Re[0], We = g[Le], ot = Re[1];
        if (fe && Re[2]) {
          if (We === void 0 && !(Le in g))
            return !1;
        } else {
          var pt = new Rf();
          if (z)
            var _t = z(We, ot, Le, g, S, pt);
          if (!(_t === void 0 ? aP(ot, We, XD | lP, z, pt) : _t))
            return !1;
        }
      }
      return !0;
    }
    var ZD = QD;
    function uP(g) {
      return g === g && !Bi(g);
    }
    var w_ = uP;
    function cP(g) {
      for (var S = Eh(g), k = S.length; k--; ) {
        var z = S[k], X = g[z];
        S[k] = [z, X, w_(X)];
      }
      return S;
    }
    var dP = cP;
    function hP(g, S) {
      return function(k) {
        return k == null ? !1 : k[g] === S && (S !== void 0 || g in Object(k));
      };
    }
    var E_ = hP;
    function pP(g) {
      var S = dP(g);
      return S.length == 1 && S[0][2] ? E_(S[0][0], S[0][1]) : function(k) {
        return k === g || ZD(k, g, S);
      };
    }
    var fP = pP;
    function mP(g, S) {
      return g != null && S in Object(g);
    }
    var gP = mP;
    function yP(g, S, k) {
      S = wu(S, g);
      for (var z = -1, X = S.length, te = !1; ++z < X; ) {
        var fe = To(S[z]);
        if (!(te = g != null && k(g, fe)))
          break;
        g = g[fe];
      }
      return te || ++z != X ? te : (X = g == null ? 0 : g.length, !!X && yx(X) && Cu(fe, X) && (Ht(g) || wx(g)));
    }
    var vP = yP;
    function bP(g, S) {
      return g != null && vP(g, S, gP);
    }
    var xP = bP, _P = 1, SP = 2;
    function wP(g, S) {
      return mu(g) && w_(S) ? E_(To(g), S) : function(k) {
        var z = Oa(k, g);
        return z === void 0 && z === S ? xP(k, g) : aP(S, z, _P | SP);
      };
    }
    var EP = wP;
    function TP(g) {
      return function(S) {
        return S?.[g];
      };
    }
    var T_ = TP;
    function JD(g) {
      return function(S) {
        return gh(S, g);
      };
    }
    var eF = JD;
    function CP(g) {
      return mu(g) ? T_(To(g)) : eF(g);
    }
    var tF = CP;
    function nF(g) {
      return typeof g == "function" ? g : g == null ? xh : typeof g == "object" ? Ht(g) ? EP(g[0], g[1]) : fP(g) : tF(g);
    }
    var PP = nF;
    function AP(g) {
      return function(S, k, z) {
        for (var X = -1, te = Object(S), fe = z(S), Re = fe.length; Re--; ) {
          var Le = fe[g ? Re : ++X];
          if (k(te[Le], Le, te) === !1)
            break;
        }
        return S;
      };
    }
    var rF = AP, C_ = rF(), kP = C_;
    function MP(g, S) {
      return g && kP(g, S, Eh);
    }
    var iF = MP, sF = function() {
      return Kn.Date.now();
    }, Yy = sF, RP = "Expected a function", oF = Math.max, P_ = Math.min;
    function IP(g, S, k) {
      var z, X, te, fe, Re, Le, We = 0, ot = !1, pt = !1, _t = !0;
      if (typeof g != "function")
        throw new TypeError(RP);
      S = K(S) || 0, Bi(k) && (ot = !!k.leading, pt = "maxWait" in k, te = pt ? oF(K(k.maxWait) || 0, S) : te, _t = "trailing" in k ? !!k.trailing : _t);
      function Rt(tn) {
        var fi = z, Xi = X;
        return z = X = void 0, We = tn, fe = g.apply(Xi, fi), fe;
      }
      function Mt(tn) {
        return We = tn, Re = setTimeout(Jt, S), ot ? Rt(tn) : fe;
      }
      function ln(tn) {
        var fi = tn - Le, Xi = tn - We, xe = S - fi;
        return pt ? P_(xe, te - Xi) : xe;
      }
      function mn(tn) {
        var fi = tn - Le, Xi = tn - We;
        return Le === void 0 || fi >= S || fi < 0 || pt && Xi >= te;
      }
      function Jt() {
        var tn = Yy();
        if (mn(tn))
          return Dn(tn);
        Re = setTimeout(Jt, ln(tn));
      }
      function Dn(tn) {
        return Re = void 0, _t && z ? Rt(tn) : (z = X = void 0, fe);
      }
      function hi() {
        Re !== void 0 && clearTimeout(Re), We = 0, z = Le = X = Re = void 0;
      }
      function ar() {
        return Re === void 0 ? fe : Dn(Yy());
      }
      function pi() {
        var tn = Yy(), fi = mn(tn);
        if (z = arguments, X = this, Le = tn, fi) {
          if (Re === void 0)
            return Mt(Le);
          if (pt)
            return clearTimeout(Re), Re = setTimeout(Jt, S), Rt(Le);
        }
        return Re === void 0 && (Re = setTimeout(Jt, S)), fe;
      }
      return pi.cancel = hi, pi.flush = ar, pi;
    }
    var NP = IP;
    function aF(g) {
      var S = g == null ? 0 : g.length;
      return S ? g[S - 1] : void 0;
    }
    var Xy = aF;
    function OP(g, S) {
      return S.length < 2 ? g : gh(g, Bx(S, 0, -1));
    }
    var DP = OP;
    function FP(g) {
      return typeof g == "number" && g == Ei(g);
    }
    var A_ = FP;
    function BP(g, S) {
      var k = {};
      return S = PP(S), iF(g, function(z, X, te) {
        bl(k, X, S(z, X, te));
      }), k;
    }
    var LP = BP;
    function jP(g, S) {
      return S = wu(S, g), g = DP(g, S), g == null || delete g[To(Xy(S))];
    }
    var UP = jP, k_ = 9007199254740991, zP = Math.floor;
    function VP(g, S) {
      var k = "";
      if (!g || S < 1 || S > k_)
        return k;
      do
        S % 2 && (k += g), S = zP(S / 2), S && (g += g);
      while (S);
      return k;
    }
    var M_ = VP, R_ = T_("length"), GP = R_, I_ = "\\ud800-\\udfff", qP = "\\u0300-\\u036f", HP = "\\ufe20-\\ufe2f", $P = "\\u20d0-\\u20ff", WP = qP + HP + $P, KP = "\\ufe0e\\ufe0f", YP = "[" + I_ + "]", Qy = "[" + WP + "]", Zy = "\\ud83c[\\udffb-\\udfff]", XP = "(?:" + Qy + "|" + Zy + ")", N_ = "[^" + I_ + "]", O_ = "(?:\\ud83c[\\udde6-\\uddff]){2}", D_ = "[\\ud800-\\udbff][\\udc00-\\udfff]", QP = "\\u200d", F_ = XP + "?", sr = "[" + KP + "]?", ZP = "(?:" + QP + "(?:" + [N_, O_, D_].join("|") + ")" + sr + F_ + ")*", lF = sr + F_ + ZP, uF = "(?:" + [N_ + Qy + "?", Qy, O_, D_, YP].join("|") + ")", B_ = RegExp(Zy + "(?=" + Zy + ")|" + uF + lF, "g");
    function JP(g) {
      for (var S = B_.lastIndex = 0; B_.test(g); )
        ++S;
      return S;
    }
    var eA = JP;
    function cF(g) {
      return Ay(g) ? eA(g) : GP(g);
    }
    var tA = cF, nA = Math.ceil;
    function rA(g, S) {
      S = S === void 0 ? " " : ty(S);
      var k = S.length;
      if (k < 2)
        return k ? M_(S, g) : S;
      var z = M_(S, nA(g / tA(S)));
      return Ay(S) ? Py(q2(z), 0, g).join("") : z.slice(0, g);
    }
    var dF = rA;
    function hF(g, S, k) {
      g = Oc(g), S = Ei(S);
      var z = S ? tA(g) : 0;
      return S && z < S ? dF(S - z, k) + g : g;
    }
    var Bh = hF;
    function pF(g, S) {
      return g == null ? !0 : UP(g, S);
    }
    var Uf = pF, L_ = 5 * 1e3, iA = class {
      /**
       * @internal
       */
      constructor(g) {
        J(this, "_cache", new vl()), J(this, "_keepHotUntapDebounce"), st(this, g);
      }
      get type() {
        return "Theatre_SheetObject_PublicAPI";
      }
      get props() {
        return Tt(this).propsP;
      }
      get sheet() {
        return Tt(this).sheet.publicApi;
      }
      get project() {
        return Tt(this).sheet.project.publicApi;
      }
      get address() {
        return I({}, Tt(this).address);
      }
      _valuesPrism() {
        return this._cache.get("_valuesPrism", () => {
          const g = Tt(this);
          return (0, wf.prism)(() => (0, wf.val)(g.getValues().getValue()));
        });
      }
      onValuesChange(g, S) {
        return v1(this._valuesPrism(), g, S);
      }
      // internal: Make the deviration keepHot if directly read
      get value() {
        const g = this._valuesPrism();
        {
          if (!g.isHot) {
            this._keepHotUntapDebounce != null && (process.env.NODE_ENV === "development" && Tt(this)._logger.errorDev(
              "`sheet.value` keepHot debouncer is set, even though the derivation is not actually hot."
            ), this._keepHotUntapDebounce.flush());
            const S = g.keepHot();
            this._keepHotUntapDebounce = NP(() => {
              S(), this._keepHotUntapDebounce = void 0;
            }, L_);
          }
          this._keepHotUntapDebounce && this._keepHotUntapDebounce();
        }
        return g.getValue();
      }
      set initialValue(g) {
        Tt(this).setInitialValue(g);
      }
    };
    function fF(g) {
      const S = /* @__PURE__ */ new WeakMap();
      return (k) => (S.has(k) || S.set(k, g(k)), S.get(k));
    }
    function zf(g) {
      return g.type === "compound" || g.type === "enum";
    }
    function j_(g, S) {
      if (!g)
        return;
      const [k, ...z] = S;
      if (k === void 0)
        return g;
      if (!zf(g))
        return;
      const X = g.type === "enum" ? g.cases[k] : g.props[k];
      return j_(X, z);
    }
    function mF(g) {
      return !zf(g);
    }
    var U_ = class {
      constructor(g, S, k) {
        this.sheet = g, this.template = S, this.nativeObject = k, J(this, "$$isPointerToPrismProvider", !0), J(this, "address"), J(this, "publicApi"), J(this, "_initialValue", new Un.Atom({})), J(this, "_cache", new vl()), J(this, "_logger"), J(this, "_internalUtilCtx"), this._logger = g._logger.named(
          "SheetObject",
          S.address.objectKey
        ), this._logger._trace("creating object"), this._internalUtilCtx = { logger: this._logger.utilFor.internal() }, this.address = j(I({}, S.address), {
          sheetInstanceId: g.address.sheetInstanceId
        }), this.publicApi = new iA(this);
      }
      get type() {
        return "Theatre_SheetObject";
      }
      getValues() {
        return this._cache.get(
          "getValues()",
          () => (0, Un.prism)(() => {
            const g = (0, Un.val)(this.template.getDefaultValues()), S = (0, Un.val)(this._initialValue.pointer), k = Un.prism.memo(
              "withInitialCache",
              () => /* @__PURE__ */ new WeakMap(),
              []
            ), z = ra(
              g,
              S,
              k
            ), X = (0, Un.val)(this.template.getStaticValues()), te = Un.prism.memo(
              "withStatics",
              () => /* @__PURE__ */ new WeakMap(),
              []
            );
            let Re = ra(
              z,
              X,
              te
            ), Le;
            {
              const ot = Un.prism.memo(
                "seq",
                () => this.getSequencedValues(),
                []
              ), pt = Un.prism.memo(
                "withSeqsCache",
                () => /* @__PURE__ */ new WeakMap(),
                []
              );
              Le = (0, Un.val)((0, Un.val)(ot)), Re = ra(Re, Le, pt);
            }
            return Pu("finalAtom", Re).pointer;
          })
        );
      }
      getValueByPointer(g) {
        const S = (0, Un.val)(this.getValues()), { path: k } = (0, Un.getPointerParts)(g);
        return (0, Un.val)(
          Da(S, k)
        );
      }
      pointerToPrism(g) {
        const { path: S } = (0, Un.getPointerParts)(g);
        return (0, Un.prism)(() => {
          const k = (0, Un.val)(this.getValues());
          return (0, Un.val)(Da(k, S));
        });
      }
      /**
       * Returns values of props that are sequenced.
       */
      getSequencedValues() {
        return (0, Un.prism)(() => {
          const g = Un.prism.memo(
            "tracksToProcess",
            () => this.template.getArrayOfValidSequenceTracks(),
            []
          ), S = (0, Un.val)(g), k = new Un.Atom({}), z = (0, Un.val)(this.template.configPointer);
          return Un.prism.effect(
            "processTracks",
            () => {
              const X = [];
              for (const { trackId: te, pathToProp: fe } of S) {
                const Re = this._trackIdToPrism(te), Le = j_(
                  z,
                  fe
                ), We = Le.deserializeAndSanitize, ot = Le.interpolate, pt = () => {
                  const Rt = Re.getValue();
                  if (!Rt)
                    return k.setByPointer(
                      (Dn) => Da(Dn, fe),
                      void 0
                    );
                  const Mt = We(Rt.left), ln = Mt === void 0 ? Le.default : Mt;
                  if (Rt.right === void 0)
                    return k.setByPointer(
                      (Dn) => Da(Dn, fe),
                      ln
                    );
                  const mn = We(Rt.right), Jt = mn === void 0 ? Le.default : mn;
                  return k.setByPointer(
                    (Dn) => Da(Dn, fe),
                    ot(ln, Jt, Rt.progression)
                  );
                }, _t = Re.onStale(pt);
                pt(), X.push(_t);
              }
              return () => {
                for (const te of X)
                  te();
              };
            },
            [z, ...S]
          ), k.pointer;
        });
      }
      _trackIdToPrism(g) {
        const S = this.template.project.pointers.historic.sheetsById[this.address.sheetId].sequence.tracksByObject[this.address.objectKey].trackData[g], k = this.sheet.getSequence().positionPrism;
        return hy(this._internalUtilCtx, S, k);
      }
      get propsP() {
        return this._cache.get(
          "propsP",
          () => (0, Un.pointer)({ root: this, path: [] })
        );
      }
      validateValue(g, S) {
      }
      setInitialValue(g) {
        this.validateValue(this.propsP, g), this._initialValue.set(g);
      }
    };
    function cr(g) {
      return function(k, z) {
        return g(k, z());
      };
    }
    var no = {
      _hmm: Rs(
        524
        /* _HMM */
      ),
      _todo: Rs(
        522
        /* _TODO */
      ),
      _error: Rs(
        521
        /* _ERROR */
      ),
      errorDev: Rs(
        529
        /* ERROR_DEV */
      ),
      errorPublic: Rs(
        545
        /* ERROR_PUBLIC */
      ),
      _kapow: Rs(
        268
        /* _KAPOW */
      ),
      _warn: Rs(
        265
        /* _WARN */
      ),
      warnDev: Rs(
        273
        /* WARN_DEV */
      ),
      warnPublic: Rs(
        289
        /* WARN_PUBLIC */
      ),
      _debug: Rs(
        137
        /* _DEBUG */
      ),
      debugDev: Rs(
        145
        /* DEBUG_DEV */
      ),
      _trace: Rs(
        73
        /* _TRACE */
      ),
      traceDev: Rs(
        81
        /* TRACE_DEV */
      )
    };
    function Rs(g) {
      return Object.freeze({
        audience: Du(
          g,
          8
          /* INTERNAL */
        ) ? "internal" : Du(
          g,
          16
          /* DEV */
        ) ? "dev" : "public",
        category: Du(
          g,
          4
          /* TROUBLESHOOTING */
        ) ? "troubleshooting" : Du(
          g,
          2
          /* TODO */
        ) ? "todo" : "general",
        level: (
          // I think this is equivalent... but I'm not using it until we have tests.
          // this code won't really impact performance much anyway, since it's just computed once
          // up front.
          // level &
          // (TheatreLoggerLevel.TRACE |
          //   TheatreLoggerLevel.DEBUG |
          //   TheatreLoggerLevel.WARN |
          //   TheatreLoggerLevel.ERROR),
          Du(
            g,
            512
            /* ERROR */
          ) ? 512 : Du(
            g,
            256
            /* WARN */
          ) ? 256 : Du(
            g,
            128
            /* DEBUG */
          ) ? 128 : (
            // no other option
            64
          )
        )
      });
    }
    function Du(g, S) {
      return (g & S) === S;
    }
    function or(g, S) {
      return ((S & 32) === 32 ? !0 : (S & 16) === 16 ? g.dev : (S & 8) === 8 ? g.internal : !1) && g.min <= S;
    }
    var Fa = {
      loggingConsoleStyle: !0,
      loggerConsoleStyle: !0,
      includes: Object.freeze({
        internal: !1,
        dev: !1,
        min: 256
        /* WARN */
      }),
      filtered: function() {
      },
      include: function() {
        return {};
      },
      create: null,
      creatExt: null,
      named(g, S, k) {
        return this.create({
          names: [...g.names, { name: S, key: k }]
        });
      },
      style: {
        bold: void 0,
        // /Service$/
        italic: void 0,
        // /Model$/
        cssMemo: /* @__PURE__ */ new Map([
          // handle empty names so we don't have to check for
          // name.length > 0 during this.css('')
          ["", ""]
          // bring a specific override
          // ["Marker", "color:#aea9ff;font-size:0.75em;text-transform:uppercase"]
        ]),
        collapseOnRE: /[a-z- ]+/g,
        color: void 0,
        // create collapsed name
        // insert collapsed name into cssMemo with original's style
        collapsed(g) {
          if (g.length < 5)
            return g;
          const S = g.replace(this.collapseOnRE, "");
          return this.cssMemo.has(S) || this.cssMemo.set(S, this.css(g)), S;
        },
        css(g) {
          var S, k, z, X;
          const te = this.cssMemo.get(g);
          if (te)
            return te;
          let fe = "color:".concat((k = (S = this.color) == null ? void 0 : S.call(this, g)) != null ? k : "hsl(".concat((g.charCodeAt(0) + g.charCodeAt(g.length - 1)) % 360, ", 100%, 60%)"));
          return (z = this.bold) != null && z.test(g) && (fe += ";font-weight:600"), (X = this.italic) != null && X.test(g) && (fe += ";font-style:italic"), this.cssMemo.set(g, fe), fe;
        }
      }
    };
    function sA(g = console, S = {}) {
      const k = j(I({}, Fa), { includes: I({}, Fa.includes) }), z = {
        styled: yF.bind(k, g),
        noStyle: z_.bind(k, g)
      }, X = gF.bind(k);
      function te() {
        return k.loggingConsoleStyle && k.loggerConsoleStyle ? z.styled : z.noStyle;
      }
      return k.create = te(), {
        configureLogger(fe) {
          var Re;
          fe === "console" ? (k.loggerConsoleStyle = Fa.loggerConsoleStyle, k.create = te()) : fe.type === "console" ? (k.loggerConsoleStyle = (Re = fe.style) != null ? Re : Fa.loggerConsoleStyle, k.create = te()) : fe.type === "keyed" ? (k.creatExt = (Le) => fe.keyed(Le.names), k.create = X) : fe.type === "named" && (k.creatExt = oA.bind(null, fe.named), k.create = X);
        },
        configureLogging(fe) {
          var Re, Le, We, ot, pt;
          k.includes.dev = (Re = fe.dev) != null ? Re : Fa.includes.dev, k.includes.internal = (Le = fe.internal) != null ? Le : Fa.includes.internal, k.includes.min = (We = fe.min) != null ? We : Fa.includes.min, k.include = (ot = fe.include) != null ? ot : Fa.include, k.loggingConsoleStyle = (pt = fe.consoleStyle) != null ? pt : Fa.loggingConsoleStyle, k.create = te();
        },
        getLogger() {
          return k.create({ names: [] });
        }
      };
    }
    function oA(g, S) {
      const k = [];
      for (let { name: z, key: X } of S.names)
        k.push(X == null ? z : "".concat(z, " (").concat(X, ")"));
      return g(k);
    }
    function gF(g) {
      const S = I(I({}, this.includes), this.include(g)), k = this.filtered, z = this.named.bind(this, g), X = this.creatExt(g), te = or(
        S,
        524
        /* _HMM */
      ), fe = or(
        S,
        522
        /* _TODO */
      ), Re = or(
        S,
        521
        /* _ERROR */
      ), Le = or(
        S,
        529
        /* ERROR_DEV */
      ), We = or(
        S,
        545
        /* ERROR_PUBLIC */
      ), ot = or(
        S,
        265
        /* _WARN */
      ), pt = or(
        S,
        268
        /* _KAPOW */
      ), _t = or(
        S,
        273
        /* WARN_DEV */
      ), Rt = or(
        S,
        289
        /* WARN_PUBLIC */
      ), Mt = or(
        S,
        137
        /* _DEBUG */
      ), ln = or(
        S,
        145
        /* DEBUG_DEV */
      ), mn = or(
        S,
        73
        /* _TRACE */
      ), Jt = or(
        S,
        81
        /* TRACE_DEV */
      ), Dn = te ? X.error.bind(X, no._hmm) : k.bind(
        g,
        524
        /* _HMM */
      ), hi = fe ? X.error.bind(X, no._todo) : k.bind(
        g,
        522
        /* _TODO */
      ), ar = Re ? X.error.bind(X, no._error) : k.bind(
        g,
        521
        /* _ERROR */
      ), pi = Le ? X.error.bind(X, no.errorDev) : k.bind(
        g,
        529
        /* ERROR_DEV */
      ), tn = We ? X.error.bind(X, no.errorPublic) : k.bind(
        g,
        545
        /* ERROR_PUBLIC */
      ), fi = pt ? X.warn.bind(X, no._kapow) : k.bind(
        g,
        268
        /* _KAPOW */
      ), Xi = ot ? X.warn.bind(X, no._warn) : k.bind(
        g,
        265
        /* _WARN */
      ), xe = _t ? X.warn.bind(X, no.warnDev) : k.bind(
        g,
        273
        /* WARN_DEV */
      ), La = Rt ? X.warn.bind(X, no.warnPublic) : k.bind(
        g,
        273
        /* WARN_DEV */
      ), ja = Mt ? X.debug.bind(X, no._debug) : k.bind(
        g,
        137
        /* _DEBUG */
      ), Ua = ln ? X.debug.bind(X, no.debugDev) : k.bind(
        g,
        145
        /* DEBUG_DEV */
      ), oi = mn ? X.trace.bind(X, no._trace) : k.bind(
        g,
        73
        /* _TRACE */
      ), ji = Jt ? X.trace.bind(X, no.traceDev) : k.bind(
        g,
        81
        /* TRACE_DEV */
      ), At = {
        _hmm: Dn,
        _todo: hi,
        _error: ar,
        errorDev: pi,
        errorPublic: tn,
        _kapow: fi,
        _warn: Xi,
        warnDev: xe,
        warnPublic: La,
        _debug: ja,
        debugDev: Ua,
        _trace: oi,
        traceDev: ji,
        lazy: {
          _hmm: te ? cr(Dn) : Dn,
          _todo: fe ? cr(hi) : hi,
          _error: Re ? cr(ar) : ar,
          errorDev: Le ? cr(pi) : pi,
          errorPublic: We ? cr(tn) : tn,
          _kapow: pt ? cr(fi) : fi,
          _warn: ot ? cr(Xi) : Xi,
          warnDev: _t ? cr(xe) : xe,
          warnPublic: Rt ? cr(La) : La,
          _debug: Mt ? cr(ja) : ja,
          debugDev: ln ? cr(Ua) : Ua,
          _trace: mn ? cr(oi) : oi,
          traceDev: Jt ? cr(ji) : ji
        },
        //
        named: z,
        utilFor: {
          internal() {
            return {
              debug: At._debug,
              error: At._error,
              warn: At._warn,
              trace: At._trace,
              named(ai, Yn) {
                return At.named(ai, Yn).utilFor.internal();
              }
            };
          },
          dev() {
            return {
              debug: At.debugDev,
              error: At.errorDev,
              warn: At.warnDev,
              trace: At.traceDev,
              named(ai, Yn) {
                return At.named(ai, Yn).utilFor.dev();
              }
            };
          },
          public() {
            return {
              error: At.errorPublic,
              warn: At.warnPublic,
              debug(ai, Yn) {
                At._warn('(public "debug" filtered out) '.concat(ai), Yn);
              },
              trace(ai, Yn) {
                At._warn('(public "trace" filtered out) '.concat(ai), Yn);
              },
              named(ai, Yn) {
                return At.named(ai, Yn).utilFor.public();
              }
            };
          }
        }
      };
      return At;
    }
    function yF(g, S) {
      const k = I(I({}, this.includes), this.include(S)), z = [];
      let X = "";
      for (let Le = 0; Le < S.names.length; Le++) {
        const { name: We, key: ot } = S.names[Le];
        if (X += " %c".concat(We), z.push(this.style.css(We)), ot != null) {
          const pt = "%c#".concat(ot);
          X += pt, z.push(this.style.css(pt));
        }
      }
      const te = this.filtered, fe = this.named.bind(this, S), Re = [X, ...z];
      return aA(
        te,
        S,
        k,
        g,
        Re,
        Jy(Re),
        fe
      );
    }
    function Jy(g) {
      const S = g.slice(0);
      for (let k = 1; k < S.length; k++)
        S[k] += ";background-color:#e0005a;padding:2px;color:white";
      return S;
    }
    function z_(g, S) {
      const k = I(I({}, this.includes), this.include(S));
      let z = "";
      for (let Re = 0; Re < S.names.length; Re++) {
        const { name: Le, key: We } = S.names[Re];
        z += " ".concat(Le), We != null && (z += "#".concat(We));
      }
      const X = this.filtered, te = this.named.bind(this, S), fe = [z];
      return aA(
        X,
        S,
        k,
        g,
        fe,
        fe,
        te
      );
    }
    function aA(g, S, k, z, X, te, fe) {
      const Re = or(
        k,
        524
        /* _HMM */
      ), Le = or(
        k,
        522
        /* _TODO */
      ), We = or(
        k,
        521
        /* _ERROR */
      ), ot = or(
        k,
        529
        /* ERROR_DEV */
      ), pt = or(
        k,
        545
        /* ERROR_PUBLIC */
      ), _t = or(
        k,
        265
        /* _WARN */
      ), Rt = or(
        k,
        268
        /* _KAPOW */
      ), Mt = or(
        k,
        273
        /* WARN_DEV */
      ), ln = or(
        k,
        289
        /* WARN_PUBLIC */
      ), mn = or(
        k,
        137
        /* _DEBUG */
      ), Jt = or(
        k,
        145
        /* DEBUG_DEV */
      ), Dn = or(
        k,
        73
        /* _TRACE */
      ), hi = or(
        k,
        81
        /* TRACE_DEV */
      ), ar = Re ? z.error.bind(z, ...X) : g.bind(
        S,
        524
        /* _HMM */
      ), pi = Le ? z.error.bind(z, ...X) : g.bind(
        S,
        522
        /* _TODO */
      ), tn = We ? z.error.bind(z, ...X) : g.bind(
        S,
        521
        /* _ERROR */
      ), fi = ot ? z.error.bind(z, ...X) : g.bind(
        S,
        529
        /* ERROR_DEV */
      ), Xi = pt ? z.error.bind(z, ...X) : g.bind(
        S,
        545
        /* ERROR_PUBLIC */
      ), xe = Rt ? z.warn.bind(z, ...te) : g.bind(
        S,
        268
        /* _KAPOW */
      ), La = _t ? z.warn.bind(z, ...X) : g.bind(
        S,
        265
        /* _WARN */
      ), ja = Mt ? z.warn.bind(z, ...X) : g.bind(
        S,
        273
        /* WARN_DEV */
      ), Ua = ln ? z.warn.bind(z, ...X) : g.bind(
        S,
        273
        /* WARN_DEV */
      ), oi = mn ? z.info.bind(z, ...X) : g.bind(
        S,
        137
        /* _DEBUG */
      ), ji = Jt ? z.info.bind(z, ...X) : g.bind(
        S,
        145
        /* DEBUG_DEV */
      ), At = Dn ? z.debug.bind(z, ...X) : g.bind(
        S,
        73
        /* _TRACE */
      ), ai = hi ? z.debug.bind(z, ...X) : g.bind(
        S,
        81
        /* TRACE_DEV */
      ), Yn = {
        _hmm: ar,
        _todo: pi,
        _error: tn,
        errorDev: fi,
        errorPublic: Xi,
        _kapow: xe,
        _warn: La,
        warnDev: ja,
        warnPublic: Ua,
        _debug: oi,
        debugDev: ji,
        _trace: At,
        traceDev: ai,
        lazy: {
          _hmm: Re ? cr(ar) : ar,
          _todo: Le ? cr(pi) : pi,
          _error: We ? cr(tn) : tn,
          errorDev: ot ? cr(fi) : fi,
          errorPublic: pt ? cr(Xi) : Xi,
          _kapow: Rt ? cr(xe) : xe,
          _warn: _t ? cr(La) : La,
          warnDev: Mt ? cr(ja) : ja,
          warnPublic: ln ? cr(Ua) : Ua,
          _debug: mn ? cr(oi) : oi,
          debugDev: Jt ? cr(ji) : ji,
          _trace: Dn ? cr(At) : At,
          traceDev: hi ? cr(ai) : ai
        },
        //
        named: fe,
        utilFor: {
          internal() {
            return {
              debug: Yn._debug,
              error: Yn._error,
              warn: Yn._warn,
              trace: Yn._trace,
              named(Qi, za) {
                return Yn.named(Qi, za).utilFor.internal();
              }
            };
          },
          dev() {
            return {
              debug: Yn.debugDev,
              error: Yn.errorDev,
              warn: Yn.warnDev,
              trace: Yn.traceDev,
              named(Qi, za) {
                return Yn.named(Qi, za).utilFor.dev();
              }
            };
          },
          public() {
            return {
              error: Yn.errorPublic,
              warn: Yn.warnPublic,
              debug(Qi, za) {
                Yn._warn('(public "debug" filtered out) '.concat(Qi), za);
              },
              trace(Qi, za) {
                Yn._warn('(public "trace" filtered out) '.concat(Qi), za);
              },
              named(Qi, za) {
                return Yn.named(Qi, za).utilFor.public();
              }
            };
          }
        }
      };
      return Yn;
    }
    var V_ = sA(console, {});
    V_.configureLogging({
      dev: !0,
      min: 64
      /* TRACE */
    });
    var Vf = V_.getLogger().named("Theatre.js (default logger)").utilFor.dev(), G_ = /* @__PURE__ */ new WeakMap();
    function lA(g) {
      const S = G_.get(g);
      if (S)
        return S;
      const k = /* @__PURE__ */ new Map();
      return G_.set(g, k), q_([], g, k), k;
    }
    function q_(g, S, k) {
      for (const [z, X] of Object.entries(S.props))
        if (!zf(X)) {
          const te = [...g, z];
          k.set(JSON.stringify(te), k.size), H_(te, X, k);
        }
      for (const [z, X] of Object.entries(S.props))
        if (zf(X)) {
          const te = [...g, z];
          k.set(JSON.stringify(te), k.size), H_(te, X, k);
        }
    }
    function H_(g, S, k) {
      if (S.type === "compound")
        q_(g, S, k);
      else {
        if (S.type === "enum")
          throw new Error("Enums aren't supported yet");
        k.set(JSON.stringify(g), k.size);
      }
    }
    function $_(g) {
      return typeof g == "object" && g !== null && Object.keys(g).length === 0;
    }
    var uA = class {
      constructor(g, S, k, z, X) {
        this.sheetTemplate = g, J(this, "address"), J(this, "type", "Theatre_SheetObjectTemplate"), J(this, "_config"), J(this, "_temp_actions_atom"), J(this, "_cache", new vl()), J(this, "project"), J(this, "pointerToSheetState"), J(this, "pointerToStaticOverrides"), this.address = j(I({}, g.address), { objectKey: S }), this._config = new Dr.Atom(z), this._temp_actions_atom = new Dr.Atom(X), this.project = g.project, this.pointerToSheetState = this.sheetTemplate.project.pointers.historic.sheetsById[this.address.sheetId], this.pointerToStaticOverrides = this.pointerToSheetState.staticOverrides.byObject[this.address.objectKey];
      }
      get staticConfig() {
        return this._config.get();
      }
      get configPointer() {
        return this._config.pointer;
      }
      get _temp_actions() {
        return this._temp_actions_atom.get();
      }
      get _temp_actionsPointer() {
        return this._temp_actions_atom.pointer;
      }
      createInstance(g, S, k) {
        return this._config.set(k), new U_(g, this, S);
      }
      reconfigure(g) {
        this._config.set(g);
      }
      /**
       * The `actions` api is temporary until we implement events.
       */
      _temp_setActions(g) {
        this._temp_actions_atom.set(g);
      }
      /**
       * Returns the default values (all defaults are read from the config)
       */
      getDefaultValues() {
        return this._cache.get(
          "getDefaultValues()",
          () => (0, Dr.prism)(() => {
            const g = (0, Dr.val)(this.configPointer);
            return cy(g);
          })
        );
      }
      /**
       * Returns values that are set statically (ie, not sequenced, and not defaults)
       */
      getStaticValues() {
        return this._cache.get(
          "getStaticValues",
          () => (0, Dr.prism)(() => {
            var g;
            const S = (g = (0, Dr.val)(this.pointerToStaticOverrides)) != null ? g : {};
            return (0, Dr.val)(this.configPointer).deserializeAndSanitize(S) || {};
          })
        );
      }
      /**
       * Filters through the sequenced tracks and returns those tracks who are valid
       * according to the object's prop types, then sorted in the same order as the config
       *
       * Returns an array.
       */
      getArrayOfValidSequenceTracks() {
        return this._cache.get(
          "getArrayOfValidSequenceTracks",
          () => (0, Dr.prism)(() => {
            const g = this.project.pointers.historic.sheetsById[this.address.sheetId], S = (0, Dr.val)(
              g.sequence.tracksByObject[this.address.objectKey].trackIdByPropPath
            );
            if (!S)
              return Zt;
            const k = [];
            if (!S)
              return Zt;
            const z = (0, Dr.val)(this.configPointer), X = Object.entries(S);
            for (const [fe, Re] of X) {
              const Le = cA(fe);
              if (!Le)
                continue;
              const We = j_(z, Le);
              We && mF(We) && k.push({ pathToProp: Le, trackId: Re });
            }
            const te = lA(z);
            return k.sort((fe, Re) => {
              const Le = fe.pathToProp, We = Re.pathToProp, ot = te.get(JSON.stringify(Le)), pt = te.get(JSON.stringify(We));
              return ot > pt ? 1 : -1;
            }), k.length === 0 ? Zt : k;
          })
        );
      }
      /**
       * Filters through the sequenced tracks those tracks that are valid
       * according to the object's prop types.
       *
       * Returns a map.
       *
       * Not available in core.
       */
      getMapOfValidSequenceTracks_forStudio() {
        return this._cache.get(
          "getMapOfValidSequenceTracks_forStudio",
          () => (0, Dr.prism)(() => {
            const g = (0, Dr.val)(this.getArrayOfValidSequenceTracks());
            let S = {};
            for (const { pathToProp: k, trackId: z } of g)
              vh(S, k, z);
            return S;
          })
        );
      }
      /**
       * @returns The static overrides that are not sequenced. Returns undefined if there are no static overrides,
       * or if all those static overrides are sequenced.
       */
      getStaticButNotSequencedOverrides() {
        return this._cache.get(
          "getStaticButNotSequencedOverrides",
          () => (0, Dr.prism)(() => {
            const g = (0, Dr.val)(this.getStaticValues()), S = (0, Dr.val)(
              this.getArrayOfValidSequenceTracks()
            ), k = UD(g);
            for (const { pathToProp: z } of S) {
              Uf(k, z);
              let X = z.slice(0, -1);
              for (; X.length > 0; ) {
                const te = iy(
                  k,
                  X
                );
                if (!$_(te))
                  break;
                Uf(k, X), X = X.slice(0, -1);
              }
            }
            if (!$_(k))
              return k;
          })
        );
      }
      getDefaultsAtPointer(g) {
        const { path: S } = (0, Dr.getPointerParts)(g), k = this.getDefaultValues().getValue();
        return iy(k, S);
      }
    };
    function cA(g) {
      try {
        return JSON.parse(g);
      } catch {
        Vf.warn(
          "property ".concat(JSON.stringify(
            g
          ), " cannot be parsed. Skipping.")
        );
        return;
      }
    }
    var W_ = ut(), dA = fF(
      (g) => (
        // we're using JSON.stringify here, but we could use a faster alternative.
        // If you happen to do that, first make sure no `PathToProp_Encoded` is ever
        // used in the store, otherwise you'll have to write a migration.
        JSON.stringify(g)
      )
    ), hA = re(Y());
    function pA(g, S, k = "Did you mean ", z = "?") {
      const X = (0, hA.default)(g, S, {
        threshold: 0.7
      });
      return X ? k + JSON.stringify(X) + z : "";
    }
    var K_ = class extends Error {
    }, yr = class extends K_ {
    }, Y_ = ut(), vF = ut(), bF = ut(), qr = ut();
    function Ba() {
      let g, S;
      const k = new Promise((X, te) => {
        g = (fe) => {
          X(fe), z.status = "resolved";
        }, S = (fe) => {
          te(fe), z.status = "rejected";
        };
      }), z = {
        resolve: g,
        reject: S,
        promise: k,
        status: "pending"
      };
      return z;
    }
    var fA = () => {
    }, Gf = fA, xF = ut(), _F = class {
      constructor() {
        J(this, "_stopPlayCallback", Gf), J(this, "_state", new xF.Atom({
          position: 0,
          playing: !1
        })), J(this, "statePointer"), this.statePointer = this._state.pointer;
      }
      destroy() {
      }
      pause() {
        this._stopPlayCallback(), this.playing = !1, this._stopPlayCallback = Gf;
      }
      gotoPosition(g) {
        this._updatePositionInState(g);
      }
      _updatePositionInState(g) {
        this._state.setByPointer((S) => S.position, g);
      }
      getCurrentPosition() {
        return this._state.get().position;
      }
      get playing() {
        return this._state.get().playing;
      }
      set playing(g) {
        this._state.setByPointer((S) => S.playing, g);
      }
      play(g, S, k, z, X) {
        this.playing && this.pause(), this.playing = !0;
        const te = S[1] - S[0];
        {
          const _t = this.getCurrentPosition();
          _t < S[0] || _t > S[1] ? z === "normal" || z === "alternate" ? this._updatePositionInState(S[0]) : (z === "reverse" || z === "alternateReverse") && this._updatePositionInState(S[1]) : z === "normal" || z === "alternate" ? _t === S[1] && this._updatePositionInState(S[0]) : _t === S[0] && this._updatePositionInState(S[1]);
        }
        const fe = Ba(), Re = X.time, Le = te * g;
        let We = this.getCurrentPosition() - S[0];
        (z === "reverse" || z === "alternateReverse") && (We = S[1] - this.getCurrentPosition());
        const ot = (_t) => {
          const Mt = Math.max(
            _t - Re,
            0
          ) / 1e3, ln = Math.min(
            Mt * k + We,
            Le
          );
          if (ln !== Le) {
            const mn = Math.floor(ln / te);
            let Jt = ln / te % 1 * te;
            if (z !== "normal")
              if (z === "reverse")
                Jt = te - Jt;
              else {
                const Dn = mn % 2 === 0;
                z === "alternate" ? Dn || (Jt = te - Jt) : Dn && (Jt = te - Jt);
              }
            this._updatePositionInState(Jt + S[0]), pt();
          } else {
            if (z === "normal")
              this._updatePositionInState(S[1]);
            else if (z === "reverse")
              this._updatePositionInState(S[0]);
            else {
              const mn = (g - 1) % 2 === 0;
              z === "alternate" ? mn ? this._updatePositionInState(S[1]) : this._updatePositionInState(S[0]) : mn ? this._updatePositionInState(S[0]) : this._updatePositionInState(S[1]);
            }
            this.playing = !1, fe.resolve(!0);
          }
        };
        this._stopPlayCallback = () => {
          X.offThisOrNextTick(ot), X.offNextTick(ot), this.playing && fe.resolve(!1);
        };
        const pt = () => X.onNextTick(ot);
        return X.onThisOrNextTick(ot), fe.promise;
      }
      playDynamicRange(g, S) {
        this.playing && this.pause(), this.playing = !0;
        const k = Ba(), z = g.keepHot();
        k.promise.then(z, z);
        let X = S.time;
        const te = (Re) => {
          const Le = Math.max(
            Re - X,
            0
          );
          X = Re;
          const We = Le / 1e3, ot = this.getCurrentPosition(), pt = g.getValue();
          if (ot < pt[0] || ot > pt[1])
            this.gotoPosition(pt[0]);
          else {
            let _t = ot + We;
            _t > pt[1] && (_t = pt[0] + (_t - pt[1])), this.gotoPosition(_t);
          }
          fe();
        };
        this._stopPlayCallback = () => {
          S.offThisOrNextTick(te), S.offNextTick(te), k.resolve(!1);
        };
        const fe = () => S.onNextTick(te);
        return S.onThisOrNextTick(te), k.promise;
      }
    }, mA = ut(), X_ = "__TheatreJS_StudioBundle", qf = "__TheatreJS_CoreBundle", Hf = "__TheatreJS_Notifications", $f = (g) => (...S) => {
      var k;
      switch (g) {
        case "success": {
          Vf.debug(S.slice(0, 2).join(`
`));
          break;
        }
        case "info": {
          Vf.debug(S.slice(0, 2).join(`
`));
          break;
        }
        case "warning": {
          Vf.warn(S.slice(0, 2).join(`
`));
          break;
        }
      }
      return typeof window < "u" ? (
        // @ts-ignore
        (k = window[Hf]) == null ? void 0 : k.notify[g](...S)
      ) : void 0;
    }, Po = {
      warning: $f("warning"),
      success: $f("success"),
      info: $f("info"),
      error: $f("error")
    };
    typeof window < "u" && (window.addEventListener("error", (g) => {
      Po.error(
        "An error occurred",
        "<pre>".concat(g.message, `</pre>

See **console** for details.`)
      );
    }), window.addEventListener("unhandledrejection", (g) => {
      Po.error(
        "An error occurred",
        "<pre>".concat(g.reason, `</pre>

See **console** for details.`)
      );
    }));
    var gA = class {
      constructor(g, S, k) {
        this._decodedBuffer = g, this._audioContext = S, this._nodeDestination = k, J(this, "_mainGain"), J(this, "_state", new mA.Atom({
          position: 0,
          playing: !1
        })), J(this, "statePointer"), J(this, "_stopPlayCallback", Gf), this.statePointer = this._state.pointer, this._mainGain = this._audioContext.createGain(), this._mainGain.connect(this._nodeDestination);
      }
      playDynamicRange(g, S) {
        const k = Ba();
        this._playing && this.pause(), this._playing = !0;
        let z;
        const X = () => {
          z?.(), z = this._loopInRange(g.getValue(), S).stop;
        }, te = g.onStale(X);
        return X(), this._stopPlayCallback = () => {
          z?.(), te(), k.resolve(!1);
        }, k.promise;
      }
      _loopInRange(g, S) {
        let z = this.getCurrentPosition();
        const X = g[1] - g[0];
        z < g[0] || z > g[1] ? this._updatePositionInState(g[0]) : z === g[1] && this._updatePositionInState(g[0]), z = this.getCurrentPosition();
        const te = this._audioContext.createBufferSource();
        te.buffer = this._decodedBuffer, te.connect(this._mainGain), te.playbackRate.value = 1, te.loop = !0, te.loopStart = g[0], te.loopEnd = g[1];
        const fe = S.time;
        let Re = z - g[0];
        te.start(0, z);
        const Le = (pt) => {
          let ln = (Math.max(
            pt - fe,
            0
          ) / 1e3 * 1 + Re) / X % 1 * X;
          this._updatePositionInState(ln + g[0]), We();
        }, We = () => S.onNextTick(Le);
        return S.onThisOrNextTick(Le), { stop: () => {
          te.stop(), te.disconnect(), S.offThisOrNextTick(Le), S.offNextTick(Le);
        } };
      }
      get _playing() {
        return this._state.get().playing;
      }
      set _playing(g) {
        this._state.setByPointer((S) => S.playing, g);
      }
      destroy() {
      }
      pause() {
        this._stopPlayCallback(), this._playing = !1, this._stopPlayCallback = Gf;
      }
      gotoPosition(g) {
        this._updatePositionInState(g);
      }
      _updatePositionInState(g) {
        this._state.reduce((S) => j(I({}, S), { position: g }));
      }
      getCurrentPosition() {
        return this._state.get().position;
      }
      play(g, S, k, z, X) {
        this._playing && this.pause(), this._playing = !0;
        let te = this.getCurrentPosition();
        const fe = S[1] - S[0];
        if (z !== "normal")
          throw new yr(
            'Audio-controlled sequences can only be played in the "normal" direction. ' + "'".concat(z, "' given.")
          );
        te < S[0] || te > S[1] ? this._updatePositionInState(S[0]) : te === S[1] && this._updatePositionInState(S[0]), te = this.getCurrentPosition();
        const Re = Ba(), Le = this._audioContext.createBufferSource();
        Le.buffer = this._decodedBuffer, Le.connect(this._mainGain), Le.playbackRate.value = k, g > 1e3 && (Po.warning(
          "Can't play sequences with audio more than 1000 times",
          "The sequence will still play, but only 1000 times. The `iterationCount: ".concat(g, "` provided to `sequence.play()`\nis too high for a sequence with audio.\n\nTo fix this, either set `iterationCount` to a lower value, or remove the audio from the sequence."),
          [
            {
              url: "https://www.theatrejs.com/docs/latest/manual/audio",
              title: "Using Audio"
            },
            {
              url: "https://www.theatrejs.com/docs/latest/api/core#sequence.attachaudio",
              title: "Audio API"
            }
          ]
        ), g = 1e3), g > 1 && (Le.loop = !0, Le.loopStart = S[0], Le.loopEnd = S[1]);
        const We = X.time;
        let ot = te - S[0];
        const pt = fe * g;
        Le.start(0, te, pt - ot);
        const _t = (ln) => {
          const Jt = Math.max(
            ln - We,
            0
          ) / 1e3, Dn = Math.min(
            Jt * k + ot,
            pt
          );
          if (Dn !== pt) {
            let hi = Dn / fe % 1 * fe;
            this._updatePositionInState(hi + S[0]), Mt();
          } else
            this._updatePositionInState(S[1]), this._playing = !1, Rt(), Re.resolve(!0);
        }, Rt = () => {
          Le.stop(), Le.disconnect();
        };
        this._stopPlayCallback = () => {
          Rt(), X.offThisOrNextTick(_t), X.offNextTick(_t), this._playing && Re.resolve(!1);
        };
        const Mt = () => X.onNextTick(_t);
        return X.onThisOrNextTick(_t), Re.promise;
      }
    }, SF = ut(), Q_ = 0;
    function Wf(g) {
      var S;
      const k = (fe) => {
        z.tick(fe);
      }, z = new SF.Ticker({
        onActive() {
          var fe;
          (fe = g?.start) == null || fe.call(g);
        },
        onDormant() {
          var fe;
          (fe = g?.stop) == null || fe.call(g);
        }
      }), X = {
        tick: k,
        id: Q_++,
        name: (S = g?.name) != null ? S : "CustomRafDriver-".concat(Q_),
        type: "Theatre_RafDriver_PublicAPI"
      }, te = {
        type: "Theatre_RafDriver_PrivateAPI",
        publicApi: X,
        ticker: z,
        start: g?.start,
        stop: g?.stop
      };
      return st(X, te), X;
    }
    function yA() {
      let g = null;
      const z = Wf({ name: "DefaultCoreRafDriver", start: () => {
        if (typeof window < "u") {
          const X = (te) => {
            z.tick(te), g = window.requestAnimationFrame(X);
          };
          g = window.requestAnimationFrame(X);
        } else
          z.tick(0), setTimeout(() => z.tick(1), 0);
      }, stop: () => {
        typeof window < "u" && g !== null && window.cancelAnimationFrame(g);
      } });
      return z;
    }
    var e0;
    function Z_() {
      return e0 || vA(yA()), e0;
    }
    function t0() {
      return Z_().ticker;
    }
    function vA(g) {
      if (e0)
        throw new Error("`setCoreRafDriver()` is already called.");
      e0 = Tt(g);
    }
    var wF = class {
      get type() {
        return "Theatre_Sequence_PublicAPI";
      }
      /**
       * @internal
       */
      constructor(g) {
        st(this, g);
      }
      play(g) {
        const S = Tt(this);
        if (S._project.isReady()) {
          const k = g?.rafDriver ? Tt(g.rafDriver).ticker : t0();
          return S.play(g ?? {}, k);
        } else {
          process.env.NODE_ENV !== "production" && Po.warning(
            "Sequence can't be played",
            "You seem to have called `sequence.play()` before the project has finished loading.\n\nThis would **not** a problem in production when using `@tomorrowevening/theatre-core`, since Theatre.js loads instantly in core mode. However, when using `@tomorrowevening/theatre-studio`, it takes a few milliseconds for it to load your project's state, before which your sequences cannot start playing.\n\nTo fix this, simply defer calling `sequence.play()` until after the project is loaded, like this:\n\n```\nproject.ready.then(() => {\n  sequence.play()\n})\n```",
            [
              {
                url: "https://www.theatrejs.com/docs/0.5/api/core#project.ready",
                title: "Project.ready"
              }
            ]
          );
          const k = Ba();
          return k.resolve(!0), k.promise;
        }
      }
      pause() {
        Tt(this).pause();
      }
      get position() {
        return Tt(this).position;
      }
      set position(g) {
        Tt(this).position = g;
      }
      __experimental_getKeyframes(g) {
        return Tt(this).getKeyframesOfSimpleProp(g);
      }
      async attachAudio(g) {
        const { audioContext: S, destinationNode: k, decodedBuffer: z, gainNode: X } = await EF(g), te = new gA(
          z,
          S,
          X
        );
        return Tt(this).replacePlaybackController(te), { audioContext: S, destinationNode: k, decodedBuffer: z, gainNode: X };
      }
      get pointer() {
        return Tt(this).pointer;
      }
      getMarkerPosition(g) {
        return Tt(this).getMarkerPosition(g);
      }
      goToAndPlay(g, S) {
        const k = Tt(this);
        if (k._project.isReady()) {
          const z = S?.rafDriver ? Tt(S.rafDriver).ticker : t0();
          return k.goToAndPlay(g, S ?? {}, z);
        } else {
          process.env.NODE_ENV !== "production" && Po.warning(
            "Sequence can't go to marker",
            "You seem to have called `sequence.goToAndPlay()` before the project has finished loading.\n\nThis would **not** a problem in production when using `@tomorrowevening/theatre-core`, since Theatre.js loads instantly in core mode. However, it seems that you are using `@tomorrowevening/theatre-studio`, which takes a few milliseconds to load, because itcontains a lot of code responsible for the editing UI.\n\nTo fix this, wait for `project.ready` to resolve, and only then call `sequence.goToAndPlay()`.\n\nLearn more at https://www.theatrejs.com/docs/latest/manual/projects#state"
          );
          const z = Ba();
          return z.resolve(!0), z.promise;
        }
      }
      goToAndStop(g) {
        return Tt(this).goToAndStop(g);
      }
      listen(g, S) {
        return Tt(this).listen(g, S);
      }
      unlisten(g, S) {
        return Tt(this).unlisten(g, S);
      }
      addSubSequence(g, S, k) {
        return Tt(this).addSubSequence(g, S, k);
      }
      removeSubSequence(g) {
        return Tt(this).removeSubSequence(g);
      }
      updateSubSequence(g, S) {
        return Tt(this).updateSubSequence(g, S);
      }
    };
    async function EF(g) {
      function S() {
        if (g.audioContext)
          return Promise.resolve(g.audioContext);
        const We = new AudioContext();
        return We.state === "running" || typeof window > "u" ? Promise.resolve(We) : new Promise((ot) => {
          const pt = () => {
            We.resume().catch((Mt) => {
              console.error(Mt);
            });
          }, _t = [
            "mousedown",
            "keydown",
            "touchstart"
          ], Rt = { capture: !0, passive: !1 };
          _t.forEach((Mt) => {
            window.addEventListener(Mt, pt, Rt);
          }), We.addEventListener("statechange", () => {
            We.state === "running" && (_t.forEach((Mt) => {
              window.removeEventListener(Mt, pt, Rt);
            }), ot(We));
          });
        });
      }
      async function k() {
        if (g.source instanceof AudioBuffer)
          return g.source;
        const We = Ba();
        if (typeof g.source != "string")
          throw new Error(
            "Error validating arguments to sequence.attachAudio(). args.source must either be a string or an instance of AudioBuffer."
          );
        let ot;
        try {
          ot = await fetch(g.source);
        } catch (Mt) {
          throw console.error(Mt), new Error(
            "Could not fetch '".concat(g.source, "'. Network error logged above.")
          );
        }
        let pt;
        try {
          pt = await ot.arrayBuffer();
        } catch (Mt) {
          throw console.error(Mt), new Error("Could not read '".concat(g.source, "' as an arrayBuffer."));
        }
        (await z).decodeAudioData(
          pt,
          We.resolve,
          We.reject
        );
        let Rt;
        try {
          Rt = await We.promise;
        } catch (Mt) {
          throw console.error(Mt), new Error("Could not decode ".concat(g.source, " as an audio file."));
        }
        return Rt;
      }
      const z = S(), X = k(), [te, fe] = await Promise.all([
        z,
        X
      ]), Re = g.destinationNode || te.destination, Le = te.createGain();
      return Le.connect(Re), {
        audioContext: te,
        decodedBuffer: fe,
        gainNode: Le,
        destinationNode: Re
      };
    }
    var J_ = bA("Theatre_SheetObject");
    function bA(g) {
      return (S) => typeof S == "object" && !!S && S.type === g;
    }
    var e1 = [
      "normal",
      "reverse",
      "alternate",
      "alternateReverse"
    ], xA = class {
      constructor(g, S, k, z, X) {
        this._project = g, this._sheet = S, this._lengthD = k, this._subUnitsPerUnitD = z, J(this, "address"), J(this, "publicApi"), J(this, "_playbackControllerBox"), J(this, "_prismOfStatePointer"), J(this, "_positionD"), J(this, "_positionFormatterD"), J(this, "_playableRangeD"), J(this, "_eventListeners", /* @__PURE__ */ new Map()), J(this, "_lastProcessedPosition", -1), J(this, "_processedEvents", /* @__PURE__ */ new Set()), J(this, "pointer", (0, bF.pointer)({ root: this, path: [] })), J(this, "$$isPointerToPrismProvider", !0), J(this, "_logger"), J(this, "closestGridPosition", (te) => {
          const Re = 1 / this.subUnitsPerUnit;
          return parseFloat(
            (Math.round(te / Re) * Re).toFixed(3)
          );
        }), this._logger = g._logger.named("Sheet", S.address.sheetId).named("Instance", S.address.sheetInstanceId), this.address = j(I({}, this._sheet.address), { sequenceName: "default" }), this.publicApi = new wF(this), this._playbackControllerBox = new vF.Atom(
          X ?? new _F()
        ), this._prismOfStatePointer = (0, qr.prism)(
          () => this._playbackControllerBox.prism.getValue().statePointer
        ), this._positionD = (0, qr.prism)(() => {
          const te = this._prismOfStatePointer.getValue();
          return (0, qr.val)(te.position);
        }), this._positionFormatterD = (0, qr.prism)(() => {
          const te = (0, qr.val)(this._subUnitsPerUnitD);
          return new TF(te);
        }), this._positionD.onStale(() => {
          const te = this._positionD.getValue();
          this._processEventsForPositionChange(
            this._lastProcessedPosition,
            te
          ), this._processSubSequencesForPositionChange(
            this._lastProcessedPosition,
            te
          ), this._lastProcessedPosition = te;
        });
      }
      get type() {
        return "Theatre_Sequence";
      }
      // Event system methods
      listen(g, S) {
        this._eventListeners.has(g) || this._eventListeners.set(g, /* @__PURE__ */ new Set()), this._eventListeners.get(g).add(S);
      }
      unlisten(g, S) {
        const k = this._eventListeners.get(g);
        k && (k.delete(S), k.size === 0 && this._eventListeners.delete(g));
      }
      _processEventsForPositionChange(g, S) {
        const k = this._getEvents();
        if (!k || k.length === 0)
          return;
        const z = this.length;
        if (g > S && g > z * 0.8 && S < z * 0.2) {
          this._processedEvents.clear();
          return;
        }
        const te = Math.min(g, S), fe = Math.max(g, S);
        Math.abs(S - g) > 0.1 && this._processedEvents.clear();
        for (const Re of k)
          if (Re.position > te && Re.position <= fe) {
            const Le = "".concat(Re.id, "-").concat(Re.position);
            if (this._processedEvents.has(Le))
              continue;
            if (Re.name === "goTo" || this._processedEvents.add(Le), this._triggerEvent(Re), Re.name === "stop") {
              requestAnimationFrame(() => {
                this.pause(), this._playbackControllerBox.get().gotoPosition(Re.position);
              });
              return;
            } else if (Re.name === "goTo" && Re.value !== void 0) {
              requestAnimationFrame(() => {
                if (this._processedEvents.clear(), typeof Re.value == "string") {
                  const ot = this.getMarkerPosition(Re.value);
                  ot !== void 0 && this._gotoPositionWithoutPausing(ot);
                } else typeof Re.value == "number" && this._gotoPositionWithoutPausing(Re.value);
              });
              return;
            }
          }
      }
      _triggerEvent(g) {
        const S = this._eventListeners.get(g.name);
        S && S.forEach((k) => {
          try {
            k(g);
          } catch (z) {
            console.error("Error in sequence event listener:", z);
          }
        });
      }
      _processSubSequencesForPositionChange(g, S) {
        var k, z;
        const X = this._getSubSequences();
        if (!(!X || X.length === 0))
          for (const te of X) {
            const fe = te.position, Re = (k = te.duration) != null ? k : this._getSubSequenceDuration(te.sheetId), Le = (z = te.timeScale) != null ? z : 1, We = fe + Re / Le;
            if (S >= fe && S <= We) {
              const pt = (S - fe) * Le;
              try {
                const Rt = this._project.getOrCreateSheet(
                  te.sheetId,
                  "default"
                  // Use default instance for now
                ).getSequence();
                Rt && "_gotoPositionWithoutPausing" in Rt && Rt._gotoPositionWithoutPausing(
                  pt
                );
              } catch {
                this._logger._error(
                  "Sub-sequence references non-existent sheet: ".concat(te.sheetId)
                );
              }
            }
          }
      }
      _getSubSequenceDuration(g) {
        var S;
        try {
          const z = this._project.getOrCreateSheet(
            g,
            "default"
          ).getSequence();
          return (S = z?.length) != null ? S : 0;
        } catch {
          return 0;
        }
      }
      _getEvents() {
        const g = this._project.pointers.historic.sheetsById[this._sheet.address.sheetId], S = (0, qr.val)(g.sequence);
        return S?.events || [];
      }
      _getSubSequences() {
        const g = this._project.pointers.historic.sheetsById[this._sheet.address.sheetId], S = (0, qr.val)(g.sequence);
        return S?.subSequences || [];
      }
      pointerToPrism(g) {
        const { path: S } = (0, Y_.getPointerParts)(g);
        if (S.length === 0)
          return (0, qr.prism)(() => ({
            length: (0, qr.val)(this.pointer.length),
            playing: (0, qr.val)(this.pointer.playing),
            position: (0, qr.val)(this.pointer.position),
            subUnitsPerUnit: (0, qr.val)(this.pointer.subUnitsPerUnit)
          }));
        if (S.length > 1)
          return (0, qr.prism)(() => {
          });
        const [k] = S;
        return k === "length" ? this._lengthD : k === "subUnitsPerUnit" ? this._subUnitsPerUnitD : k === "position" ? this._positionD : k === "playing" ? (0, qr.prism)(() => (0, qr.val)(this._prismOfStatePointer.getValue().playing)) : (0, qr.prism)(() => {
        });
      }
      /**
       * Takes a pointer to a property of a SheetObject and returns the keyframes of that property.
       *
       * Theoretically, this method can be called from inside a prism so it can be reactive.
       */
      getKeyframesOfSimpleProp(g) {
        const { path: S, root: k } = (0, Y_.getPointerParts)(g);
        if (!J_(k))
          throw new yr(
            "Argument prop must be a pointer to a SheetObject property"
          );
        const z = (0, qr.val)(
          this._project.pointers.historic.sheetsById[this._sheet.address.sheetId].sequence.tracksByObject[k.address.objectKey]
        );
        if (!z)
          return [];
        const { trackData: X, trackIdByPropPath: te } = z, fe = dA(S), Re = te[fe];
        if (!Re)
          return [];
        const Le = X[Re];
        return Le ? Le.keyframes : [];
      }
      get positionFormatter() {
        return this._positionFormatterD.getValue();
      }
      get prismOfStatePointer() {
        return this._prismOfStatePointer;
      }
      get length() {
        return this._lengthD.getValue();
      }
      get positionPrism() {
        return this._positionD;
      }
      get position() {
        return this._playbackControllerBox.get().getCurrentPosition();
      }
      get subUnitsPerUnit() {
        return this._subUnitsPerUnitD.getValue();
      }
      get positionSnappedToGrid() {
        return this.closestGridPosition(this.position);
      }
      set position(g) {
        let S = g;
        this.pause(), process.env.NODE_ENV !== "production" && (typeof S != "number" && (console.error(
          "value t in sequence.position = t must be a number. ".concat(typeof S, " given")
        ), S = 0), S < 0 && (console.error(
          "sequence.position must be a positive number. ".concat(S, " given")
        ), S = 0)), S > this.length && (S = this.length);
        const k = this.length;
        this._playbackControllerBox.get().gotoPosition(S > k ? k : S);
      }
      // Private method to change position without pausing (for goTo events)
      _gotoPositionWithoutPausing(g) {
        let S = g;
        process.env.NODE_ENV !== "production" && (typeof S != "number" && (console.error(
          "value t in sequence.position = t must be a number. ".concat(typeof S, " given")
        ), S = 0), S < 0 && (console.error(
          "sequence.position must be a positive number. ".concat(S, " given")
        ), S = 0)), S > this.length && (S = this.length);
        const k = this.length;
        this._playbackControllerBox.get().gotoPosition(S > k ? k : S);
      }
      getDurationCold() {
        return this._lengthD.getValue();
      }
      get playing() {
        return (0, qr.val)(this._playbackControllerBox.get().statePointer.playing);
      }
      _makeRangeFromSequenceTemplate() {
        return (0, qr.prism)(() => [0, (0, qr.val)(this._lengthD)]);
      }
      /**
       * Controls the playback within a range. Repeats infinitely unless stopped.
       *
       * @remarks
       *   One use case for this is to play the playback within the focus range.
       *
       * @param rangeD - The prism that contains the range that will be used for the playback
       *
       * @returns  a promise that gets rejected if the playback stopped for whatever reason
       *
       */
      playDynamicRange(g, S) {
        return this._playbackControllerBox.get().playDynamicRange(g, S);
      }
      async play(g, S) {
        const k = this.length, z = g && g.range ? g.range : [0, k];
        if (process.env.NODE_ENV !== "production") {
          if (typeof z[0] != "number" || z[0] < 0)
            throw new yr(
              "Argument conf.range[0] in sequence.play(conf) must be a positive number. ".concat(JSON.stringify(
                z[0]
              ), " given.")
            );
          if (z[0] >= k)
            throw new yr(
              "Argument conf.range[0] in sequence.play(conf) cannot be longer than the duration of the sequence, which is ".concat(k, "s. ").concat(JSON.stringify(
                z[0]
              ), " given.")
            );
          if (typeof z[1] != "number" || z[1] <= 0)
            throw new yr(
              "Argument conf.range[1] in sequence.play(conf) must be a number larger than zero. ".concat(JSON.stringify(
                z[1]
              ), " given.")
            );
          if (z[1] > k && (Po.warning(
            "Couldn't play sequence in given range",
            "Your animation will still play until the end of the sequence, however the argument `conf.range[1]` given in `sequence.play(conf)` (".concat(JSON.stringify(
              z[1]
            ), "s) is longer than the duration of the sequence (").concat(k, "s).\n\nTo fix this, either set `conf.range[1]` to be less the duration of the sequence, or adjust the sequence duration in the UI."),
            [
              {
                url: "https://www.theatrejs.com/docs/latest/manual/sequences",
                title: "Sequences"
              },
              {
                url: "https://www.theatrejs.com/docs/latest/manual/sequences",
                title: "Playback API"
              }
            ]
          ), z[1] = k), z[1] <= z[0])
            throw new yr(
              "Argument conf.range[1] in sequence.play(conf) must be larger than conf.range[0]. ".concat(JSON.stringify(
                z
              ), " given.")
            );
        }
        const X = g && typeof g.iterationCount == "number" ? g.iterationCount : 1;
        if (process.env.NODE_ENV !== "production" && !(Number.isInteger(X) && X > 0) && X !== 1 / 0)
          throw new yr(
            "Argument conf.iterationCount in sequence.play(conf) must be an integer larger than 0. ".concat(JSON.stringify(
              X
            ), " given.")
          );
        const te = g && typeof g.rate < "u" ? g.rate : 1;
        if (process.env.NODE_ENV !== "production") {
          if (typeof te != "number" || te === 0)
            throw new yr(
              "Argument conf.rate in sequence.play(conf) must be a number larger than 0. ".concat(JSON.stringify(
                te
              ), " given.")
            );
          if (te < 0)
            throw new yr(
              "Argument conf.rate in sequence.play(conf) must be a number larger than 0. ".concat(JSON.stringify(
                te
              ), " given. If you want the animation to play backwards, try setting conf.direction to 'reverse' or 'alternateReverse'.")
            );
        }
        const fe = g && g.direction ? g.direction : "normal";
        if (process.env.NODE_ENV !== "production" && e1.indexOf(fe) === -1)
          throw new yr(
            "Argument conf.direction in sequence.play(conf) must be one of ".concat(JSON.stringify(
              e1
            ), ". ").concat(JSON.stringify(fe), " given. ").concat(pA(
              fe,
              e1
            ))
          );
        return await this._play(
          X,
          [z[0], z[1]],
          te,
          fe,
          S
        );
      }
      _play(g, S, k, z, X) {
        return this._playbackControllerBox.get().play(g, S, k, z, X);
      }
      pause() {
        this._playbackControllerBox.get().pause();
      }
      replacePlaybackController(g) {
        this.pause();
        const S = this._playbackControllerBox.get();
        this._playbackControllerBox.set(g);
        const k = S.getCurrentPosition();
        S.destroy(), g.gotoPosition(k);
      }
      getMarkerPosition(g) {
        const S = this._project.pointers.historic.sheetsById[this._sheet.address.sheetId], k = (0, qr.val)(S.sequence.markers);
        if (!k)
          return;
        let z = k.find((X) => X.label === g);
        return z || (z = k.find(
          (X) => {
            var te;
            return ((te = X.label) == null ? void 0 : te.toLowerCase()) === g.toLowerCase();
          }
        )), z || (z = k.find((X) => {
          var te;
          return (te = X.label) == null ? void 0 : te.includes(g);
        })), z?.position;
      }
      async goToAndPlay(g, S, k) {
        const z = this.getMarkerPosition(g);
        if (z === void 0)
          throw new Error(
            'Marker "'.concat(g, '" not found in sequence "').concat(this._sheet.address.sheetId, '"')
          );
        return this.position = z, this.play(S, k);
      }
      goToAndStop(g) {
        const S = this.getMarkerPosition(g);
        if (S === void 0)
          throw new Error(
            'Marker "'.concat(g, '" not found in sequence "').concat(this._sheet.address.sheetId, '"')
          );
        this.position = S;
      }
      /**
       * Adds a sub-sequence to this sequence.
       *
       * @param sheetId - The ID of the sheet/sequence to reference
       * @param position - The position in this sequence where the sub-sequence should start
       * @param options - Optional configuration for the sub-sequence
       * @returns The ID of the created sub-sequence
       */
      addSubSequence(g, S, k) {
        throw new Error(
          "addSubSequence() can only be called when Theatre.js Studio is loaded."
        );
      }
      /**
       * Removes a sub-sequence from this sequence.
       *
       * @param subSequenceId - The ID of the sub-sequence to remove
       */
      removeSubSequence(g) {
        throw new Error(
          "removeSubSequence() can only be called when Theatre.js Studio is loaded."
        );
      }
      /**
       * Updates properties of a sub-sequence.
       *
       * @param subSequenceId - The ID of the sub-sequence to update
       * @param updates - The properties to update
       */
      updateSubSequence(g, S) {
        throw new Error(
          "updateSubSequence() can only be called when Theatre.js Studio is loaded."
        );
      }
    }, TF = class {
      constructor(g) {
        this._fps = g;
      }
      formatSubUnitForGrid(g) {
        const S = g % 1, k = 1 / this._fps;
        return Math.round(S / k) + "f";
      }
      formatFullUnitForGrid(g) {
        let S = g, k = "";
        if (S >= Kc) {
          const X = Math.floor(S / Kc);
          k += X + "h", S = S % Kc;
        }
        if (S >= Sl) {
          const X = Math.floor(S / Sl);
          k += X + "m", S = S % Sl;
        }
        if (S >= Wc) {
          const X = Math.floor(S / Wc);
          k += X + "s", S = S % Wc;
        }
        const z = 1 / this._fps;
        if (S >= z) {
          const X = Math.floor(S / z);
          k += X + "f", S = S % z;
        }
        return k.length === 0 ? "0s" : k;
      }
      formatForPlayhead(g) {
        let S = g, k = "";
        if (S >= Kc) {
          const X = Math.floor(S / Kc);
          k += Bh(X.toString(), 2, "0") + "h", S = S % Kc;
        }
        if (S >= Sl) {
          const X = Math.floor(S / Sl);
          k += Bh(X.toString(), 2, "0") + "m", S = S % Sl;
        } else k.length > 0 && (k += "00m");
        if (S >= Wc) {
          const X = Math.floor(S / Wc);
          k += Bh(X.toString(), 2, "0") + "s", S = S % Wc;
        } else
          k += "00s";
        const z = 1 / this._fps;
        if (S >= z) {
          const X = Math.round(S / z);
          k += Bh(X.toString(), 2, "0") + "f", S = S % z;
        } else S / z > 0.98 ? (k += Bh("1", 2, "0") + "f", S = S % z) : k += "00f";
        return k.length === 0 ? "00s00f" : k;
      }
      formatBasic(g) {
        return g.toFixed(2) + "s";
      }
    }, Wc = 1, Sl = Wc * 60, Kc = Sl * 60, t1 = {};
    L(t1, {
      boolean: () => jh,
      compound: () => n0,
      file: () => AF,
      image: () => kF,
      number: () => i1,
      rgba: () => NF,
      string: () => RA,
      stringLiteral: () => IA
    });
    function n1(g, S) {
      return g.length <= S ? g : g.substr(0, S - 3) + "...";
    }
    var CF = (g) => typeof g == "string" ? 'string("'.concat(n1(g, 10), '")') : typeof g == "number" ? "number(".concat(n1(String(g), 10), ")") : g === null ? "null" : g === void 0 ? "undefined" : typeof g == "boolean" ? String(g) : Array.isArray(g) ? "array" : typeof g == "object" ? "object" : "unknown", gs = CF;
    function _A(g, {
      /** Alpha is usually an optional value for most hex inputs, so if it's opaque, we can omit its value. */
      removeAlphaIfOpaque: S = !1
    } = {}) {
      const k = (g.a * 255 | 256).toString(16).slice(1), z = (g.r * 255 | 256).toString(16).slice(1) + (g.g * 255 | 256).toString(16).slice(1) + (g.b * 255 | 256).toString(16).slice(1) + (S && k === "ff" ? "" : k);
      return "#".concat(z);
    }
    function r1(g) {
      return j(I({}, g), {
        toString() {
          return _A(this, { removeAlphaIfOpaque: !0 });
        }
      });
    }
    function PF(g) {
      return Object.fromEntries(
        Object.entries(g).map(([S, k]) => [S, jx(k, 0, 1)])
      );
    }
    function SA(g) {
      function S(k) {
        return k >= 31308e-7 ? 1.055 * k ** (1 / 2.4) - 0.055 : 12.92 * k;
      }
      return PF({
        r: S(g.r),
        g: S(g.g),
        b: S(g.b),
        a: g.a
      });
    }
    function wA(g) {
      function S(k) {
        return k >= 0.04045 ? ((k + 0.055) / (1 + 0.055)) ** 2.4 : k / 12.92;
      }
      return {
        r: S(g.r),
        g: S(g.g),
        b: S(g.b),
        a: g.a
      };
    }
    function EA(g) {
      let S = 0.4122214708 * g.r + 0.5363325363 * g.g + 0.0514459929 * g.b, k = 0.2119034982 * g.r + 0.6806995451 * g.g + 0.1073969566 * g.b, z = 0.0883024619 * g.r + 0.2817188376 * g.g + 0.6299787005 * g.b, X = Math.cbrt(S), te = Math.cbrt(k), fe = Math.cbrt(z);
      return {
        L: 0.2104542553 * X + 0.793617785 * te - 0.0040720468 * fe,
        a: 1.9779984951 * X - 2.428592205 * te + 0.4505937099 * fe,
        b: 0.0259040371 * X + 0.7827717662 * te - 0.808675766 * fe,
        alpha: g.a
      };
    }
    function TA(g) {
      let S = g.L + 0.3963377774 * g.a + 0.2158037573 * g.b, k = g.L - 0.1055613458 * g.a - 0.0638541728 * g.b, z = g.L - 0.0894841775 * g.a - 1.291485548 * g.b, X = S * S * S, te = k * k * k, fe = z * z * z;
      return {
        r: 4.0767416621 * X - 3.3077115913 * te + 0.2309699292 * fe,
        g: -1.2684380046 * X + 2.6097574011 * te - 0.3413193965 * fe,
        b: -0.0041960863 * X - 0.7034186147 * te + 1.707614701 * fe,
        a: g.alpha
      };
    }
    var wl = Symbol("TheatrePropType_Basic");
    function CA(g) {
      return typeof g == "object" && !!g && g[wl] === "TheatrePropType";
    }
    function PA(g) {
      if (typeof g == "number")
        return i1(g);
      if (typeof g == "boolean")
        return jh(g);
      if (typeof g == "string")
        return RA(g);
      if (typeof g == "object" && g) {
        if (CA(g))
          return g;
        if (Cy(g))
          return n0(g);
        throw new yr(
          "This value is not a valid prop type: ".concat(gs(g))
        );
      } else
        throw new yr(
          "This value is not a valid prop type: ".concat(gs(g))
        );
    }
    function AA(g) {
      const S = {};
      if (process.env.NODE_ENV !== "production" && (typeof g != "object" || !g))
        throw new yr(
          "t.compound() expects an object, like: {x: 10}. ".concat(gs(
            g
          ), " given.")
        );
      for (const k of Object.keys(g)) {
        if (process.env.NODE_ENV !== "production") {
          if (typeof k != "string")
            throw new yr(
              "t.compound()'s keys must be all strings. ".concat(gs(
                k
              ), " given.")
            );
          if (k.length === 0 || !k.match(/^\w+$/))
            throw new yr(
              "compound key ".concat(gs(
                k
              ), " is invalid. The keys must be alphanumeric and start with a letter.")
            );
          if (k.length > 64)
            throw new yr(
              "compound key ".concat(gs(k), " is too long.")
            );
        }
        const z = g[k];
        CA(z) ? S[k] = z : S[k] = PA(z);
      }
      return S;
    }
    var Fu = (g, S) => {
      if (process.env.NODE_ENV !== "production") {
        if (S === void 0)
          return;
        if (typeof S != "object" || S === null)
          throw new Error(
            "opts in ".concat(g, " must either be undefined or an object.")
          );
        if (Object.prototype.hasOwnProperty.call(S, "label")) {
          const { label: k } = S;
          if (typeof k != "string")
            throw new Error(
              "opts.label in ".concat(g, " should be a string. ").concat(gs(
                k
              ), " given.")
            );
          if (k.trim().length !== k.length)
            throw new Error(
              "opts.label in ".concat(g, ' should not start/end with whitespace. "').concat(k, '" given.')
            );
          if (k.length === 0)
            throw new Error(
              "opts.label in ".concat(g, " should not be an empty string. If you wish to have no label, remove opts.label from opts.")
            );
        }
      }
    }, n0 = (g, S = {}) => {
      Fu("t.compound(props, opts)", S);
      const k = AA(g), z = /* @__PURE__ */ new WeakMap();
      return {
        type: "compound",
        props: k,
        valueType: null,
        [wl]: "TheatrePropType",
        label: S.label,
        default: LP(k, (te) => te.default),
        deserializeAndSanitize: (te) => {
          if (typeof te != "object" || !te)
            return;
          if (z.has(te))
            return z.get(te);
          const fe = {};
          let Re = !1;
          for (const [Le, We] of Object.entries(k))
            if (Object.prototype.hasOwnProperty.call(te, Le)) {
              const ot = We.deserializeAndSanitize(
                te[Le]
              );
              ot != null && (Re = !0, fe[Le] = ot);
            }
          if (z.set(te, fe), Re)
            return fe;
        }
      };
    }, AF = (g, S = {}) => {
      process.env.NODE_ENV !== "production" && Fu("t.file(defaultValue, opts)", S);
      const k = (z, X, te) => {
        var fe;
        return {
          type: "file",
          id: ((fe = S.interpolate) != null ? fe : Uh)(z.id, X.id, te)
        };
      };
      return {
        type: "file",
        default: { type: "file", id: g },
        valueType: null,
        [wl]: "TheatrePropType",
        label: S.label,
        interpolate: k,
        deserializeAndSanitize: kA
      };
    }, kA = (g) => {
      if (!g)
        return;
      let S = !0;
      if (typeof g.id != "string" && ![null, void 0].includes(g.id) && (S = !1), g.type !== "file" && (S = !1), !!S)
        return g;
    }, kF = (g, S = {}) => {
      process.env.NODE_ENV !== "production" && Fu("t.image(defaultValue, opts)", S);
      const k = (z, X, te) => {
        var fe;
        return {
          type: "image",
          id: ((fe = S.interpolate) != null ? fe : Uh)(z.id, X.id, te)
        };
      };
      return {
        type: "image",
        default: { type: "image", id: g },
        valueType: null,
        [wl]: "TheatrePropType",
        label: S.label,
        interpolate: k,
        deserializeAndSanitize: MF
      };
    }, MF = (g) => {
      if (!g)
        return;
      let S = !0;
      if (typeof g.id != "string" && ![null, void 0].includes(g.id) && (S = !1), g.type !== "image" && (S = !1), !!S)
        return g;
    }, i1 = (g, S = {}) => {
      var k;
      if (process.env.NODE_ENV !== "production") {
        if (Fu("t.number(defaultValue, opts)", S), typeof g != "number" || !isFinite(g))
          throw new Error(
            "Argument defaultValue in t.number(defaultValue) must be a number. ".concat(gs(
              g
            ), " given.")
          );
        if (typeof S == "object" && S !== null) {
          if (Object.prototype.hasOwnProperty.call(S, "range")) {
            if (!Array.isArray(S.range))
              throw new Error(
                "opts.range in t.number(defaultValue, opts) must be a tuple of two numbers. ".concat(gs(
                  S.range
                ), " given.")
              );
            if (S.range.length !== 2)
              throw new Error(
                "opts.range in t.number(defaultValue, opts) must have two elements. ".concat(S.range.length, " given.")
              );
            if (!S.range.every((z) => typeof z == "number" && !isNaN(z)))
              throw new Error(
                "opts.range in t.number(defaultValue, opts) must be a tuple of two numbers."
              );
            if (S.range[0] >= S.range[1])
              throw new Error(
                "opts.range[0] in t.number(defaultValue, opts) must be smaller than opts.range[1]. Given: ".concat(JSON.stringify(
                  S.range
                ))
              );
          }
          if (Object.prototype.hasOwnProperty.call(S, "nudgeMultiplier") && (typeof S.nudgeMultiplier != "number" || !isFinite(S.nudgeMultiplier)))
            throw new Error(
              "opts.nudgeMultiplier in t.number(defaultValue, opts) must be a finite number. ".concat(gs(
                S.nudgeMultiplier
              ), " given.")
            );
          if (Object.prototype.hasOwnProperty.call(S, "nudgeFn") && typeof S.nudgeFn != "function")
            throw new Error(
              "opts.nudgeFn in t.number(defaultValue, opts) must be a function. ".concat(gs(
                S.nudgeFn
              ), " given.")
            );
        }
      }
      return j(I({
        type: "number",
        valueType: 0,
        default: g,
        [wl]: "TheatrePropType"
      }, S || {}), {
        label: S.label,
        nudgeFn: (k = S.nudgeFn) != null ? k : BF,
        nudgeMultiplier: typeof S.nudgeMultiplier == "number" ? S.nudgeMultiplier : void 0,
        interpolate: MA,
        deserializeAndSanitize: RF(S.range)
      });
    }, RF = (g) => g ? (S) => {
      if (typeof S == "number" && isFinite(S))
        return jx(S, g[0], g[1]);
    } : IF, IF = (g) => typeof g == "number" && isFinite(g) ? g : void 0, MA = (g, S, k) => g + k * (S - g), NF = (g = { r: 0, g: 0, b: 0, a: 1 }, S = {}) => {
      if (process.env.NODE_ENV !== "production") {
        Fu("t.rgba(defaultValue, opts)", S);
        let z = !0;
        for (const X of ["r", "g", "b", "a"])
          (!Object.prototype.hasOwnProperty.call(g, X) || typeof g[X] != "number") && (z = !1);
        if (!z)
          throw new Error(
            "Argument defaultValue in t.rgba(defaultValue) must be of the shape { r: number; g: number, b: number, a: number; }."
          );
      }
      const k = {};
      for (const z of ["r", "g", "b", "a"])
        k[z] = Math.min(
          Math.max(g[z], 0),
          1
        );
      return {
        type: "rgba",
        valueType: null,
        default: r1(k),
        [wl]: "TheatrePropType",
        label: S.label,
        interpolate: Lh,
        deserializeAndSanitize: OF
      };
    }, OF = (g) => {
      if (!g)
        return;
      let S = !0;
      for (const z of ["r", "g", "b", "a"])
        (!Object.prototype.hasOwnProperty.call(g, z) || typeof g[z] != "number") && (S = !1);
      if (!S)
        return;
      const k = {};
      for (const z of ["r", "g", "b", "a"])
        k[z] = Math.min(
          Math.max(g[z], 0),
          1
        );
      return r1(k);
    }, Lh = (g, S, k) => {
      const z = EA(wA(g)), X = EA(wA(S)), te = {
        L: (1 - k) * z.L + k * X.L,
        a: (1 - k) * z.a + k * X.a,
        b: (1 - k) * z.b + k * X.b,
        alpha: (1 - k) * z.alpha + k * X.alpha
      }, fe = SA(TA(te));
      return r1(fe);
    }, jh = (g, S = {}) => {
      var k;
      if (process.env.NODE_ENV !== "production" && (Fu("t.boolean(defaultValue, opts)", S), typeof g != "boolean"))
        throw new Error(
          "defaultValue in t.boolean(defaultValue) must be a boolean. ".concat(gs(
            g
          ), " given.")
        );
      return {
        type: "boolean",
        default: g,
        valueType: null,
        [wl]: "TheatrePropType",
        label: S.label,
        interpolate: (k = S.interpolate) != null ? k : Uh,
        deserializeAndSanitize: DF
      };
    }, DF = (g) => typeof g == "boolean" ? g : void 0;
    function Uh(g) {
      return g;
    }
    var RA = (g, S = {}) => {
      var k;
      if (process.env.NODE_ENV !== "production" && (Fu("t.string(defaultValue, opts)", S), typeof g != "string"))
        throw new Error(
          "defaultValue in t.string(defaultValue) must be a string. ".concat(gs(
            g
          ), " given.")
        );
      return {
        type: "string",
        default: g,
        valueType: null,
        [wl]: "TheatrePropType",
        label: S.label,
        interpolate: (k = S.interpolate) != null ? k : Uh,
        deserializeAndSanitize: FF
      };
    };
    function FF(g) {
      return typeof g == "string" ? g : void 0;
    }
    function IA(g, S, k = {}) {
      var z, X;
      return {
        type: "stringLiteral",
        default: g,
        valuesAndLabels: I({}, S),
        [wl]: "TheatrePropType",
        valueType: null,
        as: (z = k.as) != null ? z : "menu",
        label: k.label,
        interpolate: (X = k.interpolate) != null ? X : Uh,
        deserializeAndSanitize(te) {
          if (typeof te == "string" && Object.prototype.hasOwnProperty.call(S, te))
            return te;
        }
      };
    }
    var BF = ({
      config: g,
      deltaX: S,
      deltaFraction: k,
      magnitude: z
    }) => {
      var X;
      const { range: te } = g;
      return !g.nudgeMultiplier && te && !te.includes(1 / 0) && !te.includes(-1 / 0) ? k * (te[1] - te[0]) * z : S * z * ((X = g.nudgeMultiplier) != null ? X : 1);
    }, NA = (g) => g.replace(/^[\s\/]*/, "").replace(/[\s\/]*$/, "").replace(/\s*\/\s*/g, " / "), OA = (g) => {
      if (typeof g != "string")
        return "it is not a string. (it is a ".concat(typeof g, ")");
      const S = g.split(/\//);
      if (S.length === 0)
        return "it is empty.";
      for (let k = 0; k < S.length; k++) {
        const z = S[k].trim();
        if (z.length === 0)
          return "the component #".concat(k + 1, " is empty.");
        if (z.length > 64)
          return "the component '".concat(z, "' must have 64 characters or less.");
      }
    };
    function r0(g, S) {
      const k = NA(g);
      if (process.env.NODE_ENV !== "development")
        return k;
      const z = OA(k);
      if (z)
        throw new yr(
          "The path in ".concat(S, "(").concat(typeof g == "string" ? '"'.concat(g, '"') : "", ") is invalid because ").concat(z)
        );
      return g !== k && Po.warning(
        "Invalid path provided to object",
        "The path in `".concat(S, '("').concat(g, '")` was sanitized to `"').concat(k, `"\`.

`) + "Please replace the path with the sanitized one, otherwise it will likely break in the future.",
        [
          {
            url: "https://www.theatrejs.com/docs/latest/manual/objects#creating-sheet-objects",
            title: "Sheet Objects"
          },
          {
            url: "https://www.theatrejs.com/docs/latest/api/core#sheet.object",
            title: "API"
          }
        ]
      ), k;
    }
    var LF = re(Fe()), Kf = /* @__PURE__ */ new WeakMap(), DA = class {
      get type() {
        return "Theatre_Sheet_PublicAPI";
      }
      /**
       * @internal
       */
      constructor(g) {
        st(this, g);
      }
      object(g, S, k) {
        const z = Tt(this), X = r0(
          g,
          "sheet.object"
        ), te = z.getObject(X), fe = null, Re = k?.__actions__THIS_API_IS_UNSTABLE_AND_WILL_CHANGE_IN_THE_NEXT_VERSION;
        if (te) {
          if (process.env.NODE_ENV !== "production") {
            const Le = Kf.get(te);
            if (Le && !(0, LF.default)(S, Le))
              if (k?.reconfigure === !0) {
                const We = n0(S);
                return te.template.reconfigure(We), Kf.set(te, S), te.publicApi;
              } else
                throw new Error(
                  'You seem to have called sheet.object("'.concat(g, '", config) twice, with different values for `config`. ') + `This is disallowed because changing the config of an object on the fly would make it difficult to reason about.

` + 'You can fix this by either re-using the existing object, or calling sheet.object("'.concat(g, `", config) with the same config.

`) + "If you mean to reconfigure the object's config, set `{reconfigure: true}` in sheet.object(\"".concat(g, '", config, {reconfigure: true})')
                );
          }
          return Re && te.template._temp_setActions(Re), te.publicApi;
        } else {
          const Le = n0(S), We = z.createObject(
            X,
            fe,
            Le,
            Re
          );
          return process.env.NODE_ENV !== "production" && Kf.set(We, S), We.publicApi;
        }
      }
      __experimental_getExistingObject(g) {
        const S = Tt(this), k = r0(
          g,
          "sheet.object"
        ), z = S.getObject(k);
        return z?.publicApi;
      }
      get sequence() {
        return Tt(this).getSequence().publicApi;
      }
      get project() {
        return Tt(this).project.publicApi;
      }
      get address() {
        return I({}, Tt(this).address);
      }
      detachObject(g) {
        const S = Tt(this), k = r0(
          g,
          'sheet.deleteObject("'.concat(g, '")')
        );
        if (!S.getObject(k)) {
          Po.warning(
            `Couldn't delete object "`.concat(k, '"'),
            'There is no object with key "'.concat(k, `".

To fix this, make sure you are calling \`sheet.deleteObject("`).concat(k, '")` with the correct key.')
          ), console.warn('Object key "'.concat(k, '" does not exist.'));
          return;
        }
        S.deleteObject(k);
      }
    }, Yf = ut(), FA = class {
      constructor(g, S) {
        this.template = g, this.instanceId = S, J(this, "_objects", new Yf.Atom({})), J(this, "_sequence"), J(this, "address"), J(this, "publicApi"), J(this, "project"), J(this, "objectsP", this._objects.pointer), J(this, "type", "Theatre_Sheet"), J(this, "_logger"), this._logger = g.project._logger.named("Sheet", S), this._logger._trace("creating sheet"), this.project = g.project, this.address = j(I({}, g.address), {
          sheetInstanceId: this.instanceId
        }), this.publicApi = new DA(this);
      }
      /**
       * @remarks At some point, we have to reconcile the concept of "an object"
       * with that of "an element."
       */
      createObject(g, S, k, z = {}) {
        const te = this.template.getObjectTemplate(
          g,
          S,
          k,
          z
        ).createInstance(this, S, k);
        return this._objects.setByPointer((fe) => fe[g], te), te;
      }
      getObject(g) {
        return this._objects.get()[g];
      }
      deleteObject(g) {
        this._objects.reduce((S) => {
          const k = I({}, S);
          return delete k[g], k;
        });
      }
      getSequence() {
        if (!this._sequence) {
          const g = (0, Yf.prism)(() => {
            const k = (0, Yf.val)(
              this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.length
            );
            return jF(k);
          }), S = (0, Yf.prism)(() => {
            const k = (0, Yf.val)(
              this.project.pointers.historic.sheetsById[this.address.sheetId].sequence.subUnitsPerUnit
            );
            return BA(k);
          });
          this._sequence = new xA(
            this.template.project,
            this,
            g,
            S
          );
        }
        return this._sequence;
      }
    }, jF = (g) => typeof g == "number" && isFinite(g) && g > 0 ? g : 10, BA = (g) => typeof g == "number" && A_(g) && g >= 1 && g <= 1e3 ? g : 30, s1 = class {
      constructor(g, S) {
        this.project = g, J(this, "type", "Theatre_SheetTemplate"), J(this, "address"), J(this, "_instances", new W_.Atom({})), J(this, "instancesP", this._instances.pointer), J(this, "_objectTemplates", new W_.Atom({})), J(this, "objectTemplatesP", this._objectTemplates.pointer), this.address = j(I({}, g.address), { sheetId: S });
      }
      getInstance(g) {
        let S = this._instances.get()[g];
        return S || (S = new FA(this, g), this._instances.setByPointer((k) => k[g], S)), S;
      }
      getObjectTemplate(g, S, k, z) {
        let X = this._objectTemplates.get()[g];
        return X || (X = new uA(
          this,
          g,
          S,
          k,
          z
        ), this._objectTemplates.setByPointer((te) => te[g], X)), X;
      }
    }, i0 = ut(), LA = ut(), jA = (g) => new Promise((S) => setTimeout(S, g)), UF = jA;
    function Ti(g) {
      for (var S = arguments.length, k = Array(S > 1 ? S - 1 : 0), z = 1; z < S; z++)
        k[z - 1] = arguments[z];
      if (process.env.NODE_ENV !== "production") {
        var X = GF[g], te = X ? typeof X == "function" ? X.apply(null, k) : X : "unknown error nr: " + g;
        throw Error("[Immer] " + te);
      }
      throw Error("[Immer] minified error nr: " + g + (k.length ? " " + k.map(function(fe) {
        return "'" + fe + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function Bu(g) {
      return !!g && !!g[Is];
    }
    function Yc(g) {
      return !!g && (function(S) {
        if (!S || typeof S != "object")
          return !1;
        var k = Object.getPrototypeOf(S);
        if (k === null)
          return !0;
        var z = Object.hasOwnProperty.call(k, "constructor") && k.constructor;
        return z === Object || typeof z == "function" && Function.toString.call(z) === Zc;
      }(g) || Array.isArray(g) || !!g[El] || !!g.constructor[El] || Xf(g) || s0(g));
    }
    function UA(g) {
      return Bu(g) || Ti(23, g), g[Is].t;
    }
    function Lu(g, S, k) {
      k === void 0 && (k = !1), zh(g) === 0 ? (k ? Object.keys : p0)(g).forEach(function(z) {
        k && typeof z == "symbol" || S(z, g[z], g);
      }) : g.forEach(function(z, X) {
        return S(X, z, g);
      });
    }
    function zh(g) {
      var S = g[Is];
      return S ? S.i > 3 ? S.i - 4 : S.i : Array.isArray(g) ? 1 : Xf(g) ? 2 : s0(g) ? 3 : 0;
    }
    function o1(g, S) {
      return zh(g) === 2 ? g.has(S) : Object.prototype.hasOwnProperty.call(g, S);
    }
    function zA(g, S) {
      return zh(g) === 2 ? g.get(S) : g[S];
    }
    function a1(g, S, k) {
      var z = zh(g);
      z === 2 ? g.set(S, k) : z === 3 ? (g.delete(S), g.add(k)) : g[S] = k;
    }
    function VA(g, S) {
      return g === S ? g !== 0 || 1 / g == 1 / S : g != g && S != S;
    }
    function Xf(g) {
      return VF && g instanceof Map;
    }
    function s0(g) {
      return h1 && g instanceof Set;
    }
    function Xc(g) {
      return g.o || g.t;
    }
    function o0(g) {
      if (Array.isArray(g))
        return Array.prototype.slice.call(g);
      var S = qF(g);
      delete S[Is];
      for (var k = p0(S), z = 0; z < k.length; z++) {
        var X = k[z], te = S[X];
        te.writable === !1 && (te.writable = !0, te.configurable = !0), (te.get || te.set) && (S[X] = { configurable: !0, writable: !0, enumerable: te.enumerable, value: g[X] });
      }
      return Object.create(Object.getPrototypeOf(g), S);
    }
    function l1(g, S) {
      return S === void 0 && (S = !1), Qc(g) || Bu(g) || !Yc(g) || (zh(g) > 1 && (g.set = g.add = g.clear = g.delete = zF), Object.freeze(g), S && Lu(g, function(k, z) {
        return l1(z, !0);
      }, !0)), g;
    }
    function zF() {
      Ti(2);
    }
    function Qc(g) {
      return g == null || typeof g != "object" || Object.isFrozen(g);
    }
    function ia(g) {
      var S = QA[g];
      return S || Ti(18, g), S;
    }
    function GA() {
      return process.env.NODE_ENV === "production" || ju || Ti(0), ju;
    }
    function a0(g, S) {
      S && (ia("Patches"), g.u = [], g.s = [], g.v = S);
    }
    function Vh(g) {
      u1(g), g.p.forEach(HA), g.p = null;
    }
    function u1(g) {
      g === ju && (ju = g.l);
    }
    function qA(g) {
      return ju = { p: [], l: ju, h: g, m: !0, _: 0 };
    }
    function HA(g) {
      var S = g[Is];
      S.i === 0 || S.i === 1 ? S.j() : S.O = !0;
    }
    function l0(g, S) {
      S._ = S.p.length;
      var k = S.p[0], z = g !== void 0 && g !== k;
      return S.h.g || ia("ES5").S(S, g, z), z ? (k[Is].P && (Vh(S), Ti(4)), Yc(g) && (g = Qf(S, g), S.l || u0(S, g)), S.u && ia("Patches").M(k[Is], g, S.u, S.s)) : g = Qf(S, k, []), Vh(S), S.u && S.v(S.u, S.s), g !== f1 ? g : void 0;
    }
    function Qf(g, S, k) {
      if (Qc(S))
        return S;
      var z = S[Is];
      if (!z)
        return Lu(S, function(te, fe) {
          return $A(g, z, S, te, fe, k);
        }, !0), S;
      if (z.A !== g)
        return S;
      if (!z.P)
        return u0(g, z.t, !0), z.t;
      if (!z.I) {
        z.I = !0, z.A._--;
        var X = z.i === 4 || z.i === 5 ? z.o = o0(z.k) : z.o;
        Lu(z.i === 3 ? new Set(X) : X, function(te, fe) {
          return $A(g, z, X, te, fe, k);
        }), u0(g, X, !1), k && g.u && ia("Patches").R(z, k, g.u, g.s);
      }
      return z.o;
    }
    function $A(g, S, k, z, X, te) {
      if (process.env.NODE_ENV !== "production" && X === k && Ti(5), Bu(X)) {
        var fe = Qf(g, X, te && S && S.i !== 3 && !o1(S.D, z) ? te.concat(z) : void 0);
        if (a1(k, z, fe), !Bu(fe))
          return;
        g.m = !1;
      }
      if (Yc(X) && !Qc(X)) {
        if (!g.h.F && g._ < 1)
          return;
        Qf(g, X), S && S.A.l || u0(g, X);
      }
    }
    function u0(g, S, k) {
      k === void 0 && (k = !1), g.h.F && g.m && l1(S, k);
    }
    function c0(g, S) {
      var k = g[Is];
      return (k ? Xc(k) : g)[S];
    }
    function WA(g, S) {
      if (S in g)
        for (var k = Object.getPrototypeOf(g); k; ) {
          var z = Object.getOwnPropertyDescriptor(k, S);
          if (z)
            return z;
          k = Object.getPrototypeOf(k);
        }
    }
    function c1(g) {
      g.P || (g.P = !0, g.l && c1(g.l));
    }
    function d0(g) {
      g.o || (g.o = o0(g.t));
    }
    function h0(g, S, k) {
      var z = Xf(S) ? ia("MapSet").N(S, k) : s0(S) ? ia("MapSet").T(S, k) : g.g ? function(X, te) {
        var fe = Array.isArray(X), Re = { i: fe ? 1 : 0, A: te ? te.A : GA(), P: !1, I: !1, D: {}, l: te, t: X, k: null, o: null, j: null, C: !1 }, Le = Re, We = f0;
        fe && (Le = [Re], We = m0);
        var ot = Proxy.revocable(Le, We), pt = ot.revoke, _t = ot.proxy;
        return Re.k = _t, Re.j = pt, _t;
      }(S, k) : ia("ES5").J(S, k);
      return (k ? k.A : GA()).p.push(z), z;
    }
    function KA(g) {
      return Bu(g) || Ti(22, g), function S(k) {
        if (!Yc(k))
          return k;
        var z, X = k[Is], te = zh(k);
        if (X) {
          if (!X.P && (X.i < 4 || !ia("ES5").K(X)))
            return X.t;
          X.I = !0, z = YA(k, te), X.I = !1;
        } else
          z = YA(k, te);
        return Lu(z, function(fe, Re) {
          X && zA(X.t, fe) === Re || a1(z, fe, S(Re));
        }), te === 3 ? new Set(z) : z;
      }(g);
    }
    function YA(g, S) {
      switch (S) {
        case 2:
          return new Map(g);
        case 3:
          return Array.from(g);
      }
      return o0(g);
    }
    var XA, ju, d1 = typeof Symbol < "u" && typeof Symbol("x") == "symbol", VF = typeof Map < "u", h1 = typeof Set < "u", p1 = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", f1 = d1 ? Symbol.for("immer-nothing") : ((XA = {})["immer-nothing"] = !0, XA), El = d1 ? Symbol.for("immer-draftable") : "__$immer_draftable", Is = d1 ? Symbol.for("immer-state") : "__$immer_state", GF = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(g) {
      return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + g;
    }, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(g) {
      return "Cannot apply patch, path doesn't resolve: " + g;
    }, 16: 'Sets cannot have "replace" patches.', 17: function(g) {
      return "Unsupported patch operation: " + g;
    }, 18: function(g) {
      return "The plugin for '" + g + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + g + "()` when initializing your application.";
    }, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(g) {
      return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + g + "'";
    }, 22: function(g) {
      return "'current' expects a draft, got: " + g;
    }, 23: function(g) {
      return "'original' expects a draft, got: " + g;
    }, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" }, Zc = "" + Object.prototype.constructor, p0 = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(g) {
      return Object.getOwnPropertyNames(g).concat(Object.getOwnPropertySymbols(g));
    } : Object.getOwnPropertyNames, qF = Object.getOwnPropertyDescriptors || function(g) {
      var S = {};
      return p0(g).forEach(function(k) {
        S[k] = Object.getOwnPropertyDescriptor(g, k);
      }), S;
    }, QA = {}, f0 = { get: function(g, S) {
      if (S === Is)
        return g;
      var k = Xc(g);
      if (!o1(k, S))
        return function(X, te, fe) {
          var Re, Le = WA(te, fe);
          return Le ? "value" in Le ? Le.value : (Re = Le.get) === null || Re === void 0 ? void 0 : Re.call(X.k) : void 0;
        }(g, k, S);
      var z = k[S];
      return g.I || !Yc(z) ? z : z === c0(g.t, S) ? (d0(g), g.o[S] = h0(g.A.h, z, g)) : z;
    }, has: function(g, S) {
      return S in Xc(g);
    }, ownKeys: function(g) {
      return Reflect.ownKeys(Xc(g));
    }, set: function(g, S, k) {
      var z = WA(Xc(g), S);
      if (z?.set)
        return z.set.call(g.k, k), !0;
      if (!g.P) {
        var X = c0(Xc(g), S), te = X?.[Is];
        if (te && te.t === k)
          return g.o[S] = k, g.D[S] = !1, !0;
        if (VA(k, X) && (k !== void 0 || o1(g.t, S)))
          return !0;
        d0(g), c1(g);
      }
      return g.o[S] === k && typeof k != "number" && (k !== void 0 || S in g.o) || (g.o[S] = k, g.D[S] = !0, !0);
    }, deleteProperty: function(g, S) {
      return c0(g.t, S) !== void 0 || S in g.t ? (g.D[S] = !1, d0(g), c1(g)) : delete g.D[S], g.o && delete g.o[S], !0;
    }, getOwnPropertyDescriptor: function(g, S) {
      var k = Xc(g), z = Reflect.getOwnPropertyDescriptor(k, S);
      return z && { writable: !0, configurable: g.i !== 1 || S !== "length", enumerable: z.enumerable, value: k[S] };
    }, defineProperty: function() {
      Ti(11);
    }, getPrototypeOf: function(g) {
      return Object.getPrototypeOf(g.t);
    }, setPrototypeOf: function() {
      Ti(12);
    } }, m0 = {};
    Lu(f0, function(g, S) {
      m0[g] = function() {
        return arguments[0] = arguments[0][0], S.apply(this, arguments);
      };
    }), m0.deleteProperty = function(g, S) {
      return process.env.NODE_ENV !== "production" && isNaN(parseInt(S)) && Ti(13), f0.deleteProperty.call(this, g[0], S);
    }, m0.set = function(g, S, k) {
      return process.env.NODE_ENV !== "production" && S !== "length" && isNaN(parseInt(S)) && Ti(14), f0.set.call(this, g[0], S, k, g[0]);
    };
    var ZA = function() {
      function g(k) {
        var z = this;
        this.g = p1, this.F = !0, this.produce = function(X, te, fe) {
          if (typeof X == "function" && typeof te != "function") {
            var Re = te;
            te = X;
            var Le = z;
            return function(Rt) {
              var Mt = this;
              Rt === void 0 && (Rt = Re);
              for (var ln = arguments.length, mn = Array(ln > 1 ? ln - 1 : 0), Jt = 1; Jt < ln; Jt++)
                mn[Jt - 1] = arguments[Jt];
              return Le.produce(Rt, function(Dn) {
                var hi;
                return (hi = te).call.apply(hi, [Mt, Dn].concat(mn));
              });
            };
          }
          var We;
          if (typeof te != "function" && Ti(6), fe !== void 0 && typeof fe != "function" && Ti(7), Yc(X)) {
            var ot = qA(z), pt = h0(z, X, void 0), _t = !0;
            try {
              We = te(pt), _t = !1;
            } finally {
              _t ? Vh(ot) : u1(ot);
            }
            return typeof Promise < "u" && We instanceof Promise ? We.then(function(Rt) {
              return a0(ot, fe), l0(Rt, ot);
            }, function(Rt) {
              throw Vh(ot), Rt;
            }) : (a0(ot, fe), l0(We, ot));
          }
          if (!X || typeof X != "object")
            return (We = te(X)) === f1 ? void 0 : (We === void 0 && (We = X), z.F && l1(We, !0), We);
          Ti(21, X);
        }, this.produceWithPatches = function(X, te) {
          return typeof X == "function" ? function(Le) {
            for (var We = arguments.length, ot = Array(We > 1 ? We - 1 : 0), pt = 1; pt < We; pt++)
              ot[pt - 1] = arguments[pt];
            return z.produceWithPatches(Le, function(_t) {
              return X.apply(void 0, [_t].concat(ot));
            });
          } : [z.produce(X, te, function(Le, We) {
            fe = Le, Re = We;
          }), fe, Re];
          var fe, Re;
        }, typeof k?.useProxies == "boolean" && this.setUseProxies(k.useProxies), typeof k?.autoFreeze == "boolean" && this.setAutoFreeze(k.autoFreeze);
      }
      var S = g.prototype;
      return S.createDraft = function(k) {
        Yc(k) || Ti(8), Bu(k) && (k = KA(k));
        var z = qA(this), X = h0(this, k, void 0);
        return X[Is].C = !0, u1(z), X;
      }, S.finishDraft = function(k, z) {
        var X = k && k[Is];
        process.env.NODE_ENV !== "production" && (X && X.C || Ti(9), X.I && Ti(10));
        var te = X.A;
        return a0(te, z), l0(void 0, te);
      }, S.setAutoFreeze = function(k) {
        this.F = k;
      }, S.setUseProxies = function(k) {
        k && !p1 && Ti(20), this.g = k;
      }, S.applyPatches = function(k, z) {
        var X;
        for (X = z.length - 1; X >= 0; X--) {
          var te = z[X];
          if (te.path.length === 0 && te.op === "replace") {
            k = te.value;
            break;
          }
        }
        var fe = ia("Patches").$;
        return Bu(k) ? fe(k, z) : this.produce(k, function(Re) {
          return fe(Re, z.slice(X + 1));
        });
      }, g;
    }(), ro = new ZA();
    ro.produce, ro.produceWithPatches.bind(ro), ro.setAutoFreeze.bind(ro), ro.setUseProxies.bind(ro), ro.applyPatches.bind(ro), ro.createDraft.bind(ro), ro.finishDraft.bind(ro);
    var HF = {
      /**
       * If the schema of the redux store changes in a backwards-incompatible way, then this version number should be incremented.
       *
       * While this looks like semver, it is not. There are no patch numbers, so any change in this number is a breaking change.
       *
       * However, as long as the schema of the redux store is backwards-compatible, then we don't have to change this number.
       *
       * Since the 0.4.0 release, this number has not had to change.
       */
      currentProjectStateDefinitionVersion: "0.4.0"
    }, g0 = HF;
    async function $F(g, S, k) {
      if (await UF(0), g.transaction(({ drafts: z }) => {
        var X;
        const te = S.address.projectId;
        z.ephemeral.coreByProject[te] = {
          lastExportedObject: null,
          loadingState: { type: "loading" }
        }, z.ahistoric.coreByProject[te] = {
          ahistoricStuff: ""
        };
        function fe() {
          z.ephemeral.coreByProject[te].loadingState = {
            type: "loaded"
          }, z.historic.coreByProject[te] = {
            sheetsById: {},
            definitionVersion: g0.currentProjectStateDefinitionVersion,
            revisionHistory: []
          };
        }
        function Re(pt) {
          z.ephemeral.coreByProject[te].loadingState = {
            type: "loaded"
          }, z.historic.coreByProject[te] = pt;
        }
        function Le() {
          z.ephemeral.coreByProject[te].loadingState = {
            type: "loaded"
          };
        }
        function We(pt) {
          z.ephemeral.coreByProject[te].loadingState = {
            type: "browserStateIsNotBasedOnDiskState",
            onDiskState: pt
          };
        }
        const ot = (X = UA(z.historic)) == null ? void 0 : X.coreByProject[S.address.projectId];
        ot ? k && ot.revisionHistory.indexOf(
          k.revisionHistory[0]
        ) == -1 ? We(k) : Le() : k ? Re(k) : fe();
      }), k?.sheetsById) {
        const z = S.address.projectId;
        g.transaction(({ stateEditors: X }) => {
          var te, fe, Re, Le, We, ot, pt, _t, Rt, Mt, ln, mn, Jt, Dn, hi, ar, pi, tn, fi, Xi, xe, La, ja, Ua;
          for (const [oi, ji] of Object.entries(
            k.sheetsById
          )) {
            if ((te = ji?.sequence) != null && te.markers) {
              const At = ji.sequence.markers;
              (pt = (ot = (We = (Le = (Re = (fe = X?.studio) == null ? void 0 : fe.historic) == null ? void 0 : Re.projects) == null ? void 0 : Le.stateByProjectId) == null ? void 0 : We.stateBySheetId) == null ? void 0 : ot.sequenceEditor) != null && pt.replaceMarkers && X.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers(
                {
                  sheetAddress: { projectId: z, sheetId: oi },
                  markers: At,
                  snappingFunction: (ai) => ai
                }
              );
            }
            if ((_t = ji?.sequence) != null && _t.events) {
              const At = ji.sequence.events;
              (Dn = (Jt = (mn = (ln = (Mt = (Rt = X?.studio) == null ? void 0 : Rt.historic) == null ? void 0 : Mt.projects) == null ? void 0 : ln.stateByProjectId) == null ? void 0 : mn.stateBySheetId) == null ? void 0 : Jt.sequenceEditor) != null && Dn.replaceEvents && X.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents(
                {
                  sheetAddress: { projectId: z, sheetId: oi },
                  events: At,
                  snappingFunction: (ai) => ai
                }
              );
            }
            if ((hi = ji?.sequence) != null && hi.subSequences) {
              const At = ji.sequence.subSequences;
              if ((xe = (Xi = (fi = (tn = (pi = (ar = X?.studio) == null ? void 0 : ar.historic) == null ? void 0 : pi.projects) == null ? void 0 : tn.stateByProjectId) == null ? void 0 : fi.stateBySheetId) == null ? void 0 : Xi.sequenceEditor) != null && xe.replaceSubSequences) {
                const ai = (Ua = (ja = (La = X.studio.historic.projects.stateByProjectId[z]) == null ? void 0 : La.stateBySheetId[oi]) == null ? void 0 : ja.sequenceEditor) == null ? void 0 : Ua.subSequenceSet, Yn = ai ? At.filter(
                  (Qi) => !ai.byId[Qi.id]
                ) : At;
                Yn.length > 0 && X.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceSubSequences(
                  {
                    sheetAddress: { projectId: z, sheetId: oi },
                    subSequences: Yn,
                    snappingFunction: (Qi) => Qi
                  }
                );
              }
            }
          }
        });
      }
    }
    function JA() {
    }
    function m1(g) {
      var S, k;
      const z = (S = g?.logging) != null && S.internal ? (k = g.logging.min) != null ? k : 256 : 1 / 0, X = z <= 128, te = z <= 512, fe = sA(void 0, {
        _debug: X ? console.debug.bind(console, "_coreLogger(TheatreInternalLogger) debug") : JA,
        _error: te ? console.error.bind(console, "_coreLogger(TheatreInternalLogger) error") : JA
      });
      if (g) {
        const { logger: Re, logging: Le } = g;
        Re && fe.configureLogger(Re), Le ? fe.configureLogging(Le) : fe.configureLogging({
          dev: process.env.NODE_ENV !== "production"
        });
      }
      return fe.getLogger().named("Theatre");
    }
    var WF = class {
      constructor(g, S = {}, k) {
        this.config = S, this.publicApi = k, J(this, "pointers"), J(this, "_pointerProxies"), J(this, "address"), J(this, "_studioReadyDeferred"), J(this, "_assetStorageReadyDeferred"), J(this, "_readyPromise"), J(this, "_sheetTemplates", new LA.Atom({})), J(this, "sheetTemplatesP", this._sheetTemplates.pointer), J(this, "_studio"), J(this, "assetStorage"), J(this, "type", "Theatre_Project"), J(this, "_logger");
        var z;
        this._logger = m1({ logging: { dev: !0 } }).named("Project", g), this._logger.traceDev("creating project"), this.address = { projectId: g };
        const X = new LA.Atom({
          ahistoric: {
            ahistoricStuff: ""
          },
          historic: (z = S.state) != null ? z : {
            sheetsById: {},
            definitionVersion: g0.currentProjectStateDefinitionVersion,
            revisionHistory: []
          },
          ephemeral: {
            loadingState: {
              type: "loaded"
            },
            lastExportedObject: null
          }
        });
        this._assetStorageReadyDeferred = Ba(), this.assetStorage = {
          getAssetUrl: (te) => {
            var fe;
            return "".concat((fe = S.assets) == null ? void 0 : fe.baseUrl, "/").concat(te);
          },
          // Until the asset storage is ready, we'll throw an error when the user tries to use it
          createAsset: () => {
            throw new Error("Please wait for Project.ready to use assets.");
          }
        }, this._pointerProxies = {
          historic: new i0.PointerProxy(X.pointer.historic),
          ahistoric: new i0.PointerProxy(X.pointer.ahistoric),
          ephemeral: new i0.PointerProxy(X.pointer.ephemeral)
        }, this.pointers = {
          historic: this._pointerProxies.historic.pointer,
          ahistoric: this._pointerProxies.ahistoric.pointer,
          ephemeral: this._pointerProxies.ephemeral.pointer
        }, Ct.add(g, this), this._studioReadyDeferred = Ba(), this._readyPromise = Promise.all([
          this._studioReadyDeferred.promise,
          this._assetStorageReadyDeferred.promise
          // hide the array from the user, i.e. make it Promise<void> instead of Promise<[undefined, undefined]>
        ]).then(() => {
        }), S.state ? setTimeout(() => {
          this._studio || (this._studioReadyDeferred.resolve(void 0), this._assetStorageReadyDeferred.resolve(void 0), this._logger._trace("ready deferred resolved with no state"));
        }, 0) : typeof window > "u" ? process.env.NODE_ENV === "production" && console.error(
          'Argument config.state in Theatre.getProject("'.concat(g, '", config) is empty. ') + "You can safely ignore this message if you're developing a Next.js/Remix project in development mode. But if you are shipping to your end-users, then you need to set config.state, otherwise your project's state will be empty and nothing will animate. Learn more at https://www.theatrejs.com/docs/latest/manual/projects#state"
        ) : setTimeout(() => {
          if (!this._studio)
            throw new Error(
              'Argument config.state in Theatre.getProject("'.concat(g, '", config) is empty. This is fine ') + "while you are using @tomorrowevening/theatre-core along with @tomorrowevening/theatre-studio. But since @tomorrowevening/theatre-studio " + 'is not loaded, the state of project "'.concat(g, `" will be empty.

`) + `To fix this, you need to add @tomorrowevening/theatre-studio into the bundle and export the project's state. Learn how to do that at https://www.theatrejs.com/docs/latest/manual/projects#state
`
            );
        }, 1e3);
      }
      attachToStudio(g) {
        if (this._studio) {
          if (this._studio !== g)
            throw new Error(
              "Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId)
            );
          console.warn(
            "Project ".concat(this.address.projectId, " is already attached to studio ").concat(this._studio.address.studioId)
          );
          return;
        }
        this._studio = g, g.initialized.then(async () => {
          var S;
          await $F(g, this, this.config.state), this._pointerProxies.historic.setPointer(
            g.atomP.historic.coreByProject[this.address.projectId]
          ), this._pointerProxies.ahistoric.setPointer(
            g.atomP.ahistoric.coreByProject[this.address.projectId]
          ), this._pointerProxies.ephemeral.setPointer(
            g.atomP.ephemeral.coreByProject[this.address.projectId]
          ), await g.createAssetStorage(this, (S = this.config.assets) == null ? void 0 : S.baseUrl).then((k) => {
            this.assetStorage = k, this._assetStorageReadyDeferred.resolve(void 0);
          }), this._studioReadyDeferred.resolve(void 0);
        }).catch((S) => {
          throw console.error(S), S;
        });
      }
      get isAttachedToStudio() {
        return !!this._studio;
      }
      get ready() {
        return this._readyPromise;
      }
      isReady() {
        return this._studioReadyDeferred.status === "resolved" && this._assetStorageReadyDeferred.status === "resolved";
      }
      getOrCreateSheet(g, S = "default") {
        let k = this._sheetTemplates.get()[g];
        return k || (k = new s1(this, g), this._sheetTemplates.reduce((z) => j(I({}, z), { [g]: k }))), k.getInstance(S);
      }
    }, ek = (g, S, k) => {
      if (typeof g != "string")
        return "".concat(S, " must be a string. ").concat(gs(g), " given.");
      if (g.trim().length !== g.length)
        return "".concat(S, " must not have leading or trailing spaces. '").concat(g, "' given.");
      if (g.length < k[0] || g.length > k[1])
        return "".concat(S, " must have between ").concat(k[0], " and ").concat(k[1], " characters. '").concat(g, "' given.");
    }, tk = (g, S, k = !1) => {
      const z = ek(g, S, [3, 32]);
      if (typeof z == "string" && k)
        throw new yr(z);
      return z;
    }, KF = (g, S, k = !1) => {
      const z = ek(g, S, [1, 32]);
      if (typeof z == "string" && k)
        throw new yr(z);
      return z;
    }, YF = class {
      get type() {
        return "Theatre_Project_PublicAPI";
      }
      /**
       * @internal
       */
      constructor(g, S = {}) {
        st(this, new WF(g, S, this));
      }
      get ready() {
        return Tt(this).ready;
      }
      get isReady() {
        return Tt(this).isReady();
      }
      get address() {
        return I({}, Tt(this).address);
      }
      getAssetUrl(g) {
        if (!this.isReady) {
          console.error(
            "Calling `project.getAssetUrl()` before `project.ready` is resolved, will always return `undefined`. Either use `project.ready.then(() => project.getAssetUrl())` or `await project.ready` before calling `project.getAssetUrl()`."
          );
          return;
        }
        return g.id ? Tt(this).assetStorage.getAssetUrl(g.id) : void 0;
      }
      sheet(g, S = "default") {
        const k = r0(
          g,
          "project.sheet"
        );
        return process.env.NODE_ENV !== "production" && KF(
          S,
          "instanceId in project.sheet(sheetId, instanceId)",
          !0
        ), Tt(this).getOrCreateSheet(
          k,
          S
        ).publicApi;
      }
    }, nk = re(Fe()), rk = ut(), g1 = ut();
    function y1(g, S = {}) {
      const k = Ct.get(g);
      if (k) {
        if (process.env.NODE_ENV !== "production" && !(0, nk.default)(S, k.config))
          throw new Error(
            'You seem to have called Theatre.getProject("'.concat(g, '", config) twice, with different config objects. ') + `This is disallowed because changing the config of a project on the fly can lead to hard-to-debug issues.

You can fix this by either calling Theatre.getProject() once per projectId, or calling it multiple times but with the exact same config.`
          );
        return k.publicApi;
      }
      const X = m1().named("Project", g);
      return process.env.NODE_ENV !== "production" && (tk(g, "projectName in Theatre.getProject(projectName)", !0), XF(g), X._debug("validated projectName", { projectName: g })), S.state ? process.env.NODE_ENV !== "production" ? (y0(g, S.state), X._debug("shallow validated config.state on disk")) : (ik(g, S.state), X._debug("deep validated config.state on disk")) : X._debug("no config.state"), new YF(g, S);
    }
    var y0 = (g, S) => {
      if (Array.isArray(S) || S == null || S.definitionVersion !== g0.currentProjectStateDefinitionVersion)
        throw new yr(
          "Error validating conf.state in Theatre.getProject(".concat(JSON.stringify(
            g
          ), ", conf). The state seems to be formatted in a way that is unreadable to Theatre.js. Read more at https://www.theatrejs.com/docs/latest/manual/projects#state")
        );
    }, ik = (g, S) => {
      y0(g, S);
    }, XF = (g) => {
      if (typeof g != "string")
        throw new yr(
          "Argument 'projectId' in `Theatre.getProject(projectId, ...)` must be a string. Instead, it was ".concat(gs(
            g
          ), ".")
        );
      const S = g.trim();
      if (S.length !== g.length)
        throw new yr(
          "Argument 'projectId' in `Theatre.getProject(\"".concat(g, '", ...)` should not have surrounding whitespace.')
        );
      if (S.length < 3)
        throw new yr(
          "Argument 'projectId' in `Theatre.getProject(\"".concat(g, '", ...)` should be at least 3 characters long.')
        );
    };
    function v1(g, S, k) {
      const z = k ? Tt(k).ticker : t0();
      if ((0, rk.isPointer)(g))
        return (0, g1.pointerToPrism)(g).onChange(z, S, !0);
      if ((0, g1.isPrism)(g))
        return g.onChange(z, S, !0);
      throw new Error(
        "Called onChange(p) where p is neither a pointer nor a prism."
      );
    }
    function b1(g) {
      if ((0, rk.isPointer)(g))
        return (0, g1.pointerToPrism)(g).getValue();
      throw new Error("Called val(p) where p is not a pointer.");
    }
    var QF = class {
      constructor() {
        J(this, "_studio");
      }
      get type() {
        return "Theatre_CoreBundle";
      }
      get version() {
        return "1.0.19";
      }
      getBitsForStudio(g, S) {
        if (this._studio)
          throw new Error("@tomorrowevening/theatre-core is already attached to @tomorrowevening/theatre-studio");
        this._studio = g;
        const k = {
          projectsP: Ct.atom.pointer.projects,
          privateAPI: Tt,
          coreExports: $,
          getCoreRafDriver: Z_
        };
        S(k);
      }
    };
    sk();
    function sk() {
      if (typeof window > "u")
        return;
      const g = (
        // @ts-ignore ignore
        window[qf]
      );
      if (typeof g < "u")
        throw typeof g == "object" && g && typeof g.version == "string" ? new Error(
          `It seems that the module '@tomorrowevening/theatre-core' is loaded more than once. This could have two possible causes:
1. You might have two separate versions of Theatre.js in node_modules.
2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.

Note that it **is okay** to import '@tomorrowevening/theatre-core' multiple times. But those imports should point to the same module.`
        ) : new Error(
          "The variable window.".concat(qf, " seems to be already set by a module other than @tomorrowevening/theatre-core.")
        );
      const S = new QF();
      window[qf] = S;
      const k = (
        // @ts-ignore ignore
        window[X_]
      );
      k && k !== null && k.type === "Theatre_StudioBundle" && k.registerCoreBundle(S);
    }
    /*! Bundled license information:
    
    		lodash-es/lodash.js:
    		  (**
    		   * @license
    		   * Lodash (Custom Build) <https://lodash.com/>
    		   * Build: `lodash modularize exports="es" -o ./`
    		   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
    		   * Released under MIT license <https://lodash.com/license>
    		   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    		   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    		   *)
    		*/
  }(Jw, Jw.exports)), Jw.exports;
}
var En = zge();
let Yv;
function OUe() {
  const [c, e] = nr(Yv);
  return Pg(() => {
    Yv || Promise.resolve().then(() => EUe).then((t) => {
      Yv = t.default, Yv.initialize(), Yv.ui.hide(), e(Yv);
    });
  }, []), c;
}
async function DUe() {
  for (; !document.getElementById("theatrejs-studio-root"); )
    await new Promise((n) => setTimeout(n, 100));
  const c = document.getElementById("theatrejs-studio-root");
  if (c === null || c.shadowRoot === null) return;
  const e = c.shadowRoot.getElementById("pointer-root");
  if (e === null) return;
  const t = e.children[0];
  if (t !== null) {
    try {
      const i = t.children[1].children[1];
      i.parentElement?.removeChild(i);
    } catch {
    }
    try {
      const n = t.children[3];
      n.style.top = "0", n.style.right = "300px";
    } catch {
    }
  }
}
function FUe(c, e, t, n) {
  n.sheetObject(c, e, {
    transform: {
      position: {
        x: t.position.x,
        y: t.position.y,
        z: t.position.z
      },
      rotation: {
        x: t.rotation.x,
        y: t.rotation.y,
        z: t.rotation.z
      },
      scale: {
        x: t.scale.x,
        y: t.scale.y,
        z: t.scale.z
      },
      visible: t.visible
    }
  }, (i) => {
    const o = i.transform;
    t.position.copy(o.position), t.rotation.copy(o.rotation), t.scale.copy(o.scale), t.visible = o.visible;
  });
}
const Ake = [
  "allowOverride",
  "alphaHash",
  "alphaTest",
  "alphaToCoverage",
  "blendAlpha",
  "blendColor",
  "blendDst",
  "blendDstAlpha",
  "blendEquation",
  "blendEquationAlpha",
  "blendSrc",
  "blendSrcAlpha",
  "blending",
  "clipIntersection",
  "clipShadows",
  "clipping",
  "clippingPlanes",
  "colorWrite",
  "combine",
  "defaultAttributeValues",
  "defines",
  "depthFunc",
  "depthTest",
  "depthWrite",
  "dithering",
  "extensions",
  "fog",
  "forceSinglePass",
  "fragmentShader",
  "glslVersion",
  "id",
  "index0AttributeName",
  "index1AttributeName",
  "index2AttributeName",
  "index3AttributeName",
  "index4AttributeName",
  "isMaterial",
  "lights",
  "linewidth",
  "name",
  "needsUpdate",
  "polygonOffset",
  "polygonOffsetFactor",
  "polygonOffsetUnits",
  "precision",
  "premultipliedAlpha",
  "shadowSide",
  "side",
  "stencilFail",
  "stencilFunc",
  "stencilFuncMask",
  "stencilRef",
  "stencilWrite",
  "stencilWriteMask",
  "stencilZFail",
  "stencilZPass",
  "toneMapped",
  "transparent",
  "type",
  "uniformsGroups",
  "uniformsNeedUpdate",
  "userData",
  "uuid",
  "version",
  "vertexColors",
  "vertexShader",
  "visible",
  "wireframe",
  "wireframeLinewidth",
  "wireframeLinecap",
  "wireframeLinejoin"
];
function Bpe(c) {
  const e = typeof c;
  if (c === null || c.isTexture)
    return "texture";
  if (e === "boolean")
    return "boolean";
  if (e === "number")
    return "number";
  if (e === "string")
    return "string";
  if (e === "object") {
    if (c.isColor)
      return "color";
    if (c.isVector2)
      return "vector2";
    if (c.isVector3)
      return "vector3";
    if (c.isVector4)
      return "vector4";
    if (c.isMatrix2)
      return "matrix2";
    if (c.isMatrix3)
      return "matrix3";
    if (c.isMatrix4)
      return "matrix4";
    if (c.isEuler)
      return "euler";
    if (Array.isArray(c))
      return "array";
  }
  return "object";
}
function kke(c) {
  const e = [];
  for (const n in c) {
    const i = Ake.find((p) => p === n), o = n.indexOf("_") === 0 || n.indexOf("is") === 0;
    if (!(i || o))
      if (n === "uniforms") {
        const p = c.uniforms;
        for (const f in p) {
          const v = p[f].value, _ = Bpe(v);
          _ === "array" || _ === "object" || e.push({
            name: `uniforms.${f}.value`,
            type: _,
            value: v
          });
        }
      } else {
        const p = Bpe(c[n]);
        e.push({
          name: n,
          type: p,
          value: c[n]
        });
      }
  }
  return e.filter(
    (n) => n.type !== "array" && n.type !== "object" && n.type !== "texture"
  );
}
function Mke(c) {
  const e = {}, t = { nudgeMultiplier: 0.01 };
  return c.forEach((n) => {
    let i = n.value;
    switch (n.type) {
      case "color":
        i = En.types.rgba({ r: i.r, g: i.g, b: i.b, a: 1 });
        break;
      case "number":
        i = En.types.number(i, t);
        break;
      case "euler":
      case "vector3":
        i = {
          x: En.types.number(i.x, t),
          y: En.types.number(i.y, t),
          z: En.types.number(i.z, t)
        };
        break;
      case "vector2":
        i = {
          x: En.types.number(i.x, t),
          y: En.types.number(i.y, t)
        };
        break;
      case "vector4":
        i = {
          x: En.types.number(i.x, t),
          y: En.types.number(i.y, t),
          z: En.types.number(i.z, t),
          w: En.types.number(i.w, t)
        };
        break;
      case "matrix2":
        i = {
          0: En.types.number(i.elements[0], t),
          1: En.types.number(i.elements[1], t),
          2: En.types.number(i.elements[2], t),
          3: En.types.number(i.elements[3], t)
        };
        break;
      case "matrix3":
        i = {
          0: En.types.number(i.elements[0], t),
          1: En.types.number(i.elements[1], t),
          2: En.types.number(i.elements[2], t),
          3: En.types.number(i.elements[3], t),
          4: En.types.number(i.elements[4], t),
          5: En.types.number(i.elements[5], t),
          6: En.types.number(i.elements[6], t),
          7: En.types.number(i.elements[7], t),
          8: En.types.number(i.elements[8], t)
        };
        break;
      case "matrix4":
        i = {
          0: En.types.number(i.elements[0], t),
          1: En.types.number(i.elements[1], t),
          2: En.types.number(i.elements[2], t),
          3: En.types.number(i.elements[3], t),
          4: En.types.number(i.elements[4], t),
          5: En.types.number(i.elements[5], t),
          6: En.types.number(i.elements[6], t),
          7: En.types.number(i.elements[7], t),
          8: En.types.number(i.elements[8], t),
          9: En.types.number(i.elements[9], t),
          10: En.types.number(i.elements[10], t),
          11: En.types.number(i.elements[11], t),
          12: En.types.number(i.elements[12], t),
          13: En.types.number(i.elements[13], t),
          14: En.types.number(i.elements[14], t),
          15: En.types.number(i.elements[15], t)
        };
        break;
    }
    if (n.name.includes(".")) {
      const o = n.name.split(".");
      let l = e;
      for (let p = 0; p < o.length - 1; p++) {
        const f = o[p];
        l[f] || (l[f] = {}), l = l[f];
      }
      l[o[o.length - 1]] = i;
    } else
      e[n.name] = i;
  }), e;
}
function Rke(c, e, t) {
  e.forEach((n) => {
    if (c[n.name] !== void 0)
      switch (n.type) {
        case "boolean":
        case "number":
          c[n.name] = t.material[n.name];
          break;
        case "color":
        case "euler":
        case "matrix2":
        case "matrix3":
        case "matrix4":
        case "vector2":
        case "vector3":
        case "vector4":
          c[n.name].copy(t.material[n.name]);
          break;
      }
  });
}
function BUe(c, e, t, n) {
  if (!t.isMaterial) return;
  const i = kke(t), o = Mke(i);
  n.sheetObject(c, e, {
    material: o
  }, (l) => {
    Rke(t, i, l);
  });
}
const E6 = new Qp();
E6.setAttribute("position", new bc([-0.5, -0.5, 0, 1.5, -0.5, 0, -0.5, 1.5, 0], 3));
E6.setAttribute("normal", new bc([0, 0, 1, 0, 0, 1], 3));
E6.setAttribute("uv", new bc([0, 0, 2, 0, 0, 2], 2));
const LUe = new SO(-0.5, 0.5, 0.5, -0.5, 0, 100), Lpe = (c) => {
  c?.dispose();
}, Vge = (c) => {
  if (c)
    if (Array.isArray(c))
      c.forEach((e) => Vge(e));
    else {
      for (const e in c) {
        const t = c[e];
        t !== null && t instanceof IV && Lpe(t);
      }
      if (c.isShaderMaterial === !0) {
        const e = c;
        for (const t in e.uniforms) {
          const n = e.uniforms[t];
          n.value !== null && n.value instanceof IV && Lpe(n.value);
        }
      }
      c.dispose();
    }
}, Hd = (c) => {
  if (c) {
    for (; c.children.length > 0; ) {
      const e = c.children[0];
      e.type === "Audio" ? (e.pause(), e.parent && e.parent.remove(e)) : Hd(e);
    }
    if (c.parent && c.parent.remove(c), c.isMesh) {
      const e = c;
      e.geometry?.dispose(), Vge(e.material);
    }
    c.dispose !== void 0 && c.dispose();
  }
};
let DV = 0;
const jpe = () => {
  DV = 0;
}, FV = (c) => {
  if (!c) return;
  let e = c.name.replaceAll(" ", "").replaceAll("/", ".");
  if (e.length === 0 && (e = `obj_${DV}`, DV++), c.parent !== null && c.parent.uuid.length > 0 && (e = `${c.parent.uuid}.${e}`), c.uuid = e, c.isMesh !== void 0) {
    const t = c;
    if (Array.isArray(t.material))
      t.material.forEach((n, i) => {
        n.uuid = `${e}.material.${i}`;
      });
    else {
      const n = t.material;
      n.uuid = `${e}.material`;
    }
  }
  c.children.forEach((t) => FV(t));
};
class Sg {
  static renderer;
  static canvas;
  static context = null;
  static scene = null;
  static camera = null;
  static material = null;
  static inited = !1;
  static width = 100;
  static height = 100;
  static init() {
    this.inited || (this.canvas = document.createElement("canvas"), this.canvas.width = this.width, this.canvas.height = this.height, this.context = this.canvas.getContext("2d"), this.inited = !0);
  }
  static renderToBlob(e) {
    this.init();
    const t = e.repeat.clone(), n = e.offset.clone();
    if (e.repeat.set(1, 1), e.offset.set(0, 0), this.context !== null) {
      this.context.clearRect(0, 0, this.width, this.height);
      const i = e.image;
      if (i != null && i.width > 0) {
        this.canvas.title = e.sourceFile;
        const o = this.canvas.width / i.width, l = this.renderToCanvas(e);
        this.context.drawImage(l, 0, 0, i.width * o, i.height * o);
      }
    }
    return e.repeat.copy(t), e.offset.copy(n), this.canvas.toDataURL("image/png");
  }
  static renderToCanvas(e) {
    if (this.material === null) {
      this.camera = new SO(-0.5, 0.5, 0.5, -0.5, 0, 100), this.scene = new _ge(), this.material = new Tg();
      const t = new Qp();
      t.setAttribute("position", new bc([-0.5, -0.5, 0, 1.5, -0.5, 0, -0.5, 1.5, 0], 3)), t.setAttribute("normal", new bc([0, 0, 1, 0, 0, 1], 3)), t.setAttribute("uv", new bc([0, 0, 2, 0, 0, 2], 2));
      const n = new Dt(t, this.material);
      this.scene.add(n);
    }
    if (e.isRenderTargetTexture)
      this.material.map = e, this.renderer.render(this.scene, this.camera);
    else {
      const t = this.renderer.outputColorSpace, n = e.colorSpace;
      this.renderer.outputColorSpace = xE, e.colorSpace = xE, this.material.map = e, this.renderer.render(this.scene, this.camera), this.renderer.outputColorSpace = t, e.colorSpace = n;
    }
    return this.renderer.domElement;
  }
}
function jUe(c) {
  return new Promise((e) => {
    const t = new CAe();
    t.parseAsync(c.scene).then((n) => {
      const i = new PAe(n);
      if (c.animations.length > 0) {
        const l = c.animations.map((f) => AAe.parse(f));
        i.clipAction(l[0]).play(), i.getRoot().animations = c.animations, i.getRoot().mixer = i;
      }
      const o = [];
      c.cameras && c.cameras.length > 0 && c.cameras.forEach((l) => {
        const p = t.parse(l);
        o.push(p);
      }), e({
        animations: c.animations,
        model: n,
        mixer: i,
        cameras: o
      });
    });
  });
}
const UUe = (c, e, t, n) => {
  c.setRenderTarget(n), c.clear(), c.render(e, t);
};
function Ike(c, e, t, n) {
  c.applyMatrix4(new IE().makeTranslation(e, -t, -n));
}
function zUe(c) {
  c.computeBoundingBox();
  const e = c.boundingBox, t = (e.max.x - e.min.x) / 2, n = (e.max.y - e.min.y) / 2;
  Ike(c, t, n, 0);
}
function VUe(c, e, t) {
  c.left = e / -2, c.right = e / 2, c.top = t / 2, c.bottom = t / -2, c.position.x = e / 2, c.position.y = t / -2, c.updateProjectionMatrix();
}
function GUe(c, e, t) {
  const n = 1.7777777777777777, i = e / t;
  let o = e, l = t;
  i > n ? o = t * n : l = e / n, c.left = o / -2, c.right = o / 2, c.top = l / 2, c.bottom = l / -2, c.updateProjectionMatrix();
}
function qUe() {
  let e = "transferControlToOffscreen" in document.createElement("canvas");
  if (/^((?!chrome|android).)*safari/i.test(navigator.userAgent)) {
    const n = navigator.userAgent.match(/version\/(\d+)/i);
    e = (n ? parseInt(n[1]) : 0) >= 17;
  }
  return e;
}
function HUe(c, e, t = !0, n = !1) {
  c.renderOrder = -e;
  const i = c.material;
  Array.isArray(i) ? i.forEach((o) => {
    o.colorWrite = t, o.depthWrite = n, o.stencilWrite = !0, o.stencilRef = e, o.stencilFunc = wpe, o.stencilFail = Wv, o.stencilZFail = Wv, o.stencilZPass = Wv;
  }) : (i.colorWrite = t, i.depthWrite = n, i.stencilWrite = !0, i.stencilRef = e, i.stencilFunc = wpe, i.stencilFail = Wv, i.stencilZFail = Wv, i.stencilZPass = Wv);
}
function $Ue(c, e, t = !1) {
  const n = c.material;
  Array.isArray(n) ? n.forEach((i) => {
    i.stencilWrite = !0, i.stencilRef = e, i.stencilFunc = t ? Epe : Tpe, i.stencilFail = Kv, i.stencilZFail = Kv, i.stencilZPass = Kv;
  }) : (n.stencilWrite = !0, n.stencilRef = e, n.stencilFunc = t ? Epe : Tpe, n.stencilFail = Kv, n.stencilZFail = Kv, n.stencilZPass = Kv);
}
function WUe(c) {
  c.blending = Sge, c.blendEquation = NE, c.blendSrc = $O, c.blendDst = WO, c.needsUpdate = !0;
}
function KUe(c) {
  c.blending = KO, c.blendEquation = NE, c.blendSrc = $O, c.blendDst = YO, c.needsUpdate = !0;
}
function YUe(c) {
  c.blending = KO, c.blendEquation = NE, c.blendSrc = x6, c.blendDst = WO, c.needsUpdate = !0;
}
function XUe(c) {
  c.blending = KO, c.blendEquation = NE, c.blendSrc = _6, c.blendDst = YO, c.needsUpdate = !0;
}
let BV = [];
function Nke(c, e, t = !0) {
  Sg.renderer = e.renderer;
  const n = [];
  n.push({
    type: "boolean",
    prop: "Enabled",
    value: c.enabled
  });
  let i = (l, p) => {
    console.log("Default Handle Pass:", l, p);
  };
  if (c.name === "EffectPass")
    c.effects.forEach((l) => {
      l.uniforms.size > 0 && l.uniforms.forEach((p, f) => {
        if (f === "map") return;
        const v = `${l.name.replace("Effect", "")} ${f}`;
        if (p.value === null && t)
          n.push({
            prop: f,
            title: v,
            type: "image",
            value: {
              offset: [0, 0],
              repeat: [1, 1],
              src: ""
            }
          });
        else if (p.value.isTexture && t) {
          const _ = p.value, E = Sg.renderToBlob(_);
          n.push({
            prop: f,
            title: v,
            type: "image",
            value: {
              offset: [_.offset.x, _.offset.y],
              repeat: [_.repeat.x, _.repeat.y],
              src: E
            }
          });
        } else typeof p.value == "number" ? n.push({
          prop: f,
          title: v,
          type: "number",
          value: p.value,
          step: 0.01
        }) : typeof p.value == "string" ? n.push({
          prop: f,
          title: v,
          type: "string",
          value: p.value
        }) : typeof p.value == "boolean" && n.push({
          prop: f,
          title: v,
          type: "boolean",
          value: p.value
        });
      });
    }), i = (l, p) => {
      c.effects.forEach((f) => {
        f.uniforms.size > 0 && f.uniforms.forEach((v, _) => {
          _ === l && (v.value = p);
        });
      });
    };
  else if (c.name === "ShaderPass") {
    const l = c.fullscreenMaterial;
    for (const p in l.uniforms) {
      if (p === "inputBuffer" || p === "map") continue;
      const f = l.uniforms[p], v = `${l.name.replace("Material", "")} ${p}`;
      if (f.value === null && t)
        n.push({
          title: v,
          prop: p,
          type: "image",
          value: {
            offset: [0, 0],
            repeat: [1, 1],
            src: ""
          }
        });
      else if (f.value.isTexture && t) {
        const _ = f.value, E = Sg.renderToBlob(_);
        n.push({
          title: v,
          prop: p,
          type: "image",
          value: {
            offset: [_.offset.x, _.offset.y],
            repeat: [_.repeat.x, _.repeat.y],
            src: E
          }
        });
      } else typeof f.value == "number" ? n.push({
        title: v,
        prop: p,
        type: "number",
        value: f.value,
        step: 0.01
      }) : typeof f.value == "string" ? n.push({
        title: v,
        prop: p,
        type: "string",
        value: f.value
      }) : typeof f.value == "boolean" && n.push({
        title: v,
        prop: p,
        type: "boolean",
        value: f.value
      });
    }
    i = (p, f) => {
      const v = l.uniforms[p];
      v.value = f;
    };
  } else
    return;
  const o = `${c.name}: ${c.scene.name}`;
  e.addGroup({
    title: o,
    items: n,
    onUpdate: (l, p) => {
      l === "Enabled" ? c.enabled = p : i(l, p);
    }
  }), BV.push(o);
}
function QUe(c, e) {
  c.passes.forEach((t) => {
    Nke(t, e);
  });
}
function ZUe(c) {
  BV.forEach((e) => {
    c.removeGroup(e);
  }), BV = [];
}
function JUe(c, e, t, n = 1024) {
  return new Promise((i) => {
    const o = e.aspect, l = e.fov, p = e.rotation.clone(), f = t.outputBuffer;
    e.aspect = 1, e.fov = 90, e.updateProjectionMatrix();
    const v = new wge(n, n, {
      format: kAe,
      depthBuffer: !0,
      stencilBuffer: !1
    });
    t.outputBuffer = v, Xv(c, v, e, "nx", t, n).then(() => {
      Xv(c, v, e, "ny", t, n).then(() => {
        Xv(c, v, e, "nz", t, n).then(() => {
          Xv(c, v, e, "px", t, n).then(() => {
            Xv(c, v, e, "py", t, n).then(() => {
              Xv(c, v, e, "pz", t, n).then(() => {
                e.aspect = o, e.fov = l, e.rotation.copy(p), e.updateMatrixWorld(), e.updateProjectionMatrix(), t.outputBuffer = f, v.dispose(), i();
              });
            });
          });
        });
      });
    });
  });
}
function Xv(c, e, t, n, i, o) {
  return new Promise((l) => {
    const p = Math.PI / 2;
    switch (n) {
      case "nx":
        t.rotation.set(0, -p, 0);
        break;
      case "ny":
        t.rotation.set(-p, 0, Math.PI);
        break;
      case "nz":
        t.rotation.set(0, 0, 0);
        break;
      case "px":
        t.rotation.set(0, p, 0);
        break;
      case "py":
        t.rotation.set(p, 0, Math.PI);
        break;
      case "pz":
        t.rotation.set(0, Math.PI, 0);
        break;
    }
    t.updateMatrixWorld(), i.render();
    const f = new Uint8Array(o * o * 4);
    c.readRenderTargetPixels(e, 0, 0, o, o, f);
    const v = document.createElement("canvas");
    v.width = v.height = o;
    const _ = v.getContext("2d"), E = _.createImageData(o, o);
    E.data.set(f), _.putImageData(E, 0, 0);
    const A = document.createElement("canvas");
    A.width = A.height = o;
    const I = A.getContext("2d");
    I.translate(0, o), I.scale(1, -1), I.drawImage(v, 0, 0);
    const j = A.toDataURL("image/png"), q = document.createElement("a");
    q.href = j, q.download = `${t.name}_${n}.png`, document.body.appendChild(q), q.click(), q.remove(), l();
  });
}
const Qv = T6([
  "ctrlKey",
  "metaKey",
  "shiftKey",
  "button",
  "pointerId",
  "pointerType",
  "clientX",
  "clientY",
  "pageX",
  "pageY"
]), Oke = T6([
  "clientX",
  "clientY",
  "deltaX",
  "deltaY",
  "deltaMode"
]), Dke = T6([
  "ctrlKey",
  "metaKey",
  "shiftKey",
  "keyCode"
]);
function Fke(c, e) {
  c.preventDefault(), Oke(c, e);
}
function Bke(c) {
  c.preventDefault();
}
function Lke(c, e, t) {
  for (const n of e)
    t[n] = c[n];
}
function T6(c) {
  return function(t, n) {
    const i = { type: t.type };
    Lke(t, c, i), n(i);
  };
}
function o5(c, e) {
  const t = [], n = { type: c.type, touches: t };
  for (let i = 0; i < c.touches.length; ++i) {
    const o = c.touches[i];
    t.push({
      pageX: o.pageX,
      pageY: o.pageY
    });
  }
  e(n);
}
const jke = {
  37: !0,
  // left
  38: !0,
  // up
  39: !0,
  // right
  40: !0
  // down
};
function Uke(c, e) {
  const { keyCode: t } = c;
  jke[t] && (c.preventDefault(), Dke(c, e));
}
const eze = {
  contextmenu: Bke,
  mousedown: Qv,
  mousemove: Qv,
  mouseup: Qv,
  pointerdown: Qv,
  pointermove: Qv,
  pointerup: Qv,
  touchstart: o5,
  touchmove: o5,
  touchend: o5,
  wheel: Fke,
  keydown: Uke
};
let zke = 0;
class tze {
  id;
  worker;
  constructor(e, t, n) {
    this.id = zke++, this.worker = t;
    const i = (l) => {
      this.worker.postMessage({
        type: "event",
        id: this.id,
        data: l
      });
    };
    t.postMessage({
      type: "makeProxy",
      id: this.id
    });
    for (const [l, p] of Object.entries(n))
      e.addEventListener(l, (f) => {
        p(f, i);
      });
    function o() {
      i({
        type: "resize",
        left: 0,
        top: 0,
        width: innerWidth,
        height: innerHeight
      });
    }
    window.addEventListener("resize", o), o();
  }
}
class Vke extends Ege {
  style = {};
  left = 0;
  top = 0;
  width = 0;
  height = 0;
  ownerDocument = void 0;
  constructor() {
    super(), this.ownerDocument = this;
  }
  get clientWidth() {
    return this.width;
  }
  set clientWidth(e) {
    this.width = e;
  }
  get clientHeight() {
    return this.height;
  }
  set clientHeight(e) {
    this.height = e;
  }
  // OrbitControls call these as of r132. Implementing as no-ops
  setPointerCapture() {
  }
  releasePointerCapture() {
  }
  getBoundingClientRect() {
    return {
      x: this.left,
      y: this.top,
      left: this.left,
      top: this.top,
      width: this.width,
      height: this.height,
      right: this.left + this.width,
      bottom: this.top + this.height,
      toJSON: () => ({})
      // Satisfies the DOMRect interface
    };
  }
  handleEvent(e) {
    if (e.type === "size") {
      this.left = e.left, this.top = e.top, this.width = e.width, this.height = e.height;
      return;
    }
    e.preventDefault = wO, e.stopPropagation = wO, this.dispatchEvent(e);
  }
  focus() {
  }
  getRootNode() {
    return this;
  }
}
class nze {
  targets = {};
  constructor() {
    this.handleEvent = this.handleEvent.bind(this);
  }
  makeProxy(e) {
    const { id: t } = e, n = new Vke();
    this.targets[t] = n;
  }
  getProxy(e) {
    return this.targets[e];
  }
  handleEvent(e) {
    this.targets[e.id]?.handleEvent(e.data);
  }
}
class rze {
  assets = {
    audio: /* @__PURE__ */ new Map(),
    image: /* @__PURE__ */ new Map(),
    json: /* @__PURE__ */ new Map(),
    model: /* @__PURE__ */ new Map(),
    video: /* @__PURE__ */ new Map()
  };
  components = /* @__PURE__ */ new Map();
  settings = {
    dpr: 1,
    fps: 30,
    width: 0,
    height: 0,
    mobile: !1,
    supportOffScreenCanvas: !1,
    supportWebGPU: !1,
    quality: "Low",
    dev: !1,
    editor: !1
  };
  onUpdateCallback;
  // Protected
  playing = !1;
  rafID = -1;
  dispose() {
    this.pause(), this.components.forEach((e) => e.dispose()), this.components.clear();
  }
  detectSettings(e = !1, t = !1) {
    return new Promise((n) => {
      Ske(e, t).then((i) => {
        this.settings = i, n();
      });
    });
  }
  // Playback
  update() {
  }
  draw() {
  }
  play = () => {
    this.playing || (this.playing = !0, this.onUpdate());
  };
  pause = () => {
    this.playing && (this.playing = !1, cancelAnimationFrame(this.rafID), this.rafID = -1);
  };
  onUpdate = () => {
    this.update(), this.isApp && this.draw(), this.onUpdateCallback && this.onUpdateCallback(), this.rafID = requestAnimationFrame(this.onUpdate);
  };
  // Remote Components
  addComponent(e, t) {
    this.components.set(e, t);
  }
  // Getters
  get debugEnabled() {
    return this.settings.dev;
  }
  get isApp() {
    return !this.editor;
  }
  set isApp(e) {
    this.editor = !e;
  }
  get editor() {
    return this.settings.editor;
  }
  set editor(e) {
    this.settings.editor = e;
  }
}
class Gge {
  name;
  _debug = !1;
  _editor = !1;
  broadcastChannel;
  constructor(e, t = !1, n = !1) {
    this.name = e, this._debug = t, this._editor = n, t && (this.broadcastChannel = new BroadcastChannel(e), this.broadcastChannel.addEventListener("message", this.messageHandler.bind(this)));
  }
  dispose() {
    this.broadcastChannel?.removeEventListener("message", this.messageHandler.bind(this)), this.broadcastChannel?.close();
  }
  get debug() {
    return this._debug;
  }
  get editor() {
    return this._editor;
  }
  // Broadcast
  send(e) {
    if (this.editor && e.target === "app" || !this.editor && e.target === "editor")
      try {
        this.broadcastChannel?.postMessage(e);
      } catch (n) {
        console.log("Hermes - Error sending message:"), console.log(n), console.log(e);
      }
  }
  messageHandler(e) {
    const t = e.data;
    t.target === "app" ? this.handleApp(t) : this.handleEditor(t);
  }
  handleApp(e) {
  }
  handleEditor(e) {
  }
}
function Gke(c, e, t, n, i) {
  const o = 1 - c;
  return o * o * o * e + 3 * o * o * c * t + 3 * o * c * c * n + c * c * c * i;
}
function qke(c, e, t) {
  if (c.type !== "bezier" || c.handles.length !== 4)
    throw new Error("Invalid keyframe data for Bzier interpolation.");
  const [n, i] = c.handles, o = (t - c.position) / (e.position - c.position);
  return Gke(
    o,
    c.value,
    c.value + n,
    e.value + i,
    e.value
  );
}
class ize extends Gge {
  project;
  sheets = /* @__PURE__ */ new Map();
  sheetObjects = /* @__PURE__ */ new Map();
  sheetObjectCBs = /* @__PURE__ */ new Map();
  sheetObjectUnsubscribe = /* @__PURE__ */ new Map();
  activeSheet;
  studio = void 0;
  constructor(e = !1, t = !1) {
    super("RemoteTheatre", e, t);
  }
  dispose() {
    this.project = void 0, this.sheets = /* @__PURE__ */ new Map(), this.sheetObjects = /* @__PURE__ */ new Map(), this.sheetObjectCBs = /* @__PURE__ */ new Map(), this.sheetObjectUnsubscribe = /* @__PURE__ */ new Map();
  }
  loadProject(e, t) {
    return console.log(e, t), this.project = En.getProject(e, { state: t }), new Promise((n, i) => {
      this.project?.ready.then(() => {
        if (t) {
          const o = t.sheetsById;
          console.log("loaded sheets", o);
          for (const l in o) this.sheet(l);
        }
        n();
      }).catch(() => i());
    });
  }
  getSheetInstance(e, t) {
    return t !== void 0 ? `${e}-${t}` : e;
  }
  sheet(e, t) {
    if (this.project === void 0) {
      console.error("Theatre Project hasn't been created yet.");
      return;
    }
    const n = this.getSheetInstance(e, t);
    let i = this.sheets.get(n);
    return i !== void 0 || (i = this.project?.sheet(e, t), this.sheets.set(n, i)), i;
  }
  playSheet(e, t, n) {
    return new Promise((i) => {
      this.sheet(e, n)?.sequence.play(t).then((o) => i(o)), this.send({
        event: "playSheet",
        target: "editor",
        data: {
          sheet: e,
          instance: n,
          value: t
        }
      });
    });
  }
  pauseSheet(e, t) {
    this.sheet(e, t)?.sequence.pause(), this.send({
      event: "pauseSheet",
      target: "editor",
      data: {
        sheet: e,
        instance: t
      }
    });
  }
  clearSheetObjects(e) {
    this.sheetObjects.forEach((t, n) => {
      n.search(`${e}_`) > -1 && this.unsubscribe(t);
    });
  }
  sheetObject(e, t, n, i, o) {
    if (this.project === void 0) {
      console.error("Theatre Project hasn't been created yet.");
      return;
    }
    const l = this.sheet(e, o);
    if (l === void 0) return;
    const f = `${this.getSheetInstance(e, o)}_${t}`;
    let v = this.sheetObjects.get(f), _ = n;
    v !== void 0 && (_ = { ...n, ...v.value }), v = l.object(t, _, { reconfigure: !0 }), this.sheetObjects.set(f, v), this.sheetObjectCBs.set(f, i !== void 0 ? i : wO);
    function E(I, j, q) {
      if (typeof q == "object")
        if (mke(q))
          I[j] = {
            r: q.r,
            g: q.g,
            b: q.b,
            a: q.a
          };
        else
          for (const L in q) {
            const V = q[L];
            typeof V == "object" && E(q, L, V);
          }
    }
    const A = v.onValuesChange((I) => {
      const j = this.sheetObjectCBs.get(f);
      if (this.editor) {
        for (const q in I) {
          const L = I[q];
          typeof L == "object" && E(I, q, L);
        }
        this.send({
          event: "updateSheetObject",
          target: "app",
          data: {
            sheet: e,
            sheetObject: f,
            values: I
          }
        }), j && j(I);
      } else
        j && j(I);
    });
    return this.sheetObjectUnsubscribe.set(f, A), v;
  }
  getSheetObjectKeyframes(e, t, n) {
    const i = this.sheet(e);
    if (i === void 0) return [];
    const o = `${e}_${t}`, l = this.sheetObjects.get(o);
    return l === void 0 ? [] : i.sequence.__experimental_getKeyframes(l.props[n]);
  }
  getSheetObjectVectors(e, t) {
    const n = this.sheet(e);
    if (n === void 0) return [];
    const i = `${e}_${t}`, o = this.sheetObjects.get(i);
    if (o === void 0) return [];
    const l = [], p = n.sequence.__experimental_getKeyframes(o.props.x), f = n.sequence.__experimental_getKeyframes(o.props.y), v = n.sequence.__experimental_getKeyframes(o.props.z), _ = /* @__PURE__ */ new Set();
    return p.forEach((A) => _.add(A.position)), f.forEach((A) => _.add(A.position)), v.forEach((A) => _.add(A.position)), Array.from(_).sort((A, I) => A - I).forEach((A) => {
      const I = (j, q) => {
        const L = j.find((R, J) => R.position <= q && (j[J + 1]?.position || 1 / 0) > q), V = j.find((R) => R.position > q);
        if (!L) return V?.value || 0;
        if (!V || L.position === q) return L.value;
        if (L.type === "bezier")
          return qke(L, V, q);
        const re = (q - L.position) / (V.position - L.position);
        return L.value + re * (V.value - L.value);
      };
      l.push({
        position: A,
        x: I(p, A),
        y: I(f, A),
        z: I(v, A)
      });
    }), l;
  }
  update(e) {
  }
  unsubscribe(e) {
    if (this.project === void 0) {
      console.error("Theatre Project hasn't been created yet.");
      return;
    }
    const t = e.address.sheetId, n = e.address.objectKey;
    this.sheets.get(t)?.detachObject(n);
    const o = `${t}_${n}`, l = this.sheetObjectUnsubscribe.get(o);
    l !== void 0 && (this.sheetObjects.delete(o), this.sheetObjectCBs.delete(o), this.sheetObjectUnsubscribe.delete(o), l());
  }
  handleApp(e) {
    let t;
    switch (e.event) {
      case "setSheet":
        t = this.sheets.get(e.data.sheet), t !== void 0 ? this.studio?.setSelection([t]) : console.log(`Hermes - Can't set Sheet: ${e.data.sheet}`, t);
        break;
      case "setSheetObject":
        t = this.sheetObjects.get(`${e.data.sheet}_${e.data.key}`), t !== void 0 ? this.studio?.setSelection([t]) : console.log(`Hermes - Can't set Sheet Object: ${e.data.sheet}, ${e.data.key}: ${e.data.sheet}_${e.data.key}`, t);
        break;
      case "updateSheetObject":
        t = this.sheets.get(e.data.sheet), t !== void 0 && t.sequence.pause(), t = this.sheetObjectCBs.get(e.data.sheetObject), t !== void 0 ? t(e.data.values) : console.log(`Hermes - Can't update Sheet Object: ${e.data.sheetObject}, ${e.data.sheet}`, t);
        break;
      case "updateTimeline":
        t = this.sheets.get(e.data.sheet), t !== void 0 ? t.sequence.position = e.data.position : console.log(`Hermes - Can't update sheet position: ${e.data.sheet}, ${e.data.position}`);
        break;
    }
  }
  handleEditor(e) {
    switch (e.event) {
      case "playSheet":
        this.sheet(e.data.sheet, e.data.instance)?.sequence.play(e.data.value);
        break;
      case "pauseSheet":
        this.sheet(e.data.sheet, e.data.instance)?.sequence.pause();
        break;
    }
  }
  getSheetNames() {
    const e = [];
    return this.sheets.forEach((t, n) => {
      e.push(n);
    }), e;
  }
  handleEditorApp() {
    if (this.editor) {
      this.studio?.ui.restore(), this.studio?.onSelectionChange((i) => {
        i.length < 1 || i.forEach((o) => {
          let l = o.address.sheetId, p = "setSheet", f = {};
          switch (o.type) {
            case "Theatre_Sheet_PublicAPI":
              p = "setSheet", f = {
                sheet: o.address.sheetId
              }, this.activeSheet = this.sheets.get(o.address.sheetId);
              break;
            case "Theatre_SheetObject_PublicAPI":
              p = "setSheetObject", l += `_${o.address.objectKey}`, f = {
                id: l,
                sheet: o.address.sheetId,
                key: o.address.objectKey
              }, this.activeSheet = this.sheets.get(o.address.sheetId);
              break;
          }
          this.send({ event: p, target: "app", data: f });
        });
      });
      let e = -1;
      const t = () => {
        if (this.activeSheet !== void 0 && e !== this.activeSheet.sequence.position) {
          e = this.activeSheet.sequence.position;
          const i = this.activeSheet;
          this.send({
            event: "updateTimeline",
            target: "app",
            data: {
              position: e,
              sheet: i.address.sheetId
            }
          });
        }
      }, n = () => {
        t(), requestAnimationFrame(n);
      };
      t(), n();
    } else
      this.studio?.ui.hide();
  }
}
function Hke(c) {
  if (c.name === "cameras")
    return "camera";
  if (c.name === "interactive")
    return "interactive";
  if (c.name === "lights")
    return "light";
  if (c.name === "ui")
    return "ui";
  if (c.name === "utils")
    return "utils";
  const e = c.type;
  return e.search("Helper") > -1 ? "icon_utils" : e.search("Camera") > -1 ? "camera" : e.search("Light") > -1 ? "light" : "obj3D";
}
function xb(c) {
  const e = {
    name: c.name,
    type: c.type,
    uuid: c.uuid,
    children: []
  };
  return c.children.forEach((t) => {
    e.children.push(xb(t));
  }), e;
}
function $ke(c) {
  const e = {};
  for (const t in c) {
    const n = c[t].value;
    e[t] = { value: n }, n === null ? e[t].value = {
      src: "",
      offset: [0, 0],
      repeat: [1, 1]
    } : n !== void 0 && n.isTexture && (e[t].value = {
      src: n.image.src,
      offset: [n.offset.x, n.offset.y],
      repeat: [n.repeat.x, n.repeat.y]
    });
  }
  return e;
}
function Wke(c) {
  switch (c) {
    case "blendSrcAlpha":
    case "blendDstAlpha":
    case "blendEquationAlpha":
    case "clippingPlanes":
    case "shadowSide":
    case "precision":
      return !0;
  }
  return !1;
}
function Zv(c) {
  const e = {};
  for (const t in c) {
    if (t.substring(0, 1) === "_" || t.substring(0, 2) === "is" || Wke(t)) continue;
    const n = typeof c[t], i = c[t];
    switch (n) {
      case "boolean":
      case "number":
      case "string":
        e[t] = i;
        break;
      case "object":
        i !== null ? (e[t] = i, i.isTexture ? e[t] = {
          src: Sg.renderToBlob(i),
          offset: [i.offset.x, i.offset.y],
          repeat: [i.repeat.x, i.repeat.y]
        } : t === "uniforms" && (e[t] = $ke(e[t]))) : t === "glslVersion" ? e[t] = "" : e[t] = {
          src: "",
          offset: [0, 0],
          repeat: [1, 1]
        };
        break;
    }
  }
  return c.anisotropy !== void 0 && (e.anisotropy = c.anisotropy), c.clearcoat !== void 0 && (e.clearcoat = c.clearcoat), c.iridescence !== void 0 && (e.iridescence = c.iridescence), c.dispersion !== void 0 && (e.dispersion = c.dispersion), c.sheen !== void 0 && (e.sheen = c.sheen), c.transmission !== void 0 && (e.transmission = c.transmission), c.transmission !== void 0 && (e.transmission = c.transmission), e;
}
function a5(c) {
  c.updateMatrix();
  const e = {
    name: c.name,
    type: c.type,
    uuid: c.uuid,
    visible: c.visible,
    matrix: c.matrix.elements,
    animations: [],
    material: void 0,
    perspectiveCameraInfo: void 0,
    orthographicCameraInfo: void 0,
    lightInfo: void 0,
    children: []
  };
  c.animations.forEach((n) => {
    e.animations.push({
      name: n.name,
      duration: n.duration,
      blendMode: n.blendMode
    });
  });
  const t = c.type.toLowerCase();
  if (t.search("mesh") > -1) {
    const n = c;
    if (Array.isArray(n.material)) {
      const i = [];
      n.material.forEach((o) => {
        i.push(Zv(o));
      }), e.material = i;
    } else
      e.material = Zv(n.material);
  } else if (t.search("points") > -1) {
    const n = c;
    if (Array.isArray(n.material)) {
      const i = [];
      n.material.forEach((o) => {
        i.push(Zv(o));
      }), e.material = i;
    } else
      e.material = Zv(n.material);
  } else if (t.search("line") > -1) {
    const n = c;
    if (Array.isArray(n.material)) {
      const i = [];
      n.material.forEach((o) => {
        i.push(Zv(o));
      }), e.material = i;
    } else
      e.material = Zv(n.material);
  } else t.search("camera") > -1 ? c.type === "PerspectiveCamera" ? e.perspectiveCameraInfo = {
    fov: c.fov,
    zoom: c.zoom,
    near: c.near,
    far: c.far,
    focus: c.focus,
    aspect: c.aspect,
    filmGauge: c.filmGauge,
    filmOffset: c.filmOffset
  } : c.type === "OrthographicCamera" && (e.orthographicCameraInfo = {
    zoom: c.zoom,
    near: c.near,
    far: c.far,
    left: c.left,
    right: c.right,
    top: c.top,
    bottom: c.bottom
  }) : t.search("light") > -1 && (e.lightInfo = {
    color: c.color,
    intensity: c.intensity,
    decay: c.decay,
    distance: c.distance,
    angle: c.angle,
    penumbra: c.penumbra,
    groundColor: c.groundColor,
    width: c.width,
    height: c.height
  });
  return e;
}
function Kke(c, e) {
  const t = e.split(".");
  switch (t.length) {
    case 1:
      return c[t[0]];
    case 2:
      return c[t[0]][t[1]];
    case 3:
      return c[t[0]][t[1]][t[2]];
    case 4:
      return c[t[0]][t[1]][t[2]][t[3]];
    case 5:
      return c[t[0]][t[1]][t[2]][t[3]][t[4]];
    case 6:
      return c[t[0]][t[1]][t[2]][t[3]][t[4]][t[5]];
  }
}
function Yke(c, e) {
  for (const t in e) c[t] = e[t];
}
function bi(c, e, t) {
  if (c === void 0) {
    console.log(`Hermes - Can't set props: ${e}`, t);
    return;
  }
  const n = e.split("."), i = n.length;
  if (typeof t != "object")
    switch (i) {
      case 1:
        c[n[0]] = t;
        break;
      case 2:
        c[n[0]][n[1]] = t;
        break;
      case 3:
        c[n[0]][n[1]][n[2]] = t;
        break;
      case 4:
        c[n[0]][n[1]][n[2]][n[3]] = t;
        break;
      case 5:
        c[n[0]][n[1]][n[2]][n[3]][n[4]] = t;
        break;
    }
  else {
    let l;
    switch (i) {
      case 1:
        l = c[n[0]];
        break;
      case 2:
        l = c[n[0]][n[1]];
        break;
      case 3:
        l = c[n[0]][n[1]][n[2]];
        break;
      case 4:
        l = c[n[0]][n[1]][n[2]][n[3]];
        break;
      case 5:
        l = c[n[0]][n[1]][n[2]][n[3]][n[4]];
        break;
    }
    l != null ? Yke(l, t) : console.log(`Hermes - Can't set props because target isn't found: ${e}`, t);
  }
}
function qge(c) {
  return new Promise((e, t) => {
    const n = new Image();
    n.onload = () => {
      const i = new IV(n);
      i.wrapS = Cpe, i.wrapT = Cpe, i.needsUpdate = !0, e(i);
    }, n.onerror = t, n.src = c;
  });
}
var Cn = /* @__PURE__ */ ((c) => (c.CUSTOM = "ToolEvents::custom", c.SELECT_DROPDOWN = "ToolEvents::selectDropdown", c.DRAG_UPDATE = "ToolEvents::dragUpdate", c.ADD_SCENE = "ToolEvents::addScene", c.REFRESH_SCENE = "ToolEvents::refreshScene", c.REMOVE_SCENE = "ToolEvents::removeScene", c.SET_SCENE = "ToolEvents::setScene", c.SET_OBJECT = "ToolEvents::setObject", c.CLEAR_OBJECT = "ToolEvents::clearObject", c.ADD_CAMERA = "ToolEvents::addCamera", c.REMOVE_CAMERA = "ToolEvents::removeCamera", c.ADD_GROUP = "ToolEvents::addGroup", c.REMOVE_GROUP = "ToolEvents::removeGroup", c.ADD_SPLINE = "ToolEvents::addSpline", c.ADD_RENDERER = "ToolEvents::addRenderer", c.UPDATE_RENDERER = "ToolEvents::updateRenderer", c))(Cn || {});
class sze extends Gge {
  name;
  canvas = null;
  // Canvas or OffscreenCanvas
  inputElement = null;
  // reference this to receive events
  scene = void 0;
  scenes = /* @__PURE__ */ new Map();
  renderer = void 0;
  renderTargets = /* @__PURE__ */ new Map();
  renderTargetsResize = /* @__PURE__ */ new Map();
  groups = /* @__PURE__ */ new Map();
  _listeners = {};
  constructor(e, t = !1, n = !1) {
    super("RemoteThree", t, n), this.name = e;
  }
  dispose() {
    this.scenes.forEach((e) => {
      Hd(e);
    }), this.scenes.clear(), this.scene && Hd(this.scene), this.renderTargets.forEach((e) => {
      e.dispose();
    }), this.renderTargets.clear(), this.renderer?.dispose();
  }
  // Event Dispatching (used for editor only)
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const i = n[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      const i = { ...e, target: this }, o = n.slice(0);
      for (let l = 0, p = o.length; l < p; l++)
        o[l].call(this, i);
    }
  }
  // Objects
  /**
   * Searches ALL active scenes
   */
  getObjectByUUID(e) {
    const t = e.split(".")[0], n = this.scenes.get(t);
    if (n !== void 0)
      return n.getObjectByProperty("uuid", e);
  }
  getObject(e) {
    if (!this.debug) return;
    this.renderer !== void 0 && (Sg.renderer = this.renderer);
    const t = this.getObjectByUUID(e);
    t && this.setObject(t);
  }
  setObject(e) {
    this.renderer !== void 0 && (Sg.renderer = this.renderer);
    const t = a5(e);
    this.dispatchEvent({ type: "ToolEvents::setObject", value: t });
  }
  requestMethod(e, t, n, i) {
    const o = this.getObjectByUUID(e);
    if (o)
      try {
        i !== void 0 ? Kke(o, i)[t](n) : o[t](n);
      } catch (l) {
        console.log("Hermes - Error requesting method:", e, t, n), console.log(l);
      }
  }
  updateObject(e, t, n) {
    this.send({
      event: "updateObject",
      target: "app",
      // used by both
      data: {
        uuid: e,
        key: t,
        value: n
      }
    });
  }
  createTexture(e, t, n) {
    this.send({
      event: "createTexture",
      target: "app",
      // used by both
      data: {
        uuid: e,
        key: t,
        value: n
      }
    });
  }
  onUpdateObject(e, t, n) {
    const i = this.getObjectByUUID(e);
    i && bi(i, t, n);
  }
  onCreateTexture(e, t, n) {
    const i = this.getObjectByUUID(e);
    if (i) {
      const o = (l) => {
        const p = t.split(".");
        switch (p.length) {
          case 1:
            i[p[0]] = l;
            break;
          case 2:
            i[p[0]][p[1]] = l;
            break;
          case 3:
            i[p[0]][p[1]][p[2]] = l;
            break;
          case 4:
            i[p[0]][p[1]][p[2]][p[3]] = l;
            break;
          case 5:
            i[p[0]][p[1]][p[2]][p[3]][p[4]] = l;
            break;
        }
        i.material.needsUpdate = !0;
      };
      n.src.length > 0 ? qge(n.src).then((l) => {
        l.offset.set(n.offset[0], n.offset[1]), l.repeat.set(n.repeat[0], n.repeat[1]), o(l);
      }) : o(null);
    }
  }
  // Groups
  addGroup(e) {
    this.groups.get(e.title) === void 0 && (this.groups.set(e.title, {
      title: e.title,
      onUpdate: e.onUpdate
    }), this.send({
      event: "addGroup",
      target: "editor",
      data: JSON.stringify(e)
    }));
  }
  removeGroup(e) {
    this.groups.get(e) !== void 0 && (this.groups.delete(e), this.send({
      event: "removeGroup",
      target: "editor",
      data: e
    }));
  }
  updateGroup(e, t, n) {
    this.send({
      event: "updateGroup",
      target: "app",
      data: JSON.stringify({ group: e, prop: t, value: n })
    });
  }
  addSplineCurve(e) {
    setTimeout(() => {
      this.send({
        event: "addSpline",
        target: "editor",
        data: JSON.stringify(e.toJSON())
      });
    }, 1);
  }
  addSplineObject(e) {
    setTimeout(() => {
      this.send({
        event: "addSpline",
        target: "editor",
        data: JSON.stringify(e)
      });
    }, 1);
  }
  // Renderer
  setRenderer(e, t = null) {
    if (this.renderer = e, this.canvas = e.domElement, this.inputElement = t !== null ? t : this.canvas, !this.debug) return;
    const n = `#${e.getClearColor(new Ag()).getHexString()}`;
    this.send({
      event: "addRenderer",
      target: "editor",
      data: {
        autoClear: e.autoClear,
        autoClearColor: e.autoClearColor,
        autoClearDepth: e.autoClearDepth,
        autoClearStencil: e.autoClearStencil,
        outputColorSpace: e.outputColorSpace,
        localClippingEnabled: e.localClippingEnabled,
        clearColor: n,
        clearAlpha: e.getClearAlpha(),
        colorManagement: _b.enabled,
        toneMapping: e.toneMapping,
        toneMappingExposure: e.toneMappingExposure,
        type: e.isWebGLRenderer ? "WebGLRenderer" : "WebGPURenderer"
      }
    });
  }
  updateRenderer(e) {
    this.send({
      event: "updateRenderer",
      target: "app",
      data: e
    });
  }
  // Scenes
  addScene(e) {
    if (e === void 0 || (this.scenes.set(e.name, e), !this.debug)) return;
    jpe(), FV(e);
    const t = xb(e);
    this.send({
      event: "addScene",
      target: "editor",
      data: t
    });
  }
  refreshScene(e) {
    if (!this.debug) return;
    const t = this.scenes.get(e);
    if (t !== void 0) {
      const n = xb(t);
      this.send({
        event: "refreshScene",
        target: "app",
        data: n
      });
    }
  }
  removeScene(e) {
    if (e === void 0 || (this.scenes.delete(e.name), !this.debug)) return;
    const t = xb(e);
    this.send({
      event: "removeScene",
      target: "editor",
      data: t
    });
  }
  removeAllScenes() {
    this.scenes.forEach((e) => this.removeScene(e));
  }
  getScene(e) {
    let t = null;
    return this.scene !== void 0 && this.scene.uuid.search(e) > -1 ? this.scene : (this.scenes.forEach((n, i) => {
      e.search(i) > -1 && (t = n);
    }), t);
  }
  setScene(e) {
    if (e === void 0 || (this.scene = e, !this.debug)) return;
    this.renderer !== void 0 && (Sg.renderer = this.renderer), jpe(), FV(e);
    const t = xb(e);
    this.send({
      event: "setScene",
      target: "editor",
      data: t
    });
  }
  requestSize() {
    this.send({
      event: "requestSize",
      target: "app"
    });
  }
  // Cameras
  addCamera(e) {
    if (!this.debug) return;
    const t = a5(e);
    this.send({
      event: "addCamera",
      target: "editor",
      data: t
    });
  }
  removeCamera(e) {
    if (!this.debug) return;
    const t = a5(e);
    this.send({
      event: "removeCamera",
      target: "editor",
      data: t
    });
  }
  handleApp(e) {
    switch (e.event) {
      case "refreshScene":
        this.send({
          event: "refreshScene",
          target: "editor",
          data: xb(this.scenes.get(e.data.name))
        });
        break;
      case "updateRenderer":
        this.renderer && (this.renderer.autoClearColor = e.data.autoClearColor, this.renderer.outputColorSpace = e.data.outputColorSpace, this.renderer.localClippingEnabled = e.data.localClippingEnabled, this.renderer.setClearColor(e.data.clearColor, e.data.clearAlpha), this.renderer.toneMapping = e.data.toneMapping, this.renderer.toneMappingExposure = e.data.toneMappingExposure, _b.enabled = e.data.colorManagement);
        break;
    }
    if (e.event === "updateGroup") {
      const t = JSON.parse(e.data);
      this.groups.get(t.group)?.onUpdate(t.prop, t.value);
    }
  }
  handleEditor(e) {
    switch (e.event) {
      case "addScene":
        this.dispatchEvent({ type: "ToolEvents::addScene", value: e.data });
        break;
      case "refreshScene":
        this.dispatchEvent({ type: "ToolEvents::refreshScene", value: e.data });
        break;
      case "removeScene":
        this.dispatchEvent({ type: "ToolEvents::removeScene", value: e.data });
        break;
      case "setScene":
        this.dispatchEvent({ type: "ToolEvents::setScene", value: e.data });
        break;
      case "addCamera":
        this.dispatchEvent({ type: "ToolEvents::addCamera", value: e.data });
        break;
      case "removeCamera":
        this.dispatchEvent({ type: "ToolEvents::removeCamera", value: e.data });
        break;
      case "addGroup":
        this.dispatchEvent({ type: "ToolEvents::addGroup", value: e.data });
        break;
      case "removeGroup":
        this.dispatchEvent({ type: "ToolEvents::removeGroup", value: e.data });
        break;
      case "addSpline":
        this.dispatchEvent({ type: "ToolEvents::addSpline", value: e.data });
        break;
      case "addRenderer":
        this.dispatchEvent({ type: "ToolEvents::addRenderer", value: e.data });
    }
  }
  messageHandler(e) {
    const t = e.data;
    if (t.event === "updateObject") {
      this.onUpdateObject(t.data.uuid, t.data.key, t.data.value);
      return;
    } else if (t.event === "createTexture") {
      this.onCreateTexture(t.data.uuid, t.data.key, t.data.value);
      return;
    } else if (t.event === "requestSize") {
      t.target === "app" ? this.send({
        event: "requestSize",
        target: "editor",
        data: {
          width: this.width,
          height: this.height
        }
      }) : this.scenes.forEach((n) => {
        n.resize !== void 0 && n.resize(t.data.width, t.data.height);
      });
      return;
    }
    t.target === "app" ? this.handleApp(t) : this.handleEditor(t);
  }
  // Renderer
  addRT(e, t = !0, n) {
    const i = new wge(32, 32, n);
    i.texture.name = e, this.renderTargets.set(e, i), this.renderTargetsResize.set(e, t);
  }
  removeRT(e) {
    this.renderTargets.delete(e), this.renderTargetsResize.delete(e);
  }
  resize(e, t) {
    const n = this.dpr;
    this.renderTargets.forEach((o, l) => {
      this.renderTargetsResize.get(l) && o.setSize(e * n, t * n);
    });
    const i = !(this.renderer?.domElement instanceof OffscreenCanvas);
    this.renderer?.setSize(e, t, i);
  }
  set dpr(e) {
    this.renderer?.setPixelRatio(dg(1, 2, e));
  }
  get dpr() {
    return this.renderer !== void 0 ? this.renderer?.getPixelRatio() : 1;
  }
  get width() {
    return this.renderer !== void 0 ? this.renderer.domElement.width / this.dpr : 0;
  }
  get height() {
    return this.renderer !== void 0 ? this.renderer.domElement.height / this.dpr : 0;
  }
}
var vN = { exports: {} }, Ew = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Upe;
function Xke() {
  if (Upe) return Ew;
  Upe = 1;
  var c = xge, e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), n = Object.prototype.hasOwnProperty, i = c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(p, f, v) {
    var _, E = {}, A = null, I = null;
    v !== void 0 && (A = "" + v), f.key !== void 0 && (A = "" + f.key), f.ref !== void 0 && (I = f.ref);
    for (_ in f) n.call(f, _) && !o.hasOwnProperty(_) && (E[_] = f[_]);
    if (p && p.defaultProps) for (_ in f = p.defaultProps, f) E[_] === void 0 && (E[_] = f[_]);
    return { $$typeof: e, type: p, key: A, ref: I, props: E, _owner: i.current };
  }
  return Ew.Fragment = t, Ew.jsx = l, Ew.jsxs = l, Ew;
}
var Tw = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zpe;
function Qke() {
  return zpe || (zpe = 1, process.env.NODE_ENV !== "production" && function() {
    var c = xge, e = Symbol.for("react.element"), t = Symbol.for("react.portal"), n = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), l = Symbol.for("react.provider"), p = Symbol.for("react.context"), f = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), _ = Symbol.for("react.suspense_list"), E = Symbol.for("react.memo"), A = Symbol.for("react.lazy"), I = Symbol.for("react.offscreen"), j = Symbol.iterator, q = "@@iterator";
    function L(be) {
      if (be === null || typeof be != "object")
        return null;
      var ht = j && be[j] || be[q];
      return typeof ht == "function" ? ht : null;
    }
    var V = c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function re(be) {
      {
        for (var ht = arguments.length, Pt = new Array(ht > 1 ? ht - 1 : 0), Wt = 1; Wt < ht; Wt++)
          Pt[Wt - 1] = arguments[Wt];
        R("error", be, Pt);
      }
    }
    function R(be, ht, Pt) {
      {
        var Wt = V.ReactDebugCurrentFrame, vn = Wt.getStackAddendum();
        vn !== "" && (ht += "%s", Pt = Pt.concat([vn]));
        var qn = Pt.map(function(fn) {
          return String(fn);
        });
        qn.unshift("Warning: " + ht), Function.prototype.apply.call(console[be], console, qn);
      }
    }
    var J = !1, ge = !1, _e = !1, Y = !1, Fe = !1, Me;
    Me = Symbol.for("react.module.reference");
    function $(be) {
      return !!(typeof be == "string" || typeof be == "function" || be === n || be === o || Fe || be === i || be === v || be === _ || Y || be === I || J || ge || _e || typeof be == "object" && be !== null && (be.$$typeof === A || be.$$typeof === E || be.$$typeof === l || be.$$typeof === p || be.$$typeof === f || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      be.$$typeof === Me || be.getModuleId !== void 0));
    }
    function dt(be, ht, Pt) {
      var Wt = be.displayName;
      if (Wt)
        return Wt;
      var vn = ht.displayName || ht.name || "";
      return vn !== "" ? Pt + "(" + vn + ")" : Pt;
    }
    function wt(be) {
      return be.displayName || "Context";
    }
    function St(be) {
      if (be == null)
        return null;
      if (typeof be.tag == "number" && re("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof be == "function")
        return be.displayName || be.name || null;
      if (typeof be == "string")
        return be;
      switch (be) {
        case n:
          return "Fragment";
        case t:
          return "Portal";
        case o:
          return "Profiler";
        case i:
          return "StrictMode";
        case v:
          return "Suspense";
        case _:
          return "SuspenseList";
      }
      if (typeof be == "object")
        switch (be.$$typeof) {
          case p:
            var ht = be;
            return wt(ht) + ".Consumer";
          case l:
            var Pt = be;
            return wt(Pt._context) + ".Provider";
          case f:
            return dt(be, be.render, "ForwardRef");
          case E:
            var Wt = be.displayName || null;
            return Wt !== null ? Wt : St(be.type) || "Memo";
          case A: {
            var vn = be, qn = vn._payload, fn = vn._init;
            try {
              return St(fn(qn));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Ct = Object.assign, pe = 0, Tt, st, Zt, $t, Ht, Gn, an;
    function An() {
    }
    An.__reactDisabledLog = !0;
    function pr() {
      {
        if (pe === 0) {
          Tt = console.log, st = console.info, Zt = console.warn, $t = console.error, Ht = console.group, Gn = console.groupCollapsed, an = console.groupEnd;
          var be = {
            configurable: !0,
            enumerable: !0,
            value: An,
            writable: !0
          };
          Object.defineProperties(console, {
            info: be,
            log: be,
            warn: be,
            error: be,
            group: be,
            groupCollapsed: be,
            groupEnd: be
          });
        }
        pe++;
      }
    }
    function Kn() {
      {
        if (pe--, pe === 0) {
          var be = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Ct({}, be, {
              value: Tt
            }),
            info: Ct({}, be, {
              value: st
            }),
            warn: Ct({}, be, {
              value: Zt
            }),
            error: Ct({}, be, {
              value: $t
            }),
            group: Ct({}, be, {
              value: Ht
            }),
            groupCollapsed: Ct({}, be, {
              value: Gn
            }),
            groupEnd: Ct({}, be, {
              value: an
            })
          });
        }
        pe < 0 && re("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Qo = V.ReactCurrentDispatcher, _r;
    function Ta(be, ht, Pt) {
      {
        if (_r === void 0)
          try {
            throw Error();
          } catch (vn) {
            var Wt = vn.stack.trim().match(/\n( *(at )?)/);
            _r = Wt && Wt[1] || "";
          }
        return `
` + _r + be;
      }
    }
    var fl = !1, Ca;
    {
      var Pa = typeof WeakMap == "function" ? WeakMap : Map;
      Ca = new Pa();
    }
    function Cc(be, ht) {
      if (!be || fl)
        return "";
      {
        var Pt = Ca.get(be);
        if (Pt !== void 0)
          return Pt;
      }
      var Wt;
      fl = !0;
      var vn = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var qn;
      qn = Qo.current, Qo.current = null, pr();
      try {
        if (ht) {
          var fn = function() {
            throw Error();
          };
          if (Object.defineProperty(fn.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fn, []);
            } catch (di) {
              Wt = di;
            }
            Reflect.construct(be, [], fn);
          } else {
            try {
              fn.call();
            } catch (di) {
              Wt = di;
            }
            be.call(fn.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (di) {
            Wt = di;
          }
          be();
        }
      } catch (di) {
        if (di && Wt && typeof di.stack == "string") {
          for (var Gt = di.stack.split(`
`), rr = Wt.stack.split(`
`), Sr = Gt.length - 1, fr = rr.length - 1; Sr >= 1 && fr >= 0 && Gt[Sr] !== rr[fr]; )
            fr--;
          for (; Sr >= 1 && fr >= 0; Sr--, fr--)
            if (Gt[Sr] !== rr[fr]) {
              if (Sr !== 1 || fr !== 1)
                do
                  if (Sr--, fr--, fr < 0 || Gt[Sr] !== rr[fr]) {
                    var Li = `
` + Gt[Sr].replace(" at new ", " at ");
                    return be.displayName && Li.includes("<anonymous>") && (Li = Li.replace("<anonymous>", be.displayName)), typeof be == "function" && Ca.set(be, Li), Li;
                  }
                while (Sr >= 1 && fr >= 0);
              break;
            }
        }
      } finally {
        fl = !1, Qo.current = qn, Kn(), Error.prepareStackTrace = vn;
      }
      var ea = be ? be.displayName || be.name : "", wo = ea ? Ta(ea) : "";
      return typeof be == "function" && Ca.set(be, wo), wo;
    }
    function Fi(be, ht, Pt) {
      return Cc(be, !1);
    }
    function Ki(be) {
      var ht = be.prototype;
      return !!(ht && ht.isReactComponent);
    }
    function ml(be, ht, Pt) {
      if (be == null)
        return "";
      if (typeof be == "function")
        return Cc(be, Ki(be));
      if (typeof be == "string")
        return Ta(be);
      switch (be) {
        case v:
          return Ta("Suspense");
        case _:
          return Ta("SuspenseList");
      }
      if (typeof be == "object")
        switch (be.$$typeof) {
          case f:
            return Fi(be.render);
          case E:
            return ml(be.type, ht, Pt);
          case A: {
            var Wt = be, vn = Wt._payload, qn = Wt._init;
            try {
              return ml(qn(vn), ht, Pt);
            } catch {
            }
          }
        }
      return "";
    }
    var Qr = Object.prototype.hasOwnProperty, Zo = {}, fu = V.ReactDebugCurrentFrame;
    function Jo(be) {
      if (be) {
        var ht = be._owner, Pt = ml(be.type, be._source, ht ? ht.type : null);
        fu.setExtraStackFrame(Pt);
      } else
        fu.setExtraStackFrame(null);
    }
    function Pc(be, ht, Pt, Wt, vn) {
      {
        var qn = Function.call.bind(Qr);
        for (var fn in be)
          if (qn(be, fn)) {
            var Gt = void 0;
            try {
              if (typeof be[fn] != "function") {
                var rr = Error((Wt || "React class") + ": " + Pt + " type `" + fn + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof be[fn] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw rr.name = "Invariant Violation", rr;
              }
              Gt = be[fn](ht, fn, Wt, Pt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Sr) {
              Gt = Sr;
            }
            Gt && !(Gt instanceof Error) && (Jo(vn), re("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Wt || "React class", Pt, fn, typeof Gt), Jo(null)), Gt instanceof Error && !(Gt.message in Zo) && (Zo[Gt.message] = !0, Jo(vn), re("Failed %s type: %s", Pt, Gt.message), Jo(null));
          }
      }
    }
    var Jd = Array.isArray;
    function Si(be) {
      return Jd(be);
    }
    function eh(be) {
      {
        var ht = typeof Symbol == "function" && Symbol.toStringTag, Pt = ht && be[Symbol.toStringTag] || be.constructor.name || "Object";
        return Pt;
      }
    }
    function to(be) {
      try {
        return th(be), !1;
      } catch {
        return !0;
      }
    }
    function th(be) {
      return "" + be;
    }
    function Ac(be) {
      if (to(be))
        return re("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", eh(be)), th(be);
    }
    var Aa = V.ReactCurrentOwner, nh = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, rh, ih;
    function mu(be) {
      if (Qr.call(be, "ref")) {
        var ht = Object.getOwnPropertyDescriptor(be, "ref").get;
        if (ht && ht.isReactWarning)
          return !1;
      }
      return be.ref !== void 0;
    }
    function sh(be) {
      if (Qr.call(be, "key")) {
        var ht = Object.getOwnPropertyDescriptor(be, "key").get;
        if (ht && ht.isReactWarning)
          return !1;
      }
      return be.key !== void 0;
    }
    function Bi(be, ht) {
      typeof be.ref == "string" && Aa.current;
    }
    function _o(be, ht) {
      {
        var Pt = function() {
          rh || (rh = !0, re("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ht));
        };
        Pt.isReactWarning = !0, Object.defineProperty(be, "key", {
          get: Pt,
          configurable: !0
        });
      }
    }
    function ka(be, ht) {
      {
        var Pt = function() {
          ih || (ih = !0, re("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ht));
        };
        Pt.isReactWarning = !0, Object.defineProperty(be, "ref", {
          get: Pt,
          configurable: !0
        });
      }
    }
    var of = function(be, ht, Pt, Wt, vn, qn, fn) {
      var Gt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: be,
        key: ht,
        ref: Pt,
        props: fn,
        // Record the component responsible for creating this element.
        _owner: qn
      };
      return Gt._store = {}, Object.defineProperty(Gt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(Gt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Wt
      }), Object.defineProperty(Gt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: vn
      }), Object.freeze && (Object.freeze(Gt.props), Object.freeze(Gt)), Gt;
    };
    function Ms(be, ht, Pt, Wt, vn) {
      {
        var qn, fn = {}, Gt = null, rr = null;
        Pt !== void 0 && (Ac(Pt), Gt = "" + Pt), sh(ht) && (Ac(ht.key), Gt = "" + ht.key), mu(ht) && (rr = ht.ref, Bi(ht, vn));
        for (qn in ht)
          Qr.call(ht, qn) && !nh.hasOwnProperty(qn) && (fn[qn] = ht[qn]);
        if (be && be.defaultProps) {
          var Sr = be.defaultProps;
          for (qn in Sr)
            fn[qn] === void 0 && (fn[qn] = Sr[qn]);
        }
        if (Gt || rr) {
          var fr = typeof be == "function" ? be.displayName || be.name || "Unknown" : be;
          Gt && _o(fn, fr), rr && ka(fn, fr);
        }
        return of(be, Gt, rr, vn, Wt, Aa.current, fn);
      }
    }
    var ds = V.ReactCurrentOwner, kc = V.ReactDebugCurrentFrame;
    function hs(be) {
      if (be) {
        var ht = be._owner, Pt = ml(be.type, be._source, ht ? ht.type : null);
        kc.setExtraStackFrame(Pt);
      } else
        kc.setExtraStackFrame(null);
    }
    var ps;
    ps = !1;
    function So(be) {
      return typeof be == "object" && be !== null && be.$$typeof === e;
    }
    function oh() {
      {
        if (ds.current) {
          var be = St(ds.current.type);
          if (be)
            return `

Check the render method of \`` + be + "`.";
        }
        return "";
      }
    }
    function Ma(be) {
      return "";
    }
    var gu = {};
    function ah(be) {
      {
        var ht = oh();
        if (!ht) {
          var Pt = typeof be == "string" ? be : be.displayName || be.name;
          Pt && (ht = `

Check the top-level render call using <` + Pt + ">.");
        }
        return ht;
      }
    }
    function ci(be, ht) {
      {
        if (!be._store || be._store.validated || be.key != null)
          return;
        be._store.validated = !0;
        var Pt = ah(ht);
        if (gu[Pt])
          return;
        gu[Pt] = !0;
        var Wt = "";
        be && be._owner && be._owner !== ds.current && (Wt = " It was passed a child from " + St(be._owner.type) + "."), hs(be), re('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Pt, Wt), hs(null);
      }
    }
    function Or(be, ht) {
      {
        if (typeof be != "object")
          return;
        if (Si(be))
          for (var Pt = 0; Pt < be.length; Pt++) {
            var Wt = be[Pt];
            So(Wt) && ci(Wt, ht);
          }
        else if (So(be))
          be._store && (be._store.validated = !0);
        else if (be) {
          var vn = L(be);
          if (typeof vn == "function" && vn !== be.entries)
            for (var qn = vn.call(be), fn; !(fn = qn.next()).done; )
              So(fn.value) && ci(fn.value, ht);
        }
      }
    }
    function lh(be) {
      {
        var ht = be.type;
        if (ht == null || typeof ht == "string")
          return;
        var Pt;
        if (typeof ht == "function")
          Pt = ht.propTypes;
        else if (typeof ht == "object" && (ht.$$typeof === f || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        ht.$$typeof === E))
          Pt = ht.propTypes;
        else
          return;
        if (Pt) {
          var Wt = St(ht);
          Pc(Pt, be.props, "prop", Wt, be);
        } else if (ht.PropTypes !== void 0 && !ps) {
          ps = !0;
          var vn = St(ht);
          re("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", vn || "Unknown");
        }
        typeof ht.getDefaultProps == "function" && !ht.getDefaultProps.isReactClassApproved && re("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function uh(be) {
      {
        for (var ht = Object.keys(be.props), Pt = 0; Pt < ht.length; Pt++) {
          var Wt = ht[Pt];
          if (Wt !== "children" && Wt !== "key") {
            hs(be), re("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Wt), hs(null);
            break;
          }
        }
        be.ref !== null && (hs(be), re("Invalid attribute `ref` supplied to `React.Fragment`."), hs(null));
      }
    }
    var yu = {};
    function vu(be, ht, Pt, Wt, vn, qn) {
      {
        var fn = $(be);
        if (!fn) {
          var Gt = "";
          (be === void 0 || typeof be == "object" && be !== null && Object.keys(be).length === 0) && (Gt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var rr = Ma();
          rr ? Gt += rr : Gt += oh();
          var Sr;
          be === null ? Sr = "null" : Si(be) ? Sr = "array" : be !== void 0 && be.$$typeof === e ? (Sr = "<" + (St(be.type) || "Unknown") + " />", Gt = " Did you accidentally export a JSX literal instead of a component?") : Sr = typeof be, re("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Sr, Gt);
        }
        var fr = Ms(be, ht, Pt, vn, qn);
        if (fr == null)
          return fr;
        if (fn) {
          var Li = ht.children;
          if (Li !== void 0)
            if (Wt)
              if (Si(Li)) {
                for (var ea = 0; ea < Li.length; ea++)
                  Or(Li[ea], be);
                Object.freeze && Object.freeze(Li);
              } else
                re("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Or(Li, be);
        }
        if (Qr.call(ht, "key")) {
          var wo = St(be), di = Object.keys(ht).filter(function(uf) {
            return uf !== "key";
          }), fs = di.length > 0 ? "{key: someKey, " + di.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yu[wo + fs]) {
            var gl = di.length > 0 ? "{" + di.join(": ..., ") + ": ...}" : "{}";
            re(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, fs, wo, gl, wo), yu[wo + fs] = !0;
          }
        }
        return be === n ? uh(fr) : lh(fr), fr;
      }
    }
    function ch(be, ht, Pt) {
      return vu(be, ht, Pt, !0);
    }
    function af(be, ht, Pt) {
      return vu(be, ht, Pt, !1);
    }
    var lf = af, dh = ch;
    Tw.Fragment = n, Tw.jsx = lf, Tw.jsxs = dh;
  }()), Tw;
}
var Vpe;
function Zke() {
  return Vpe || (Vpe = 1, process.env.NODE_ENV === "production" ? vN.exports = Xke() : vN.exports = Qke()), vN.exports;
}
var ke = Zke();
function Hge(c) {
  return c.title.search("<") > -1 ? /* @__PURE__ */ ke.jsx("button", { className: "svg", dangerouslySetInnerHTML: { __html: c.title } }) : /* @__PURE__ */ ke.jsx("button", { children: c.title });
}
const Jke = /* @__PURE__ */ ke.jsxs("svg", { className: "closeIcon", width: "14", height: "14", fill: "none", stroke: "#666666", strokeMiterlimit: "10", children: [
  /* @__PURE__ */ ke.jsx("circle", { cx: "7", cy: "7", r: "6" }),
  /* @__PURE__ */ ke.jsx("line", { x1: "4", y1: "4", x2: "10", y2: "10" }),
  /* @__PURE__ */ ke.jsx("line", { x1: "4", y1: "10", x2: "10", y2: "4" })
] }), eMe = /* @__PURE__ */ ke.jsx("svg", { className: "dragIcon", width: "14", height: "14", fill: "#666666", stroke: "none", children: /* @__PURE__ */ ke.jsx(
  "path",
  {
    d: `M10.43,4H3.57C3.26,4,3,4.22,3,4.5v1C3,5.78,3.26,6,3.57,6h6.86C10.74,6,11,5.78,11,5.5v-1\r
C11,4.22,10.74,4,10.43,4z M10.43,8H3.57C3.26,8,3,8.22,3,8.5v1C3,9.78,3.26,10,3.57,10h6.86C10.74,10,11,9.78,11,9.5v-1\r
C11,8.22,10.74,8,10.43,8z`
  }
) });
function tMe(c) {
  return /* @__PURE__ */ ke.jsx(
    "li",
    {
      className: `reorder-item ${c.draggingIndex === c.index ? "dragging" : ""}`,
      draggable: !0,
      onDragStart: () => c.onDragStart(c.index),
      onDragOver: (e) => {
        e.preventDefault(), c.onDragOver(c.index);
      },
      onDragEnd: c.onDragEnd,
      children: /* @__PURE__ */ ke.jsxs("div", { children: [
        eMe,
        /* @__PURE__ */ ke.jsx("span", { children: c.title }),
        /* @__PURE__ */ ke.jsx("button", { className: "closeIcon", onClick: () => c.onDelete(c.index), children: Jke })
      ] })
    }
  );
}
function nMe(c) {
  const [e, t] = nr(!1), [n, i] = nr(c.options), [o, l] = nr(null), p = (I) => {
    c.onDragComplete(I), i(I);
  }, f = (I) => {
    const j = [...n];
    j.splice(I, 1), p(j);
  }, v = (I) => {
    l(I);
  }, _ = (I) => {
    if (o === I || o === null) return;
    const j = [...n], q = j.splice(o, 1)[0];
    j.splice(I, 0, q), l(I), i(j);
  }, E = () => {
    c.onDragComplete(n), l(null);
  };
  let A = "dropdown draggable";
  return c.subdropdown && (A += " subdropdown"), /* @__PURE__ */ ke.jsxs("div", { className: A, onMouseEnter: () => t(!0), onMouseLeave: () => t(!1), children: [
    /* @__PURE__ */ ke.jsx(Hge, { title: c.title }),
    /* @__PURE__ */ ke.jsx("ul", { className: "reorder-list", style: { display: e ? "block" : "none" }, children: n.map((I, j) => /* @__PURE__ */ ke.jsx(
      tMe,
      {
        title: I,
        index: j,
        draggingIndex: o,
        onDelete: f,
        onDragStart: v,
        onDragOver: _,
        onDragEnd: E
      },
      I
    )) })
  ] });
}
function rMe(c) {
  const [e, t] = nr(!1), n = [];
  c.options.map((o, l) => {
    c.onSelect !== void 0 && (o.onSelect = c.onSelect), n.push(/* @__PURE__ */ ke.jsx(iMe, { option: o }, l));
  });
  let i = "dropdown";
  return c.subdropdown && (i += " subdropdown"), /* @__PURE__ */ ke.jsxs(
    "div",
    {
      className: i,
      onMouseEnter: () => t(!0),
      onMouseLeave: () => t(!1),
      children: [
        /* @__PURE__ */ ke.jsx(Hge, { title: c.title }),
        /* @__PURE__ */ ke.jsx(
          "ul",
          {
            style: { visibility: e ? "visible" : "hidden" },
            children: n
          }
        )
      ]
    }
  );
}
function iMe(c) {
  const { option: e } = c, [t, n] = nr("");
  let i;
  switch (e.type) {
    case "draggable":
      i = /* @__PURE__ */ ke.jsx(
        nMe,
        {
          title: e.title,
          options: e.value,
          onDragComplete: (o) => {
            e.onDragComplete !== void 0 && e.onDragComplete(o);
          },
          subdropdown: !0
        }
      );
      break;
    case "dropdown":
      i = /* @__PURE__ */ ke.jsx(
        rMe,
        {
          title: e.title,
          options: e.value,
          onSelect: e.onSelect,
          subdropdown: !0
        }
      );
      break;
    case "option":
      i = /* @__PURE__ */ ke.jsx(
        "button",
        {
          onClick: () => {
            e.onSelect !== void 0 && e.onSelect(e.value), e.selectable && (t !== e.title ? n(e.title) : n(""));
          },
          children: e.title
        }
      );
      break;
  }
  return /* @__PURE__ */ ke.jsx("li", { className: t === e.title ? "selected" : "", children: i }, cs());
}
function dE(c) {
  const [e, t] = nr(c.open !== void 0 ? c.open : !1), [n, i] = nr(c.visible !== void 0 ? c.visible : !1), o = !e || c.children === void 0, l = () => {
    c.three.dispatchEvent({ type: Cn.REMOVE_SCENE, value: c.scene });
  };
  return /* @__PURE__ */ ke.jsxs("div", { className: `accordion ${o ? "hide" : ""}`, children: [
    /* @__PURE__ */ ke.jsxs(
      "button",
      {
        className: "toggle",
        onClick: () => {
          const p = !e;
          c.onToggle !== void 0 && c.onToggle(p), t(p);
        },
        children: [
          /* @__PURE__ */ ke.jsx(
            "p",
            {
              className: `status ${e ? "open" : ""}`,
              children: "Toggle"
            }
          ),
          /* @__PURE__ */ ke.jsx("p", { className: "label", children: EO(c.label) })
        ]
      }
    ),
    c.onRefresh ? /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
      /* @__PURE__ */ ke.jsx(
        "button",
        {
          className: "visibility",
          style: {
            opacity: n ? 1 : 0.25
          },
          onClick: () => {
            const f = c.three.getScene(c.scene.uuid);
            if (f) {
              const v = !f.visible;
              f.visible = v, i(v);
            }
          }
        }
      ),
      /* @__PURE__ */ ke.jsx("button", { className: "refresh", onClick: c.onRefresh }),
      /* @__PURE__ */ ke.jsx("button", { className: "remove", onClick: l })
    ] }) : null,
    c.button,
    /* @__PURE__ */ ke.jsx("div", { className: e ? "open" : "", children: /* @__PURE__ */ ke.jsx("div", { children: c.children }) }, Math.random())
  ] });
}
function $ge(c) {
  if (c.child === void 0)
    return console.log("Hermes - No child attached"), null;
  const e = Yr(null), [t, n] = nr(!1), i = c.child.children.length > 0, o = [];
  return c.child.children.length > 0 && c.child.children.map((l, p) => {
    o.push(/* @__PURE__ */ ke.jsx($ge, { child: l, three: c.three }, p));
  }), Pg(() => {
    if (c.child) {
      const l = c.child.uuid.split(".")[0], p = c.three.getScene(l);
      if (p !== null)
        try {
          const f = p.getObjectByProperty("uuid", c.child.uuid);
          f !== void 0 ? e.current.style.opacity = f.visible ? "1" : "0.25" : console.log(`Hermes - Can't find child: ${c.child.uuid}`);
        } catch (f) {
          console.log("Error looking for child:", f), console.log(c.child), console.log(c.three.scenes), console.log(p);
        }
      else
        console.log(`Hermes (ChildObject) - Can't find Scene: ${l} with child UUID: ${c.child.uuid}`, c.three.scenes, c.three.scene, p);
    }
  }, [t]), /* @__PURE__ */ ke.jsxs("div", { className: "childObject", children: [
    /* @__PURE__ */ ke.jsxs("div", { className: "child", children: [
      i ? /* @__PURE__ */ ke.jsx(
        "button",
        {
          className: "status",
          style: {
            backgroundPositionX: t ? "-14px" : "2px"
          },
          onClick: () => {
            n(!t);
          }
        }
      ) : null,
      /* @__PURE__ */ ke.jsx(
        "button",
        {
          className: "name",
          style: {
            left: i ? "20px" : "5px"
          },
          onClick: () => {
            c.child !== void 0 ? (c.three.getObject(c.child.uuid), !t && i && n(!0)) : console.log("Hermes - No child attached...");
          },
          children: c.child.name.length > 0 ? `${c.child.name} (${c.child.type})` : `${c.child.type}::${c.child.uuid}`
        }
      ),
      /* @__PURE__ */ ke.jsx(
        "button",
        {
          className: "visibility",
          ref: e,
          onClick: () => {
            if (c.child) {
              const l = c.three.getScene(c.child.uuid);
              if (l !== null) {
                const p = l.getObjectByProperty("uuid", c.child.uuid);
                if (p !== void 0) {
                  const f = "visible", v = !p.visible;
                  e.current.style.opacity = v ? "1" : "0.25", c.three.updateObject(c.child.uuid, f, v), bi(p, f, v);
                } else
                  console.log(`Hermes - Couldn't find object: ${c.child.uuid}`, l);
              } else
                console.log(`Hermes - Couldn't find object in scene: ${c.child.uuid}, ${c.child.name}`);
            }
          }
        }
      ),
      /* @__PURE__ */ ke.jsx("div", { className: `icon ${Hke(c.child)}` })
    ] }),
    /* @__PURE__ */ ke.jsx("div", { className: t ? "open" : "", children: /* @__PURE__ */ ke.jsx("div", { className: "container", children: o }) })
  ] }, Math.random());
}
function l5(c) {
  const e = [];
  return c.child?.children.map((t, n) => {
    e.push(/* @__PURE__ */ ke.jsx($ge, { child: t, scene: c.scene, three: c.three }, n));
  }), /* @__PURE__ */ ke.jsx("div", { className: `scene ${c.class !== void 0 ? c.class : ""}`, children: e });
}
function eE(c) {
  const [e, t] = nr(c.defaultValue);
  return Pg(() => {
    let n = !1, i = -1, o = 0, l = c.defaultValue, p = !1;
    const f = (I) => {
      p = I.ctrlKey;
    }, v = (I) => {
      n = !0, o = Number(c.input.current?.value), i = I.clientX, document.addEventListener("mouseup", E, !1), document.addEventListener("mousemove", _, !1), document.addEventListener("contextmenu", E, !1);
    }, _ = (I) => {
      if (!n) return;
      const j = c.step !== void 0 ? c.step : 1, q = (I.clientX - i) * j * (p ? 10 : 1);
      l = Number((o + q).toFixed(4)), c.min !== void 0 && (l = Math.max(l, c.min)), c.max !== void 0 && (l = Math.min(l, c.max)), c.onChange !== void 0 && c.onChange(l), t(l);
    }, E = () => {
      n = !1, document.removeEventListener("mouseup", E), document.removeEventListener("mousemove", _), document.removeEventListener("contextmenu", E);
    }, A = (I) => {
      const j = Number(I.target.value);
      c.onChange !== void 0 && c.onChange(j), t(j);
    };
    return c.label.current?.addEventListener("mousedown", v, !1), c.sliderRef !== void 0 && c.sliderRef.current?.addEventListener("input", A), document.addEventListener("keydown", f, !1), document.addEventListener("keyup", f, !1), () => {
      c.label.current?.removeEventListener("mousedown", v), c.sliderRef !== void 0 && c.sliderRef.current?.removeEventListener("input", A), document.removeEventListener("mouseup", E), document.removeEventListener("mousemove", _), document.removeEventListener("contextmenu", E), document.removeEventListener("keydown", f), document.addEventListener("keyup", f, !1);
    };
  }, []), e;
}
function wg(c) {
  const e = Yr(null), t = Yr(null), [n, i] = nr(c.value);
  return eE({
    label: c.labelRef,
    input: e,
    sliderRef: t,
    defaultValue: n,
    min: c.min,
    max: c.max,
    step: c.step,
    onChange: (o) => {
      i(o), c.onChange !== void 0 && c.onChange(c.prop, o);
    }
  }), /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
    c.type === "number" && /* @__PURE__ */ ke.jsx(
      "input",
      {
        alt: c.alt,
        className: c.className,
        ref: e,
        type: "number",
        value: n,
        min: c.min,
        max: c.max,
        step: c.step,
        disabled: c.disabled,
        name: cs(),
        onChange: (o) => {
          if (i(o.target.value), o.target.value.length === 0) return;
          const l = Number(o.target.value);
          isNaN(l) || c.onChange !== void 0 && c.onChange(c.prop, l);
        }
      }
    ),
    c.type === "range" && /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
      /* @__PURE__ */ ke.jsx(
        "input",
        {
          type: "text",
          value: n.toString(),
          disabled: c.disabled,
          ref: e,
          className: "min",
          name: cs(),
          onChange: (o) => {
            if (o.target.value.length === 0) return;
            const l = Number(o.target.value);
            isNaN(l) || (i(l), c.onChange !== void 0 && c.onChange(c.prop, l));
          }
        }
      ),
      /* @__PURE__ */ ke.jsx(
        "input",
        {
          disabled: c.disabled,
          type: "range",
          value: n,
          min: c.min,
          max: c.max,
          step: c.step,
          ref: t,
          name: cs(),
          onChange: wO
        }
      )
    ] })
  ] });
}
function sMe(c) {
  const e = Yr(null), t = Yr(null), n = Yr(null), i = Yr(null), o = Yr(null), l = Yr(null), p = Yr(null), f = Yr(null), v = Yr(null), _ = Yr(null), [E, A] = nr(c.value.x), [I, j] = nr(c.value.y), [q, L] = nr({
    min: Math.min(c.min, Math.min(c.value.x, c.value.y)),
    max: Math.max(c.max, Math.max(c.value.x, c.value.y))
  }), [V, re] = nr(!1);
  eE({
    label: p,
    input: e,
    defaultValue: E,
    min: q.min,
    max: q.max,
    step: 0.01,
    onChange: (Me) => {
      A(Me), c.onChange({ target: { value: { x: Me, y: I } } });
    }
  }), eE({
    label: f,
    input: t,
    defaultValue: I,
    min: q.min,
    max: q.max,
    step: 0.01,
    onChange: (Me) => {
      j(Me), c.onChange({ target: { value: { x: E, y: Me } } });
    }
  }), eE({
    label: v,
    input: n,
    defaultValue: q.min,
    min: q.min - 1,
    max: q.max + 1,
    step: 0.01,
    onChange: (Me) => {
      L({ min: Me, max: q.max });
    }
  }), eE({
    label: _,
    input: i,
    defaultValue: q.max,
    min: q.min - 1,
    max: q.max + 1,
    step: 0.01,
    onChange: (Me) => {
      L({ min: q.min, max: Me });
    }
  });
  function R() {
    V || (window.addEventListener("mousemove", ge), window.addEventListener("mouseup", J), re(!0));
  }
  function J() {
    window.removeEventListener("mousemove", ge), window.removeEventListener("mouseup", J), re(!1);
  }
  function ge(Me) {
    const $ = o.current.getBoundingClientRect(), dt = dg(0, 99, Me.clientX - $.left) / 99, wt = 1 - dg(0, 99, Me.clientY - $.top) / 99, St = au(SE(q.min, q.max, dt), 3), Ct = au(SE(q.min, q.max, wt), 3);
    c.onChange({ target: { value: { x: St, y: Ct } } }), A(St), j(Ct);
  }
  function _e() {
    const Me = Number(n.current.value);
    L({ min: Me, max: q.max }), E < Me && A(dg(Me, q.max, E)), I < Me && j(dg(Me, q.max, I));
  }
  function Y() {
    const Me = Number(i.current.value);
    L({ min: q.min, max: Me }), E > Me && A(dg(q.min, Me, E)), I > Me && j(dg(q.min, Me, I));
  }
  Pg(() => {
    l.current.style.left = `${OV(q.min, q.max, E) * 100}%`, l.current.style.top = `${(1 - OV(q.min, q.max, I)) * 100}%`;
  }, [q, E, I]);
  const Fe = c.step !== void 0 ? c.step : 0.01;
  return /* @__PURE__ */ ke.jsxs("div", { className: "vector2", children: [
    /* @__PURE__ */ ke.jsxs("div", { className: "fields", children: [
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { ref: p, children: "X" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: e,
            type: "number",
            value: E,
            min: q.min,
            max: q.max,
            step: Fe,
            name: cs(),
            onChange: (Me) => {
              if (A(Me.target.value), Me.target.value.length === 0) return;
              const $ = Number(Me.target.value);
              isNaN($) || (c.onChange({ target: { value: { x: $, y: I } } }), $ < q.min && L({ min: $, max: q.max }));
            }
          }
        )
      ] }),
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { ref: f, children: "Y" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: t,
            type: "number",
            value: I,
            min: q.min,
            max: q.max,
            step: Fe,
            name: cs(),
            onChange: (Me) => {
              if (j(Me.target.value), Me.target.value.length === 0) return;
              const $ = Number(Me.target.value);
              isNaN($) || (c.onChange({ target: { value: { x: E, y: $ } } }), $ > q.max && L({ min: q.min, max: $ }));
            }
          }
        )
      ] }),
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { ref: v, children: "Min" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: n,
            type: "number",
            value: q.min,
            step: Fe,
            name: cs(),
            onChange: _e
          }
        )
      ] }),
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { ref: _, children: "Max" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: i,
            type: "number",
            value: q.max,
            step: Fe,
            name: cs(),
            onChange: Y
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ ke.jsxs("div", { className: "input", ref: o, onMouseDown: R, onMouseUp: J, children: [
      /* @__PURE__ */ ke.jsx("div", { className: "x" }),
      /* @__PURE__ */ ke.jsx("div", { className: "y" }),
      /* @__PURE__ */ ke.jsx("div", { className: "pt", ref: l })
    ] })
  ] });
}
const Ws = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Gpe = 1234567;
const hE = Math.PI / 180, Ub = 180 / Math.PI;
function Bd() {
  const c = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0;
  return (Ws[c & 255] + Ws[c >> 8 & 255] + Ws[c >> 16 & 255] + Ws[c >> 24 & 255] + "-" + Ws[e & 255] + Ws[e >> 8 & 255] + "-" + Ws[e >> 16 & 15 | 64] + Ws[e >> 24 & 255] + "-" + Ws[t & 63 | 128] + Ws[t >> 8 & 255] + "-" + Ws[t >> 16 & 255] + Ws[t >> 24 & 255] + Ws[n & 255] + Ws[n >> 8 & 255] + Ws[n >> 16 & 255] + Ws[n >> 24 & 255]).toLowerCase();
}
function Nn(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function C6(c, e) {
  return (c % e + e) % e;
}
function hg(c, e, t, n, i) {
  return n + (c - e) * (i - n) / (t - e);
}
function oMe(c, e, t) {
  return c !== e ? (t - c) / (e - c) : 0;
}
function Yp(c, e, t) {
  return (1 - t) * c + t * e;
}
function aMe(c, e, t, n) {
  return Yp(c, e, 1 - Math.exp(-t * n));
}
function lMe(c, e = 1) {
  return e - Math.abs(C6(c, e * 2) - e);
}
function uMe(c, e, t) {
  return c <= e ? 0 : c >= t ? 1 : (c = (c - e) / (t - e), c * c * (3 - 2 * c));
}
function cMe(c, e, t) {
  return c <= e ? 0 : c >= t ? 1 : (c = (c - e) / (t - e), c * c * c * (c * (c * 6 - 15) + 10));
}
function dMe(c, e) {
  return c + Math.floor(Math.random() * (e - c + 1));
}
function hMe(c, e) {
  return c + Math.random() * (e - c);
}
function pMe(c) {
  return c * (0.5 - Math.random());
}
function fMe(c) {
  c !== void 0 && (Gpe = c);
  let e = Gpe += 1831565813;
  return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296;
}
function TO(c) {
  return c * hE;
}
function Wge(c) {
  return c * Ub;
}
function mMe(c) {
  return (c & c - 1) === 0 && c !== 0;
}
function gMe(c) {
  return Math.pow(2, Math.ceil(Math.log(c) / Math.LN2));
}
function yMe(c) {
  return Math.pow(2, Math.floor(Math.log(c) / Math.LN2));
}
function vMe(c, e, t, n, i) {
  const o = Math.cos, l = Math.sin, p = o(t / 2), f = l(t / 2), v = o((e + n) / 2), _ = l((e + n) / 2), E = o((e - n) / 2), A = l((e - n) / 2), I = o((n - e) / 2), j = l((n - e) / 2);
  switch (i) {
    case "XYX":
      c.set(p * _, f * E, f * A, p * v);
      break;
    case "YZY":
      c.set(f * A, p * _, f * E, p * v);
      break;
    case "ZXZ":
      c.set(f * E, f * A, p * _, p * v);
      break;
    case "XZX":
      c.set(p * _, f * j, f * I, p * v);
      break;
    case "YXY":
      c.set(f * I, p * _, f * j, p * v);
      break;
    case "ZYZ":
      c.set(f * j, f * I, p * _, p * v);
      break;
    default:
      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i);
  }
}
function go(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return c / 4294967295;
    case Uint16Array:
      return c / 65535;
    case Uint8Array:
      return c / 255;
    case Int32Array:
      return Math.max(c / 2147483647, -1);
    case Int16Array:
      return Math.max(c / 32767, -1);
    case Int8Array:
      return Math.max(c / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function xn(c, e) {
  switch (e.constructor) {
    case Float32Array:
      return c;
    case Uint32Array:
      return Math.round(c * 4294967295);
    case Uint16Array:
      return Math.round(c * 65535);
    case Uint8Array:
      return Math.round(c * 255);
    case Int32Array:
      return Math.round(c * 2147483647);
    case Int16Array:
      return Math.round(c * 32767);
    case Int8Array:
      return Math.round(c * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const bMe = {
  DEG2RAD: hE,
  RAD2DEG: Ub,
  /**
   * Generate a [UUID]{@link https://en.wikipedia.org/wiki/Universally_unique_identifier}
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID: Bd,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp: Nn,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo: C6,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear: hg,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp: oMe,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp: Yp,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp]{@link http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/}.
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp: aMe,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong: lMe,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep]{@link http://en.wikipedia.org/wiki/Smoothstep} for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep: uMe,
  /**
   * A [variation on smoothstep]{@link https://en.wikipedia.org/wiki/Smoothstep#Variations}
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep: cMe,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt: dMe,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat: hMe,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread: pMe,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom: fMe,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad: TO,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg: Wge,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo: mMe,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo: gMe,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo: yMe,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles]{@link https://en.wikipedia.org/wiki/Euler_angles}
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler: vMe,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize: xn,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize: go
};
function qpe(c) {
  const e = c.value.x !== void 0 && c.value.y !== void 0 && c.value.z !== void 0, t = c.value.isEuler !== void 0, n = c.value.elements !== void 0, i = c.step !== void 0 ? c.step : 0.01, o = [];
  if (t) {
    const l = cE(() => c.value, []);
    ["_x", "_y", "_z"].forEach((f) => {
      const v = Yr(null);
      o.push(
        /* @__PURE__ */ ke.jsxs("div", { children: [
          /* @__PURE__ */ ke.jsx("span", { ref: v, children: f.substring(1).toUpperCase() }),
          /* @__PURE__ */ ke.jsx(
            wg,
            {
              value: Wge(l[f]),
              type: "number",
              prop: f,
              step: 0.1,
              labelRef: v,
              onChange: (_, E) => {
                l[_] = TO(E), c.onChange({ target: { value: l } });
              }
            }
          )
        ] }, f)
      );
    });
  } else if (e) {
    const l = cE(() => c.value, []), p = (v, _) => {
      l[v] = _, c.onChange({ target: { value: l } });
    };
    ["x", "y", "z"].forEach((v) => {
      const _ = Yr(null);
      o.push(
        /* @__PURE__ */ ke.jsxs("div", { children: [
          /* @__PURE__ */ ke.jsx("label", { ref: _, children: v.toUpperCase() }),
          /* @__PURE__ */ ke.jsx(
            wg,
            {
              value: l[v],
              type: "number",
              prop: v,
              step: i,
              labelRef: _,
              onChange: p
            }
          )
        ] }, v)
      );
    });
  } else if (n) {
    const l = cE(() => c.value, []), p = (f, v) => {
      const _ = Number(f);
      l.elements[_] = v, c.onChange({ target: { value: l } });
    };
    for (let f = 0; f < 9; f++) {
      const v = Yr(null);
      o.push(
        /* @__PURE__ */ ke.jsxs("div", { children: [
          /* @__PURE__ */ ke.jsx("label", { ref: v, children: f + 1 }),
          /* @__PURE__ */ ke.jsx(
            wg,
            {
              value: l.elements[f],
              type: "number",
              prop: f.toString(),
              step: i,
              labelRef: v,
              onChange: p
            }
          )
        ] }, f.toString())
      );
    }
  }
  return /* @__PURE__ */ ke.jsx("div", { className: "grid3", children: o }, Math.random().toString());
}
function xMe(c) {
  const e = c.value.x !== void 0, t = c.step !== void 0 ? c.step : 0.01, n = [];
  if (e) {
    const i = cE(() => c.value, []), o = (p, f) => {
      i[p] = f, c.onChange({ target: { value: i } });
    };
    ["x", "y", "z", "w"].forEach((p) => {
      const f = Yr(null);
      n.push(
        /* @__PURE__ */ ke.jsxs("div", { children: [
          /* @__PURE__ */ ke.jsx("label", { ref: f, children: p.toUpperCase() }),
          /* @__PURE__ */ ke.jsx(
            wg,
            {
              value: i[p],
              type: "number",
              prop: p,
              step: t,
              labelRef: f,
              onChange: o
            }
          )
        ] }, p)
      );
    });
  } else {
    const i = cE(() => c.value, []), o = (l, p) => {
      const f = Number(l);
      i.elements[f] = p, c.onChange({ target: { value: i } });
    };
    for (let l = 0; l < 16; l++) {
      const p = Yr(null);
      n.push(
        /* @__PURE__ */ ke.jsxs("div", { children: [
          /* @__PURE__ */ ke.jsx("span", { ref: p, children: l + 1 }),
          /* @__PURE__ */ ke.jsx(
            wg,
            {
              value: i.elements[l],
              type: "number",
              prop: l.toString(),
              step: t,
              labelRef: p,
              onChange: o
            }
          )
        ] }, l.toString())
      );
    }
  }
  return /* @__PURE__ */ ke.jsx("div", { className: "grid4", children: n });
}
function _Me(c) {
  return !(c === "defaultAttributeValues" || c === "forceSinglePass" || c === "linecap" || c === "linejoin" || c === "linewidth" || c === "normalMapType" || c === "precision" || c === "shadowSide" || c === "uniformsGroups" || c === "uniformsNeedUpdate" || c === "userData" || c === "version" || c === "wireframeLinecap" || c === "wireframeLinejoin" || c === "wireframeLinewidth" || c.slice(0, 4) === "clip" || c.slice(0, 7) === "polygon" || c.slice(0, 7) === "stencil" || c.slice(0, 2) === "is");
}
function SMe(c) {
  switch (c) {
    case "Alpha Map":
      return "alphaMap";
    case "Anisotropy Map":
      return "anisotropyMap";
    case "AO Map":
      return "aoMap";
    case "Bump Map":
      return "bumpMap";
    case "Clearcoat Map":
      return "clearcoatMap";
    case "Clearcoat Normal Map":
      return "clearcoatNormalMap";
    case "Clearcoat Roughness Map":
      return "clearcoatRoughnessMap";
    case "Displacement Map":
      return "displacementMap";
    case "Emissive Map":
      return "emissiveMap";
    case "Gradient Map":
      return "gradientMap";
    case "Iridescence Map":
      return "iridescenceMap";
    case "Iridescence Thickness Map":
      return "iridescenceThicknessMap";
    case "Map":
      return "map";
    case "Matcap":
      return "matcap";
    case "Normal Map":
      return "normalMap";
    case "Roughness Map":
      return "roughnessMap";
    case "Sheen Color Map":
      return "sheenColorMap";
    case "Sheen Roughness Map":
      return "sheenRoughnessMap";
    case "Specular Color Map":
      return "specularColorMap";
    case "Specular Map Intensity":
      return "specularIntensityMap";
    case "Thickness Map":
      return "thicknessMap";
    case "Transmission Map":
      return "transmissionMap";
  }
  return c;
}
function XO(c) {
  switch (c) {
    case "alphaHash":
      return "Alpha Hash";
    case "alphaMap":
      return "Alpha Map";
    case "alphaToCoverage":
      return "Alpha To Coverage";
    case "anisotropy":
      return "Anisotropy";
    case "anisotropyMap":
      return "Anisotropy Map";
    case "anisotropyRotation":
      return "Anisotropy Rotation";
    case "aoMap":
      return "AO Map";
    case "aoMapIntensity":
      return "AO Map Intensity";
    case "attenuationColor":
      return "Attenuation Color";
    case "attenuationDistance":
      return "Attenuation Distance";
    case "blendAlpha":
      return "Blend Alpha";
    case "blendColor":
      return "Blend Color";
    case "blendDst":
      return "Blend Dst";
    case "blendDstAlpha":
      return "Blend Dst Alha";
    case "blendEquation":
      return "Blend Equation";
    case "blendEquationAlpha":
      return "Blend Equation Alpha";
    case "blending":
      return "Blending";
    case "blendSrc":
      return "Blend Src";
    case "blendSrcAlpha":
      return "Blend Src Alpha";
    case "bumpMap":
      return "Bump Map";
    case "bumpScale":
      return "Bump Scale";
    case "clearcoat":
      return "Clearcoat";
    case "clearcoatMap":
      return "Clearcoat Map";
    case "clearcoatNormalMap":
      return "Clearcoat Normal Map";
    case "clearcoatNormalScale":
      return "Clearcoat Normal Scale";
    case "clearcoatRoughness":
      return "Clearcoat Roughness";
    case "clearcoatRoughnessMap":
      return "Clearcoat Roughness Map";
    case "color":
      return "Color";
    case "colorWrite":
      return "Color Write";
    case "defines":
      return "Defines";
    case "depthFunc":
      return "Depth Func";
    case "depthTest":
      return "Depth Test";
    case "depthWrite":
      return "Depth Write";
    case "dispersion":
      return "Dispersion";
    case "displacementBias":
      return "Displacement Bias";
    case "displacementMap":
      return "Displacement Map";
    case "displacementScale":
      return "Displacement Scale";
    case "dithering":
      return "Dithering";
    case "emissive":
      return "Emissive";
    case "emissiveMap":
      return "Emissive Map";
    case "emissiveIntensity":
      return "Emissive Intensity";
    case "envMap":
      return "Environment Map";
    case "envMapIntensity":
      return "Environment Map Intensity";
    case "envMapRotation":
      return "Environment Map Rotation";
    case "extensions":
      return "Extensions";
    case "flatShading":
      return "Flat Shading";
    case "fragmentShader":
      return "Fragment Shader";
    case "fog":
      return "Fog";
    case "glslVersion":
      return "GLSL Version";
    case "gradientMap":
      return "Gradient Map";
    case "ior":
      return "IOR";
    case "iridescence":
      return "Iridescence";
    case "iridescenceIOR":
      return "Iridescence IOR";
    case "iridescenceMap":
      return "Iridescence Map";
    case "iridescenceThicknessMap":
      return "Iridescence Thickness Map";
    case "iridescenceThicknessRange":
      return "Iridescence Thickness Range";
    case "lights":
      return "Lights";
    case "lightMap":
      return "Light Map";
    case "lightMapIntensity":
      return "Light Map Intensity";
    case "map":
      return "Map";
    case "matcap":
      return "Matcap";
    case "metalness":
      return "Metalness";
    case "metalnessMap":
      return "Metalness Map";
    case "name":
      return "Name";
    case "normalMap":
      return "Normal Map";
    case "normalScale":
      return "Normal Scale";
    case "premultipliedAlpha":
      return "Premultiplied Alpha";
    case "opacity":
      return "Opacity";
    case "reflectivity":
      return "Reflectivity";
    case "refractionRatio":
      return "Refraction Ratio";
    case "roughness":
      return "Roughness";
    case "roughnessMap":
      return "Roughness Map";
    case "sheen":
      return "Sheen";
    case "sheenColor":
      return "Sheen Color";
    case "sheenColorMap":
      return "Sheen Color Map";
    case "sheenRoughness":
      return "Sheen Roughness";
    case "sheenRoughnessMap":
      return "Sheen Roughness Map";
    case "shininess":
      return "Shininess";
    case "side":
      return "Side";
    case "size":
      return "Size";
    case "sizeAttenuation":
      return "Size Attenuation";
    case "specular":
      return "Specular";
    case "specularColor":
      return "Specular Color";
    case "specularColorMap":
      return "Specular Color Map";
    case "specularIntensity":
      return "Specular Intensity";
    case "specularIntensityMap":
      return "Specular Map Intensity";
    case "thickness":
      return "Thickness";
    case "thicknessMap":
      return "Thickness Map";
    case "toneMapped":
      return "Tone Mapped";
    case "transmission":
      return "Transmission";
    case "transmissionMap":
      return "Transmission Map";
    case "transparent":
      return "Transparent";
    case "type":
      return "Type";
    case "uuid":
      return "UUID";
    case "uniforms":
      return "Uniforms";
    case "vertexColors":
      return "Vertex Colors";
    case "vertexShader":
      return "Vertex Shader";
    case "visible":
      return "Visible";
    case "wireframe":
      return "Wireframe";
  }
  return c;
}
function Kge(c) {
  const e = c.toLowerCase();
  return e.search("intensity") > -1 || e === "anisotropyrotation" || e === "blendalpha" || e === "bumpscale" || e === "clearcoatroughness" || e === "displacementbias" || e === "displacementscale" || e === "metalness" || e === "opacity" || e === "reflectivity" || e === "refractionratio" || e === "roughness" || e === "sheenroughness";
}
function wMe() {
  const c = document.createElement("input");
  return c.type = "file", new Promise((e, t) => {
    c.addEventListener("change", function() {
      if (c.files === null)
        t();
      else {
        const n = c.files[0], i = new FileReader();
        i.onload = function(o) {
          e(o.target.result);
        }, i.readAsDataURL(n);
      }
    }), c.click();
  });
}
const EMe = [
  {
    title: "Front",
    value: MAe
  },
  {
    title: "Back",
    value: Tge
  },
  {
    title: "Double",
    value: S6
  }
], TMe = [
  {
    title: "No Blending",
    value: FAe
  },
  {
    title: "Normal",
    value: Sge
  },
  {
    title: "Additive",
    value: BAe
  },
  {
    title: "Subtractive",
    value: LAe
  },
  {
    title: "Multiply",
    value: jAe
  },
  {
    title: "Custom",
    value: KO
  }
], CMe = [
  {
    title: "Add",
    value: NE
  },
  {
    title: "Subtract",
    value: IAe
  },
  {
    title: "Reverse Subtract",
    value: NAe
  },
  {
    title: "Min",
    value: OAe
  },
  {
    title: "Max",
    value: DAe
  }
], PMe = [
  {
    title: "Zero",
    value: Cge
  },
  {
    title: "One",
    value: YO
  },
  {
    title: "Src Color",
    value: Pge
  },
  {
    title: "One Minus Src Color",
    value: Age
  },
  {
    title: "Src Alpha",
    value: $O
  },
  {
    title: "One Minus Src Alpha",
    value: WO
  },
  {
    title: "Dst Alpha",
    value: kge
  },
  {
    title: "One Minus Dst Alpha",
    value: Mge
  },
  {
    title: "Dst Color",
    value: x6
  },
  {
    title: "One Minus Dst Color",
    value: _6
  },
  {
    title: "Src Alpha Saturate",
    value: RAe
  },
  {
    title: "Constant Color",
    value: Rge
  },
  {
    title: "One Minus Constant Color",
    value: Ige
  },
  {
    title: "Constant Alpha",
    value: Nge
  },
  {
    title: "One Minus Constant Alpha",
    value: Oge
  }
], AMe = [
  {
    title: "Zero",
    value: Cge
  },
  {
    title: "One",
    value: YO
  },
  {
    title: "Src Color",
    value: Pge
  },
  {
    title: "One Minus Src Color",
    value: Age
  },
  {
    title: "Src Alpha",
    value: $O
  },
  {
    title: "One Minus Src Alpha",
    value: WO
  },
  {
    title: "Dst Alpha",
    value: kge
  },
  {
    title: "One Minus Dst Alpha",
    value: Mge
  },
  {
    title: "Dst Color",
    value: x6
  },
  {
    title: "One Minus Dst Color",
    value: _6
  },
  {
    title: "Constant Color",
    value: Rge
  },
  {
    title: "One Minus Constant Color",
    value: Ige
  },
  {
    title: "Constant Alpha",
    value: Nge
  },
  {
    title: "One Minus Constant Alpha",
    value: Oge
  }
];
function Cw(c, e) {
  c.needsUpdate = !0, c.type = "option", c.options = e;
}
function kMe(c, e, t, n) {
  return {
    type: "boolean",
    title: XO(c),
    prop: c,
    value: e,
    needsUpdate: !0,
    onChange: (i, o) => {
      n.updateObject(t.uuid, `material.${c}`, o), n.updateObject(t.uuid, "material.needsUpdate", !0);
      const l = n.getScene(t.uuid);
      if (l !== null) {
        const p = l.getObjectByProperty("uuid", t.uuid);
        bi(p, `material.${c}`, o);
      }
    }
  };
}
function MMe(c, e, t, n) {
  const i = {
    type: "number",
    title: XO(c),
    prop: c,
    value: e,
    min: void 0,
    max: void 0,
    step: 0.01,
    needsUpdate: !0,
    onChange: (o, l) => {
      n.updateObject(t.uuid, `material.${c}`, l), n.updateObject(t.uuid, "material.needsUpdate", !0);
      const p = n.getScene(t.uuid);
      if (p !== null) {
        const f = p.getObjectByProperty("uuid", t.uuid);
        bi(f, `material.${c}`, l);
      }
    }
  };
  switch (c) {
    case "blending":
      Cw(i, TMe);
      break;
    case "blendDst":
      Cw(i, AMe);
      break;
    case "blendEquation":
      Cw(i, CMe);
      break;
    case "blendSrc":
      Cw(i, PMe);
      break;
    case "side":
      Cw(i, EMe);
      break;
  }
  return Kge(c) && (i.value = Number(e), i.type = "range", i.min = Math.min(0, i.value), i.max = Math.max(1, i.value), i.step = 0.01), i;
}
function RMe(c, e, t, n) {
  const i = {
    type: "string",
    title: XO(c),
    prop: c,
    value: e,
    needsUpdate: !0,
    onChange: (l, p) => {
      n.updateObject(t.uuid, `material.${c}`, p), n.updateObject(t.uuid, "material.needsUpdate", !0);
      const f = n.getScene(t.uuid);
      if (f !== null) {
        const v = f.getObjectByProperty("uuid", t.uuid);
        bi(v, `material.${c}`, p);
      }
    },
    onKeyDown: (l) => {
    }
  };
  return (c === "vertexShader" || c === "fragmentShader") && (i.type = "field", i.disabled = !1, i.latest = i.value, i.onChange = (l, p) => {
    i.latest = p, n.updateObject(t.uuid, `material.${c}`, p);
    const f = n.getScene(t.uuid);
    if (f !== null) {
      const v = f.getObjectByProperty("uuid", t.uuid);
      bi(v, `material.${c}`, p);
    }
  }, i.onKeyDown = (l) => {
    if (l.key === "Enter" && (l.altKey || l.metaKey)) {
      n.updateObject(t.uuid, "material.needsUpdate", !0);
      const p = n.getScene(t.uuid);
      if (p !== null) {
        const f = p.getObjectByProperty("uuid", t.uuid);
        bi(f, "material.needsUpdate", !0);
      }
    }
  }), i;
}
function IMe(c) {
  return c.x !== void 0 && c.y !== void 0 && c.z === void 0;
}
function NMe(c) {
  return c.x !== void 0 && c.y !== void 0 && c.z !== void 0 && c.w === void 0;
}
function OMe(c) {
  return c.x !== void 0 && c.y !== void 0 && c.z !== void 0 && c.w !== void 0;
}
function LV(c) {
  c.sort((e, t) => e.title < t.title ? -1 : e.title > t.title ? 1 : 0);
}
function tE(c, e, t, n, i = "", o = !1) {
  const l = XO(c).split(".")[0].replaceAll("[", "").replaceAll("]", ""), p = i.length > 0 ? `${i}.${c}` : c, f = typeof e;
  if (f === "boolean" || f === "string")
    return {
      title: l,
      prop: p,
      type: f,
      value: e,
      disabled: o,
      onChange: (v, _) => {
        n.updateObject(t.uuid, `material.${p}`, _);
        const E = n.getScene(t.uuid);
        if (E !== null) {
          const A = E.getObjectByProperty("uuid", t.uuid);
          bi(A, `material.${p}`, _);
        }
      }
    };
  if (f === "number") {
    const v = {
      title: l,
      prop: p,
      type: "number",
      value: e,
      step: 0.01,
      disabled: o,
      onChange: (_, E) => {
        n.updateObject(t.uuid, `material.${p}`, E);
        const A = n.getScene(t.uuid);
        if (A !== null) {
          const I = A.getObjectByProperty("uuid", t.uuid);
          bi(I, `material.${p}`, E);
        }
      }
    };
    return Kge(l) && (v.type = "range", v.min = 0, v.max = 1), v;
  } else {
    if (e.isColor)
      return {
        title: l,
        prop: p,
        type: "color",
        value: e,
        disabled: o,
        onChange: (v, _) => {
          const E = new Ag(_);
          n.updateObject(t.uuid, `material.${p}`, E);
          const A = n.getScene(t.uuid);
          if (A !== null) {
            const I = A.getObjectByProperty("uuid", t.uuid);
            bi(I, `material.${p}`, E);
          }
        }
      };
    if (Array.isArray(e)) {
      const v = [];
      for (const _ in e) {
        const E = e[_], A = `[${_.toString()}]`;
        if (E.value !== void 0) {
          const I = tE(`${A}.value`, E.value, t, n, p, o);
          I !== void 0 && v.push(I);
        } else {
          const I = tE(A, E, t, n, p, o);
          I !== void 0 && v.push(I);
        }
      }
      if (v.length > 0)
        return LV(v), {
          title: l,
          items: v
        };
    } else {
      if (IMe(e))
        return {
          title: l,
          prop: p,
          type: "vector2",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            n.updateObject(t.uuid, `material.${p}`, _);
            const E = n.getScene(t.uuid);
            if (E !== null) {
              const A = E.getObjectByProperty("uuid", t.uuid);
              bi(A, `material.${p}`, _);
            }
          }
        };
      if (NMe(e))
        return {
          title: l,
          prop: p,
          type: "grid3",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            n.updateObject(t.uuid, `material.${p}`, _);
            const E = n.getScene(t.uuid);
            if (E !== null) {
              const A = E.getObjectByProperty("uuid", t.uuid);
              bi(A, `material.${p}`, _);
            }
          }
        };
      if (OMe(e))
        return {
          title: l,
          prop: p,
          type: "grid4",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            n.updateObject(t.uuid, `material.${p}`, _);
            const E = n.getScene(t.uuid);
            if (E !== null) {
              const A = E.getObjectByProperty("uuid", t.uuid);
              bi(A, `material.${p}`, _);
            }
          }
        };
      if (e.isEuler)
        return {
          title: l,
          prop: p,
          type: "euler",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            n.updateObject(t.uuid, `material.${p}`, _);
            const E = n.getScene(t.uuid);
            if (E !== null) {
              const A = E.getObjectByProperty("uuid", t.uuid);
              bi(A, `material.${p}`, _);
            }
          }
        };
      if (e.src !== void 0)
        return {
          title: l,
          type: "image",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            const E = SMe(c), A = i.length > 0 ? `${i}.${E}` : E;
            n.createTexture(t.uuid, `material.${A}`, _);
            const I = n.getScene(t.uuid);
            if (I !== null) {
              const j = I.getObjectByProperty("uuid", t.uuid);
              if (j !== void 0) {
                const q = (L) => {
                  const V = j.material, re = A.split(".");
                  switch (re.length) {
                    case 1:
                      V[re[0]] = L;
                      break;
                    case 2:
                      V[re[0]][re[1]] = L;
                      break;
                    case 3:
                      V[re[0]][re[1]][re[2]] = L;
                      break;
                    case 4:
                      V[re[0]][re[1]][re[2]][re[3]] = L;
                      break;
                    case 5:
                      V[re[0]][re[1]][re[2]][re[3]][re[4]] = L;
                      break;
                  }
                  V.needsUpdate = !0;
                };
                _.src.length > 0 ? qge(_.src).then((L) => {
                  L.offset.set(_.offset[0], _.offset[1]), L.repeat.set(_.repeat[0], _.repeat[1]), q(L);
                }) : q(null);
              }
            }
          }
        };
      if (e.elements !== void 0)
        return {
          title: l,
          prop: p,
          type: e.elements.length > 9 ? "grid4" : "grid3",
          value: e,
          disabled: o,
          onChange: (v, _) => {
            n.updateObject(t.uuid, `material.${p}`, _);
            const E = n.getScene(t.uuid);
            if (E !== null) {
              const A = E.getObjectByProperty("uuid", t.uuid);
              bi(A, `material.${p}`, _);
            }
          }
        };
      {
        const v = [], _ = c === "defines" || c === "extensions";
        try {
          for (const E in e) {
            const A = e[E];
            if (A !== void 0)
              if (A.value !== void 0) {
                const I = tE(`${E}.value`, A.value, t, n, p, _);
                I !== void 0 && v.push(I);
              } else {
                const I = tE(E, A, t, n, p, _);
                I !== void 0 && v.push(I);
              }
          }
        } catch {
          console.log("Hermes - Issue cycling through material object:", c, e);
        }
        if (v.length > 0)
          return LV(v), {
            title: l,
            items: v
          };
      }
    }
  }
}
function Hpe(c, e, t) {
  const n = [];
  for (const i in c) {
    if (!_Me(i)) continue;
    const o = typeof c[i], l = c[i];
    if (o === "boolean")
      n.push(kMe(i, l, e, t));
    else if (o === "number")
      n.push(MMe(i, l, e, t));
    else if (o === "string")
      n.push(RMe(i, l, e, t));
    else if (o === "object") {
      const p = tE(i, l, e, t);
      p !== void 0 && n.push(p);
    } else l !== void 0 && console.log("Hermes - Other Material Prop Type:", i, o, l);
  }
  return LV(n), n.push({
    title: "Update Material",
    type: "button",
    onChange: () => {
      t.updateObject(e.uuid, "material.needsUpdate", !0);
      const i = t.getScene(e.uuid);
      if (i !== null) {
        const o = i.getObjectByProperty("uuid", e.uuid);
        bi(o, "material.needsUpdate", !0);
      }
    }
  }), n;
}
function DMe(c, e) {
  function t() {
    return `${e.name}_material`;
  }
  const n = localStorage.getItem(t()), i = n !== null ? n === "open" : !1;
  function o(p) {
    localStorage.setItem(t(), p ? "open" : "closed");
  }
  const l = c.material;
  if (Array.isArray(l)) {
    const p = [], f = l.length;
    for (let v = 0; v < f; v++)
      p.push(
        /* @__PURE__ */ ke.jsx(
          dl,
          {
            three: e,
            title: `Material ${v}`,
            items: Hpe(l[v], c, e)
          },
          `Material ${v}`
        )
      );
    return /* @__PURE__ */ ke.jsx(ke.Fragment, { children: p });
  } else
    return /* @__PURE__ */ ke.jsx(
      dl,
      {
        three: e,
        title: "Material",
        items: Hpe(l, c, e),
        expanded: i,
        onToggle: (p) => {
          o(p);
        }
      }
    );
}
const $pe = "data:image/gif;base64,R0lGODlhDgFkAIAAAP///wAAACH/C1hNUCBEYXRhWE1QPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgOS4xLWMwMDIgNzkuZGJhM2RhM2I1LCAyMDIzLzEyLzE1LTEwOjQyOjM3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIiB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjUuNiAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoyMDk3M0NEODAxQjQxMUVGODVGNENDMkUyMUExNDk1NSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoyMDk3M0NEOTAxQjQxMUVGODVGNENDMkUyMUExNDk1NSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkE4ODc3Qzg5MDFCMzExRUY4NUY0Q0MyRTIxQTE0OTU1IiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkE4ODc3QzhBMDFCMzExRUY4NUY0Q0MyRTIxQTE0OTU1Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Af/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQAAIfkEAAAAAAAsAAAAAA4BZAAAAv+Mj6nL7Q+jnLTai7PevPsPhuJIluaJpurKtu4Lx/JM1/aN5/rO9/4PDAqHxKLxiEwql8ym8wmNSqfUqvWKzWq33K73Cw6Lx+Sy+YxOq9fstvsNj8vn9Lr9js/r9/y+/w8YKDhIWGh4iJiouMjY6PgIGSk5SVlpeYmZqTkJAGDQ+dnpuekmGgAKejpKuiZqmprKqoZKGyrbOlqrejub6xvLGyw8TFzcprurGuvqybxq7ETbrItsCz0l7Zpc+6p9/cS967w9/S2FTF0u/mzehK4Oqz3eTl9vf4+fr7/P3+//DzCgwIEECxo8iDChwoUMGzp8CDGixIkUK1q8iDGjxo0XHDt6/AgypMiRJEuaPIkypcqVLFt+KwAAOw==";
function FMe(c) {
  const e = c.step !== void 0 ? c.step : 0.01, t = Yr(null), n = Yr(null), i = Yr(null), o = Yr(null), l = Yr(null), [p] = nr(c.value), [f, v] = nr(c.value.offset[0]), [_, E] = nr(c.value.offset[1]), [A, I] = nr(c.value.repeat[0]), [j, q] = nr(c.value.repeat[1]);
  function L(re, R, J, ge, _e) {
    if (c.onChange !== void 0) {
      const Y = c.prop !== void 0 ? c.prop : c.title;
      c.onChange(Y, {
        src: re,
        offset: [R, J],
        repeat: [ge, _e]
      });
    }
  }
  function V(re) {
    const R = t.current.src, J = re.target.value;
    switch (re.target) {
      case n.current:
        v(J), L(R, J, _, A, j);
        break;
      case i.current:
        E(J), L(R, f, J, A, j);
        break;
      case o.current:
        I(J), L(R, f, _, J, j);
        break;
      case l.current:
        q(J), L(R, f, _, A, J);
        break;
    }
  }
  return /* @__PURE__ */ ke.jsxs("div", { className: "imageField", children: [
    /* @__PURE__ */ ke.jsx("img", { alt: c.title, ref: t, onClick: () => {
      wMe().then((re) => {
        t.current.src = re, L(re, f, _, A, j);
      });
    }, src: p.src.length > 0 ? p.src : $pe }),
    /* @__PURE__ */ ke.jsxs("div", { className: "fields", children: [
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { children: "Offset:" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: n,
            type: "number",
            value: f,
            step: e,
            name: cs(),
            onChange: V
          }
        ),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: i,
            type: "number",
            value: _,
            step: e,
            name: cs(),
            onChange: V
          }
        )
      ] }),
      /* @__PURE__ */ ke.jsxs("div", { children: [
        /* @__PURE__ */ ke.jsx("span", { children: "Repeat:" }),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: o,
            type: "number",
            value: A,
            step: e,
            name: cs(),
            onChange: V
          }
        ),
        /* @__PURE__ */ ke.jsx(
          "input",
          {
            ref: l,
            type: "number",
            value: j,
            step: e,
            name: cs(),
            onChange: V
          }
        )
      ] }),
      /* @__PURE__ */ ke.jsx("button", { onClick: () => {
        L("", f, _, A, j), t.current.src = $pe;
      }, children: "Clear" })
    ] })
  ] });
}
function cO(c) {
  let e = c.value;
  e !== void 0 && (e.isColor !== void 0 ? e = Rpe(c.value) : c.type === "color" && (e = Rpe(new Ag().setStyle(c.value, xE))));
  const [t, n] = nr(e), i = Yr(null), o = (v) => {
    let _ = v.target.value;
    if (c.type === "boolean")
      _ = v.target.checked;
    else if (c.type === "option" && (typeof c.value == "number" ? _ = Number(_) : typeof c.value == "boolean" ? _ = !!_ : typeof c.value == "object" && (_ = JSON.parse(_)), c.options !== void 0)) {
      const E = c.options.length;
      for (let A = 0; A < E && c.options[A].value !== _; A++)
        ;
    }
    n(_), c.onChange !== void 0 && c.onChange(c.prop !== void 0 ? c.prop : c.title, _);
  }, l = {};
  c.disabled && (l.opacity = 0.8);
  const p = c.type === "field" || c.type === "string" && (t.length > 100 || t.search(`
`) > -1), f = p || c.type === "image" || c.type === "vector2";
  return /* @__PURE__ */ ke.jsxs("div", { className: `field ${f ? "block" : ""}`, style: l, children: [
    c.type !== "button" && /* @__PURE__ */ ke.jsx("span", { ref: i, children: EO(c.title) }, "fieldLabel"),
    c.type === "string" && !p && /* @__PURE__ */ ke.jsx(
      "input",
      {
        type: "text",
        disabled: c.disabled,
        onChange: o,
        value: t,
        name: cs()
      }
    ),
    (c.type === "field" || c.type === "string" && p) && /* @__PURE__ */ ke.jsx(
      "textarea",
      {
        cols: 50,
        rows: 10,
        disabled: c.disabled !== void 0 ? c.disabled : !0,
        onChange: o,
        onKeyDown: (v) => {
          c.onKeyDown !== void 0 && c.onKeyDown(v);
        },
        value: t,
        name: cs()
      }
    ),
    c.type === "boolean" && /* @__PURE__ */ ke.jsx(
      "input",
      {
        type: "checkbox",
        disabled: c.disabled,
        onChange: o,
        checked: t,
        name: cs()
      }
    ),
    c.type === "number" && /* @__PURE__ */ ke.jsx(
      wg,
      {
        value: t,
        type: c.type,
        prop: c.prop !== void 0 ? c.prop : c.title,
        min: c.min,
        max: c.max,
        step: c.step,
        disabled: c.disabled,
        labelRef: i,
        onChange: c.onChange
      }
    ),
    c.type === "range" && /* @__PURE__ */ ke.jsx(
      wg,
      {
        value: t,
        type: c.type,
        prop: c.prop !== void 0 ? c.prop : c.title,
        min: c.min,
        max: c.max,
        step: c.step,
        disabled: c.disabled,
        labelRef: i,
        onChange: c.onChange
      }
    ),
    c.type === "color" && /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
      /* @__PURE__ */ ke.jsx("input", { type: "text", value: t.toString(), onChange: o, disabled: c.disabled, className: "color", name: cs() }),
      /* @__PURE__ */ ke.jsx("input", { type: "color", value: t, onChange: o, disabled: c.disabled, name: cs() })
    ] }),
    c.type === "button" && /* @__PURE__ */ ke.jsx(
      "button",
      {
        disabled: c.disabled,
        onClick: () => {
          c.onChange !== void 0 && c.onChange(c.prop !== void 0 ? c.prop : c.title, !0);
        },
        children: c.title
      }
    ),
    c.type === "image" && /* @__PURE__ */ ke.jsx(FMe, { title: c.title, prop: c.prop, value: c.value, onChange: c.onChange }),
    c.type === "option" && /* @__PURE__ */ ke.jsx(ke.Fragment, { children: /* @__PURE__ */ ke.jsx(
      "select",
      {
        onChange: o,
        disabled: c.disabled,
        defaultValue: c.value,
        name: cs(),
        children: c.options?.map((v, _) => /* @__PURE__ */ ke.jsx("option", { value: v.value, children: EO(v.title) }, _))
      }
    ) }),
    c.type === "vector2" && /* @__PURE__ */ ke.jsx(sMe, { step: c.step, value: t, min: 0, max: 1, onChange: o }),
    c.type === "grid3" && /* @__PURE__ */ ke.jsx(qpe, { step: c.step, value: t, onChange: o }),
    c.type === "grid4" && /* @__PURE__ */ ke.jsx(xMe, { step: c.step, value: t, onChange: o }),
    c.type === "euler" && /* @__PURE__ */ ke.jsx(qpe, { step: c.step, value: t, onChange: o })
  ] });
}
function BMe(c) {
  return "items" in c;
}
class dl extends RE {
  subgroupNames = [];
  subgroupElements = [];
  valueOverrides = /* @__PURE__ */ new Map();
  three;
  constructor(e) {
    super(e), this.three = e.three, this.state = { lastUpdated: Date.now() };
  }
  addGroup(e) {
    const t = [];
    e.items.forEach((o) => {
      t.push({
        type: o.type,
        prop: o.prop,
        title: o.title !== void 0 ? o.title : o.prop,
        value: o.value,
        min: o.min,
        max: o.max,
        step: o.step,
        options: o.options,
        disabled: o.disabled,
        onChange: (l, p) => {
          e.onUpdate(l, p);
        }
      });
    });
    const n = zp(), i = /* @__PURE__ */ ke.jsx(
      dl,
      {
        three: this.props.three,
        ref: n,
        title: e.title,
        expanded: e.expanded,
        items: t
      },
      Math.random()
    );
    return this.subgroupNames.push(e.title), this.subgroupElements.push(i), this.setState({ lastUpdated: Date.now() }), n;
  }
  removeGroup(e) {
    const t = this.subgroupNames.length;
    for (let n = 0; n < t; n++) {
      const i = this.subgroupNames[n];
      if (e === i) {
        this.subgroupNames.splice(n, 1), this.subgroupElements.splice(n, 1), this.setState({ lastUpdated: Date.now() });
        return;
      }
    }
  }
  setField(e, t) {
    this.valueOverrides.set(e, t), this.setState({ lastUpdated: Date.now() });
  }
  render() {
    const e = [];
    return this.props.items.forEach((t) => {
      if (BMe(t))
        e.push(
          /* @__PURE__ */ ke.jsx(dl, { three: this.props.three, title: EO(t.title), items: t.items }, Math.random())
        );
      else {
        const n = this.valueOverrides.get(t.title), i = n !== void 0 ? n : t.value;
        e.push(
          /* @__PURE__ */ ke.jsx(
            cO,
            {
              title: t.title,
              prop: t.prop,
              value: i,
              type: t.type,
              min: t.min,
              max: t.max,
              step: t.step,
              disabled: t.disabled,
              options: t.options,
              onChange: (o, l) => {
                t.onChange !== void 0 && (this.valueOverrides.delete(t.title), t.onChange(o, l));
              },
              onKeyDown: (o) => {
                t.onKeyDown !== void 0 && t.onKeyDown(o);
              }
            },
            Math.random()
          )
        );
      }
    }), this.subgroupElements.forEach((t) => e.push(t)), /* @__PURE__ */ ke.jsx(
      dE,
      {
        three: this.props.three,
        label: this.props.title,
        open: this.props.expanded === !0,
        onToggle: (t) => {
          this.props.onToggle && this.props?.onToggle(t);
        },
        children: e
      }
    );
  }
}
class Vn extends RE {
  static instance;
  static groups = [];
  static groupsRefs = [];
  static groupTitles = [];
  static three;
  constructor(e) {
    super(e), this.state = { lastUpdate: Date.now() }, Vn.instance = this, Vn.three = e.three, e.three.addEventListener(Cn.ADD_GROUP, this.addGroup), e.three.addEventListener(Cn.REMOVE_GROUP, this.removeGroup);
  }
  componentWillUnmount() {
    this.props.three.removeEventListener(Cn.ADD_GROUP, this.addGroup), this.props.three.removeEventListener(Cn.REMOVE_GROUP, this.removeGroup);
  }
  render() {
    return /* @__PURE__ */ ke.jsx("div", { className: "customGroups", children: Vn.groups }, this.state.lastUpdate);
  }
  // Events
  addGroup = (e) => {
    const t = JSON.parse(e.value), n = [];
    t.items.forEach((i) => {
      n.push({
        type: i.type,
        prop: i.prop,
        title: i.title !== void 0 ? i.title : i.prop,
        value: i.value,
        min: i.min,
        max: i.max,
        step: i.step,
        options: i.options,
        disabled: i.disabled,
        onChange: (o, l) => {
          this.props.three.updateGroup(t.title, o, l);
        }
      });
    }), Vn.groups.push(
      /* @__PURE__ */ ke.jsx(
        dl,
        {
          three: this.props.three,
          title: t.title,
          items: n
        },
        Math.random()
      )
    ), Vn.groupTitles.push(t.title), this.setState({ lastUpdate: Date.now() });
  };
  removeGroup = (e) => {
    const t = e.value, n = Vn.groupTitles.length;
    for (let i = 0; i < n; i++)
      if (t === Vn.groupTitles[i]) {
        Vn.groups.splice(i, 1), Vn.groupTitles.splice(i, 1), this.setState({ lastUpdate: Date.now() });
        return;
      }
  };
  // Static
  static addEditorGroup(e) {
    const t = Vn.groupTitles.length;
    for (let l = 0; l < t; l++)
      if (Vn.groupTitles[l] === e.title)
        return Vn.groupsRefs[l];
    const n = [];
    e.items.forEach((l) => {
      n.push({
        type: l.type,
        prop: l.prop,
        title: l.title !== void 0 ? l.title : l.prop,
        value: l.value,
        min: l.min,
        max: l.max,
        step: l.step,
        options: l.options,
        disabled: l.disabled,
        onChange: (p, f) => {
          e.onUpdate(p, f);
        }
      });
    }), e.subgroups && e.subgroups.length > 0 && e.subgroups.forEach((l) => {
      const p = [];
      l.items.forEach((f) => {
        p.push({
          type: f.type,
          prop: f.prop,
          title: f.title !== void 0 ? f.title : f.prop,
          value: f.value,
          min: f.min,
          max: f.max,
          step: f.step,
          options: f.options,
          disabled: f.disabled,
          onChange: (v, _) => {
            l.onUpdate(v, _);
          }
        });
      }), n.push({
        three: Vn.three,
        title: l.title,
        expanded: l.expanded,
        items: p
      });
    });
    const i = zp(), o = /* @__PURE__ */ ke.jsx(
      dl,
      {
        three: Vn.three,
        ref: i,
        title: e.title,
        expanded: e.expanded,
        items: n
      },
      Math.random()
    );
    return Vn.groups.push(o), Vn.groupsRefs.push(i), Vn.groupTitles.push(e.title), setTimeout(() => {
      Vn.instance.setState({ lastUpdate: Date.now() });
    }, 0), i;
  }
  static removeEditorGroup(e) {
    const t = Vn.groupTitles.length;
    for (let n = 0; n < t; n++)
      if (e === Vn.groupTitles[n]) {
        Vn.groups.splice(n, 1), Vn.groupTitles.splice(n, 1), Vn.instance.setState({ lastUpdate: Date.now() });
        return;
      }
  }
  static removeAllGroups() {
    for (let e = Vn.groupTitles.length; e > 0; e--)
      Vn.groups.splice(e, 1), Vn.groupTitles.splice(e, 1);
    Vn.instance.setState({ lastUpdate: Date.now() });
  }
}
function Wpe(c) {
  switch (c) {
    case "fov":
      return "FOV";
    case "zoom":
      return "Zoom";
    case "near":
      return "Near";
    case "far":
      return "Far";
    case "focus":
      return "Focus";
    case "aspect":
      return "Aspect";
    case "filmGauge":
      return "Film Gauge";
    case "filmOffset":
      return "Film Offset";
    case "left":
      return "Left";
    case "right":
      return "Right";
    case "top":
      return "Top";
    case "bottom":
      return "Bottom";
  }
  return c;
}
function LMe(c, e) {
  function t() {
    return `${e.name}_camera`;
  }
  const n = localStorage.getItem(t()), i = n !== null ? n === "open" : !1;
  function o(p) {
    localStorage.setItem(t(), p ? "open" : "closed");
  }
  const l = [];
  if (c.perspectiveCameraInfo !== void 0)
    for (const p in c.perspectiveCameraInfo)
      l.push({
        title: Wpe(p),
        prop: p,
        type: "number",
        step: 0.01,
        value: c.perspectiveCameraInfo[p],
        onChange: (f, v) => {
          e.updateObject(c.uuid, f, v), e.requestMethod(c.uuid, "updateProjectionMatrix");
          const _ = e.getScene(c.uuid);
          if (_ !== null) {
            const E = _.getObjectByProperty("uuid", c.uuid);
            E !== void 0 && (bi(E, f, v), E.updateProjectionMatrix());
          }
        }
      });
  else if (c.orthographicCameraInfo !== void 0)
    for (const p in c.orthographicCameraInfo)
      l.push({
        title: Wpe(p),
        prop: p,
        type: "number",
        step: 0.01,
        value: c.orthographicCameraInfo[p],
        onChange: (f, v) => {
          e.updateObject(c.uuid, f, v), e.requestMethod(c.uuid, "updateProjectionMatrix");
          const _ = e.getScene(c.uuid);
          if (_ !== null) {
            const E = _.getObjectByProperty("uuid", c.uuid);
            E !== void 0 && (bi(E, f, v), E.updateProjectionMatrix());
          }
        }
      });
  return /* @__PURE__ */ ke.jsx(
    dl,
    {
      three: e,
      title: "Camera",
      items: l,
      expanded: i,
      onToggle: (p) => {
        o(p);
      }
    }
  );
}
class jMe {
  /**
   * Constructs a new animation loop management component.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t) {
    this.nodes = e, this.info = t, this._context = typeof self < "u" ? self : null, this._animationLoop = null, this._requestId = null;
  }
  /**
   * Starts the internal animation loop.
   */
  start() {
    const e = (t, n) => {
      this._requestId = this._context.requestAnimationFrame(e), this.info.autoReset === !0 && this.info.reset(), this.nodes.nodeFrame.update(), this.info.frame = this.nodes.nodeFrame.frameId, this._animationLoop !== null && this._animationLoop(t, n);
    };
    e();
  }
  /**
   * Stops the internal animation loop.
   */
  stop() {
    this._context.cancelAnimationFrame(this._requestId), this._requestId = null;
  }
  /**
   * Returns the user-level animation loop.
   *
   * @return {?Function} The animation loop.
   */
  getAnimationLoop() {
    return this._animationLoop;
  }
  /**
   * Defines the user-level animation loop.
   *
   * @param {?Function} callback - The animation loop.
   */
  setAnimationLoop(e) {
    this._animationLoop = e;
  }
  /**
   * Returns the animation context.
   *
   * @return {Window|XRSession} The animation context.
   */
  getContext() {
    return this._context;
  }
  /**
   * Defines the context in which `requestAnimationFrame()` is executed.
   *
   * @param {Window|XRSession} context - The context to set.
   */
  setContext(e) {
    this._context = e;
  }
  /**
   * Frees all internal resources and stops the animation loop.
   */
  dispose() {
    this.stop();
  }
}
class hu {
  /**
   * Constructs a new Chain Map.
   */
  constructor() {
    this.weakMap = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the value for the given array of keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @return {any} The value. Returns `undefined` if no value was found.
   */
  get(e) {
    let t = this.weakMap;
    for (let n = 0; n < e.length - 1; n++)
      if (t = t.get(e[n]), t === void 0) return;
    return t.get(e[e.length - 1]);
  }
  /**
   * Sets the value for the given keys.
   *
   * @param {Array<Object>} keys - List of keys.
   * @param {any} value - The value to set.
   * @return {ChainMap} A reference to this Chain Map.
   */
  set(e, t) {
    let n = this.weakMap;
    for (let i = 0; i < e.length - 1; i++) {
      const o = e[i];
      n.has(o) === !1 && n.set(o, /* @__PURE__ */ new WeakMap()), n = n.get(o);
    }
    return n.set(e[e.length - 1], t), this;
  }
  /**
   * Deletes a value for the given keys.
   *
   * @param {Array<Object>} keys - The keys.
   * @return {boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
   */
  delete(e) {
    let t = this.weakMap;
    for (let n = 0; n < e.length - 1; n++)
      if (t = t.get(e[n]), t === void 0) return !1;
    return t.delete(e[e.length - 1]);
  }
}
const Yge = "177", UMe = 0, zMe = 1, VMe = 2, GMe = 0, qMe = 1, dO = 3, Ld = 0, Ko = 1, Mb = 2, zb = 0, jd = 1, CO = 2, PO = 3, AO = 4, pE = 5, uu = 100, Xge = 101, Qge = 102, HMe = 103, $Me = 104, Vp = 200, Zge = 201, Jge = 202, eye = 203, kO = 204, MO = 205, tye = 206, nye = 207, rye = 208, iye = 209, sye = 210, oye = 0, aye = 1, lye = 2, RO = 3, uye = 4, cye = 5, dye = 6, hye = 7, QO = 0, WMe = 1, KMe = 2, Rb = 0, YMe = 1, XMe = 2, QMe = 3, ZMe = 4, JMe = 6, eRe = 7, P6 = 300, wE = 301, IO = 302, A6 = 303, k6 = 304, jV = 306, Vb = 1e3, Kp = 1001, Gb = 1002, $i = 1003, pye = 1004, EE = 1005, Ea = 1006, UV = 1007, Ud = 1008, yo = 1009, fE = 1010, mE = 1011, wb = 1012, fo = 1013, xi = 1014, wa = 1015, ol = 1016, tRe = 1017, nRe = 1018, Xp = 1020, fye = 35902, rRe = 1021, M6 = 1022, al = 1023, xc = 1026, zd = 1027, R6 = 1028, I6 = 1029, _g = 1030, N6 = 1031, iRe = 1032, O6 = 1033, u5 = 33776, hO = 33777, pO = 33778, fO = 33779, Kpe = 35840, Ype = 35841, Xpe = 35842, Qpe = 35843, Zpe = 36196, zV = 37492, VV = 37496, GV = 37808, qV = 37809, HV = 37810, $V = 37811, WV = 37812, KV = 37813, YV = 37814, XV = 37815, QV = 37816, ZV = 37817, JV = 37818, e6 = 37819, t6 = 37820, n6 = 37821, c5 = 36492, sRe = 36283, Jpe = 36284, efe = 36285, tfe = 36286, Zp = 0, oRe = 1, $d = "", _a = "srgb", Ib = "srgb-linear", NO = "linear", hn = "srgb", aRe = 0, pg = 7680, lRe = 7681, uRe = 7682, cRe = 7683, dRe = 34055, hRe = 34056, pRe = 5386, fRe = 512, mRe = 513, gRe = 514, yRe = 515, vRe = 516, bRe = 517, xRe = 518, r6 = 519, mye = 512, D6 = 513, gye = 514, yye = 515, vye = 516, bye = 517, xye = 518, _ye = 519, OO = 35044, Eb = 35048, Ho = 2e3, Jp = 2001;
class Xo {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(e, t, n, i, o, l, p, f, v) {
    Xo.prototype.isMatrix3 = !0, this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, p, f, v);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(e, t, n, i, o, l, p, f, v) {
    const _ = this.elements;
    return _[0] = e, _[1] = i, _[2] = p, _[3] = t, _[4] = o, _[5] = f, _[6] = n, _[7] = l, _[8] = v, this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(e, t, n) {
    return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[4],
      t[8],
      t[1],
      t[5],
      t[9],
      t[2],
      t[6],
      t[10]
    ), this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], p = n[3], f = n[6], v = n[1], _ = n[4], E = n[7], A = n[2], I = n[5], j = n[8], q = i[0], L = i[3], V = i[6], re = i[1], R = i[4], J = i[7], ge = i[2], _e = i[5], Y = i[8];
    return o[0] = l * q + p * re + f * ge, o[3] = l * L + p * R + f * _e, o[6] = l * V + p * J + f * Y, o[1] = v * q + _ * re + E * ge, o[4] = v * L + _ * R + E * _e, o[7] = v * V + _ * J + E * Y, o[2] = A * q + I * re + j * ge, o[5] = A * L + I * R + j * _e, o[8] = A * V + I * J + j * Y, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], p = e[5], f = e[6], v = e[7], _ = e[8];
    return t * l * _ - t * p * v - n * o * _ + n * p * f + i * o * v - i * l * f;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], p = e[5], f = e[6], v = e[7], _ = e[8], E = _ * l - p * v, A = p * f - _ * o, I = v * o - l * f, j = t * E + n * A + i * I;
    if (j === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const q = 1 / j;
    return e[0] = E * q, e[1] = (i * v - _ * n) * q, e[2] = (p * n - i * l) * q, e[3] = A * q, e[4] = (_ * t - i * f) * q, e[5] = (i * o - p * t) * q, e[6] = I * q, e[7] = (n * f - v * t) * q, e[8] = (l * t - n * o) * q, this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let e;
    const t = this.elements;
    return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(e) {
    const t = this.elements;
    return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(e, t, n, i, o, l, p) {
    const f = Math.cos(o), v = Math.sin(o);
    return this.set(
      n * f,
      n * v,
      -n * (f * l + v * p) + l + e,
      -i * v,
      i * f,
      -i * (-v * l + f * p) + p + t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(e, t) {
    return this.premultiply(d5.makeScale(e, t)), this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(e) {
    return this.premultiply(d5.makeRotation(-e)), this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(e, t) {
    return this.premultiply(d5.makeTranslation(e, t)), this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(e, t) {
    return e.isVector2 ? this.set(
      1,
      0,
      e.x,
      0,
      1,
      e.y,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      e,
      0,
      1,
      t,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      n,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(e, t) {
    return this.set(
      e,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 9; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const d5 = /* @__PURE__ */ new Xo();
function Sye(c) {
  for (let e = c.length - 1; e >= 0; --e)
    if (c[e] >= 65535) return !0;
  return !1;
}
function i6(c) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", c);
}
function _Re() {
  const c = i6("canvas");
  return c.style.display = "block", c;
}
const nfe = {};
function Wd(c) {
  c in nfe || (nfe[c] = !0, console.warn(c));
}
const rfe = /* @__PURE__ */ new Xo().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
), ife = /* @__PURE__ */ new Xo().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function SRe() {
  const c = {
    enabled: !0,
    workingColorSpace: Ib,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(i, o, l) {
      return this.enabled === !1 || o === l || !o || !l || (this.spaces[o].transfer === hn && (i.r = Vd(i.r), i.g = Vd(i.g), i.b = Vd(i.b)), this.spaces[o].primaries !== this.spaces[l].primaries && (i.applyMatrix3(this.spaces[o].toXYZ), i.applyMatrix3(this.spaces[l].fromXYZ)), this.spaces[l].transfer === hn && (i.r = Nb(i.r), i.g = Nb(i.g), i.b = Nb(i.b))), i;
    },
    workingToColorSpace: function(i, o) {
      return this.convert(i, this.workingColorSpace, o);
    },
    colorSpaceToWorking: function(i, o) {
      return this.convert(i, o, this.workingColorSpace);
    },
    getPrimaries: function(i) {
      return this.spaces[i].primaries;
    },
    getTransfer: function(i) {
      return i === $d ? NO : this.spaces[i].transfer;
    },
    getLuminanceCoefficients: function(i, o = this.workingColorSpace) {
      return i.fromArray(this.spaces[o].luminanceCoefficients);
    },
    define: function(i) {
      Object.assign(this.spaces, i);
    },
    // Internal APIs
    _getMatrix: function(i, o, l) {
      return i.copy(this.spaces[o].toXYZ).multiply(this.spaces[l].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(i) {
      return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(i = this.workingColorSpace) {
      return this.spaces[i].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(i, o) {
      return Wd("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."), c.workingToColorSpace(i, o);
    },
    toWorkingColorSpace: function(i, o) {
      return Wd("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."), c.colorSpaceToWorking(i, o);
    }
  }, e = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06], t = [0.2126, 0.7152, 0.0722], n = [0.3127, 0.329];
  return c.define({
    [Ib]: {
      primaries: e,
      whitePoint: n,
      transfer: NO,
      toXYZ: rfe,
      fromXYZ: ife,
      luminanceCoefficients: t,
      workingColorSpaceConfig: { unpackColorSpace: _a },
      outputColorSpaceConfig: { drawingBufferColorSpace: _a }
    },
    [_a]: {
      primaries: e,
      whitePoint: n,
      transfer: hn,
      toXYZ: rfe,
      fromXYZ: ife,
      luminanceCoefficients: t,
      outputColorSpaceConfig: { drawingBufferColorSpace: _a }
    }
  }), c;
}
const Ir = /* @__PURE__ */ SRe();
function Vd(c) {
  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
}
function Nb(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
}
const wye = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
}, Rp = { h: 0, s: 0, l: 0 }, bN = { h: 0, s: 0, l: 0 };
function h5(c, e, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? c + (e - c) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? c + (e - c) * 6 * (2 / 3 - t) : c;
}
class er {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(e, t, n) {
    return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(e, t, n) {
    if (t === void 0 && n === void 0) {
      const i = e;
      i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i);
    } else
      this.setRGB(e, t, n);
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(e) {
    return this.r = e, this.g = e, this.b = e, this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(e, t = _a) {
    return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Ir.colorSpaceToWorking(this, t), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(e, t, n, i = Ir.workingColorSpace) {
    return this.r = e, this.g = t, this.b = n, Ir.colorSpaceToWorking(this, i), this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(e, t, n, i = Ir.workingColorSpace) {
    if (e = C6(e, 1), t = Nn(t, 0, 1), n = Nn(n, 0, 1), t === 0)
      this.r = this.g = this.b = n;
    else {
      const o = n <= 0.5 ? n * (1 + t) : n + t - n * t, l = 2 * n - o;
      this.r = h5(l, o, e + 1 / 3), this.g = h5(l, o, e), this.b = h5(l, o, e - 1 / 3);
    }
    return Ir.colorSpaceToWorking(this, i), this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name]{@link https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart} -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(e, t = _a) {
    function n(o) {
      o !== void 0 && parseFloat(o) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.");
    }
    let i;
    if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
      let o;
      const l = i[1], p = i[2];
      switch (l) {
        case "rgb":
        case "rgba":
          if (o = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(p))
            return n(o[4]), this.setRGB(
              Math.min(255, parseInt(o[1], 10)) / 255,
              Math.min(255, parseInt(o[2], 10)) / 255,
              Math.min(255, parseInt(o[3], 10)) / 255,
              t
            );
          if (o = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(p))
            return n(o[4]), this.setRGB(
              Math.min(100, parseInt(o[1], 10)) / 100,
              Math.min(100, parseInt(o[2], 10)) / 100,
              Math.min(100, parseInt(o[3], 10)) / 100,
              t
            );
          break;
        case "hsl":
        case "hsla":
          if (o = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(p))
            return n(o[4]), this.setHSL(
              parseFloat(o[1]) / 360,
              parseFloat(o[2]) / 100,
              parseFloat(o[3]) / 100,
              t
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
      const o = i[1], l = o.length;
      if (l === 3)
        return this.setRGB(
          parseInt(o.charAt(0), 16) / 15,
          parseInt(o.charAt(1), 16) / 15,
          parseInt(o.charAt(2), 16) / 15,
          t
        );
      if (l === 6)
        return this.setHex(parseInt(o, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0)
      return this.setColorName(e, t);
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(e, t = _a) {
    const n = wye[e.toLowerCase()];
    return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(e) {
    return this.r = Vd(e.r), this.g = Vd(e.g), this.b = Vd(e.b), this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(e) {
    return this.r = Nb(e.r), this.g = Nb(e.g), this.b = Nb(e.b), this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(e = _a) {
    return Ir.workingToColorSpace(Ks.copy(this), e), Math.round(Nn(Ks.r * 255, 0, 255)) * 65536 + Math.round(Nn(Ks.g * 255, 0, 255)) * 256 + Math.round(Nn(Ks.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(e = _a) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(e, t = Ir.workingColorSpace) {
    Ir.workingToColorSpace(Ks.copy(this), t);
    const n = Ks.r, i = Ks.g, o = Ks.b, l = Math.max(n, i, o), p = Math.min(n, i, o);
    let f, v;
    const _ = (p + l) / 2;
    if (p === l)
      f = 0, v = 0;
    else {
      const E = l - p;
      switch (v = _ <= 0.5 ? E / (l + p) : E / (2 - l - p), l) {
        case n:
          f = (i - o) / E + (i < o ? 6 : 0);
          break;
        case i:
          f = (o - n) / E + 2;
          break;
        case o:
          f = (n - i) / E + 4;
          break;
      }
      f /= 6;
    }
    return e.h = f, e.s = v, e.l = _, e;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(e, t = Ir.workingColorSpace) {
    return Ir.workingToColorSpace(Ks.copy(this), t), e.r = Ks.r, e.g = Ks.g, e.b = Ks.b, e;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(e = _a) {
    Ir.workingToColorSpace(Ks.copy(this), e);
    const t = Ks.r, n = Ks.g, i = Ks.b;
    return e !== _a ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(e, t, n) {
    return this.getHSL(Rp), this.setHSL(Rp.h + e, Rp.s + t, Rp.l + n);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(e, t) {
    return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(e) {
    return this.r += e, this.g += e, this.b += e, this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(e) {
    return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(e) {
    return this.r *= e.r, this.g *= e.g, this.b *= e.b, this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(e, t) {
    return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(e, t, n) {
    return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(e, t) {
    this.getHSL(Rp), e.getHSL(bN);
    const n = Yp(Rp.h, bN.h, t), i = Yp(Rp.s, bN.s, t), o = Yp(Rp.l, bN.l, t);
    return this.setHSL(n, i, o), this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(e) {
    return this.r = e.x, this.g = e.y, this.b = e.z, this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(e) {
    const t = this.r, n = this.g, i = this.b, o = e.elements;
    return this.r = o[0] * t + o[3] * n + o[6] * i, this.g = o[1] * t + o[4] * n + o[7] * i, this.b = o[2] * t + o[5] * n + o[8] * i, this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(e, t = 0) {
    return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(e, t) {
    return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const Ks = /* @__PURE__ */ new er();
er.NAMES = wye;
class ZO {
  /**
   * Constructs a new 2x2 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   */
  constructor(e, t, n, i) {
    ZO.prototype.isMatrix2 = !0, this.elements = [
      1,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i);
  }
  /**
   * Sets this matrix to the 2x2 identity matrix.
   *
   * @return {Matrix2} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix2} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 4; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} n11 - 1-1 matrix element.
   * @param {number} n12 - 1-2 matrix element.
   * @param {number} n21 - 2-1 matrix element.
   * @param {number} n22 - 2-2 matrix element.
   * @return {Matrix2} A reference to this matrix.
   */
  set(e, t, n, i) {
    const o = this.elements;
    return o[0] = e, o[2] = t, o[1] = n, o[3] = i, this;
  }
}
class Yb {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(e = 0, t = 0, n = 0, i = 1) {
    this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed  in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(e, t, n, i, o, l, p) {
    let f = n[i + 0], v = n[i + 1], _ = n[i + 2], E = n[i + 3];
    const A = o[l + 0], I = o[l + 1], j = o[l + 2], q = o[l + 3];
    if (p === 0) {
      e[t + 0] = f, e[t + 1] = v, e[t + 2] = _, e[t + 3] = E;
      return;
    }
    if (p === 1) {
      e[t + 0] = A, e[t + 1] = I, e[t + 2] = j, e[t + 3] = q;
      return;
    }
    if (E !== q || f !== A || v !== I || _ !== j) {
      let L = 1 - p;
      const V = f * A + v * I + _ * j + E * q, re = V >= 0 ? 1 : -1, R = 1 - V * V;
      if (R > Number.EPSILON) {
        const ge = Math.sqrt(R), _e = Math.atan2(ge, V * re);
        L = Math.sin(L * _e) / ge, p = Math.sin(p * _e) / ge;
      }
      const J = p * re;
      if (f = f * L + A * J, v = v * L + I * J, _ = _ * L + j * J, E = E * L + q * J, L === 1 - p) {
        const ge = 1 / Math.sqrt(f * f + v * v + _ * _ + E * E);
        f *= ge, v *= ge, _ *= ge, E *= ge;
      }
    }
    e[t] = f, e[t + 1] = v, e[t + 2] = _, e[t + 3] = E;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(e, t, n, i, o, l) {
    const p = n[i], f = n[i + 1], v = n[i + 2], _ = n[i + 3], E = o[l], A = o[l + 1], I = o[l + 2], j = o[l + 3];
    return e[t] = p * j + _ * E + f * I - v * A, e[t + 1] = f * j + _ * A + v * E - p * I, e[t + 2] = v * j + _ * I + p * A - f * E, e[t + 3] = _ * j - p * E - f * A - v * I, e;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(e, t, n, i) {
    return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(e) {
    return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(e, t = !0) {
    const n = e._x, i = e._y, o = e._z, l = e._order, p = Math.cos, f = Math.sin, v = p(n / 2), _ = p(i / 2), E = p(o / 2), A = f(n / 2), I = f(i / 2), j = f(o / 2);
    switch (l) {
      case "XYZ":
        this._x = A * _ * E + v * I * j, this._y = v * I * E - A * _ * j, this._z = v * _ * j + A * I * E, this._w = v * _ * E - A * I * j;
        break;
      case "YXZ":
        this._x = A * _ * E + v * I * j, this._y = v * I * E - A * _ * j, this._z = v * _ * j - A * I * E, this._w = v * _ * E + A * I * j;
        break;
      case "ZXY":
        this._x = A * _ * E - v * I * j, this._y = v * I * E + A * _ * j, this._z = v * _ * j + A * I * E, this._w = v * _ * E - A * I * j;
        break;
      case "ZYX":
        this._x = A * _ * E - v * I * j, this._y = v * I * E + A * _ * j, this._z = v * _ * j - A * I * E, this._w = v * _ * E + A * I * j;
        break;
      case "YZX":
        this._x = A * _ * E + v * I * j, this._y = v * I * E + A * _ * j, this._z = v * _ * j - A * I * E, this._w = v * _ * E - A * I * j;
        break;
      case "XZY":
        this._x = A * _ * E - v * I * j, this._y = v * I * E - A * _ * j, this._z = v * _ * j + A * I * E, this._w = v * _ * E + A * I * j;
        break;
      default:
        console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l);
    }
    return t === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(e, t) {
    const n = t / 2, i = Math.sin(n);
    return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(e) {
    const t = e.elements, n = t[0], i = t[4], o = t[8], l = t[1], p = t[5], f = t[9], v = t[2], _ = t[6], E = t[10], A = n + p + E;
    if (A > 0) {
      const I = 0.5 / Math.sqrt(A + 1);
      this._w = 0.25 / I, this._x = (_ - f) * I, this._y = (o - v) * I, this._z = (l - i) * I;
    } else if (n > p && n > E) {
      const I = 2 * Math.sqrt(1 + n - p - E);
      this._w = (_ - f) / I, this._x = 0.25 * I, this._y = (i + l) / I, this._z = (o + v) / I;
    } else if (p > E) {
      const I = 2 * Math.sqrt(1 + p - n - E);
      this._w = (o - v) / I, this._x = (i + l) / I, this._y = 0.25 * I, this._z = (f + _) / I;
    } else {
      const I = 2 * Math.sqrt(1 + E - n - p);
      this._w = (l - i) / I, this._x = (o + v) / I, this._y = (f + _) / I, this._z = 0.25 * I;
    }
    return this._onChangeCallback(), this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    return 2 * Math.acos(Math.abs(Nn(this.dot(e), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let e = this.length();
    return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(e, t) {
    const n = e._x, i = e._y, o = e._z, l = e._w, p = t._x, f = t._y, v = t._z, _ = t._w;
    return this._x = n * _ + l * p + i * v - o * f, this._y = i * _ + l * f + o * p - n * v, this._z = o * _ + l * v + n * f - i * p, this._w = l * _ - n * p - i * f - o * v, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x, i = this._y, o = this._z, l = this._w;
    let p = l * e._w + n * e._x + i * e._y + o * e._z;
    if (p < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, p = -p) : this.copy(e), p >= 1)
      return this._w = l, this._x = n, this._y = i, this._z = o, this;
    const f = 1 - p * p;
    if (f <= Number.EPSILON) {
      const I = 1 - t;
      return this._w = I * l + t * this._w, this._x = I * n + t * this._x, this._y = I * i + t * this._y, this._z = I * o + t * this._z, this.normalize(), this;
    }
    const v = Math.sqrt(f), _ = Math.atan2(v, p), E = Math.sin((1 - t) * _) / v, A = Math.sin(t * _) / v;
    return this._w = l * E + this._w * A, this._x = n * E + this._x * A, this._y = i * E + this._y * A, this._z = o * E + this._z * A, this._onChangeCallback(), this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const e = 2 * Math.PI * Math.random(), t = 2 * Math.PI * Math.random(), n = Math.random(), i = Math.sqrt(1 - n), o = Math.sqrt(n);
    return this.set(
      i * Math.sin(e),
      i * Math.cos(e),
      o * Math.sin(t),
      o * Math.cos(t)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(e, t = 0) {
    return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(e, t) {
    return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class Ue {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(e = 0, t = 0, n = 0) {
    Ue.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(e, t, n) {
    return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(e, t) {
    return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(e) {
    return this.applyQuaternion(sfe.setFromEuler(e));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(e, t) {
    return this.applyQuaternion(sfe.setFromAxisAngle(e, t));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[3] * n + o[6] * i, this.y = o[1] * t + o[4] * n + o[7] * i, this.z = o[2] * t + o[5] * n + o[8] * i, this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements, l = 1 / (o[3] * t + o[7] * n + o[11] * i + o[15]);
    return this.x = (o[0] * t + o[4] * n + o[8] * i + o[12]) * l, this.y = (o[1] * t + o[5] * n + o[9] * i + o[13]) * l, this.z = (o[2] * t + o[6] * n + o[10] * i + o[14]) * l, this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(e) {
    const t = this.x, n = this.y, i = this.z, o = e.x, l = e.y, p = e.z, f = e.w, v = 2 * (l * i - p * n), _ = 2 * (p * t - o * i), E = 2 * (o * n - l * t);
    return this.x = t + f * v + l * E - p * _, this.y = n + f * _ + p * v - o * E, this.z = i + f * E + o * _ - l * v, this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(e) {
    const t = this.x, n = this.y, i = this.z, o = e.elements;
    return this.x = o[0] * t + o[4] * n + o[8] * i, this.y = o[1] * t + o[5] * n + o[9] * i, this.z = o[2] * t + o[6] * n + o[10] * i, this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Nn(this.x, e.x, t.x), this.y = Nn(this.y, e.y, t.y), this.z = Nn(this.z, e.z, t.z), this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Nn(this.x, e, t), this.y = Nn(this.y, e, t), this.z = Nn(this.z, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Nn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  // TODO lengthSquared?
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(e) {
    return this.crossVectors(this, e);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(e, t) {
    const n = e.x, i = e.y, o = e.z, l = t.x, p = t.y, f = t.z;
    return this.x = i * f - o * p, this.y = o * l - n * f, this.z = n * p - i * l, this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(e) {
    return p5.copy(this).projectOnVector(e), this.sub(p5);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(e) {
    return this.sub(p5.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Nn(n, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y, i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(e, t, n) {
    return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(), n = this.setFromMatrixColumn(e, 1).length(), i = this.setFromMatrixColumn(e, 2).length();
    return this.x = t, this.y = n, this.z = i, this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(e) {
    return this.x = e.r, this.y = e.g, this.z = e.b, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const e = Math.random() * Math.PI * 2, t = Math.random() * 2 - 1, n = Math.sqrt(1 - t * t);
    return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const p5 = /* @__PURE__ */ new Ue(), sfe = /* @__PURE__ */ new Yb();
class Pr {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(e, t, n, i, o, l, p, f, v, _, E, A, I, j, q, L) {
    Pr.prototype.isMatrix4 = !0, this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], e !== void 0 && this.set(e, t, n, i, o, l, p, f, v, _, E, A, I, j, q, L);
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(e, t, n, i, o, l, p, f, v, _, E, A, I, j, q, L) {
    const V = this.elements;
    return V[0] = e, V[4] = t, V[8] = n, V[12] = i, V[1] = o, V[5] = l, V[9] = p, V[13] = f, V[2] = v, V[6] = _, V[10] = E, V[14] = A, V[3] = I, V[7] = j, V[11] = q, V[15] = L, this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    return this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new Pr().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(e) {
    const t = this.elements, n = e.elements;
    return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(e) {
    const t = this.elements, n = e.elements;
    return t[12] = n[12], t[13] = n[13], t[14] = n[14], this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(e) {
    const t = e.elements;
    return this.set(
      t[0],
      t[3],
      t[6],
      0,
      t[1],
      t[4],
      t[7],
      0,
      t[2],
      t[5],
      t[8],
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(e, t, n) {
    return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(e, t, n) {
    return this.set(
      e.x,
      t.x,
      n.x,
      0,
      e.y,
      t.y,
      n.y,
      0,
      e.z,
      t.z,
      n.z,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(e) {
    const t = this.elements, n = e.elements, i = 1 / Jv.setFromMatrixColumn(e, 0).length(), o = 1 / Jv.setFromMatrixColumn(e, 1).length(), l = 1 / Jv.setFromMatrixColumn(e, 2).length();
    return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * o, t[5] = n[5] * o, t[6] = n[6] * o, t[7] = 0, t[8] = n[8] * l, t[9] = n[9] * l, t[10] = n[10] * l, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page]{@link https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix}
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z, l = Math.cos(n), p = Math.sin(n), f = Math.cos(i), v = Math.sin(i), _ = Math.cos(o), E = Math.sin(o);
    if (e.order === "XYZ") {
      const A = l * _, I = l * E, j = p * _, q = p * E;
      t[0] = f * _, t[4] = -f * E, t[8] = v, t[1] = I + j * v, t[5] = A - q * v, t[9] = -p * f, t[2] = q - A * v, t[6] = j + I * v, t[10] = l * f;
    } else if (e.order === "YXZ") {
      const A = f * _, I = f * E, j = v * _, q = v * E;
      t[0] = A + q * p, t[4] = j * p - I, t[8] = l * v, t[1] = l * E, t[5] = l * _, t[9] = -p, t[2] = I * p - j, t[6] = q + A * p, t[10] = l * f;
    } else if (e.order === "ZXY") {
      const A = f * _, I = f * E, j = v * _, q = v * E;
      t[0] = A - q * p, t[4] = -l * E, t[8] = j + I * p, t[1] = I + j * p, t[5] = l * _, t[9] = q - A * p, t[2] = -l * v, t[6] = p, t[10] = l * f;
    } else if (e.order === "ZYX") {
      const A = l * _, I = l * E, j = p * _, q = p * E;
      t[0] = f * _, t[4] = j * v - I, t[8] = A * v + q, t[1] = f * E, t[5] = q * v + A, t[9] = I * v - j, t[2] = -v, t[6] = p * f, t[10] = l * f;
    } else if (e.order === "YZX") {
      const A = l * f, I = l * v, j = p * f, q = p * v;
      t[0] = f * _, t[4] = q - A * E, t[8] = j * E + I, t[1] = E, t[5] = l * _, t[9] = -p * _, t[2] = -v * _, t[6] = I * E + j, t[10] = A - q * E;
    } else if (e.order === "XZY") {
      const A = l * f, I = l * v, j = p * f, q = p * v;
      t[0] = f * _, t[4] = -E, t[8] = v * _, t[1] = A * E + q, t[5] = l * _, t[9] = I * E - j, t[2] = j * E - I, t[6] = p * _, t[10] = q * E + A;
    }
    return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here]{@link https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion}
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(e) {
    return this.compose(wRe, e, ERe);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(e, t, n) {
    const i = this.elements;
    return ma.subVectors(e, t), ma.lengthSq() === 0 && (ma.z = 1), ma.normalize(), Ip.crossVectors(n, ma), Ip.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ma.x += 1e-4 : ma.z += 1e-4, ma.normalize(), Ip.crossVectors(n, ma)), Ip.normalize(), xN.crossVectors(ma, Ip), i[0] = Ip.x, i[4] = xN.x, i[8] = ma.x, i[1] = Ip.y, i[5] = xN.y, i[9] = ma.y, i[2] = Ip.z, i[6] = xN.z, i[10] = ma.z, this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(e, t) {
    const n = e.elements, i = t.elements, o = this.elements, l = n[0], p = n[4], f = n[8], v = n[12], _ = n[1], E = n[5], A = n[9], I = n[13], j = n[2], q = n[6], L = n[10], V = n[14], re = n[3], R = n[7], J = n[11], ge = n[15], _e = i[0], Y = i[4], Fe = i[8], Me = i[12], $ = i[1], dt = i[5], wt = i[9], St = i[13], Ct = i[2], pe = i[6], Tt = i[10], st = i[14], Zt = i[3], $t = i[7], Ht = i[11], Gn = i[15];
    return o[0] = l * _e + p * $ + f * Ct + v * Zt, o[4] = l * Y + p * dt + f * pe + v * $t, o[8] = l * Fe + p * wt + f * Tt + v * Ht, o[12] = l * Me + p * St + f * st + v * Gn, o[1] = _ * _e + E * $ + A * Ct + I * Zt, o[5] = _ * Y + E * dt + A * pe + I * $t, o[9] = _ * Fe + E * wt + A * Tt + I * Ht, o[13] = _ * Me + E * St + A * st + I * Gn, o[2] = j * _e + q * $ + L * Ct + V * Zt, o[6] = j * Y + q * dt + L * pe + V * $t, o[10] = j * Fe + q * wt + L * Tt + V * Ht, o[14] = j * Me + q * St + L * st + V * Gn, o[3] = re * _e + R * $ + J * Ct + ge * Zt, o[7] = re * Y + R * dt + J * pe + ge * $t, o[11] = re * Fe + R * wt + J * Tt + ge * Ht, o[15] = re * Me + R * St + J * st + ge * Gn, this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(e) {
    const t = this.elements;
    return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here]{@link http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html}.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const e = this.elements, t = e[0], n = e[4], i = e[8], o = e[12], l = e[1], p = e[5], f = e[9], v = e[13], _ = e[2], E = e[6], A = e[10], I = e[14], j = e[3], q = e[7], L = e[11], V = e[15];
    return j * (+o * f * E - i * v * E - o * p * A + n * v * A + i * p * I - n * f * I) + q * (+t * f * I - t * v * A + o * l * A - i * l * I + i * v * _ - o * f * _) + L * (+t * v * E - t * p * I - o * l * E + n * l * I + o * p * _ - n * v * _) + V * (-i * p * _ - t * f * E + t * p * A + i * l * E - n * l * A + n * f * _);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const e = this.elements;
    let t;
    return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(e, t, n) {
    const i = this.elements;
    return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this;
  }
  /**
   * Inverts this matrix, using the [analytic method]{@link https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution}.
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const e = this.elements, t = e[0], n = e[1], i = e[2], o = e[3], l = e[4], p = e[5], f = e[6], v = e[7], _ = e[8], E = e[9], A = e[10], I = e[11], j = e[12], q = e[13], L = e[14], V = e[15], re = E * L * v - q * A * v + q * f * I - p * L * I - E * f * V + p * A * V, R = j * A * v - _ * L * v - j * f * I + l * L * I + _ * f * V - l * A * V, J = _ * q * v - j * E * v + j * p * I - l * q * I - _ * p * V + l * E * V, ge = j * E * f - _ * q * f - j * p * A + l * q * A + _ * p * L - l * E * L, _e = t * re + n * R + i * J + o * ge;
    if (_e === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const Y = 1 / _e;
    return e[0] = re * Y, e[1] = (q * A * o - E * L * o - q * i * I + n * L * I + E * i * V - n * A * V) * Y, e[2] = (p * L * o - q * f * o + q * i * v - n * L * v - p * i * V + n * f * V) * Y, e[3] = (E * f * o - p * A * o - E * i * v + n * A * v + p * i * I - n * f * I) * Y, e[4] = R * Y, e[5] = (_ * L * o - j * A * o + j * i * I - t * L * I - _ * i * V + t * A * V) * Y, e[6] = (j * f * o - l * L * o - j * i * v + t * L * v + l * i * V - t * f * V) * Y, e[7] = (l * A * o - _ * f * o + _ * i * v - t * A * v - l * i * I + t * f * I) * Y, e[8] = J * Y, e[9] = (j * E * o - _ * q * o - j * n * I + t * q * I + _ * n * V - t * E * V) * Y, e[10] = (l * q * o - j * p * o + j * n * v - t * q * v - l * n * V + t * p * V) * Y, e[11] = (_ * p * o - l * E * o - _ * n * v + t * E * v + l * n * I - t * p * I) * Y, e[12] = ge * Y, e[13] = (_ * q * i - j * E * i + j * n * A - t * q * A - _ * n * L + t * E * L) * Y, e[14] = (j * p * i - l * q * i - j * n * f + t * q * f + l * n * L - t * p * L) * Y, e[15] = (l * E * i - _ * p * i + _ * n * f - t * E * f - l * n * A + t * p * A) * Y, this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(e) {
    const t = this.elements, n = e.x, i = e.y, o = e.z;
    return t[0] *= n, t[4] *= i, t[8] *= o, t[1] *= n, t[5] *= i, t[9] *= o, t[2] *= n, t[6] *= i, t[10] *= o, t[3] *= n, t[7] *= i, t[11] *= o, this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const e = this.elements, t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2], n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6], i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(e, t, n) {
    return e.isVector3 ? this.set(
      1,
      0,
      0,
      e.x,
      0,
      1,
      0,
      e.y,
      0,
      0,
      1,
      e.z,
      0,
      0,
      0,
      1
    ) : this.set(
      1,
      0,
      0,
      e,
      0,
      1,
      0,
      t,
      0,
      0,
      1,
      n,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      1,
      0,
      0,
      0,
      0,
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      0,
      n,
      0,
      0,
      1,
      0,
      0,
      -n,
      0,
      t,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(e) {
    const t = Math.cos(e), n = Math.sin(e);
    return this.set(
      t,
      -n,
      0,
      0,
      n,
      t,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here]{@link https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199}.
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = 1 - n, l = e.x, p = e.y, f = e.z, v = o * l, _ = o * p;
    return this.set(
      v * l + n,
      v * p - i * f,
      v * f + i * p,
      0,
      v * p + i * f,
      _ * p + n,
      _ * f - i * l,
      0,
      v * f - i * p,
      _ * f + i * l,
      o * f * f + n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(e, t, n) {
    return this.set(
      e,
      0,
      0,
      0,
      0,
      t,
      0,
      0,
      0,
      0,
      n,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(e, t, n, i, o, l) {
    return this.set(
      1,
      n,
      o,
      0,
      e,
      1,
      l,
      0,
      t,
      i,
      1,
      0,
      0,
      0,
      0,
      1
    ), this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(e, t, n) {
    const i = this.elements, o = t._x, l = t._y, p = t._z, f = t._w, v = o + o, _ = l + l, E = p + p, A = o * v, I = o * _, j = o * E, q = l * _, L = l * E, V = p * E, re = f * v, R = f * _, J = f * E, ge = n.x, _e = n.y, Y = n.z;
    return i[0] = (1 - (q + V)) * ge, i[1] = (I + J) * ge, i[2] = (j - R) * ge, i[3] = 0, i[4] = (I - J) * _e, i[5] = (1 - (A + V)) * _e, i[6] = (L + re) * _e, i[7] = 0, i[8] = (j + R) * Y, i[9] = (L - re) * Y, i[10] = (1 - (A + q)) * Y, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(e, t, n) {
    const i = this.elements;
    let o = Jv.set(i[0], i[1], i[2]).length();
    const l = Jv.set(i[4], i[5], i[6]).length(), p = Jv.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (o = -o), e.x = i[12], e.y = i[13], e.z = i[14], tu.copy(this);
    const v = 1 / o, _ = 1 / l, E = 1 / p;
    return tu.elements[0] *= v, tu.elements[1] *= v, tu.elements[2] *= v, tu.elements[4] *= _, tu.elements[5] *= _, tu.elements[6] *= _, tu.elements[8] *= E, tu.elements[9] *= E, tu.elements[10] *= E, t.setFromRotationMatrix(tu), n.x = o, n.y = l, n.z = p, this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(e, t, n, i, o, l, p = Ho) {
    const f = this.elements, v = 2 * o / (t - e), _ = 2 * o / (n - i), E = (t + e) / (t - e), A = (n + i) / (n - i);
    let I, j;
    if (p === Ho)
      I = -(l + o) / (l - o), j = -2 * l * o / (l - o);
    else if (p === Jp)
      I = -l / (l - o), j = -l * o / (l - o);
    else
      throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + p);
    return f[0] = v, f[4] = 0, f[8] = E, f[12] = 0, f[1] = 0, f[5] = _, f[9] = A, f[13] = 0, f[2] = 0, f[6] = 0, f[10] = I, f[14] = j, f[3] = 0, f[7] = 0, f[11] = -1, f[15] = 0, this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(e, t, n, i, o, l, p = Ho) {
    const f = this.elements, v = 1 / (t - e), _ = 1 / (n - i), E = 1 / (l - o), A = (t + e) * v, I = (n + i) * _;
    let j, q;
    if (p === Ho)
      j = (l + o) * E, q = -2 * E;
    else if (p === Jp)
      j = o * E, q = -1 * E;
    else
      throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + p);
    return f[0] = 2 * v, f[4] = 0, f[8] = 0, f[12] = -A, f[1] = 0, f[5] = 2 * _, f[9] = 0, f[13] = -I, f[2] = 0, f[6] = 0, f[10] = q, f[14] = -j, f[3] = 0, f[7] = 0, f[11] = 0, f[15] = 1, this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(e) {
    const t = this.elements, n = e.elements;
    for (let i = 0; i < 16; i++)
      if (t[i] !== n[i]) return !1;
    return !0;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++)
      this.elements[n] = e[n + t];
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(e = [], t = 0) {
    const n = this.elements;
    return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e;
  }
}
const Jv = /* @__PURE__ */ new Ue(), tu = /* @__PURE__ */ new Pr(), wRe = /* @__PURE__ */ new Ue(0, 0, 0), ERe = /* @__PURE__ */ new Ue(1, 1, 1), Ip = /* @__PURE__ */ new Ue(), xN = /* @__PURE__ */ new Ue(), ma = /* @__PURE__ */ new Ue();
class Pn {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(e = 0, t = 0) {
    Pn.prototype.isVector2 = !0, this.x = e, this.y = t;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(e, t) {
    return this.x = e, this.y = t, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(e) {
    const t = this.x, n = this.y, i = e.elements;
    return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Nn(this.x, e.x, t.x), this.y = Nn(this.y, e.y, t.y), this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Nn(this.x, e, t), this.y = Nn(this.y, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Nn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos(Nn(n, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(e) {
    const t = this.x - e.x, n = this.y - e.y;
    return t * t + n * n;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(e, t) {
    const n = Math.cos(t), i = Math.sin(t), o = this.x - e.x, l = this.y - e.y;
    return this.x = o * n - l * i + e.x, this.y = o * i + l * n + e.y, this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class Bn {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(e = 0, t = 0, n = 0, i = 1) {
    Bn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(e, t, n, i) {
    return this.x = e, this.y = t, this.z = n, this.w = i, this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(e) {
    return this.x = e, this.y = e, this.z = e, this.w = e, this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(e) {
    return this.x = e, this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(e) {
    return this.y = e, this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(e) {
    return this.z = e, this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(e) {
    return this.w = e, this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(e) {
    return this.x += e, this.y += e, this.z += e, this.w += e, this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(e, t) {
    return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(e, t) {
    return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(e) {
    return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(e, t) {
    return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(e) {
    const t = this.x, n = this.y, i = this.z, o = this.w, l = e.elements;
    return this.x = l[0] * t + l[4] * n + l[8] * i + l[12] * o, this.y = l[1] * t + l[5] * n + l[9] * i + l[13] * o, this.z = l[2] * t + l[6] * n + l[10] * i + l[14] * o, this.w = l[3] * t + l[7] * n + l[11] * i + l[15] * o, this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(e) {
    return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, o;
    const f = e.elements, v = f[0], _ = f[4], E = f[8], A = f[1], I = f[5], j = f[9], q = f[2], L = f[6], V = f[10];
    if (Math.abs(_ - A) < 0.01 && Math.abs(E - q) < 0.01 && Math.abs(j - L) < 0.01) {
      if (Math.abs(_ + A) < 0.1 && Math.abs(E + q) < 0.1 && Math.abs(j + L) < 0.1 && Math.abs(v + I + V - 3) < 0.1)
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const R = (v + 1) / 2, J = (I + 1) / 2, ge = (V + 1) / 2, _e = (_ + A) / 4, Y = (E + q) / 4, Fe = (j + L) / 4;
      return R > J && R > ge ? R < 0.01 ? (n = 0, i = 0.707106781, o = 0.707106781) : (n = Math.sqrt(R), i = _e / n, o = Y / n) : J > ge ? J < 0.01 ? (n = 0.707106781, i = 0, o = 0.707106781) : (i = Math.sqrt(J), n = _e / i, o = Fe / i) : ge < 0.01 ? (n = 0.707106781, i = 0.707106781, o = 0) : (o = Math.sqrt(ge), n = Y / o, i = Fe / o), this.set(n, i, o, t), this;
    }
    let re = Math.sqrt((L - j) * (L - j) + (E - q) * (E - q) + (A - _) * (A - _));
    return Math.abs(re) < 1e-3 && (re = 1), this.x = (L - j) / re, this.y = (E - q) / re, this.z = (A - _) / re, this.w = Math.acos((v + I + V - 1) / 2), this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(e) {
    const t = e.elements;
    return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(e) {
    return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(e) {
    return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(e, t) {
    return this.x = Nn(this.x, e.x, t.x), this.y = Nn(this.y, e.y, t.y), this.z = Nn(this.z, e.z, t.z), this.w = Nn(this.w, e.w, t.w), this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(e, t) {
    return this.x = Nn(this.x, e, t), this.y = Nn(this.y, e, t), this.z = Nn(this.z, e, t), this.w = Nn(this.w, e, t), this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(Nn(n, e, t));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(e, t) {
    return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(e, t, n) {
    return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(e, t = 0) {
    return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(e, t) {
    return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
function TE(c, e = 0) {
  let t = 3735928559 ^ e, n = 1103547991 ^ e;
  if (c instanceof Array)
    for (let i = 0, o; i < c.length; i++)
      o = c[i], t = Math.imul(t ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  else
    for (let i = 0, o; i < c.length; i++)
      o = c.charCodeAt(i), t = Math.imul(t ^ o, 2654435761), n = Math.imul(n ^ o, 1597334677);
  return t = Math.imul(t ^ t >>> 16, 2246822507), t ^= Math.imul(n ^ n >>> 13, 3266489909), n = Math.imul(n ^ n >>> 16, 2246822507), n ^= Math.imul(t ^ t >>> 13, 3266489909), 4294967296 * (2097151 & n) + (t >>> 0);
}
const TRe = (c) => TE(c), F6 = (c) => TE(c), DO = (...c) => TE(c);
function Eye(c, e = !1) {
  const t = [];
  c.isNode === !0 && (t.push(c.id), c = c.getSelf());
  for (const { property: n, childNode: i } of FO(c))
    t.push(TE(n.slice(0, -4)), i.getCacheKey(e));
  return TE(t);
}
function* FO(c, e = !1) {
  for (const t in c) {
    if (t.startsWith("_") === !0) continue;
    const n = c[t];
    if (Array.isArray(n) === !0)
      for (let i = 0; i < n.length; i++) {
        const o = n[i];
        o && (o.isNode === !0 || e && typeof o.toJSON == "function") && (yield { property: t, index: i, childNode: o });
      }
    else if (n && n.isNode === !0)
      yield { property: t, childNode: n };
    else if (typeof n == "object")
      for (const i in n) {
        const o = n[i];
        o && (o.isNode === !0 || e && typeof o.toJSON == "function") && (yield { property: t, index: i, childNode: o });
      }
  }
}
const CRe = /* @__PURE__ */ new Map([
  [1, "float"],
  [2, "vec2"],
  [3, "vec3"],
  [4, "vec4"],
  [9, "mat3"],
  [16, "mat4"]
]), ofe = /* @__PURE__ */ new WeakMap();
function PRe(c) {
  return CRe.get(c);
}
function BO(c) {
  if (c == null) return null;
  const e = typeof c;
  return c.isNode === !0 ? "node" : e === "number" ? "float" : e === "boolean" ? "bool" : e === "string" ? "string" : e === "function" ? "shader" : c.isVector2 === !0 ? "vec2" : c.isVector3 === !0 ? "vec3" : c.isVector4 === !0 ? "vec4" : c.isMatrix2 === !0 ? "mat2" : c.isMatrix3 === !0 ? "mat3" : c.isMatrix4 === !0 ? "mat4" : c.isColor === !0 ? "color" : c instanceof ArrayBuffer ? "ArrayBuffer" : null;
}
function Tye(c, ...e) {
  const t = c ? c.slice(-4) : void 0;
  return e.length === 1 && (t === "vec2" ? e = [e[0], e[0]] : t === "vec3" ? e = [e[0], e[0], e[0]] : t === "vec4" && (e = [e[0], e[0], e[0], e[0]])), c === "color" ? new er(...e) : t === "vec2" ? new Pn(...e) : t === "vec3" ? new Ue(...e) : t === "vec4" ? new Bn(...e) : t === "mat2" ? new ZO(...e) : t === "mat3" ? new Xo(...e) : t === "mat4" ? new Pr(...e) : c === "bool" ? e[0] || !1 : c === "float" || c === "int" || c === "uint" ? e[0] || 0 : c === "string" ? e[0] || "" : c === "ArrayBuffer" ? kRe(e[0]) : null;
}
function Cye(c) {
  let e = ofe.get(c);
  return e === void 0 && (e = {}, ofe.set(c, e)), e;
}
function ARe(c) {
  let e = "";
  const t = new Uint8Array(c);
  for (let n = 0; n < t.length; n++)
    e += String.fromCharCode(t[n]);
  return btoa(e);
}
function kRe(c) {
  return Uint8Array.from(atob(c), (e) => e.charCodeAt(0)).buffer;
}
let MRe = 0;
function RRe(c) {
  const e = Object.keys(c);
  let t = Object.getPrototypeOf(c);
  for (; t; ) {
    const n = Object.getOwnPropertyDescriptors(t);
    for (const i in n)
      if (n[i] !== void 0) {
        const o = n[i];
        o && typeof o.get == "function" && e.push(i);
      }
    t = Object.getPrototypeOf(t);
  }
  return e;
}
class IRe {
  /**
   * Constructs a new render object.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   */
  constructor(e, t, n, i, o, l, p, f, v, _) {
    this.id = MRe++, this._nodes = e, this._geometries = t, this.renderer = n, this.object = i, this.material = o, this.scene = l, this.camera = p, this.lightsNode = f, this.context = v, this.geometry = i.geometry, this.version = o.version, this.drawRange = null, this.attributes = null, this.pipeline = null, this.group = null, this.vertexBuffers = null, this.drawParams = null, this.bundle = null, this.clippingContext = _, this.clippingContextCacheKey = _ !== null ? _.cacheKey : "", this.initialNodesCacheKey = this.getDynamicCacheKey(), this.initialCacheKey = this.getCacheKey(), this._nodeBuilderState = null, this._bindings = null, this._monitor = null, this.onDispose = null, this.isRenderObject = !0, this.onMaterialDispose = () => {
      this.dispose();
    }, this.material.addEventListener("dispose", this.onMaterialDispose);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} context - The clipping context to set.
   */
  updateClipping(e) {
    this.clippingContext = e;
  }
  /**
   * Whether the clipping requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get clippingNeedsUpdate() {
    return this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey ? !1 : (this.clippingContextCacheKey = this.clippingContext.cacheKey, !0);
  }
  /**
   * The number of clipping planes defined in context of hardware clipping.
   *
   * @type {number}
   * @readonly
   */
  get hardwareClippingPlanes() {
    return this.material.hardwareClipping === !0 ? this.clippingContext.unionClippingCount : 0;
  }
  /**
   * Returns the node builder state of this render object.
   *
   * @return {NodeBuilderState} The node builder state.
   */
  getNodeBuilderState() {
    return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
  }
  /**
   * Returns the node material observer of this render object.
   *
   * @return {NodeMaterialObserver} The node material observer.
   */
  getMonitor() {
    return this._monitor || (this._monitor = this.getNodeBuilderState().observer);
  }
  /**
   * Returns an array of bind groups of this render object.
   *
   * @return {Array<BindGroup>} The bindings.
   */
  getBindings() {
    return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
  }
  /**
   * Returns a binding group by group name of this render object.
   *
   * @param {string} name - The name of the binding group.
   * @return {?BindGroup} The bindings.
   */
  getBindingGroup(e) {
    for (const t of this.getBindings())
      if (t.name === e)
        return t;
  }
  /**
   * Returns the index of the render object's geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex() {
    return this._geometries.getIndex(this);
  }
  /**
   * Returns the indirect buffer attribute.
   *
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect() {
    return this._geometries.getIndirect(this);
  }
  /**
   * Returns an array that acts as a key for identifying the render object in a chain map.
   *
   * @return {Array<Object>} An array with object references.
   */
  getChainArray() {
    return [this.object, this.material, this.context, this.lightsNode];
  }
  /**
   * This method is used when the geometry of a 3D object has been exchanged and the
   * respective render object now requires an update.
   *
   * @param {BufferGeometry} geometry - The geometry to set.
   */
  setGeometry(e) {
    this.geometry = e, this.attributes = null;
  }
  /**
   * Returns the buffer attributes of the render object. The returned array holds
   * attribute definitions on geometry and node level.
   *
   * @return {Array<BufferAttribute>} An array with buffer attributes.
   */
  getAttributes() {
    if (this.attributes !== null) return this.attributes;
    const e = this.getNodeBuilderState().nodeAttributes, t = this.geometry, n = [], i = /* @__PURE__ */ new Set();
    for (const o of e) {
      const l = o.node && o.node.attribute ? o.node.attribute : t.getAttribute(o.name);
      if (l === void 0) continue;
      n.push(l);
      const p = l.isInterleavedBufferAttribute ? l.data : l;
      i.add(p);
    }
    return this.attributes = n, this.vertexBuffers = Array.from(i.values()), n;
  }
  /**
   * Returns the vertex buffers of the render object.
   *
   * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
   */
  getVertexBuffers() {
    return this.vertexBuffers === null && this.getAttributes(), this.vertexBuffers;
  }
  /**
   * Returns the draw parameters for the render object.
   *
   * @return {?{vertexCount: number, firstVertex: number, instanceCount: number, firstInstance: number}} The draw parameters.
   */
  getDrawParameters() {
    const { object: e, material: t, geometry: n, group: i, drawRange: o } = this, l = this.drawParams || (this.drawParams = {
      vertexCount: 0,
      firstVertex: 0,
      instanceCount: 0,
      firstInstance: 0
    }), p = this.getIndex(), f = p !== null;
    let v = 1;
    if (n.isInstancedBufferGeometry === !0 ? v = n.instanceCount : e.count !== void 0 && (v = Math.max(0, e.count)), v === 0) return null;
    if (l.instanceCount = v, e.isBatchedMesh === !0) return l;
    let _ = 1;
    t.wireframe === !0 && !e.isPoints && !e.isLineSegments && !e.isLine && !e.isLineLoop && (_ = 2);
    let E = o.start * _, A = (o.start + o.count) * _;
    i !== null && (E = Math.max(E, i.start * _), A = Math.min(A, (i.start + i.count) * _));
    const I = n.attributes.position;
    let j = 1 / 0;
    f ? j = p.count : I != null && (j = I.count), E = Math.max(E, 0), A = Math.min(A, j);
    const q = A - E;
    return q < 0 || q === 1 / 0 ? null : (l.vertexCount = q, l.firstVertex = E, l);
  }
  /**
   * Returns the render object's geometry cache key.
   *
   * The geometry cache key is part of the material cache key.
   *
   * @return {string} The geometry cache key.
   */
  getGeometryCacheKey() {
    const { geometry: e } = this;
    let t = "";
    for (const n of Object.keys(e.attributes).sort()) {
      const i = e.attributes[n];
      t += n + ",", i.data && (t += i.data.stride + ","), i.offset && (t += i.offset + ","), i.itemSize && (t += i.itemSize + ","), i.normalized && (t += "n,");
    }
    for (const n of Object.keys(e.morphAttributes).sort()) {
      const i = e.morphAttributes[n];
      t += "morph-" + n + ",";
      for (let o = 0, l = i.length; o < l; o++) {
        const p = i[o];
        t += p.id + ",";
      }
    }
    return e.index && (t += "index,"), t;
  }
  /**
   * Returns the render object's material cache key.
   *
   * The material cache key is part of the render object cache key.
   *
   * @return {number} The material cache key.
   */
  getMaterialCacheKey() {
    const { object: e, material: t } = this;
    let n = t.customProgramCacheKey();
    for (const i of RRe(t)) {
      if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(i)) continue;
      const o = t[i];
      let l;
      if (o !== null) {
        const p = typeof o;
        p === "number" ? l = o !== 0 ? "1" : "0" : p === "object" ? (l = "{", o.isTexture && (l += o.mapping), l += "}") : l = String(o);
      } else
        l = String(o);
      n += /*property + ':' +*/
      l + ",";
    }
    return n += this.clippingContextCacheKey + ",", e.geometry && (n += this.getGeometryCacheKey()), e.skeleton && (n += e.skeleton.bones.length + ","), e.isBatchedMesh && (n += e._matricesTexture.uuid + ",", e._colorsTexture !== null && (n += e._colorsTexture.uuid + ",")), e.count > 1 && (n += e.uuid + ","), n += e.receiveShadow + ",", TRe(n);
  }
  /**
   * Whether the geometry requires an update or not.
   *
   * @type {boolean}
   * @readonly
   */
  get needsGeometryUpdate() {
    return this.geometry.id !== this.object.geometry.id;
  }
  /**
   * Whether the render object requires an update or not.
   *
   * Note: There are two distinct places where render objects are checked for an update.
   *
   * 1. In `RenderObjects.get()` which is executed when the render object is request. This
   * method checks the `needsUpdate` flag and recreates the render object if necessary.
   * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
   * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
   * a need for a refresh due to material, geometry or object related value changes.
   *
   * TODO: Investigate if it's possible to merge both steps so there is only a single place
   * that performs the 'needsUpdate' check.
   *
   * @type {boolean}
   * @readonly
   */
  get needsUpdate() {
    return (
      /*this.object.static !== true &&*/
      this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate
    );
  }
  /**
   * Returns the dynamic cache key which represents a key that is computed per draw command.
   *
   * @return {number} The cache key.
   */
  getDynamicCacheKey() {
    let e = 0;
    return this.material.isShadowPassMaterial !== !0 && (e = this._nodes.getCacheKey(this.scene, this.lightsNode)), this.camera.isArrayCamera && (e = DO(e, this.camera.cameras.length)), this.object.receiveShadow && (e = DO(e, 1)), e;
  }
  /**
   * Returns the render object's cache key.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return this.getMaterialCacheKey() + this.getDynamicCacheKey();
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.material.removeEventListener("dispose", this.onMaterialDispose), this.onDispose();
  }
}
const Jm = [];
class NRe {
  /**
   * Constructs a new render object management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Bindings} bindings - Renderer component for managing bindings.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n, i, o, l) {
    this.renderer = e, this.nodes = t, this.geometries = n, this.pipelines = i, this.bindings = o, this.info = l, this.chainMaps = {};
  }
  /**
   * Returns a render object for the given object and state data.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The 3D object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the 3D object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  get(e, t, n, i, o, l, p, f) {
    const v = this.getChainMap(f);
    Jm[0] = e, Jm[1] = t, Jm[2] = l, Jm[3] = o;
    let _ = v.get(Jm);
    return _ === void 0 ? (_ = this.createRenderObject(this.nodes, this.geometries, this.renderer, e, t, n, i, o, l, p, f), v.set(Jm, _)) : (_.updateClipping(p), _.needsGeometryUpdate && _.setGeometry(e.geometry), (_.version !== t.version || _.needsUpdate) && (_.initialCacheKey !== _.getCacheKey() ? (_.dispose(), _ = this.get(e, t, n, i, o, l, p, f)) : _.version = t.version)), Jm.length = 0, _;
  }
  /**
   * Returns a chain map for the given pass ID.
   *
   * @param {string} [passId='default'] - The pass ID.
   * @return {ChainMap} The chain map.
   */
  getChainMap(e = "default") {
    return this.chainMaps[e] || (this.chainMaps[e] = new hu());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
  /**
   * Factory method for creating render objects with the given list of parameters.
   *
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Geometries} geometries - Renderer component for managing geometries.
   * @param {Renderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The lights node.
   * @param {RenderContext} renderContext - The render context.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {string} [passId] - An optional ID for identifying the pass.
   * @return {RenderObject} The render object.
   */
  createRenderObject(e, t, n, i, o, l, p, f, v, _, E) {
    const A = this.getChainMap(E), I = new IRe(e, t, n, i, o, l, p, f, v, _);
    return I.onDispose = () => {
      this.pipelines.delete(I), this.bindings.delete(I), this.nodes.delete(I), A.delete(I.getChainArray());
    }, I;
  }
}
class nf {
  /**
   * Constructs a new data map.
   */
  constructor() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The dictionary.
   */
  get(e) {
    let t = this.data.get(e);
    return t === void 0 && (t = {}, this.data.set(e, t)), t;
  }
  /**
   * Deletes the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    let t = null;
    return this.data.has(e) && (t = this.data.get(e), this.data.delete(e)), t;
  }
  /**
   * Returns `true` if the given object has a dictionary defined.
   *
   * @param {Object} object - The object to test.
   * @return {boolean} Whether a dictionary is defined or not.
   */
  has(e) {
    return this.data.has(e);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.data = /* @__PURE__ */ new WeakMap();
  }
}
const ll = {
  VERTEX: 1,
  INDEX: 2,
  STORAGE: 3,
  INDIRECT: 4
}, Hp = 16, ORe = 211, DRe = 212;
class FRe extends nf {
  /**
   * Constructs a new attribute management component.
   *
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(e) {
    super(), this.backend = e;
  }
  /**
   * Deletes the data for the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {Object|null} The deleted attribute data.
   */
  delete(e) {
    const t = super.delete(e);
    return t !== null && this.backend.destroyAttribute(e), t;
  }
  /**
   * Updates the given attribute. This method creates attribute buffers
   * for new attributes and updates data for existing ones.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  update(e, t) {
    const n = this.get(e);
    if (n.version === void 0)
      t === ll.VERTEX ? this.backend.createAttribute(e) : t === ll.INDEX ? this.backend.createIndexAttribute(e) : t === ll.STORAGE ? this.backend.createStorageAttribute(e) : t === ll.INDIRECT && this.backend.createIndirectStorageAttribute(e), n.version = this._getBufferAttribute(e).version;
    else {
      const i = this._getBufferAttribute(e);
      (n.version < i.version || i.usage === Eb) && (this.backend.updateAttribute(e), n.version = i.version);
    }
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
const Od = /* @__PURE__ */ BRe();
function BRe() {
  const c = new ArrayBuffer(4), e = new Float32Array(c), t = new Uint32Array(c), n = new Uint32Array(512), i = new Uint32Array(512);
  for (let f = 0; f < 256; ++f) {
    const v = f - 127;
    v < -27 ? (n[f] = 0, n[f | 256] = 32768, i[f] = 24, i[f | 256] = 24) : v < -14 ? (n[f] = 1024 >> -v - 14, n[f | 256] = 1024 >> -v - 14 | 32768, i[f] = -v - 1, i[f | 256] = -v - 1) : v <= 15 ? (n[f] = v + 15 << 10, n[f | 256] = v + 15 << 10 | 32768, i[f] = 13, i[f | 256] = 13) : v < 128 ? (n[f] = 31744, n[f | 256] = 64512, i[f] = 24, i[f | 256] = 24) : (n[f] = 31744, n[f | 256] = 64512, i[f] = 13, i[f | 256] = 13);
  }
  const o = new Uint32Array(2048), l = new Uint32Array(64), p = new Uint32Array(64);
  for (let f = 1; f < 1024; ++f) {
    let v = f << 13, _ = 0;
    for (; (v & 8388608) === 0; )
      v <<= 1, _ -= 8388608;
    v &= -8388609, _ += 947912704, o[f] = v | _;
  }
  for (let f = 1024; f < 2048; ++f)
    o[f] = 939524096 + (f - 1024 << 13);
  for (let f = 1; f < 31; ++f)
    l[f] = f << 23;
  l[31] = 1199570944, l[32] = 2147483648;
  for (let f = 33; f < 63; ++f)
    l[f] = 2147483648 + (f - 32 << 23);
  l[63] = 3347054592;
  for (let f = 1; f < 64; ++f)
    f !== 32 && (p[f] = 1024);
  return {
    floatView: e,
    uint32View: t,
    baseTable: n,
    shiftTable: i,
    mantissaTable: o,
    exponentTable: l,
    offsetTable: p
  };
}
function ga(c) {
  Math.abs(c) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), c = Nn(c, -65504, 65504), Od.floatView[0] = c;
  const e = Od.uint32View[0], t = e >> 23 & 511;
  return Od.baseTable[t] + ((e & 8388607) >> Od.shiftTable[t]);
}
function _N(c) {
  const e = c >> 10;
  return Od.uint32View[0] = Od.mantissaTable[Od.offsetTable[e] + (c & 1023)] + Od.exponentTable[e], Od.floatView[0];
}
const ki = /* @__PURE__ */ new Ue(), SN = /* @__PURE__ */ new Pn();
let LRe = 0;
class ul {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    this.isBufferAttribute = !0, Object.defineProperty(this, "id", { value: LRe++ }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = OO, this.updateRanges = [], this.gpuType = wa, this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(e, t, n) {
    e *= this.itemSize, n *= t.itemSize;
    for (let i = 0, o = this.itemSize; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(e) {
    return this.array.set(e), this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        SN.fromBufferAttribute(this, t), SN.applyMatrix3(e), this.setXY(t, SN.x, SN.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        ki.fromBufferAttribute(this, t), ki.applyMatrix3(e), this.setXYZ(t, ki.x, ki.y, ki.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ki.fromBufferAttribute(this, t), ki.applyMatrix4(e), this.setXYZ(t, ki.x, ki.y, ki.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ki.fromBufferAttribute(this, t), ki.applyNormalMatrix(e), this.setXYZ(t, ki.x, ki.y, ki.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ki.fromBufferAttribute(this, t), ki.transformDirection(e), this.setXYZ(t, ki.x, ki.y, ki.z);
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let n = this.array[e * this.itemSize + t];
    return this.normalized && (n = go(n, this.array)), n;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(e, t, n) {
    return this.normalized && (n = xn(n, this.array)), this.array[e * this.itemSize + t] = n, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize] = t, this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 1] = t, this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 2] = t, this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 3] = t, this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), o = xn(o, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = o, this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    return this.name !== "" && (e.name = this.name), this.usage !== OO && (e.usage = this.usage), e;
  }
}
class Pye extends ul {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class Aye extends ul {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class kye extends ul {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0;
  }
  getX(e) {
    let t = _N(this.array[e * this.itemSize]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize] = ga(t), this;
  }
  getY(e) {
    let t = _N(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 1] = ga(t), this;
  }
  getZ(e) {
    let t = _N(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 2] = ga(t), this;
  }
  getW(e) {
    let t = _N(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = go(t, this.array)), t;
  }
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.array[e * this.itemSize + 3] = ga(t), this;
  }
  setXY(e, t, n) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.array[e + 0] = ga(t), this.array[e + 1] = ga(n), this;
  }
  setXYZ(e, t, n, i) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.array[e + 0] = ga(t), this.array[e + 1] = ga(n), this.array[e + 2] = ga(i), this;
  }
  setXYZW(e, t, n, i, o) {
    return e *= this.itemSize, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), o = xn(o, this.array)), this.array[e + 0] = ga(t), this.array[e + 1] = ga(n), this.array[e + 2] = ga(i), this.array[e + 3] = ga(o), this;
  }
}
class vo extends ul {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
function Mye(c) {
  return c.index !== null ? c.index.version : c.attributes.position.version;
}
function afe(c) {
  const e = [], t = c.index, n = c.attributes.position;
  if (t !== null) {
    const o = t.array;
    for (let l = 0, p = o.length; l < p; l += 3) {
      const f = o[l + 0], v = o[l + 1], _ = o[l + 2];
      e.push(f, v, v, _, _, f);
    }
  } else {
    const o = n.array;
    for (let l = 0, p = o.length / 3 - 1; l < p; l += 3) {
      const f = l + 0, v = l + 1, _ = l + 2;
      e.push(f, v, v, _, _, f);
    }
  }
  const i = new (Sye(e) ? Aye : Pye)(e, 1);
  return i.version = Mye(c), i;
}
class jRe extends nf {
  /**
   * Constructs a new geometry management component.
   *
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t) {
    super(), this.attributes = e, this.info = t, this.wireframes = /* @__PURE__ */ new WeakMap(), this.attributeCall = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Returns `true` if the given render object has an initialized geometry.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether if the given render object has an initialized geometry or not.
   */
  has(e) {
    const t = e.geometry;
    return super.has(t) && this.get(t).initialized === !0;
  }
  /**
   * Prepares the geometry of the given render object for rendering.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this.has(e) === !1 && this.initGeometry(e), this.updateAttributes(e);
  }
  /**
   * Initializes the geometry of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  initGeometry(e) {
    const t = e.geometry, n = this.get(t);
    n.initialized = !0, this.info.memory.geometries++;
    const i = () => {
      this.info.memory.geometries--;
      const o = t.index, l = e.getAttributes();
      o !== null && this.attributes.delete(o);
      for (const f of l)
        this.attributes.delete(f);
      const p = this.wireframes.get(t);
      p !== void 0 && this.attributes.delete(p), t.removeEventListener("dispose", i);
    };
    t.addEventListener("dispose", i);
  }
  /**
   * Updates the geometry attributes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAttributes(e) {
    const t = e.getAttributes();
    for (const o of t)
      o.isStorageBufferAttribute || o.isStorageInstancedBufferAttribute ? this.updateAttribute(o, ll.STORAGE) : this.updateAttribute(o, ll.VERTEX);
    const n = this.getIndex(e);
    n !== null && this.updateAttribute(n, ll.INDEX);
    const i = e.geometry.indirect;
    i !== null && this.updateAttribute(i, ll.INDIRECT);
  }
  /**
   * Updates the given attribute.
   *
   * @param {BufferAttribute} attribute - The attribute to update.
   * @param {number} type - The attribute type.
   */
  updateAttribute(e, t) {
    const n = this.info.render.calls;
    e.isInterleavedBufferAttribute ? this.attributeCall.get(e) === void 0 ? (this.attributes.update(e, t), this.attributeCall.set(e, n)) : this.attributeCall.get(e.data) !== n && (this.attributes.update(e, t), this.attributeCall.set(e.data, n), this.attributeCall.set(e, n)) : this.attributeCall.get(e) !== n && (this.attributes.update(e, t), this.attributeCall.set(e, n));
  }
  /**
   * Returns the indirect buffer attribute of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The indirect attribute. `null` if no indirect drawing is used.
   */
  getIndirect(e) {
    return e.geometry.indirect;
  }
  /**
   * Returns the index of the given render object's geometry. This is implemented
   * in a method to return a wireframe index if necessary.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {?BufferAttribute} The index. Returns `null` for non-indexed geometries.
   */
  getIndex(e) {
    const { geometry: t, material: n } = e;
    let i = t.index;
    if (n.wireframe === !0) {
      const o = this.wireframes;
      let l = o.get(t);
      l === void 0 ? (l = afe(t), o.set(t, l)) : l.version !== Mye(t) && (this.attributes.delete(l), l = afe(t), o.set(t, l)), i = l;
    }
    return i;
  }
}
class URe {
  /**
   * Constructs a new info component.
   */
  constructor() {
    this.autoReset = !0, this.frame = 0, this.calls = 0, this.render = {
      calls: 0,
      frameCalls: 0,
      drawCalls: 0,
      triangles: 0,
      points: 0,
      lines: 0,
      timestamp: 0
    }, this.compute = {
      calls: 0,
      frameCalls: 0,
      timestamp: 0
    }, this.memory = {
      geometries: 0,
      textures: 0
    };
  }
  /**
   * This method should be executed per draw call and updates the corresponding metrics.
   *
   * @param {Object3D} object - The 3D object that is going to be rendered.
   * @param {number} count - The vertex or index count.
   * @param {number} instanceCount - The instance count.
   */
  update(e, t, n) {
    this.render.drawCalls++, e.isMesh || e.isSprite ? this.render.triangles += n * (t / 3) : e.isPoints ? this.render.points += n * t : e.isLineSegments ? this.render.lines += n * (t / 2) : e.isLine ? this.render.lines += n * (t - 1) : console.error("THREE.WebGPUInfo: Unknown object type.");
  }
  /**
   * Resets frame related metrics.
   */
  reset() {
    this.render.drawCalls = 0, this.render.frameCalls = 0, this.compute.frameCalls = 0, this.render.triangles = 0, this.render.points = 0, this.render.lines = 0;
  }
  /**
   * Performs a complete reset of the object.
   */
  dispose() {
    this.reset(), this.calls = 0, this.render.calls = 0, this.compute.calls = 0, this.render.timestamp = 0, this.compute.timestamp = 0, this.memory.geometries = 0, this.memory.textures = 0;
  }
}
class Rye {
  /**
   * Constructs a new pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   */
  constructor(e) {
    this.cacheKey = e, this.usedTimes = 0;
  }
}
class zRe extends Rye {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
   * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
   */
  constructor(e, t, n) {
    super(e), this.vertexProgram = t, this.fragmentProgram = n;
  }
}
class VRe extends Rye {
  /**
   * Constructs a new render pipeline.
   *
   * @param {string} cacheKey - The pipeline's cache key.
   * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
   */
  constructor(e, t) {
    super(e), this.computeProgram = t, this.isComputePipeline = !0;
  }
}
let GRe = 0;
class f5 {
  /**
   * Constructs a new programmable stage.
   *
   * @param {string} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {string} name - The name of the shader.
   * @param {?Array<Object>} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {?Array<Object>} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  constructor(e, t, n, i = null, o = null) {
    this.id = GRe++, this.code = e, this.stage = t, this.name = n, this.transforms = i, this.attributes = o, this.usedTimes = 0;
  }
}
class qRe extends nf {
  /**
   * Constructs a new pipeline management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(e, t) {
    super(), this.backend = e, this.nodes = t, this.bindings = null, this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Returns a compute pipeline for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  getForCompute(e, t) {
    const { backend: n } = this, i = this.get(e);
    if (this._needsComputeUpdate(e)) {
      const o = i.pipeline;
      o && (o.usedTimes--, o.computeProgram.usedTimes--);
      const l = this.nodes.getForCompute(e);
      let p = this.programs.compute.get(l.computeShader);
      p === void 0 && (o && o.computeProgram.usedTimes === 0 && this._releaseProgram(o.computeProgram), p = new f5(l.computeShader, "compute", e.name, l.transforms, l.nodeAttributes), this.programs.compute.set(l.computeShader, p), n.createProgram(p));
      const f = this._getComputeCacheKey(e, p);
      let v = this.caches.get(f);
      v === void 0 && (o && o.usedTimes === 0 && this._releasePipeline(o), v = this._getComputePipeline(e, p, f, t)), v.usedTimes++, p.usedTimes++, i.version = e.version, i.pipeline = v;
    }
    return i.pipeline;
  }
  /**
   * Returns a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {?Array<Promise>} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {RenderPipeline} The render pipeline.
   */
  getForRender(e, t = null) {
    const { backend: n } = this, i = this.get(e);
    if (this._needsRenderUpdate(e)) {
      const o = i.pipeline;
      o && (o.usedTimes--, o.vertexProgram.usedTimes--, o.fragmentProgram.usedTimes--);
      const l = e.getNodeBuilderState(), p = e.material ? e.material.name : "";
      let f = this.programs.vertex.get(l.vertexShader);
      f === void 0 && (o && o.vertexProgram.usedTimes === 0 && this._releaseProgram(o.vertexProgram), f = new f5(l.vertexShader, "vertex", p), this.programs.vertex.set(l.vertexShader, f), n.createProgram(f));
      let v = this.programs.fragment.get(l.fragmentShader);
      v === void 0 && (o && o.fragmentProgram.usedTimes === 0 && this._releaseProgram(o.fragmentProgram), v = new f5(l.fragmentShader, "fragment", p), this.programs.fragment.set(l.fragmentShader, v), n.createProgram(v));
      const _ = this._getRenderCacheKey(e, f, v);
      let E = this.caches.get(_);
      E === void 0 ? (o && o.usedTimes === 0 && this._releasePipeline(o), E = this._getRenderPipeline(e, f, v, _, t)) : e.pipeline = E, E.usedTimes++, f.usedTimes++, v.usedTimes++, i.pipeline = E;
    }
    return i.pipeline;
  }
  /**
   * Deletes the pipeline for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    const t = this.get(e).pipeline;
    return t && (t.usedTimes--, t.usedTimes === 0 && this._releasePipeline(t), t.isComputePipeline ? (t.computeProgram.usedTimes--, t.computeProgram.usedTimes === 0 && this._releaseProgram(t.computeProgram)) : (t.fragmentProgram.usedTimes--, t.vertexProgram.usedTimes--, t.vertexProgram.usedTimes === 0 && this._releaseProgram(t.vertexProgram), t.fragmentProgram.usedTimes === 0 && this._releaseProgram(t.fragmentProgram))), super.delete(e);
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    super.dispose(), this.caches = /* @__PURE__ */ new Map(), this.programs = {
      vertex: /* @__PURE__ */ new Map(),
      fragment: /* @__PURE__ */ new Map(),
      compute: /* @__PURE__ */ new Map()
    };
  }
  /**
   * Updates the pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this.getForRender(e);
  }
  /**
   * Returns a compute pipeline for the given parameters.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @param {string} cacheKey - The cache key.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getComputePipeline(e, t, n, i) {
    n = n || this._getComputeCacheKey(e, t);
    let o = this.caches.get(n);
    return o === void 0 && (o = new VRe(n, t), this.caches.set(n, o), this.backend.createComputePipeline(o, i)), o;
  }
  /**
   * Returns a render pipeline for the given parameters.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @param {string} cacheKey - The cache key.
   * @param {?Array<Promise>} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
   * @return {ComputePipeline} The compute pipeline.
   */
  _getRenderPipeline(e, t, n, i, o) {
    i = i || this._getRenderCacheKey(e, t, n);
    let l = this.caches.get(i);
    return l === void 0 && (l = new zRe(i, t, n), this.caches.set(i, l), e.pipeline = l, this.backend.createRenderPipeline(e, o)), l;
  }
  /**
   * Computes a cache key representing a compute pipeline.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
   * @return {string} The cache key.
   */
  _getComputeCacheKey(e, t) {
    return e.id + "," + t.id;
  }
  /**
   * Computes a cache key representing a render pipeline.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
   * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
   * @return {string} The cache key.
   */
  _getRenderCacheKey(e, t, n) {
    return t.id + "," + n.id + "," + this.backend.getRenderCacheKey(e);
  }
  /**
   * Releases the given pipeline.
   *
   * @private
   * @param {Pipeline} pipeline - The pipeline to release.
   */
  _releasePipeline(e) {
    this.caches.delete(e.cacheKey);
  }
  /**
   * Releases the shader program.
   *
   * @private
   * @param {Object} program - The shader program to release.
   */
  _releaseProgram(e) {
    const t = e.code, n = e.stage;
    this.programs[n].delete(t);
  }
  /**
   * Returns `true` if the compute pipeline for the given compute node requires an update.
   *
   * @private
   * @param {Node} computeNode - The compute node.
   * @return {boolean} Whether the compute pipeline for the given compute node requires an update or not.
   */
  _needsComputeUpdate(e) {
    const t = this.get(e);
    return t.pipeline === void 0 || t.version !== e.version;
  }
  /**
   * Returns `true` if the render pipeline for the given render object requires an update.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render object for the given render object requires an update or not.
   */
  _needsRenderUpdate(e) {
    return this.get(e).pipeline === void 0 || this.backend.needsRenderUpdate(e);
  }
}
class HRe extends nf {
  /**
   * Constructs a new bindings management component.
   *
   * @param {Backend} backend - The renderer's backend.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   * @param {Textures} textures - Renderer component for managing textures.
   * @param {Attributes} attributes - Renderer component for managing attributes.
   * @param {Pipelines} pipelines - Renderer component for managing pipelines.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n, i, o, l) {
    super(), this.backend = e, this.textures = n, this.pipelines = o, this.attributes = i, this.nodes = t, this.info = l, this.pipelines.bindings = this;
  }
  /**
   * Returns the bind groups for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForRender(e) {
    const t = e.getBindings();
    for (const n of t) {
      const i = this.get(n);
      i.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, t, 0), i.bindGroup = n);
    }
    return t;
  }
  /**
   * Returns the bind groups for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {Array<BindGroup>} The bind groups.
   */
  getForCompute(e) {
    const t = this.nodes.getForCompute(e).bindings;
    for (const n of t) {
      const i = this.get(n);
      i.bindGroup === void 0 && (this._init(n), this.backend.createBindings(n, t, 0), i.bindGroup = n);
    }
    return t;
  }
  /**
   * Updates the bindings for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(e) {
    this._updateBindings(this.getForCompute(e));
  }
  /**
   * Updates the bindings for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    this._updateBindings(this.getForRender(e));
  }
  /**
   * Updates the given array of bindings.
   *
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _updateBindings(e) {
    for (const t of e)
      this._update(t, e);
  }
  /**
   * Initializes the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to initialize.
   */
  _init(e) {
    for (const t of e.bindings)
      if (t.isSampledTexture)
        this.textures.updateTexture(t.texture);
      else if (t.isStorageBuffer) {
        const n = t.attribute, i = n.isIndirectStorageBufferAttribute ? ll.INDIRECT : ll.STORAGE;
        this.attributes.update(n, i);
      }
  }
  /**
   * Updates the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group to update.
   * @param {Array<BindGroup>} bindings - The bind groups.
   */
  _update(e, t) {
    const { backend: n } = this;
    let i = !1, o = !0, l = 0, p = 0;
    for (const f of e.bindings)
      if (!(f.isNodeUniformsGroup && this.nodes.updateGroup(f) === !1)) {
        if (f.isStorageBuffer) {
          const v = f.attribute, _ = v.isIndirectStorageBufferAttribute ? ll.INDIRECT : ll.STORAGE;
          this.attributes.update(v, _);
        }
        if (f.isUniformBuffer)
          f.update() && n.updateBinding(f);
        else if (f.isSampler)
          f.update();
        else if (f.isSampledTexture) {
          const v = this.textures.get(f.texture);
          f.needsBindingsUpdate(v.generation) && (i = !0);
          const _ = f.update(), E = f.texture;
          _ && this.textures.updateTexture(E);
          const A = n.get(E);
          if (A.externalTexture !== void 0 || v.isDefaultTexture ? o = !1 : (l = l * 10 + E.id, p += E.version), n.isWebGPUBackend === !0 && A.texture === void 0 && A.externalTexture === void 0 && (console.error("Bindings._update: binding should be available:", f, _, E, f.textureNode.value, i), this.textures.updateTexture(E), i = !0), E.isStorageTexture === !0) {
            const I = this.get(E);
            f.store === !0 ? I.needsMipmap = !0 : this.textures.needsMipmaps(E) && I.needsMipmap === !0 && (this.backend.generateMipmaps(E), I.needsMipmap = !1);
          }
        }
      }
    i === !0 && this.backend.updateBindings(e, t, o ? l : 0, p);
  }
}
function $Re(c, e) {
  return c.groupOrder !== e.groupOrder ? c.groupOrder - e.groupOrder : c.renderOrder !== e.renderOrder ? c.renderOrder - e.renderOrder : c.z !== e.z ? c.z - e.z : c.id - e.id;
}
function lfe(c, e) {
  return c.groupOrder !== e.groupOrder ? c.groupOrder - e.groupOrder : c.renderOrder !== e.renderOrder ? c.renderOrder - e.renderOrder : c.z !== e.z ? e.z - c.z : c.id - e.id;
}
function ufe(c) {
  return (c.transmission > 0 || c.transmissionNode) && c.side === Mb && c.forceSinglePass === !1;
}
class WRe {
  /**
   * Constructs a render list.
   *
   * @param {Lighting} lighting - The lighting management component.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera the scene is rendered with.
   */
  constructor(e, t, n) {
    this.renderItems = [], this.renderItemsIndex = 0, this.opaque = [], this.transparentDoublePass = [], this.transparent = [], this.bundles = [], this.lightsNode = e.getNode(t, n), this.lightsArray = [], this.scene = t, this.camera = n, this.occlusionQueryCount = 0;
  }
  /**
   * This method is called right at the beginning of a render call
   * before the scene is analyzed. It prepares the internal data
   * structures for the upcoming render lists generation.
   *
   * @return {RenderList} A reference to this render list.
   */
  begin() {
    return this.renderItemsIndex = 0, this.opaque.length = 0, this.transparentDoublePass.length = 0, this.transparent.length = 0, this.bundles.length = 0, this.lightsArray.length = 0, this.occlusionQueryCount = 0, this;
  }
  /**
   * Returns a render item for the giving render item state. The state is defined
   * by a series of object-related parameters.
   *
   * The method avoids object creation by holding render items and reusing them in
   * subsequent render calls (just with different property values).
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   * @return {Object} The render item.
   */
  getNextRenderItem(e, t, n, i, o, l, p) {
    let f = this.renderItems[this.renderItemsIndex];
    return f === void 0 ? (f = {
      id: e.id,
      object: e,
      geometry: t,
      material: n,
      groupOrder: i,
      renderOrder: e.renderOrder,
      z: o,
      group: l,
      clippingContext: p
    }, this.renderItems[this.renderItemsIndex] = f) : (f.id = e.id, f.object = e, f.geometry = t, f.material = n, f.groupOrder = i, f.renderOrder = e.renderOrder, f.z = o, f.group = l, f.clippingContext = p), this.renderItemsIndex++, f;
  }
  /**
   * Pushes the given object as a render item to the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  push(e, t, n, i, o, l, p) {
    const f = this.getNextRenderItem(e, t, n, i, o, l, p);
    e.occlusionTest === !0 && this.occlusionQueryCount++, n.transparent === !0 || n.transmission > 0 ? (ufe(n) && this.transparentDoublePass.push(f), this.transparent.push(f)) : this.opaque.push(f);
  }
  /**
   * Inserts the given object as a render item at the start of the internal render lists.
   * The selected lists depend on the object properties.
   *
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {number} groupOrder - The current group order.
   * @param {number} z - Th 3D object's depth value (z value in clip space).
   * @param {?number} group - {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  unshift(e, t, n, i, o, l, p) {
    const f = this.getNextRenderItem(e, t, n, i, o, l, p);
    n.transparent === !0 || n.transmission > 0 ? (ufe(n) && this.transparentDoublePass.unshift(f), this.transparent.unshift(f)) : this.opaque.unshift(f);
  }
  /**
   * Pushes render bundle group data into the render list.
   *
   * @param {Object} group - Bundle group data.
   */
  pushBundle(e) {
    this.bundles.push(e);
  }
  /**
   * Pushes a light into the render list.
   *
   * @param {Light} light - The light.
   */
  pushLight(e) {
    this.lightsArray.push(e);
  }
  /**
   * Sorts the internal render lists.
   *
   * @param {?function(any, any): number} customOpaqueSort - A custom sort function for opaque objects.
   * @param {?function(any, any): number} customTransparentSort -  A custom sort function for transparent objects.
   */
  sort(e, t) {
    this.opaque.length > 1 && this.opaque.sort(e || $Re), this.transparentDoublePass.length > 1 && this.transparentDoublePass.sort(t || lfe), this.transparent.length > 1 && this.transparent.sort(t || lfe);
  }
  /**
   * This method performs finalizing tasks right after the render lists
   * have been generated.
   */
  finish() {
    this.lightsNode.setLights(this.lightsArray);
    for (let e = this.renderItemsIndex, t = this.renderItems.length; e < t; e++) {
      const n = this.renderItems[e];
      if (n.id === null) break;
      n.id = null, n.object = null, n.geometry = null, n.material = null, n.groupOrder = null, n.renderOrder = null, n.z = null, n.group = null, n.clippingContext = null;
    }
  }
}
const Pw = [];
class KRe {
  /**
   * Constructs a render lists management component.
   *
   * @param {Lighting} lighting - The lighting management component.
   */
  constructor(e) {
    this.lighting = e, this.lists = new hu();
  }
  /**
   * Returns a render list for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {RenderList} The render list.
   */
  get(e, t) {
    const n = this.lists;
    Pw[0] = e, Pw[1] = t;
    let i = n.get(Pw);
    return i === void 0 && (i = new WRe(this.lighting, e, t), n.set(Pw, i)), Pw.length = 0, i;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.lists = new hu();
  }
}
let YRe = 0;
class XRe {
  /**
   * Constructs a new render context.
   */
  constructor() {
    this.id = YRe++, this.color = !0, this.clearColor = !0, this.clearColorValue = { r: 0, g: 0, b: 0, a: 1 }, this.depth = !0, this.clearDepth = !0, this.clearDepthValue = 1, this.stencil = !1, this.clearStencil = !0, this.clearStencilValue = 1, this.viewport = !1, this.viewportValue = new Bn(), this.scissor = !1, this.scissorValue = new Bn(), this.renderTarget = null, this.textures = null, this.depthTexture = null, this.activeCubeFace = 0, this.activeMipmapLevel = 0, this.sampleCount = 1, this.width = 0, this.height = 0, this.occlusionQueryCount = 0, this.clippingContext = null, this.isRenderContext = !0;
  }
  /**
   * Returns the cache key of this render context.
   *
   * @return {number} The cache key.
   */
  getCacheKey() {
    return Iye(this);
  }
}
function Iye(c) {
  const { textures: e, activeCubeFace: t } = c, n = [t];
  for (const i of e)
    n.push(i.id);
  return F6(n);
}
let kg = class {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n === void 0 ? !1 : n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(e, t) {
    const n = this._listeners;
    if (n === void 0) return;
    const i = n[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(e) {
    const t = this._listeners;
    if (t === void 0) return;
    const n = t[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
      e.target = null;
    }
  }
};
const cfe = /* @__PURE__ */ new Pr(), dfe = /* @__PURE__ */ new Yb();
class hl {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(e = 0, t = 0, n = 0, i = hl.DEFAULT_ORDER) {
    this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(e) {
    this._order = e, this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(e, t, n, i = this._order) {
    return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(e) {
    return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements, o = i[0], l = i[4], p = i[8], f = i[1], v = i[5], _ = i[9], E = i[2], A = i[6], I = i[10];
    switch (t) {
      case "XYZ":
        this._y = Math.asin(Nn(p, -1, 1)), Math.abs(p) < 0.9999999 ? (this._x = Math.atan2(-_, I), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(A, v), this._z = 0);
        break;
      case "YXZ":
        this._x = Math.asin(-Nn(_, -1, 1)), Math.abs(_) < 0.9999999 ? (this._y = Math.atan2(p, I), this._z = Math.atan2(f, v)) : (this._y = Math.atan2(-E, o), this._z = 0);
        break;
      case "ZXY":
        this._x = Math.asin(Nn(A, -1, 1)), Math.abs(A) < 0.9999999 ? (this._y = Math.atan2(-E, I), this._z = Math.atan2(-l, v)) : (this._y = 0, this._z = Math.atan2(f, o));
        break;
      case "ZYX":
        this._y = Math.asin(-Nn(E, -1, 1)), Math.abs(E) < 0.9999999 ? (this._x = Math.atan2(A, I), this._z = Math.atan2(f, o)) : (this._x = 0, this._z = Math.atan2(-l, v));
        break;
      case "YZX":
        this._z = Math.asin(Nn(f, -1, 1)), Math.abs(f) < 0.9999999 ? (this._x = Math.atan2(-_, v), this._y = Math.atan2(-E, o)) : (this._x = 0, this._y = Math.atan2(p, I));
        break;
      case "XZY":
        this._z = Math.asin(-Nn(l, -1, 1)), Math.abs(l) < 0.9999999 ? (this._x = Math.atan2(A, v), this._y = Math.atan2(p, o)) : (this._x = Math.atan2(-_, I), this._y = 0);
        break;
      default:
        console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t);
    }
    return this._order = t, n === !0 && this._onChangeCallback(), this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(e, t, n) {
    return cfe.makeRotationFromQuaternion(e), this.setFromRotationMatrix(cfe, t, n);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(e) {
    return dfe.setFromEuler(this), this.setFromQuaternion(dfe, e);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(e) {
    return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(e) {
    return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(e = [], t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e;
  }
  _onChange(e) {
    return this._onChangeCallback = e, this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
hl.DEFAULT_ORDER = "XYZ";
class QRe {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(e) {
    this.mask = (1 << e | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(e) {
    this.mask |= 1 << e | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = -1;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(e) {
    this.mask ^= 1 << e | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(e) {
    this.mask &= ~(1 << e | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(e) {
    return (this.mask & (1 << e | 0)) !== 0;
  }
}
let ZRe = 0;
const hfe = /* @__PURE__ */ new Ue(), eb = /* @__PURE__ */ new Yb(), Ad = /* @__PURE__ */ new Pr(), wN = /* @__PURE__ */ new Ue(), Aw = /* @__PURE__ */ new Ue(), JRe = /* @__PURE__ */ new Ue(), eIe = /* @__PURE__ */ new Yb(), pfe = /* @__PURE__ */ new Ue(1, 0, 0), ffe = /* @__PURE__ */ new Ue(0, 1, 0), mfe = /* @__PURE__ */ new Ue(0, 0, 1), gfe = { type: "added" }, tIe = { type: "removed" }, tb = { type: "childadded", child: null }, m5 = { type: "childremoved", child: null };
class Wi extends kg {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: ZRe++ }), this.uuid = Bd(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wi.DEFAULT_UP.clone();
    const e = new Ue(), t = new hl(), n = new Yb(), i = new Ue(1, 1, 1);
    function o() {
      n.setFromEuler(t, !1);
    }
    function l() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(o), n._onChange(l), Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: !0,
        enumerable: !0,
        value: e
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: !0,
        enumerable: !0,
        value: t
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: !0,
        enumerable: !0,
        value: n
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: !0,
        enumerable: !0,
        value: i
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new Pr()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Xo()
      }
    }), this.matrix = new Pr(), this.matrixWorld = new Pr(), this.matrixAutoUpdate = Wi.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Wi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new QRe(), this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(e, t) {
    return eb.setFromAxisAngle(e, t), this.quaternion.multiply(eb), this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(e, t) {
    return eb.setFromAxisAngle(e, t), this.quaternion.premultiply(eb), this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(e) {
    return this.rotateOnAxis(pfe, e);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(e) {
    return this.rotateOnAxis(ffe, e);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(e) {
    return this.rotateOnAxis(mfe, e);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(e, t) {
    return hfe.copy(e).applyQuaternion(this.quaternion), this.position.add(hfe.multiplyScalar(t)), this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(e) {
    return this.translateOnAxis(pfe, e);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(e) {
    return this.translateOnAxis(ffe, e);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(e) {
    return this.translateOnAxis(mfe, e);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(Ad.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(e, t, n) {
    e.isVector3 ? wN.copy(e) : wN.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1), Aw.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Ad.lookAt(Aw, wN, this.up) : Ad.lookAt(wN, Aw, this.up), this.quaternion.setFromRotationMatrix(Ad), i && (Ad.extractRotation(i.matrixWorld), eb.setFromRotationMatrix(Ad), this.quaternion.premultiply(eb.invert()));
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++)
        this.add(arguments[t]);
      return this;
    }
    return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(gfe), tb.child = e, this.dispatchEvent(tb), tb.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this);
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++)
        this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(tIe), m5.child = e, this.dispatchEvent(m5), m5.child = null), this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(e) {
    return this.updateWorldMatrix(!0, !1), Ad.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), Ad.multiply(e.parent.matrixWorld)), e.applyMatrix4(Ad), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(gfe), tb.child = e, this.dispatchEvent(tb), tb.child = null, this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const l = this.children[n].getObjectByProperty(e, t);
      if (l !== void 0)
        return l;
    }
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(e, t, n = []) {
    this[e] === t && n.push(this);
    const i = this.children;
    for (let o = 0, l = i.length; o < l; o++)
      i[o].getObjectsByProperty(e, t, n);
    return n;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(e) {
    return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Aw, e, JRe), e;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(e) {
    return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Aw, eIe, e), e;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverse(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].traverseVisible(e);
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++)
      t[n].updateMatrixWorld(e);
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
      const i = this.children;
      for (let o = 0, l = i.length; o < l; o++)
        i[o].updateWorldMatrix(!1, !0);
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string", n = {};
    t && (e = {
      geometries: {},
      materials: {},
      textures: {},
      images: {},
      shapes: {},
      skeletons: {},
      animations: {},
      nodes: {}
    }, n.metadata = {
      version: 4.7,
      type: "Object",
      generator: "Object3D.toJSON"
    });
    const i = {};
    i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.geometryInfo = this._geometryInfo.map((p) => ({
      ...p,
      boundingBox: p.boundingBox ? p.boundingBox.toJSON() : void 0,
      boundingSphere: p.boundingSphere ? p.boundingSphere.toJSON() : void 0
    })), i.instanceInfo = this._instanceInfo.map((p) => ({ ...p })), i.availableInstanceIds = this._availableInstanceIds.slice(), i.availableGeometryIds = this._availableGeometryIds.slice(), i.nextIndexStart = this._nextIndexStart, i.nextVertexStart = this._nextVertexStart, i.geometryCount = this._geometryCount, i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.matricesTexture = this._matricesTexture.toJSON(e), i.indirectTexture = this._indirectTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = this.boundingSphere.toJSON()), this.boundingBox !== null && (i.boundingBox = this.boundingBox.toJSON()));
    function o(p, f) {
      return p[f.uuid] === void 0 && (p[f.uuid] = f.toJSON(e)), f.uuid;
    }
    if (this.isScene)
      this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = o(e.geometries, this.geometry);
      const p = this.geometry.parameters;
      if (p !== void 0 && p.shapes !== void 0) {
        const f = p.shapes;
        if (Array.isArray(f))
          for (let v = 0, _ = f.length; v < _; v++) {
            const E = f[v];
            o(e.shapes, E);
          }
        else
          o(e.shapes, f);
      }
    }
    if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (o(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
      if (Array.isArray(this.material)) {
        const p = [];
        for (let f = 0, v = this.material.length; f < v; f++)
          p.push(o(e.materials, this.material[f]));
        i.material = p;
      } else
        i.material = o(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let p = 0; p < this.children.length; p++)
        i.children.push(this.children[p].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let p = 0; p < this.animations.length; p++) {
        const f = this.animations[p];
        i.animations.push(o(e.animations, f));
      }
    }
    if (t) {
      const p = l(e.geometries), f = l(e.materials), v = l(e.textures), _ = l(e.images), E = l(e.shapes), A = l(e.skeletons), I = l(e.animations), j = l(e.nodes);
      p.length > 0 && (n.geometries = p), f.length > 0 && (n.materials = f), v.length > 0 && (n.textures = v), _.length > 0 && (n.images = _), E.length > 0 && (n.shapes = E), A.length > 0 && (n.skeletons = A), I.length > 0 && (n.animations = I), j.length > 0 && (n.nodes = j);
    }
    return n.object = i, n;
    function l(p) {
      const f = [];
      for (const v in p) {
        const _ = p[v];
        delete _.metadata, f.push(_);
      }
      return f;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(e, t = !0) {
    if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Wi.DEFAULT_UP = /* @__PURE__ */ new Ue(0, 1, 0);
Wi.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Wi.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
class B6 extends Wi {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new hl(), this.environmentIntensity = 1, this.environmentRotation = new hl(), this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
  copy(e, t) {
    return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t;
  }
}
class L6 extends Wi {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Pr(), this.projectionMatrix = new Pr(), this.projectionMatrixInverse = new Pr(), this.coordinateSystem = Ho;
  }
  copy(e, t) {
    return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(e) {
    return super.getWorldDirection(e).negate();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const kw = [], nIe = /* @__PURE__ */ new B6(), rIe = /* @__PURE__ */ new L6();
class iIe {
  /**
   * Constructs a new render context management component.
   */
  constructor() {
    this.chainMaps = {};
  }
  /**
   * Returns a render context for the given scene, camera and render target.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  get(e, t, n = null) {
    kw[0] = e, kw[1] = t;
    let i;
    if (n === null)
      i = "default";
    else {
      const p = n.texture.format;
      i = `${n.textures.length}:${p}:${n.samples}:${n.depthBuffer}:${n.stencilBuffer}`;
    }
    const o = this._getChainMap(i);
    let l = o.get(kw);
    return l === void 0 && (l = new XRe(), o.set(kw, l)), kw.length = 0, n !== null && (l.sampleCount = n.samples === 0 ? 1 : n.samples), l;
  }
  /**
   * Returns a render context intended for clear operations.
   *
   * @param {?RenderTarget} [renderTarget=null] - The active render target.
   * @return {RenderContext} The render context.
   */
  getForClear(e = null) {
    return this.get(nIe, rIe, e);
  }
  /**
   * Returns a chain map for the given attachment state.
   *
   * @private
   * @param {string} attachmentState - The attachment state.
   * @return {ChainMap} The chain map.
   */
  _getChainMap(e) {
    return this.chainMaps[e] || (this.chainMaps[e] = new hu());
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    this.chainMaps = {};
  }
}
let nb;
class sIe {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(e, t = "image/png") {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
      return e.src;
    let n;
    if (e instanceof HTMLCanvasElement)
      n = e;
    else {
      nb === void 0 && (nb = i6("canvas")), nb.width = e.width, nb.height = e.height;
      const i = nb.getContext("2d");
      e instanceof ImageData ? i.putImageData(e, 0, 0) : i.drawImage(e, 0, 0, e.width, e.height), n = nb;
    }
    return n.toDataURL(t);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(e) {
    if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
      const t = i6("canvas");
      t.width = e.width, t.height = e.height;
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height), o = i.data;
      for (let l = 0; l < o.length; l++)
        o[l] = Vd(o[l] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Vd(t[n] / 255) * 255) : t[n] = Vd(t[n]);
      return {
        data: t,
        width: e.width,
        height: e.height
      };
    } else
      return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e;
  }
}
let oIe = 0;
class j6 {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(e = null) {
    this.isSource = !0, Object.defineProperty(this, "id", { value: oIe++ }), this.uuid = Bd(), this.data = e, this.dataReady = !0, this.version = 0;
  }
  getSize(e) {
    const t = this.data;
    return t instanceof HTMLVideoElement ? e.set(t.videoWidth, t.videoHeight) : t !== null ? e.set(t.width, t.height, t.depth || 0) : e.set(0, 0, 0), e;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0)
      return e.images[this.uuid];
    const n = {
      uuid: this.uuid,
      url: ""
    }, i = this.data;
    if (i !== null) {
      let o;
      if (Array.isArray(i)) {
        o = [];
        for (let l = 0, p = i.length; l < p; l++)
          i[l].isDataTexture ? o.push(g5(i[l].image)) : o.push(g5(i[l]));
      } else
        o = g5(i);
      n.url = o;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function g5(c) {
  return typeof HTMLImageElement < "u" && c instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && c instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && c instanceof ImageBitmap ? sIe.getDataURL(c) : c.data ? {
    data: Array.from(c.data),
    width: c.width,
    height: c.height,
    type: c.data.constructor.name
  } : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let aIe = 0;
const y5 = /* @__PURE__ */ new Ue();
class Js extends kg {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = Js.DEFAULT_IMAGE, t = Js.DEFAULT_MAPPING, n = Kp, i = Kp, o = Ea, l = Ud, p = al, f = yo, v = Js.DEFAULT_ANISOTROPY, _ = $d) {
    super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: aIe++ }), this.uuid = Bd(), this.name = "", this.source = new j6(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = o, this.minFilter = l, this.anisotropy = v, this.format = p, this.internalFormat = null, this.type = f, this.offset = new Pn(0, 0), this.repeat = new Pn(1, 1), this.center = new Pn(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xo(), this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = _, this.userData = {}, this.updateRanges = [], this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.isArrayTexture = !!(e && e.depth && e.depth > 1), this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(y5).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(y5).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(y5).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(e) {
    return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.isArrayTexture = e.isArrayTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(e) {
    for (const t in e) {
      const n = e[t];
      if (n === void 0) {
        console.warn(`THREE.Texture.setValues(): parameter '${t}' has value of undefined.`);
        continue;
      }
      const i = this[t];
      if (i === void 0) {
        console.warn(`THREE.Texture.setValues(): property '${t}' does not exist.`);
        continue;
      }
      i && n && i.isVector2 && n.isVector2 || i && n && i.isVector3 && n.isVector3 || i && n && i.isMatrix3 && n.isMatrix3 ? i.copy(n) : this[t] = n;
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0)
      return e.textures[this.uuid];
    const n = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(e) {
    if (this.mapping !== P6) return e;
    if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1)
      switch (this.wrapS) {
        case Vb:
          e.x = e.x - Math.floor(e.x);
          break;
        case Kp:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Gb:
          Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Vb:
          e.y = e.y - Math.floor(e.y);
          break;
        case Kp:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Gb:
          Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && (this.version++, this.source.needsUpdate = !0);
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(e) {
    e === !0 && this.pmremVersion++;
  }
}
Js.DEFAULT_IMAGE = null;
Js.DEFAULT_MAPPING = P6;
Js.DEFAULT_ANISOTROPY = 1;
class _c extends Js {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e, t, n = xi, i, o, l, p = $i, f = $i, v, _ = xc, E = 1) {
    if (_ !== xc && _ !== zd)
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    const A = { width: e, height: t, depth: E };
    super(A, i, o, l, p, f, _, n, v), this.isDepthTexture = !0, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null;
  }
  copy(e) {
    return super.copy(e), this.source = new j6(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t;
  }
}
const lIe = /* @__PURE__ */ new Ue();
class uIe extends nf {
  /**
   * Constructs a new texture management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   * @param {Info} info - Renderer component for managing metrics and monitoring data.
   */
  constructor(e, t, n) {
    super(), this.renderer = e, this.backend = t, this.info = n;
  }
  /**
   * Updates the given render target. Based on the given render target configuration,
   * it updates the texture states representing the attachments of the framebuffer.
   *
   * @param {RenderTarget} renderTarget - The render target to update.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  updateRenderTarget(e, t = 0) {
    const n = this.get(e), i = e.samples === 0 ? 1 : e.samples, o = n.depthTextureMips || (n.depthTextureMips = {}), l = e.textures, p = this.getSize(l[0]), f = p.width >> t, v = p.height >> t;
    let _ = e.depthTexture || o[t];
    const E = e.depthBuffer === !0 || e.stencilBuffer === !0;
    let A = !1;
    _ === void 0 && E && (_ = new _c(), _.format = e.stencilBuffer ? zd : xc, _.type = e.stencilBuffer ? Xp : xi, _.image.width = f, _.image.height = v, _.image.depth = p.depth, _.isArrayTexture = e.multiview === !0 && p.depth > 1, o[t] = _), (n.width !== p.width || p.height !== n.height) && (A = !0, _ && (_.needsUpdate = !0, _.image.width = f, _.image.height = v, _.image.depth = _.isArrayTexture ? _.image.depth : 1)), n.width = p.width, n.height = p.height, n.textures = l, n.depthTexture = _ || null, n.depth = e.depthBuffer, n.stencil = e.stencilBuffer, n.renderTarget = e, n.sampleCount !== i && (A = !0, _ && (_.needsUpdate = !0), n.sampleCount = i);
    const I = { sampleCount: i };
    if (e.isXRRenderTarget !== !0) {
      for (let j = 0; j < l.length; j++) {
        const q = l[j];
        A && (q.needsUpdate = !0), this.updateTexture(q, I);
      }
      _ && this.updateTexture(_, I);
    }
    if (n.initialized !== !0) {
      n.initialized = !0;
      const j = () => {
        e.removeEventListener("dispose", j);
        for (let q = 0; q < l.length; q++)
          this._destroyTexture(l[q]);
        _ && this._destroyTexture(_), this.delete(e);
      };
      e.addEventListener("dispose", j);
    }
  }
  /**
   * Updates the given texture. Depending on the texture state, this method
   * triggers the upload of texture data to the GPU memory. If the texture data are
   * not yet ready for the upload, it uses default texture data for as a placeholder.
   *
   * @param {Texture} texture - The texture to update.
   * @param {Object} [options={}] - The options.
   */
  updateTexture(e, t = {}) {
    const n = this.get(e);
    if (n.initialized === !0 && n.version === e.version) return;
    const i = e.isRenderTargetTexture || e.isDepthTexture || e.isFramebufferTexture, o = this.backend;
    if (i && n.initialized === !0 && (o.destroySampler(e), o.destroyTexture(e)), e.isFramebufferTexture) {
      const v = this.renderer.getRenderTarget();
      v ? e.type = v.texture.type : e.type = yo;
    }
    const { width: l, height: p, depth: f } = this.getSize(e);
    if (t.width = l, t.height = p, t.depth = f, t.needsMipmaps = this.needsMipmaps(e), t.levels = t.needsMipmaps ? this.getMipLevels(e, l, p) : 1, i || e.isStorageTexture === !0)
      o.createSampler(e), o.createTexture(e, t), n.generation = e.version;
    else if (n.initialized !== !0 && o.createSampler(e), e.version > 0) {
      const _ = e.image;
      if (_ === void 0)
        console.warn("THREE.Renderer: Texture marked for update but image is undefined.");
      else if (_.complete === !1)
        console.warn("THREE.Renderer: Texture marked for update but image is incomplete.");
      else {
        if (e.images) {
          const E = [];
          for (const A of e.images)
            E.push(A);
          t.images = E;
        } else
          t.image = _;
        (n.isDefaultTexture === void 0 || n.isDefaultTexture === !0) && (o.createTexture(e, t), n.isDefaultTexture = !1, n.generation = e.version), e.source.dataReady === !0 && o.updateTexture(e, t), t.needsMipmaps && e.mipmaps.length === 0 && o.generateMipmaps(e);
      }
    } else
      o.createDefaultTexture(e), n.isDefaultTexture = !0, n.generation = e.version;
    if (n.initialized !== !0) {
      n.initialized = !0, n.generation = e.version, this.info.memory.textures++;
      const v = () => {
        e.removeEventListener("dispose", v), this._destroyTexture(e);
      };
      e.addEventListener("dispose", v);
    }
    n.version = e.version;
  }
  /**
   * Computes the size of the given texture and writes the result
   * into the target vector. This vector is also returned by the
   * method.
   *
   * If no texture data are available for the compute yet, the method
   * returns default size values.
   *
   * @param {Texture} texture - The texture to compute the size for.
   * @param {Vector3} target - The target vector.
   * @return {Vector3} The target vector.
   */
  getSize(e, t = lIe) {
    let n = e.images ? e.images[0] : e.image;
    return n ? (n.image !== void 0 && (n = n.image), t.width = n.width || 1, t.height = n.height || 1, t.depth = e.isCubeTexture ? 6 : n.depth || 1) : t.width = t.height = t.depth = 1, t;
  }
  /**
   * Computes the number of mipmap levels for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {number} width - The texture's width.
   * @param {number} height - The texture's height.
   * @return {number} The number of mipmap levels.
   */
  getMipLevels(e, t, n) {
    let i;
    return e.isCompressedTexture ? e.mipmaps ? i = e.mipmaps.length : i = 1 : i = Math.floor(Math.log2(Math.max(t, n))) + 1, i;
  }
  /**
   * Returns `true` if the given texture requires mipmaps.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether mipmaps are required or not.
   */
  needsMipmaps(e) {
    return e.isCompressedTexture === !0 || e.generateMipmaps;
  }
  /**
   * Frees internal resource when the given texture isn't
   * required anymore.
   *
   * @param {Texture} texture - The texture to destroy.
   */
  _destroyTexture(e) {
    this.has(e) === !0 && (this.backend.destroySampler(e), this.backend.destroyTexture(e), this.delete(e), this.info.memory.textures--);
  }
}
class U6 extends er {
  /**
   * Constructs a new four-component color.
   * You can also pass a single THREE.Color, hex or
   * string argument to this constructor.
   *
   * @param {number|string} [r=1] - The red value.
   * @param {number} [g=1] - The green value.
   * @param {number} [b=1] - The blue value.
   * @param {number} [a=1] - The alpha value.
   */
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.a = i;
  }
  /**
   * Overwrites the default to honor alpha.
   * You can also pass a single THREE.Color, hex or
   * string argument to this method.
   *
   * @param {number|string|Color} r - The red value.
   * @param {number} g - The green value.
   * @param {number} b - The blue value.
   * @param {number} [a=1] - The alpha value.
   * @return {Color4} A reference to this object.
   */
  set(e, t, n, i = 1) {
    return this.a = i, super.set(e, t, n);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @param {Color4} color - The color to copy.
   * @return {Color4} A reference to this object.
   */
  copy(e) {
    return e.a !== void 0 && (this.a = e.a), super.copy(e);
  }
  /**
   * Overwrites the default to honor alpha.
   *
   * @return {Color4} The cloned color.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b, this.a);
  }
}
const EN = {
  VERTEX: "vertex"
}, In = {
  NONE: "none",
  FRAME: "frame",
  RENDER: "render",
  OBJECT: "object"
}, Fd = {
  READ_ONLY: "readOnly",
  WRITE_ONLY: "writeOnly",
  READ_WRITE: "readWrite"
}, cIe = ["fragment", "vertex"], yfe = ["setup", "analyze", "generate"], vfe = [...cIe, "compute"], Xb = ["x", "y", "z", "w"], dIe = {
  analyze: "setup",
  generate: "analyze"
};
let hIe = 0, yn = class extends kg {
  static get type() {
    return "Node";
  }
  /**
   * Constructs a new node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(e = null) {
    super(), this.nodeType = e, this.updateType = In.NONE, this.updateBeforeType = In.NONE, this.updateAfterType = In.NONE, this.uuid = bMe.generateUUID(), this.version = 0, this.global = !1, this.parents = !1, this.isNode = !0, this._cacheKey = null, this._cacheKeyVersion = 0, Object.defineProperty(this, "id", { value: hIe++ });
  }
  /**
   * Set this property to `true` when the node should be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * The type of the class. The value is usually the constructor name.
   *
   * @type {string}
  	 * @readonly
   */
  get type() {
    return this.constructor.type;
  }
  /**
   * Convenient method for defining {@link Node#update}.
   *
   * @param {Function} callback - The update method.
   * @param {string} updateType - The update type.
   * @return {Node} A reference to this node.
   */
  onUpdate(e, t) {
    return this.updateType = t, this.update = e.bind(this.getSelf()), this;
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `FRAME`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onFrameUpdate(e) {
    return this.onUpdate(e, In.FRAME);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `RENDER`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onRenderUpdate(e) {
    return this.onUpdate(e, In.RENDER);
  }
  /**
   * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
   * this method automatically sets the update type to `OBJECT`.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onObjectUpdate(e) {
    return this.onUpdate(e, In.OBJECT);
  }
  /**
   * Convenient method for defining {@link Node#updateReference}.
   *
   * @param {Function} callback - The update method.
   * @return {Node} A reference to this node.
   */
  onReference(e) {
    return this.updateReference = e.bind(this.getSelf()), this;
  }
  /**
   * The `this` reference might point to a Proxy so this method can be used
   * to get the reference to the actual node instance.
   *
   * @return {Node} A reference to the node.
   */
  getSelf() {
    return this.self || this;
  }
  /**
   * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
   * to such objects based on a given state (e.g. the current node frame or builder).
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {any} The updated reference.
   */
  updateReference() {
    return this;
  }
  /**
   * By default this method returns the value of the {@link Node#global} flag. This method
   * can be overwritten in derived classes if an analytical way is required to determine the
   * global cache referring to the current shader-stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether this node is global or not.
   */
  isGlobal() {
    return this.global;
  }
  /**
   * Generator function that can be used to iterate over the child nodes.
   *
   * @generator
   * @yields {Node} A child node.
   */
  *getChildren() {
    for (const { childNode: e } of FO(this))
      yield e;
  }
  /**
   * Calling this method dispatches the `dispose` event. This event can be used
   * to register event listeners for clean up tasks.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Callback for {@link Node#traverse}.
   *
   * @callback traverseCallback
   * @param {Node} node - The current node.
   */
  /**
   * Can be used to traverse through the node's hierarchy.
   *
   * @param {traverseCallback} callback - A callback that is executed per node.
   */
  traverse(e) {
    e(this);
    for (const t of this.getChildren())
      t.traverse(e);
  }
  /**
   * Returns the cache key for this node.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
   * @return {number} The cache key of the node.
   */
  getCacheKey(e = !1) {
    return e = e || this.version !== this._cacheKeyVersion, (e === !0 || this._cacheKey === null) && (this._cacheKey = DO(Eye(this, e), this.customCacheKey()), this._cacheKeyVersion = this.version), this._cacheKey;
  }
  /**
   * Generate a custom cache key for this node.
   *
   * @return {number} The cache key of the node.
   */
  customCacheKey() {
    return 0;
  }
  /**
   * Returns the references to this node which is by default `this`.
   *
   * @return {Node} A reference to this node.
   */
  getScope() {
    return this;
  }
  /**
   * Returns the hash of the node which is used to identify the node. By default it's
   * the {@link Node#uuid} however derived node classes might have to overwrite this method
   * depending on their implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash() {
    return this.uuid;
  }
  /**
   * Returns the update type of {@link Node#update}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    return this.updateType;
  }
  /**
   * Returns the update type of {@link Node#updateBefore}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  /**
   * Returns the update type of {@link Node#updateAfter}.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateAfterType() {
    return this.updateAfterType;
  }
  /**
   * Certain types are composed of multiple elements. For example a `vec3`
   * is composed of three `float` values. This method returns the type of
   * these elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(e) {
    const t = this.getNodeType(e);
    return e.getElementType(t);
  }
  /**
   * Returns the node member type for the given name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} name - The name of the member.
   * @return {string} The type of the node.
   */
  getMemberType() {
    return "void";
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  /**
   * This method is used during the build process of a node and ensures
   * equal nodes are not built multiple times but just once. For example if
   * `attribute( 'uv' )` is used multiple times by the user, the build
   * process makes sure to process just the first node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The shared node if possible. Otherwise `this` is returned.
   */
  getShared(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  /**
   * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
   * This method is often overwritten in derived modules to prepare the node which is used as the output/result.
   * The output node must be returned in the `return` statement.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?Node} The output node.
   */
  setup(e) {
    const t = e.getNodeProperties(this);
    let n = 0;
    for (const i of this.getChildren())
      t["node" + n++] = i;
    return t.outputNode || null;
  }
  /**
   * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
   * This stage analyzes the node hierarchy and ensures descendent nodes are built.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?Node} output - The target output node.
   */
  analyze(e, t = null) {
    const n = e.increaseUsage(this);
    if (this.parents === !0) {
      const i = e.getDataFromNode(this, "any");
      i.stages = i.stages || {}, i.stages[e.shaderStage] = i.stages[e.shaderStage] || [], i.stages[e.shaderStage].push(t);
    }
    if (n === 1) {
      const i = e.getNodeProperties(this);
      for (const o of Object.values(i))
        o && o.isNode === !0 && o.build(e, this);
    }
  }
  /**
   * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
   * This state builds the output node and returns the resulting shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {?string} output - Can be used to define the output type.
   * @return {?string} The generated shader string.
   */
  generate(e, t) {
    const { outputNode: n } = e.getNodeProperties(this);
    if (n && n.isNode === !0)
      return n.build(e, t);
  }
  /**
   * The method can be implemented to update the node's internal state before it is used to render an object.
   * The {@link Node#updateBeforeType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateBefore() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state after it was used to render an object.
   * The {@link Node#updateAfterType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  updateAfter() {
    console.warn("Abstract function.");
  }
  /**
   * The method can be implemented to update the node's internal state when it is used to render an object.
   * The {@link Node#updateType} property defines how often the update is executed.
   *
   * @abstract
   * @param {NodeFrame} frame - A reference to the current node frame.
   * @return {?boolean} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
   */
  update() {
    console.warn("Abstract function.");
  }
  /**
   * This method performs the build of a node. The behavior and return value depend on the current build stage:
   * - **setup**: Prepares the node and its children for the build process. This process can also create new nodes. Returns the node itself or a variant.
   * - **analyze**: Analyzes the node hierarchy for optimizations in the code generation stage. Returns `null`.
   * - **generate**: Generates the shader code for the node. Returns the generated shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string|Node|null} [output=null] - Can be used to define the output type.
   * @return {Node|string|null} The result of the build process, depending on the build stage.
   */
  build(e, t = null) {
    const n = this.getShared(e);
    if (this !== n)
      return n.build(e, t);
    const i = e.getDataFromNode(this);
    i.buildStages = i.buildStages || {}, i.buildStages[e.buildStage] = !0;
    const o = dIe[e.buildStage];
    if (o && i.buildStages[o] !== !0) {
      const f = e.getBuildStage();
      e.setBuildStage(o), this.build(e), e.setBuildStage(f);
    }
    e.addNode(this), e.addChain(this);
    let l = null;
    const p = e.getBuildStage();
    if (p === "setup") {
      this.updateReference(e);
      const f = e.getNodeProperties(this);
      if (f.initialized !== !0) {
        f.initialized = !0, f.outputNode = this.setup(e) || f.outputNode || null;
        for (const v of Object.values(f))
          if (v && v.isNode === !0) {
            if (v.parents === !0) {
              const _ = e.getNodeProperties(v);
              _.parents = _.parents || [], _.parents.push(this);
            }
            v.build(e);
          }
      }
      l = f.outputNode;
    } else if (p === "analyze")
      this.analyze(e, t);
    else if (p === "generate")
      if (this.generate.length === 1) {
        const v = this.getNodeType(e), _ = e.getDataFromNode(this);
        l = _.snippet, l === void 0 ? _.generated === void 0 ? (_.generated = !0, l = this.generate(e) || "", _.snippet = l) : (console.warn("THREE.Node: Recursion detected.", this), l = "") : _.flowCodes !== void 0 && e.context.nodeBlock !== void 0 && e.addFlowCodeHierarchy(this, e.context.nodeBlock), l = e.format(l, v, t);
      } else
        l = this.generate(e, t) || "";
    return e.removeChain(this), e.addSequentialNode(this), l;
  }
  /**
   * Returns the child nodes as a JSON object.
   *
   * @return {Array<Object>} An iterable list of serialized child objects as JSON.
   */
  getSerializeChildren() {
    return FO(this);
  }
  /**
   * Serializes the node to JSON.
   *
   * @param {Object} json - The output JSON object.
   */
  serialize(e) {
    const t = this.getSerializeChildren(), n = {};
    for (const { property: i, index: o, childNode: l } of t)
      o !== void 0 ? (n[i] === void 0 && (n[i] = Number.isInteger(o) ? [] : {}), n[i][o] = l.toJSON(e.meta).uuid) : n[i] = l.toJSON(e.meta).uuid;
    Object.keys(n).length > 0 && (e.inputNodes = n);
  }
  /**
   * Deserializes the node from the given JSON.
   *
   * @param {Object} json - The JSON object.
   */
  deserialize(e) {
    if (e.inputNodes !== void 0) {
      const t = e.meta.nodes;
      for (const n in e.inputNodes)
        if (Array.isArray(e.inputNodes[n])) {
          const i = [];
          for (const o of e.inputNodes[n])
            i.push(t[o]);
          this[n] = i;
        } else if (typeof e.inputNodes[n] == "object") {
          const i = {};
          for (const o in e.inputNodes[n]) {
            const l = e.inputNodes[n][o];
            i[o] = t[l];
          }
          this[n] = i;
        } else {
          const i = e.inputNodes[n];
          this[n] = t[i];
        }
    }
  }
  /**
   * Serializes the node into the three.js JSON Object/Scene format.
   *
   * @param {?Object} meta - An optional JSON object that already holds serialized data from other scene objects.
   * @return {Object} The serialized node.
   */
  toJSON(e) {
    const { uuid: t, type: n } = this, i = e === void 0 || typeof e == "string";
    i && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    let o = e.nodes[t];
    o === void 0 && (o = {
      uuid: t,
      type: n,
      meta: e,
      metadata: {
        version: 4.7,
        type: "Node",
        generator: "Node.toJSON"
      }
    }, i !== !0 && (e.nodes[o.uuid] = o), this.serialize(o), delete o.meta);
    function l(p) {
      const f = [];
      for (const v in p) {
        const _ = p[v];
        delete _.metadata, f.push(_);
      }
      return f;
    }
    if (i) {
      const p = l(e.textures), f = l(e.images), v = l(e.nodes);
      p.length > 0 && (o.textures = p), f.length > 0 && (o.images = f), v.length > 0 && (o.nodes = v);
    }
    return o;
  }
};
class Oi extends yn {
  static get type() {
    return "TempNode";
  }
  /**
   * Constructs a temp node.
   *
   * @param {?string} nodeType - The node type.
   */
  constructor(e = null) {
    super(e), this.isTempNode = !0;
  }
  /**
   * Whether this node is used more than once in context of other nodes.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes.
   */
  hasDependencies(e) {
    return e.getDataFromNode(this).usageCount > 1;
  }
  build(e, t) {
    if (e.getBuildStage() === "generate") {
      const i = e.getVectorType(this.getNodeType(e, t)), o = e.getDataFromNode(this);
      if (o.propertyName !== void 0)
        return e.format(o.propertyName, i, t);
      if (i !== "void" && t !== "void" && this.hasDependencies(e)) {
        const l = super.build(e, i), p = e.getVarFromNode(this, null, i), f = e.getPropertyName(p);
        return e.addLineFlowCode(`${f} = ${l}`, this), o.snippet = l, o.propertyName = f, e.format(o.propertyName, i, t);
      }
    }
    return super.build(e, t);
  }
}
class OE extends yn {
  // @TODO: If extending from TempNode it breaks webgpu_compute
  static get type() {
    return "ArrayElementNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(), this.node = e, this.indexNode = t, this.isArrayElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from the array-like node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node.getElementType(e);
  }
  generate(e) {
    const t = this.indexNode.getNodeType(e), n = this.node.build(e), i = this.indexNode.build(e, !e.isVector(t) && e.isInteger(t) ? t : "uint");
    return `${n}[ ${i} ]`;
  }
}
class Nye extends yn {
  static get type() {
    return "ConvertNode";
  }
  /**
   * Constructs a new convert node.
   *
   * @param {Node} node - The node which type should be converted.
   * @param {string} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
   */
  constructor(e, t) {
    super(), this.node = e, this.convertTo = t;
  }
  /**
   * This method is overwritten since the implementation tries to infer the best
   * matching type from the {@link ConvertNode#convertTo} property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let n = null;
    for (const i of this.convertTo.split("|"))
      (n === null || e.getTypeLength(t) === e.getTypeLength(i)) && (n = i);
    return n;
  }
  serialize(e) {
    super.serialize(e), e.convertTo = this.convertTo;
  }
  deserialize(e) {
    super.deserialize(e), this.convertTo = e.convertTo;
  }
  generate(e, t) {
    const n = this.node, i = this.getNodeType(e), o = n.build(e, i);
    return e.format(o, i, t);
  }
}
class pIe extends Oi {
  static get type() {
    return "JoinNode";
  }
  /**
   * Constructs a new join node.
   *
   * @param {Array<Node>} nodes - An array of nodes that should be joined.
   * @param {?string} [nodeType=null] - The node type.
   */
  constructor(e = [], t = null) {
    super(t), this.nodes = e;
  }
  /**
   * This method is overwritten since the node type must be inferred from the
   * joined data length if not explicitly defined.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.nodeType !== null ? e.getVectorType(this.nodeType) : e.getTypeFromLength(this.nodes.reduce((t, n) => t + e.getTypeLength(n.getNodeType(e)), 0));
  }
  generate(e, t) {
    const n = this.getNodeType(e), i = e.getTypeLength(n), o = this.nodes, l = e.getComponentType(n), p = [];
    let f = 0;
    for (const _ of o) {
      if (f >= i) {
        console.error(`THREE.TSL: Length of parameters exceeds maximum length of function '${n}()' type.`);
        break;
      }
      let E = _.getNodeType(e), A = e.getTypeLength(E), I;
      f + A > i && (console.error(`THREE.TSL: Length of '${n}()' data exceeds maximum length of output type.`), A = i - f, E = e.getTypeFromLength(A)), f += A, I = _.build(e, E);
      const j = e.getComponentType(E);
      j !== l && (I = e.format(I, j, l)), p.push(I);
    }
    const v = `${e.getType(n)}( ${p.join(", ")} )`;
    return e.format(v, n, t);
  }
}
const fIe = Xb.join("");
class bfe extends yn {
  static get type() {
    return "SplitNode";
  }
  /**
   * Constructs a new split node.
   *
   * @param {Node} node - The node that should be accessed.
   * @param {string} [components='x'] - The components that should be accessed.
   */
  constructor(e, t = "x") {
    super(), this.node = e, this.components = t, this.isSplitNode = !0;
  }
  /**
   * Returns the vector length which is computed based on the requested components.
   *
   * @return {number} The vector length.
   */
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components)
      e = Math.max(Xb.indexOf(t) + 1, e);
    return e;
  }
  /**
   * Returns the component type of the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The component type.
   */
  getComponentType(e) {
    return e.getComponentType(this.node.getNodeType(e));
  }
  /**
   * This method is overwritten since the node type is inferred from requested components.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length, this.getComponentType(e));
  }
  generate(e, t) {
    const n = this.node, i = e.getTypeLength(n.getNodeType(e));
    let o = null;
    if (i > 1) {
      let l = null;
      this.getVectorLength() >= i && (l = e.getTypeFromLength(this.getVectorLength(), this.getComponentType(e)));
      const f = n.build(e, l);
      this.components.length === i && this.components === fIe.slice(0, this.components.length) ? o = e.format(f, l, t) : o = e.format(`${f}.${this.components}`, this.getNodeType(e), t);
    } else
      o = n.build(e, t);
    return o;
  }
  serialize(e) {
    super.serialize(e), e.components = this.components;
  }
  deserialize(e) {
    super.deserialize(e), this.components = e.components;
  }
}
class mIe extends Oi {
  static get type() {
    return "SetNode";
  }
  /**
   * Constructs a new set node.
   *
   * @param {Node} sourceNode - The node that should be updated.
   * @param {string} components - The components that should be updated.
   * @param {Node} targetNode - The value node.
   */
  constructor(e, t, n) {
    super(), this.sourceNode = e, this.components = t, this.targetNode = n;
  }
  /**
   * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { sourceNode: t, components: n, targetNode: i } = this, o = this.getNodeType(e), l = e.getComponentType(i.getNodeType(e)), p = e.getTypeFromLength(n.length, l), f = i.build(e, p), v = t.build(e, o), _ = e.getTypeLength(o), E = [];
    for (let A = 0; A < _; A++) {
      const I = Xb[A];
      I === n[0] ? (E.push(f), A += n.length - 1) : E.push(v + "." + I);
    }
    return `${e.getType(o)}( ${E.join(", ")} )`;
  }
}
class gIe extends Oi {
  static get type() {
    return "FlipNode";
  }
  /**
   * Constructs a new flip node.
   *
   * @param {Node} sourceNode - The node which component(s) should be flipped.
   * @param {string} components - The components that should be flipped e.g. `'x'` or `'xy'`.
   */
  constructor(e, t) {
    super(), this.sourceNode = e, this.components = t;
  }
  /**
   * This method is overwritten since the node type is inferred from the source node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.sourceNode.getNodeType(e);
  }
  generate(e) {
    const { components: t, sourceNode: n } = this, i = this.getNodeType(e), o = n.build(e), l = e.getVarFromNode(this), p = e.getPropertyName(l);
    e.addLineFlowCode(p + " = " + o, this);
    const f = e.getTypeLength(i), v = [];
    let _ = 0;
    for (let E = 0; E < f; E++) {
      const A = Xb[E];
      A === t[_] ? (v.push("1.0 - " + (p + "." + A)), _++) : v.push(p + "." + A);
    }
    return `${e.getType(i)}( ${v.join(", ")} )`;
  }
}
class z6 extends yn {
  static get type() {
    return "InputNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. This can be any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(t), this.isInputNode = !0, this.value = e, this.precision = null;
  }
  getNodeType() {
    return this.nodeType === null ? BO(this.value) : this.nodeType;
  }
  /**
   * Returns the input type of the node which is by default the node type. Derived modules
   * might overwrite this method and use a fixed type or compute one analytically.
   *
   * A typical example for different input and node types are textures. The input type of a
   * normal RGBA texture is `texture` whereas its node type is `vec4`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    return this.getNodeType(e);
  }
  /**
   * Sets the precision to the given value. The method can be
   * overwritten in derived classes if the final precision must be computed
   * analytically.
   *
   * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
   * @return {InputNode} A reference to this node.
   */
  setPrecision(e) {
    return this.precision = e, this;
  }
  serialize(e) {
    super.serialize(e), e.value = this.value, this.value && this.value.toArray && (e.value = this.value.toArray()), e.valueType = BO(this.value), e.nodeType = this.nodeType, e.valueType === "ArrayBuffer" && (e.value = ARe(e.value)), e.precision = this.precision;
  }
  deserialize(e) {
    super.deserialize(e), this.nodeType = e.nodeType, this.value = Array.isArray(e.value) ? Tye(e.valueType, ...e.value) : e.value, this.precision = e.precision || null, this.value && this.value.fromArray && (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const xfe = /float|u?int/;
class Xd extends z6 {
  static get type() {
    return "ConstNode";
  }
  /**
   * Constructs a new input node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(e, t), this.isConstNode = !0;
  }
  /**
   * Generates the shader string of the value with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated value as a shader string.
   */
  generateConst(e) {
    return e.generateConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const n = this.getNodeType(e);
    return xfe.test(n) && xfe.test(t) ? e.generateConst(t, this.value) : e.format(this.generateConst(e), n, t);
  }
}
class yIe extends yn {
  static get type() {
    return "MemberNode";
  }
  /**
   * Constructs an array element node.
   *
   * @param {Node} node - The array-like node.
   * @param {string} property - The property name.
   */
  constructor(e, t) {
    super(), this.node = e, this.property = t, this.isMemberNode = !0;
  }
  getNodeType(e) {
    return this.node.getMemberType(e, this.property);
  }
  generate(e) {
    return this.node.build(e) + "." + this.property;
  }
}
let qb = null;
const Tb = /* @__PURE__ */ new Map();
function Ze(c, e) {
  if (Tb.has(c)) {
    console.warn(`THREE.TSL: Redefinition of method chaining '${c}'.`);
    return;
  }
  if (typeof e != "function") throw new Error(`THREE.TSL: Node element ${c} is not a function`);
  Tb.set(c, e);
}
const Oye = (c) => c.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w"), _fe = (c) => Oye(c).split("").sort().join(""), Dye = {
  setup(c, e) {
    const t = e.shift();
    return c(t2(t), ...e);
  },
  get(c, e, t) {
    if (typeof e == "string" && c[e] === void 0) {
      if (c.isStackNode !== !0 && e === "assign")
        return (...n) => (qb.assign(t, ...n), t);
      if (Tb.has(e)) {
        const n = Tb.get(e);
        return c.isStackNode ? (...i) => t.add(n(...i)) : (...i) => n(t, ...i);
      } else {
        if (e === "self")
          return c;
        if (e.endsWith("Assign") && Tb.has(e.slice(0, e.length - 6))) {
          const n = Tb.get(e.slice(0, e.length - 6));
          return c.isStackNode ? (...i) => t.assign(i[0], n(...i)) : (...i) => t.assign(n(t, ...i));
        } else {
          if (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0)
            return e = Oye(e), ct(new bfe(t, e));
          if (/^set[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = _fe(e.slice(3).toLowerCase()), (n) => ct(new mIe(c, e, ct(n)));
          if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(e) === !0)
            return e = _fe(e.slice(4).toLowerCase()), () => ct(new gIe(ct(c), e));
          if (e === "width" || e === "height" || e === "depth")
            return e === "width" ? e = "x" : e === "height" ? e = "y" : e === "depth" && (e = "z"), ct(new bfe(c, e));
          if (/^\d+$/.test(e) === !0)
            return ct(new OE(t, new Xd(Number(e), "uint")));
          if (/^get$/.test(e) === !0)
            return (n) => ct(new yIe(t, n));
        }
      }
    }
    return Reflect.get(c, e, t);
  },
  set(c, e, t, n) {
    return typeof e == "string" && c[e] === void 0 && (/^[xyzwrgbastpq]{1,4}$/.test(e) === !0 || e === "width" || e === "height" || e === "depth" || /^\d+$/.test(e) === !0) ? (n[e].assign(t), !0) : Reflect.set(c, e, t, n);
  }
}, v5 = /* @__PURE__ */ new WeakMap(), Sfe = /* @__PURE__ */ new WeakMap(), vIe = function(c, e = null) {
  const t = BO(c);
  if (t === "node") {
    let n = v5.get(c);
    return n === void 0 && (n = new Proxy(c, Dye), v5.set(c, n), v5.set(n, n)), n;
  } else {
    if (e === null && (t === "float" || t === "boolean") || t && t !== "shader" && t !== "string")
      return ct(s6(c, e));
    if (t === "shader")
      return at(c);
  }
  return c;
}, bIe = function(c, e = null) {
  for (const t in c)
    c[t] = ct(c[t], e);
  return c;
}, xIe = function(c, e = null) {
  const t = c.length;
  for (let n = 0; n < t; n++)
    c[n] = ct(c[n], e);
  return c;
}, _Ie = function(c, e = null, t = null, n = null) {
  const i = (_) => ct(n !== null ? Object.assign(_, n) : _);
  let o, l = e, p, f;
  function v(_) {
    let E;
    return l ? E = /[a-z]/i.test(l) ? l + "()" : l : E = c.type, p !== void 0 && _.length < p ? (console.error(`THREE.TSL: "${E}" parameter length is less than minimum required.`), _.concat(new Array(p - _.length).fill(0))) : f !== void 0 && _.length > f ? (console.error(`THREE.TSL: "${E}" parameter length exceeds limit.`), _.slice(0, f)) : _;
  }
  return e === null ? o = (..._) => i(new c(...Ob(v(_)))) : t !== null ? (t = ct(t), o = (..._) => i(new c(e, ...Ob(v(_)), t))) : o = (..._) => i(new c(e, ...Ob(v(_)))), o.setParameterLength = (..._) => (_.length === 1 ? p = f = _[0] : _.length === 2 && ([p, f] = _), o), o.setName = (_) => (l = _, o), o;
}, SIe = function(c, ...e) {
  return ct(new c(...Ob(e)));
};
class wIe extends yn {
  constructor(e, t) {
    super(), this.shaderNode = e, this.inputNodes = t, this.isShaderCallNodeInternal = !0;
  }
  getNodeType(e) {
    return this.shaderNode.nodeType || this.getOutputNode(e).getNodeType(e);
  }
  getMemberType(e, t) {
    return this.getOutputNode(e).getMemberType(e, t);
  }
  call(e) {
    const { shaderNode: t, inputNodes: n } = this, i = e.getNodeProperties(t), o = t.namespace && t.namespace === e.namespace ? e.getNamespace("once") : "once";
    if (i[o])
      return i[o];
    let l = null;
    if (t.layout) {
      let p = Sfe.get(e.constructor);
      p === void 0 && (p = /* @__PURE__ */ new WeakMap(), Sfe.set(e.constructor, p));
      let f = p.get(t);
      f === void 0 && (f = ct(e.buildFunctionNode(t)), p.set(t, f)), e.addInclude(f), l = ct(f.call(n));
    } else {
      const p = t.jsFunc, f = n !== null || p.length > 1 ? p(n || [], e) : p(e);
      l = ct(f);
    }
    return t.once && (i[o] = l), l;
  }
  setupOutput(e) {
    return e.addStack(), e.stack.outputNode = this.call(e), e.removeStack();
  }
  getOutputNode(e) {
    const t = e.getNodeProperties(this), n = e.getOutputNamespace();
    return t[n] = t[n] || this.setupOutput(e), t[n];
  }
  build(e, t = null) {
    let n = null;
    const i = e.getBuildStage(), o = e.getNodeProperties(this), l = e.getOutputNamespace(), p = this.getOutputNode(e);
    if (i === "setup") {
      const f = e.getNamespace("initialized");
      o[f] !== !0 && (o[f] = !0, o[l] = this.getOutputNode(e), o[l].build(e)), n = o[l];
    } else i === "analyze" ? p.build(e, t) : i === "generate" && (n = p.build(e, t) || "");
    return n;
  }
}
class EIe extends yn {
  constructor(e, t) {
    super(t), this.jsFunc = e, this.layout = null, this.global = !0, this.once = !1, this.namespace = null;
  }
  setLayout(e) {
    return this.layout = e, this;
  }
  call(e = null) {
    return t2(e), ct(new wIe(this, e));
  }
  setup() {
    return this.call();
  }
}
const TIe = [!1, !0], CIe = [0, 1, 2, 3], PIe = [-1, -2], Fye = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2], V6 = /* @__PURE__ */ new Map();
for (const c of TIe) V6.set(c, new Xd(c));
const G6 = /* @__PURE__ */ new Map();
for (const c of CIe) G6.set(c, new Xd(c, "uint"));
const q6 = new Map([...G6].map((c) => new Xd(c.value, "int")));
for (const c of PIe) q6.set(c, new Xd(c, "int"));
const JO = new Map([...q6].map((c) => new Xd(c.value)));
for (const c of Fye) JO.set(c, new Xd(c));
for (const c of Fye) JO.set(-c, new Xd(-c));
const e2 = { bool: V6, uint: G6, ints: q6, float: JO }, wfe = new Map([...V6, ...JO]), s6 = (c, e) => wfe.has(c) ? wfe.get(c) : c.isNode === !0 ? c : new Xd(c, e), AIe = (c) => {
  try {
    return c.getNodeType();
  } catch {
    return;
  }
}, Di = function(c, e = null) {
  return (...t) => {
    if ((t.length === 0 || !["bool", "float", "int", "uint"].includes(c) && t.every((i) => typeof i != "object")) && (t = [Tye(c, ...t)]), t.length === 1 && e !== null && e.has(t[0]))
      return ct(e.get(t[0]));
    if (t.length === 1) {
      const i = s6(t[0], c);
      return AIe(i) === c ? ct(i) : ct(new Nye(i, c));
    }
    const n = t.map((i) => s6(i));
    return ct(new pIe(n, c));
  };
}, Efe = (c) => typeof c == "object" && c !== null ? c.value : c, kIe = (c) => c != null ? c.nodeType || c.convertTo || (typeof c == "string" ? c : null) : null;
function nE(c, e) {
  return new Proxy(new EIe(c, e), Dye);
}
const ct = (c, e = null) => (
  /* new */
  vIe(c, e)
), t2 = (c, e = null) => new bIe(c, e), Ob = (c, e = null) => new xIe(c, e), lt = (...c) => new _Ie(...c), bt = (...c) => new SIe(...c);
let MIe = 0;
const at = (c, e = null) => {
  let t = null;
  e !== null && (typeof e == "object" ? t = e.return : (typeof e == "string" ? t = e : console.error("THREE.TSL: Invalid layout type."), e = null));
  const n = new nE(c, t), i = (...o) => {
    let l;
    t2(o), o[0] && (o[0].isNode || Object.getPrototypeOf(o[0]) !== Object.prototype) ? l = [...o] : l = o[0];
    const f = n.call(l);
    return t === "void" && f.toStack(), f;
  };
  if (i.shaderNode = n, i.id = n.id, i.getNodeType = (...o) => n.getNodeType(...o), i.getCacheKey = (...o) => n.getCacheKey(...o), i.setLayout = (o) => (n.setLayout(o), i), i.once = (o = null) => (n.once = !0, n.namespace = o, i), e !== null) {
    if (typeof e.inputs != "object") {
      const o = {
        name: "fn" + MIe++,
        type: t,
        inputs: []
      };
      for (const l in e)
        l !== "return" && o.inputs.push({
          name: l,
          type: e[l]
        });
      e = o;
    }
    i.setLayout(e);
  }
  return i;
}, LO = (c) => {
  qb = c;
}, Bye = () => qb, _i = (...c) => qb.If(...c);
function Lye(c) {
  return qb && qb.add(c), c;
}
Ze("toStack", Lye);
const RIe = new Di("color"), et = new Di("float", e2.float), Nr = new Di("int", e2.ints), IIe = new Di("uint", e2.uint), H6 = new Di("bool", e2.bool), xt = new Di("vec2"), Nd = new Di("ivec2"), NIe = new Di("uvec2"), OIe = new Di("bvec2"), tt = new Di("vec3"), DIe = new Di("ivec3"), FIe = new Di("uvec3"), BIe = new Di("bvec3"), gn = new Di("vec4"), LIe = new Di("ivec4"), jIe = new Di("uvec4"), UIe = new Di("bvec4"), $6 = new Di("mat2"), bo = new Di("mat3"), Db = new Di("mat4");
Ze("toColor", RIe);
Ze("toFloat", et);
Ze("toInt", Nr);
Ze("toUint", IIe);
Ze("toBool", H6);
Ze("toVec2", xt);
Ze("toIVec2", Nd);
Ze("toUVec2", NIe);
Ze("toBVec2", OIe);
Ze("toVec3", tt);
Ze("toIVec3", DIe);
Ze("toUVec3", FIe);
Ze("toBVec3", BIe);
Ze("toVec4", gn);
Ze("toIVec4", LIe);
Ze("toUVec4", jIe);
Ze("toBVec4", UIe);
Ze("toMat2", $6);
Ze("toMat3", bo);
Ze("toMat4", Db);
const zIe = /* @__PURE__ */ lt(OE).setParameterLength(2), VIe = (c, e) => ct(new Nye(ct(c), e));
Ze("element", zIe);
Ze("convert", VIe);
Ze("append", (c) => (console.warn("THREE.TSL: .append() has been renamed to .toStack()."), Lye(c)));
class GIe extends Oi {
  static get type() {
    return "AssignNode";
  }
  /**
   * Constructs a new assign node.
   *
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   */
  constructor(e, t) {
    super(), this.targetNode = e, this.sourceNode = t, this.isAssignNode = !0;
  }
  /**
   * Whether this node is used more than once in context of other nodes. This method
   * is overwritten since it always returns `false` (assigns are unique).
   *
   * @return {boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
   */
  hasDependencies() {
    return !1;
  }
  getNodeType(e, t) {
    return t !== "void" ? this.targetNode.getNodeType(e) : "void";
  }
  /**
   * Whether a split is required when assigning source to target. This can happen when the component length of
   * target and source data type does not match.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether a split is required when assigning source to target.
   */
  needsSplitAssign(e) {
    const { targetNode: t } = this;
    if (e.isAvailable("swizzleAssign") === !1 && t.isSplitNode && t.components.length > 1) {
      const n = e.getTypeLength(t.node.getNodeType(e));
      return Xb.join("").slice(0, n) !== t.components;
    }
    return !1;
  }
  setup(e) {
    const { targetNode: t, sourceNode: n } = this, i = e.getNodeProperties(this);
    i.sourceNode = n, i.targetNode = t.context({ assign: !0 });
  }
  generate(e, t) {
    const { targetNode: n, sourceNode: i } = e.getNodeProperties(this), o = this.needsSplitAssign(e), l = n.getNodeType(e), p = n.build(e), f = i.build(e, l), v = i.getNodeType(e), _ = e.getDataFromNode(this);
    let E;
    if (_.initialized === !0)
      t !== "void" && (E = p);
    else if (o) {
      const A = e.getVarFromNode(this, null, l), I = e.getPropertyName(A);
      e.addLineFlowCode(`${I} = ${f}`, this);
      const j = n.node, L = j.node.context({ assign: !0 }).build(e);
      for (let V = 0; V < j.components.length; V++) {
        const re = j.components[V];
        e.addLineFlowCode(`${L}.${re} = ${I}[ ${V} ]`, this);
      }
      t !== "void" && (E = p);
    } else
      E = `${p} = ${f}`, (t === "void" || v === "void") && (e.addLineFlowCode(E, this), t !== "void" && (E = p));
    return _.initialized = !0, e.format(E, l, t);
  }
}
const qIe = /* @__PURE__ */ lt(GIe).setParameterLength(2);
Ze("assign", qIe);
class Tfe extends Oi {
  static get type() {
    return "ArrayNode";
  }
  /**
   * Constructs a new array node.
   *
   * @param {?string} nodeType - The data type of the elements.
   * @param {number} count - Size of the array.
   * @param {?Array<Node>} [values=null] - Array default values.
   */
  constructor(e, t, n = null) {
    super(e), this.count = t, this.values = n, this.isArrayNode = !0;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getNodeType(e) {
    return this.nodeType === null && (this.nodeType = this.values[0].getNodeType(e)), this.nodeType;
  }
  /**
   * Returns the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The type of the node.
   */
  getElementType(e) {
    return this.getNodeType(e);
  }
  /**
   * This method builds the output node and returns the resulting array as a shader string.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated shader string.
   */
  generate(e) {
    const t = this.getNodeType(e);
    return e.generateArray(t, this.count, this.values);
  }
}
const HIe = (...c) => {
  let e;
  if (c.length === 1) {
    const t = c[0];
    e = new Tfe(null, t.length, t);
  } else {
    const t = c[0], n = c[1];
    e = new Tfe(t, n);
  }
  return ct(e);
};
Ze("toArray", (c, e) => HIe(Array(e).fill(c)));
class jye extends yn {
  static get type() {
    return "UniformGroupNode";
  }
  /**
   * Constructs a new uniform group node.
   *
   * @param {string} name - The name of the uniform group node.
   * @param {boolean} [shared=false] - Whether this uniform group node is shared or not.
   * @param {number} [order=1] - Influences the internal sorting.
   */
  constructor(e, t = !1, n = 1) {
    super("string"), this.name = e, this.shared = t, this.order = n, this.isUniformGroup = !0;
  }
  serialize(e) {
    super.serialize(e), e.name = this.name, e.version = this.version, e.shared = this.shared;
  }
  deserialize(e) {
    super.deserialize(e), this.name = e.name, this.version = e.version, this.shared = e.shared;
  }
}
const $Ie = (c) => new jye(c), W6 = (c, e = 0) => new jye(c, !0, e), WIe = /* @__PURE__ */ W6("frame"), sn = /* @__PURE__ */ W6("render"), Uye = /* @__PURE__ */ $Ie("object");
class DE extends z6 {
  static get type() {
    return "UniformNode";
  }
  /**
   * Constructs a new uniform node.
   *
   * @param {any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {?string} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   */
  constructor(e, t = null) {
    super(e, t), this.isUniformNode = !0, this.name = "", this.groupNode = Uye;
  }
  /**
   * Sets the {@link UniformNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {UniformNode} A reference to this node.
   */
  label(e) {
    return this.name = e, this;
  }
  /**
   * Sets the {@link UniformNode#groupNode} property.
   *
   * @param {UniformGroupNode} group - The uniform group.
   * @return {UniformNode} A reference to this node.
   */
  setGroup(e) {
    return this.groupNode = e, this;
  }
  /**
   * Returns the {@link UniformNode#groupNode}.
   *
   * @return {UniformGroupNode} The uniform group.
   */
  getGroup() {
    return this.groupNode;
  }
  /**
   * By default, this method returns the result of {@link Node#getHash} but derived
   * classes might overwrite this method with a different implementation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash(e) {
    return this.getHash(e);
  }
  onUpdate(e, t) {
    const n = this.getSelf();
    return e = e.bind(n), super.onUpdate((i) => {
      const o = e(i, n);
      o !== void 0 && (this.value = o);
    }, t);
  }
  generate(e, t) {
    const n = this.getNodeType(e), i = this.getUniformHash(e);
    let o = e.getNodeFromHash(i);
    o === void 0 && (e.setHashNode(this, i), o = this);
    const l = o.getInputType(e), p = e.getUniformFromNode(o, l, e.shaderStage, this.name || e.context.label), f = e.getPropertyName(p);
    return e.context.label !== void 0 && delete e.context.label, e.format(f, n, t);
  }
}
const on = (c, e) => {
  const t = kIe(e || c), n = c && c.isNode === !0 ? c.node && c.node.value || c.value : c;
  return ct(new DE(n, t));
};
class ur extends yn {
  static get type() {
    return "PropertyNode";
  }
  /**
   * Constructs a new property node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the property in the shader.
   * @param {boolean} [varying=false] - Whether this property is a varying or not.
   */
  constructor(e, t = null, n = !1) {
    super(e), this.name = t, this.varying = n, this.isPropertyNode = !0, this.global = !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  generate(e) {
    let t;
    return this.varying === !0 ? (t = e.getVaryingFromNode(this, this.name), t.needsInterpolation = !0) : t = e.getVarFromNode(this, this.name), e.getPropertyName(t);
  }
}
const zye = (c, e) => ct(new ur(c, e)), jO = (c, e) => ct(new ur(c, e, !0)), Jn = /* @__PURE__ */ bt(ur, "vec4", "DiffuseColor"), Cfe = /* @__PURE__ */ bt(ur, "vec3", "EmissiveColor"), Dd = /* @__PURE__ */ bt(ur, "float", "Roughness"), UO = /* @__PURE__ */ bt(ur, "float", "Metalness"), o6 = /* @__PURE__ */ bt(ur, "float", "Clearcoat"), zO = /* @__PURE__ */ bt(ur, "float", "ClearcoatRoughness"), Cb = /* @__PURE__ */ bt(ur, "vec3", "Sheen"), K6 = /* @__PURE__ */ bt(ur, "float", "SheenRoughness"), Y6 = /* @__PURE__ */ bt(ur, "float", "Iridescence"), Vye = /* @__PURE__ */ bt(ur, "float", "IridescenceIOR"), Gye = /* @__PURE__ */ bt(ur, "float", "IridescenceThickness"), a6 = /* @__PURE__ */ bt(ur, "float", "AlphaT"), fg = /* @__PURE__ */ bt(ur, "float", "Anisotropy"), mO = /* @__PURE__ */ bt(ur, "vec3", "AnisotropyT"), Fb = /* @__PURE__ */ bt(ur, "vec3", "AnisotropyB"), ba = /* @__PURE__ */ bt(ur, "color", "SpecularColor"), VO = /* @__PURE__ */ bt(ur, "float", "SpecularF90"), l6 = /* @__PURE__ */ bt(ur, "float", "Shininess"), gE = /* @__PURE__ */ bt(ur, "vec4", "Output"), b5 = /* @__PURE__ */ bt(ur, "float", "dashSize"), Pfe = /* @__PURE__ */ bt(ur, "float", "gapSize"), gO = /* @__PURE__ */ bt(ur, "float", "IOR"), u6 = /* @__PURE__ */ bt(ur, "float", "Transmission"), qye = /* @__PURE__ */ bt(ur, "float", "Thickness"), Hye = /* @__PURE__ */ bt(ur, "float", "AttenuationDistance"), $ye = /* @__PURE__ */ bt(ur, "color", "AttenuationColor"), Wye = /* @__PURE__ */ bt(ur, "float", "Dispersion");
class KIe extends Oi {
  static get type() {
    return "FunctionCallNode";
  }
  /**
   * Constructs a new function call node.
   *
   * @param {?FunctionNode} functionNode - The function node.
   * @param {Object<string, Node>} [parameters={}] - The parameters for the function call.
   */
  constructor(e = null, t = {}) {
    super(), this.functionNode = e, this.parameters = t;
  }
  /**
   * Sets the parameters of the function call node.
   *
   * @param {Object<string, Node>} parameters - The parameters to set.
   * @return {FunctionCallNode} A reference to this node.
   */
  setParameters(e) {
    return this.parameters = e, this;
  }
  /**
   * Returns the parameters of the function call node.
   *
   * @return {Object<string, Node>} The parameters of this node.
   */
  getParameters() {
    return this.parameters;
  }
  getNodeType(e) {
    return this.functionNode.getNodeType(e);
  }
  generate(e) {
    const t = [], n = this.functionNode, i = n.getInputs(e), o = this.parameters, l = (f, v) => {
      const _ = v.type, E = _ === "pointer";
      let A;
      return E ? A = "&" + f.build(e) : A = f.build(e, _), A;
    };
    if (Array.isArray(o)) {
      if (o.length > i.length)
        console.error("THREE.TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."), o.length = i.length;
      else if (o.length < i.length)
        for (console.error("THREE.TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'."); o.length < i.length; )
          o.push(et(0));
      for (let f = 0; f < o.length; f++)
        t.push(l(o[f], i[f]));
    } else
      for (const f of i) {
        const v = o[f.name];
        v !== void 0 ? t.push(l(v, f)) : (console.error(`THREE.TSL: Input '${f.name}' not found in 'Fn()'.`), t.push(l(et(0), f)));
      }
    return `${n.build(e, "property")}( ${t.join(", ")} )`;
  }
}
const YIe = (c, ...e) => (e = e.length > 1 || e[0] && e[0].isNode === !0 ? Ob(e) : t2(e[0]), ct(new KIe(ct(c), e)));
Ze("call", YIe);
const XIe = {
  "==": "equal",
  "!=": "notEqual",
  "<": "lessThan",
  ">": "greaterThan",
  "<=": "lessThanEqual",
  ">=": "greaterThanEqual",
  "%": "mod"
};
class Xr extends Oi {
  static get type() {
    return "OperatorNode";
  }
  /**
   * Constructs a new operator node.
   *
   * @param {string} op - The operator.
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   */
  constructor(e, t, n, ...i) {
    if (super(), i.length > 0) {
      let o = new Xr(e, t, n);
      for (let l = 0; l < i.length - 1; l++)
        o = new Xr(e, o, i[l]);
      t = o, n = i[i.length - 1];
    }
    this.op = e, this.aNode = t, this.bNode = n, this.isOperatorNode = !0;
  }
  /**
   * Returns the operator method name.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The output type.
   * @returns {string} The operator method name.
   */
  getOperatorMethod(e, t) {
    return e.getMethod(XIe[this.op], t);
  }
  /**
   * This method is overwritten since the node type is inferred from the operator
   * and the input node types.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const t = this.op, n = this.aNode, i = this.bNode, o = n.getNodeType(e), l = i ? i.getNodeType(e) : null;
    if (o === "void" || l === "void")
      return "void";
    if (t === "%")
      return o;
    if (t === "~" || t === "&" || t === "|" || t === "^" || t === ">>" || t === "<<")
      return e.getIntegerType(o);
    if (t === "!" || t === "&&" || t === "||" || t === "^^")
      return "bool";
    if (t === "==" || t === "!=" || t === "<" || t === ">" || t === "<=" || t === ">=") {
      const p = Math.max(e.getTypeLength(o), e.getTypeLength(l));
      return p > 1 ? `bvec${p}` : "bool";
    } else {
      if (e.isMatrix(o)) {
        if (l === "float")
          return o;
        if (e.isVector(l))
          return e.getVectorFromMatrix(o);
        if (e.isMatrix(l))
          return o;
      } else if (e.isMatrix(l)) {
        if (o === "float")
          return l;
        if (e.isVector(o))
          return e.getVectorFromMatrix(l);
      }
      return e.getTypeLength(l) > e.getTypeLength(o) ? l : o;
    }
  }
  generate(e, t) {
    const n = this.op, { aNode: i, bNode: o } = this, l = this.getNodeType(e);
    let p = null, f = null;
    l !== "void" ? (p = i.getNodeType(e), f = o ? o.getNodeType(e) : null, n === "<" || n === ">" || n === "<=" || n === ">=" || n === "==" || n === "!=" ? e.isVector(p) ? f = p : e.isVector(f) ? p = f : p !== f && (p = f = "float") : n === ">>" || n === "<<" ? (p = l, f = e.changeComponentType(f, "uint")) : n === "%" ? (p = l, f = e.isInteger(p) && e.isInteger(f) ? f : p) : e.isMatrix(p) ? f === "float" ? f = "float" : e.isVector(f) ? f = e.getVectorFromMatrix(p) : e.isMatrix(f) || (p = f = l) : e.isMatrix(f) ? p === "float" ? p = "float" : e.isVector(p) ? p = e.getVectorFromMatrix(f) : p = f = l : p = f = l) : p = f = l;
    const v = i.build(e, p), _ = o ? o.build(e, f) : null, E = e.getFunctionOperator(n);
    if (t !== "void") {
      const A = e.renderer.coordinateSystem === Ho;
      if (n === "==" || n === "!=" || n === "<" || n === ">" || n === "<=" || n === ">=")
        return A ? e.isVector(p) ? e.format(`${this.getOperatorMethod(e, t)}( ${v}, ${_} )`, l, t) : e.format(`( ${v} ${n} ${_} )`, l, t) : e.format(`( ${v} ${n} ${_} )`, l, t);
      if (n === "%")
        return e.isInteger(f) ? e.format(`( ${v} % ${_} )`, l, t) : e.format(`${this.getOperatorMethod(e, l)}( ${v}, ${_} )`, l, t);
      if (n === "!" || n === "~")
        return e.format(`(${n}${v})`, p, t);
      if (E)
        return e.format(`${E}( ${v}, ${_} )`, l, t);
      if (e.isMatrix(p) && f === "float")
        return e.format(`( ${_} ${n} ${v} )`, l, t);
      if (p === "float" && e.isMatrix(f))
        return e.format(`${v} ${n} ${_}`, l, t);
      {
        let I = `( ${v} ${n} ${_} )`;
        return !A && l === "bool" && e.isVector(p) && e.isVector(f) && (I = `all${I}`), e.format(I, l, t);
      }
    } else if (p !== "void")
      return E ? e.format(`${E}( ${v}, ${_} )`, l, t) : e.isMatrix(p) && f === "float" ? e.format(`${_} ${n} ${v}`, l, t) : e.format(`${v} ${n} ${_}`, l, t);
  }
  serialize(e) {
    super.serialize(e), e.op = this.op;
  }
  deserialize(e) {
    super.deserialize(e), this.op = e.op;
  }
}
const xo = /* @__PURE__ */ lt(Xr, "+").setParameterLength(2, 1 / 0).setName("add"), mo = /* @__PURE__ */ lt(Xr, "-").setParameterLength(2, 1 / 0).setName("sub"), On = /* @__PURE__ */ lt(Xr, "*").setParameterLength(2, 1 / 0).setName("mul"), Sc = /* @__PURE__ */ lt(Xr, "/").setParameterLength(2, 1 / 0).setName("div"), n2 = /* @__PURE__ */ lt(Xr, "%").setParameterLength(2).setName("mod"), Kye = /* @__PURE__ */ lt(Xr, "==").setParameterLength(2).setName("equal"), QIe = /* @__PURE__ */ lt(Xr, "!=").setParameterLength(2).setName("notEqual"), ZIe = /* @__PURE__ */ lt(Xr, "<").setParameterLength(2).setName("lessThan"), JIe = /* @__PURE__ */ lt(Xr, ">").setParameterLength(2).setName("greaterThan"), eNe = /* @__PURE__ */ lt(Xr, "<=").setParameterLength(2).setName("lessThanEqual"), tNe = /* @__PURE__ */ lt(Xr, ">=").setParameterLength(2).setName("greaterThanEqual"), nNe = /* @__PURE__ */ lt(Xr, "&&").setParameterLength(2, 1 / 0).setName("and"), rNe = /* @__PURE__ */ lt(Xr, "||").setParameterLength(2, 1 / 0).setName("or"), iNe = /* @__PURE__ */ lt(Xr, "!").setParameterLength(1).setName("not"), sNe = /* @__PURE__ */ lt(Xr, "^^").setParameterLength(2).setName("xor"), oNe = /* @__PURE__ */ lt(Xr, "&").setParameterLength(2).setName("bitAnd"), aNe = /* @__PURE__ */ lt(Xr, "~").setParameterLength(2).setName("bitNot"), lNe = /* @__PURE__ */ lt(Xr, "|").setParameterLength(2).setName("bitOr"), uNe = /* @__PURE__ */ lt(Xr, "^").setParameterLength(2).setName("bitXor"), cNe = /* @__PURE__ */ lt(Xr, "<<").setParameterLength(2).setName("shiftLeft"), dNe = /* @__PURE__ */ lt(Xr, ">>").setParameterLength(2).setName("shiftRight"), hNe = at(([c]) => (c.addAssign(1), c)), pNe = at(([c]) => (c.subAssign(1), c)), fNe = /* @__PURE__ */ at(([c]) => {
  const e = Nr(c).toConst();
  return c.addAssign(1), e;
}), mNe = /* @__PURE__ */ at(([c]) => {
  const e = Nr(c).toConst();
  return c.subAssign(1), e;
});
Ze("add", xo);
Ze("sub", mo);
Ze("mul", On);
Ze("div", Sc);
Ze("mod", n2);
Ze("equal", Kye);
Ze("notEqual", QIe);
Ze("lessThan", ZIe);
Ze("greaterThan", JIe);
Ze("lessThanEqual", eNe);
Ze("greaterThanEqual", tNe);
Ze("and", nNe);
Ze("or", rNe);
Ze("not", iNe);
Ze("xor", sNe);
Ze("bitAnd", oNe);
Ze("bitNot", aNe);
Ze("bitOr", lNe);
Ze("bitXor", uNe);
Ze("shiftLeft", cNe);
Ze("shiftRight", dNe);
Ze("incrementBefore", hNe);
Ze("decrementBefore", pNe);
Ze("increment", fNe);
Ze("decrement", mNe);
const gNe = (c, e) => (console.warn('THREE.TSL: "remainder()" is deprecated. Use "mod( int( ... ) )" instead.'), n2(c, e)), yNe = (c, e) => (console.warn('THREE.TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.'), n2(Nr(c), Nr(e)));
Ze("remainder", gNe);
Ze("modInt", yNe);
class Be extends Oi {
  static get type() {
    return "MathNode";
  }
  /**
   * Constructs a new math node.
   *
   * @param {string} method - The method name.
   * @param {Node} aNode - The first input.
   * @param {?Node} [bNode=null] - The second input.
   * @param {?Node} [cNode=null] - The third input.
   */
  constructor(e, t, n = null, i = null) {
    if (super(), (e === Be.MAX || e === Be.MIN) && arguments.length > 3) {
      let o = new Be(e, t, n);
      for (let l = 2; l < arguments.length - 1; l++)
        o = new Be(e, o, arguments[l]);
      t = o, n = arguments[arguments.length - 1], i = null;
    }
    this.method = e, this.aNode = t, this.bNode = n, this.cNode = i, this.isMathNode = !0;
  }
  /**
   * The input type is inferred from the node types of the input nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    const t = this.aNode.getNodeType(e), n = this.bNode ? this.bNode.getNodeType(e) : null, i = this.cNode ? this.cNode.getNodeType(e) : null, o = e.isMatrix(t) ? 0 : e.getTypeLength(t), l = e.isMatrix(n) ? 0 : e.getTypeLength(n), p = e.isMatrix(i) ? 0 : e.getTypeLength(i);
    return o > l && o > p ? t : l > p ? n : p > o ? i : t;
  }
  /**
   * The selected method as well as the input type determine the node type of this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const t = this.method;
    return t === Be.LENGTH || t === Be.DISTANCE || t === Be.DOT ? "float" : t === Be.CROSS ? "vec3" : t === Be.ALL || t === Be.ANY ? "bool" : t === Be.EQUALS ? e.changeComponentType(this.aNode.getNodeType(e), "bool") : this.getInputType(e);
  }
  setup(e) {
    const { aNode: t, bNode: n, method: i } = this;
    let o = null;
    if (i === Be.ONE_MINUS)
      o = mo(1, t);
    else if (i === Be.RECIPROCAL)
      o = Sc(1, t);
    else if (i === Be.DIFFERENCE)
      o = sl(mo(t, n));
    else if (i === Be.TRANSFORM_DIRECTION) {
      let l = t, p = n;
      e.isMatrix(l.getNodeType(e)) ? p = gn(tt(p), 0) : l = gn(tt(l), 0);
      const f = On(l, p).xyz;
      o = PE(f);
    }
    return o !== null ? o : super.setup(e);
  }
  generate(e, t) {
    if (e.getNodeProperties(this).outputNode)
      return super.generate(e, t);
    let i = this.method;
    const o = this.getNodeType(e), l = this.getInputType(e), p = this.aNode, f = this.bNode, v = this.cNode, _ = e.renderer.coordinateSystem;
    if (i === Be.NEGATE)
      return e.format("( - " + p.build(e, l) + " )", o, t);
    {
      const E = [];
      return i === Be.CROSS ? E.push(
        p.build(e, o),
        f.build(e, o)
      ) : _ === Ho && i === Be.STEP ? E.push(
        p.build(e, e.getTypeLength(p.getNodeType(e)) === 1 ? "float" : l),
        f.build(e, l)
      ) : _ === Ho && (i === Be.MIN || i === Be.MAX) ? E.push(
        p.build(e, l),
        f.build(e, e.getTypeLength(f.getNodeType(e)) === 1 ? "float" : l)
      ) : i === Be.REFRACT ? E.push(
        p.build(e, l),
        f.build(e, l),
        v.build(e, "float")
      ) : i === Be.MIX ? E.push(
        p.build(e, l),
        f.build(e, l),
        v.build(e, e.getTypeLength(v.getNodeType(e)) === 1 ? "float" : l)
      ) : (_ === Jp && i === Be.ATAN && f !== null && (i = "atan2"), e.shaderStage !== "fragment" && (i === Be.DFDX || i === Be.DFDY) && (console.warn(`THREE.TSL: '${i}' is not supported in the ${e.shaderStage} stage.`), i = "/*" + i + "*/"), E.push(p.build(e, l)), f !== null && E.push(f.build(e, l)), v !== null && E.push(v.build(e, l))), e.format(`${e.getMethod(i, o)}( ${E.join(", ")} )`, o, t);
    }
  }
  serialize(e) {
    super.serialize(e), e.method = this.method;
  }
  deserialize(e) {
    super.deserialize(e), this.method = e.method;
  }
}
Be.ALL = "all";
Be.ANY = "any";
Be.RADIANS = "radians";
Be.DEGREES = "degrees";
Be.EXP = "exp";
Be.EXP2 = "exp2";
Be.LOG = "log";
Be.LOG2 = "log2";
Be.SQRT = "sqrt";
Be.INVERSE_SQRT = "inversesqrt";
Be.FLOOR = "floor";
Be.CEIL = "ceil";
Be.NORMALIZE = "normalize";
Be.FRACT = "fract";
Be.SIN = "sin";
Be.COS = "cos";
Be.TAN = "tan";
Be.ASIN = "asin";
Be.ACOS = "acos";
Be.ATAN = "atan";
Be.ABS = "abs";
Be.SIGN = "sign";
Be.LENGTH = "length";
Be.NEGATE = "negate";
Be.ONE_MINUS = "oneMinus";
Be.DFDX = "dFdx";
Be.DFDY = "dFdy";
Be.ROUND = "round";
Be.RECIPROCAL = "reciprocal";
Be.TRUNC = "trunc";
Be.FWIDTH = "fwidth";
Be.TRANSPOSE = "transpose";
Be.BITCAST = "bitcast";
Be.EQUALS = "equals";
Be.MIN = "min";
Be.MAX = "max";
Be.STEP = "step";
Be.REFLECT = "reflect";
Be.DISTANCE = "distance";
Be.DIFFERENCE = "difference";
Be.DOT = "dot";
Be.CROSS = "cross";
Be.POW = "pow";
Be.TRANSFORM_DIRECTION = "transformDirection";
Be.MIX = "mix";
Be.CLAMP = "clamp";
Be.REFRACT = "refract";
Be.SMOOTHSTEP = "smoothstep";
Be.FACEFORWARD = "faceforward";
const vNe = /* @__PURE__ */ et(1e-6), bNe = /* @__PURE__ */ et(Math.PI), xNe = /* @__PURE__ */ lt(Be, Be.ALL).setParameterLength(1), _Ne = /* @__PURE__ */ lt(Be, Be.ANY).setParameterLength(1), SNe = /* @__PURE__ */ lt(Be, Be.RADIANS).setParameterLength(1), wNe = /* @__PURE__ */ lt(Be, Be.DEGREES).setParameterLength(1), Yye = /* @__PURE__ */ lt(Be, Be.EXP).setParameterLength(1), CE = /* @__PURE__ */ lt(Be, Be.EXP2).setParameterLength(1), Xye = /* @__PURE__ */ lt(Be, Be.LOG).setParameterLength(1), Gd = /* @__PURE__ */ lt(Be, Be.LOG2).setParameterLength(1), X6 = /* @__PURE__ */ lt(Be, Be.SQRT).setParameterLength(1), ENe = /* @__PURE__ */ lt(Be, Be.INVERSE_SQRT).setParameterLength(1), Eg = /* @__PURE__ */ lt(Be, Be.FLOOR).setParameterLength(1), Q6 = /* @__PURE__ */ lt(Be, Be.CEIL).setParameterLength(1), PE = /* @__PURE__ */ lt(Be, Be.NORMALIZE).setParameterLength(1), rf = /* @__PURE__ */ lt(Be, Be.FRACT).setParameterLength(1), lu = /* @__PURE__ */ lt(Be, Be.SIN).setParameterLength(1), Gp = /* @__PURE__ */ lt(Be, Be.COS).setParameterLength(1), TNe = /* @__PURE__ */ lt(Be, Be.TAN).setParameterLength(1), CNe = /* @__PURE__ */ lt(Be, Be.ASIN).setParameterLength(1), Qye = /* @__PURE__ */ lt(Be, Be.ACOS).setParameterLength(1), Zye = /* @__PURE__ */ lt(Be, Be.ATAN).setParameterLength(1, 2), sl = /* @__PURE__ */ lt(Be, Be.ABS).setParameterLength(1), GO = /* @__PURE__ */ lt(Be, Be.SIGN).setParameterLength(1), qd = /* @__PURE__ */ lt(Be, Be.LENGTH).setParameterLength(1), PNe = /* @__PURE__ */ lt(Be, Be.NEGATE).setParameterLength(1), ANe = /* @__PURE__ */ lt(Be, Be.ONE_MINUS).setParameterLength(1), Jye = /* @__PURE__ */ lt(Be, Be.DFDX).setParameterLength(1), e0e = /* @__PURE__ */ lt(Be, Be.DFDY).setParameterLength(1), kNe = /* @__PURE__ */ lt(Be, Be.ROUND).setParameterLength(1), MNe = /* @__PURE__ */ lt(Be, Be.RECIPROCAL).setParameterLength(1), RNe = /* @__PURE__ */ lt(Be, Be.TRUNC).setParameterLength(1), INe = /* @__PURE__ */ lt(Be, Be.FWIDTH).setParameterLength(1), NNe = /* @__PURE__ */ lt(Be, Be.TRANSPOSE).setParameterLength(1), ONe = (c, e) => (console.warn('THREE.TSL: "equals" is deprecated. Use "equal" inside a vector instead, like: "bvec*( equal( ... ) )"'), Kye(c, e)), Hb = /* @__PURE__ */ lt(Be, Be.MIN).setParameterLength(2, 1 / 0), eo = /* @__PURE__ */ lt(Be, Be.MAX).setParameterLength(2, 1 / 0), t0e = /* @__PURE__ */ lt(Be, Be.STEP).setParameterLength(2), DNe = /* @__PURE__ */ lt(Be, Be.REFLECT).setParameterLength(2), FNe = /* @__PURE__ */ lt(Be, Be.DISTANCE).setParameterLength(2), BNe = /* @__PURE__ */ lt(Be, Be.DIFFERENCE).setParameterLength(2), Z6 = /* @__PURE__ */ lt(Be, Be.DOT).setParameterLength(2), n0e = /* @__PURE__ */ lt(Be, Be.CROSS).setParameterLength(2), r2 = /* @__PURE__ */ lt(Be, Be.POW).setParameterLength(2), r0e = /* @__PURE__ */ lt(Be, Be.POW, 2).setParameterLength(1), LNe = /* @__PURE__ */ lt(Be, Be.POW, 3).setParameterLength(1), jNe = /* @__PURE__ */ lt(Be, Be.POW, 4).setParameterLength(1), UNe = /* @__PURE__ */ lt(Be, Be.TRANSFORM_DIRECTION).setParameterLength(2), zNe = (c) => On(GO(c), r2(sl(c), 1 / 3)), i0e = (c) => Z6(c, c), Vr = /* @__PURE__ */ lt(Be, Be.MIX).setParameterLength(3), Kd = (c, e = 0, t = 1) => ct(new Be(Be.CLAMP, ct(c), ct(e), ct(t))), s0e = (c) => Kd(c), o0e = /* @__PURE__ */ lt(Be, Be.REFRACT).setParameterLength(3), ef = /* @__PURE__ */ lt(Be, Be.SMOOTHSTEP).setParameterLength(3), VNe = /* @__PURE__ */ lt(Be, Be.FACEFORWARD).setParameterLength(3), GNe = /* @__PURE__ */ at(([c]) => {
  const n = 43758.5453, i = Z6(c.xy, xt(12.9898, 78.233)), o = n2(i, bNe);
  return rf(lu(o).mul(n));
}), qNe = (c, e, t) => Vr(e, t, c), HNe = (c, e, t) => ef(e, t, c), $Ne = (c, e) => (console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.'), Zye(c, e));
Ze("all", xNe);
Ze("any", _Ne);
Ze("equals", ONe);
Ze("radians", SNe);
Ze("degrees", wNe);
Ze("exp", Yye);
Ze("exp2", CE);
Ze("log", Xye);
Ze("log2", Gd);
Ze("sqrt", X6);
Ze("inverseSqrt", ENe);
Ze("floor", Eg);
Ze("ceil", Q6);
Ze("normalize", PE);
Ze("fract", rf);
Ze("sin", lu);
Ze("cos", Gp);
Ze("tan", TNe);
Ze("asin", CNe);
Ze("acos", Qye);
Ze("atan", Zye);
Ze("abs", sl);
Ze("sign", GO);
Ze("length", qd);
Ze("lengthSq", i0e);
Ze("negate", PNe);
Ze("oneMinus", ANe);
Ze("dFdx", Jye);
Ze("dFdy", e0e);
Ze("round", kNe);
Ze("reciprocal", MNe);
Ze("trunc", RNe);
Ze("fwidth", INe);
Ze("atan2", $Ne);
Ze("min", Hb);
Ze("max", eo);
Ze("step", t0e);
Ze("reflect", DNe);
Ze("distance", FNe);
Ze("dot", Z6);
Ze("cross", n0e);
Ze("pow", r2);
Ze("pow2", r0e);
Ze("pow3", LNe);
Ze("pow4", jNe);
Ze("transformDirection", UNe);
Ze("mix", qNe);
Ze("clamp", Kd);
Ze("refract", o0e);
Ze("smoothstep", HNe);
Ze("faceForward", VNe);
Ze("difference", BNe);
Ze("saturate", s0e);
Ze("cbrt", zNe);
Ze("transpose", NNe);
Ze("rand", GNe);
class WNe extends yn {
  static get type() {
    return "ConditionalNode";
  }
  /**
   * Constructs a new conditional node.
   *
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {?Node} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   */
  constructor(e, t, n = null) {
    super(), this.condNode = e, this.ifNode = t, this.elseNode = n;
  }
  /**
   * This method is overwritten since the node type is inferred from the if/else
   * nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const { ifNode: t, elseNode: n } = e.getNodeProperties(this);
    if (t === void 0)
      return this.setup(e), this.getNodeType(e);
    const i = t.getNodeType(e);
    if (n !== null) {
      const o = n.getNodeType(e);
      if (e.getTypeLength(o) > e.getTypeLength(i))
        return o;
    }
    return i;
  }
  setup(e) {
    const t = this.condNode.cache(), n = this.ifNode.cache(), i = this.elseNode ? this.elseNode.cache() : null, o = e.context.nodeBlock;
    e.getDataFromNode(n).parentNodeBlock = o, i !== null && (e.getDataFromNode(i).parentNodeBlock = o);
    const l = e.getNodeProperties(this);
    l.condNode = t, l.ifNode = n.context({ nodeBlock: n }), l.elseNode = i ? i.context({ nodeBlock: i }) : null;
  }
  generate(e, t) {
    const n = this.getNodeType(e), i = e.getDataFromNode(this);
    if (i.nodeProperty !== void 0)
      return i.nodeProperty;
    const { condNode: o, ifNode: l, elseNode: p } = e.getNodeProperties(this), f = e.currentFunctionNode, v = t !== "void", _ = v ? zye(n).build(e) : "";
    i.nodeProperty = _;
    const E = o.build(e, "bool");
    e.addFlowCode(`
${e.tab}if ( ${E} ) {

`).addFlowTab();
    let A = l.build(e, n);
    if (A && (v ? A = _ + " = " + A + ";" : (A = "return " + A + ";", f === null && (console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."), A = "// " + A))), e.removeFlowTab().addFlowCode(e.tab + "	" + A + `

` + e.tab + "}"), p !== null) {
      e.addFlowCode(` else {

`).addFlowTab();
      let I = p.build(e, n);
      I && (v ? I = _ + " = " + I + ";" : (I = "return " + I + ";", f === null && (console.warn("THREE.TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values."), I = "// " + I))), e.removeFlowTab().addFlowCode(e.tab + "	" + I + `

` + e.tab + `}

`);
    } else
      e.addFlowCode(`

`);
    return e.format(_, n, t);
  }
}
const Zs = /* @__PURE__ */ lt(WNe).setParameterLength(2, 3);
Ze("select", Zs);
const KNe = (...c) => (console.warn("THREE.TSL: cond() has been renamed to select()."), Zs(...c));
Ze("cond", KNe);
class a0e extends yn {
  static get type() {
    return "ContextNode";
  }
  /**
   * Constructs a new context node.
   *
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   */
  constructor(e, t = {}) {
    super(), this.isContextNode = !0, this.node = e, this.value = t;
  }
  /**
   * This method is overwritten to ensure it returns the reference to {@link ContextNode#node}.
   *
   * @return {Node} A reference to {@link ContextNode#node}.
   */
  getScope() {
    return this.node.getScope();
  }
  /**
   * This method is overwritten to ensure it returns the type of {@link ContextNode#node}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  analyze(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.value }), this.node.build(e), e.setContext(t);
  }
  setup(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.value }), this.node.build(e), e.setContext(t);
  }
  generate(e, t) {
    const n = e.getContext();
    e.setContext({ ...e.context, ...this.value });
    const i = this.node.build(e, t);
    return e.setContext(n), i;
  }
}
const J6 = /* @__PURE__ */ lt(a0e).setParameterLength(1, 2), YNe = (c, e) => J6(c, { label: e });
Ze("context", J6);
Ze("label", YNe);
class yO extends yn {
  static get type() {
    return "VarNode";
  }
  /**
   * Constructs a new variable node.
   *
   * @param {Node} node - The node for which a variable should be created.
   * @param {?string} [name=null] - The name of the variable in the shader.
   * @param {boolean} [readOnly=false] - The read-only flag.
   */
  constructor(e, t = null, n = !1) {
    super(), this.node = e, this.name = t, this.global = !0, this.isVarNode = !0, this.readOnly = n, this.parents = !0;
  }
  getMemberType(e, t) {
    return this.node.getMemberType(e, t);
  }
  getElementType(e) {
    return this.node.getElementType(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { node: t, name: n, readOnly: i } = this, { renderer: o } = e, l = o.backend.isWebGPUBackend === !0;
    let p = !1, f = !1;
    i && (p = e.isDeterministic(t), f = l ? i : p);
    const v = e.getVectorType(this.getNodeType(e)), _ = t.build(e, v), E = e.getVarFromNode(this, n, v, void 0, f), A = e.getPropertyName(E);
    let I = A;
    if (f)
      if (l)
        I = p ? `const ${A}` : `let ${A}`;
      else {
        const j = e.getArrayCount(t);
        I = `const ${e.getVar(E.type, A, j)}`;
      }
    return e.addLineFlowCode(`${I} = ${_}`, this), A;
  }
}
const eG = /* @__PURE__ */ lt(yO), XNe = (c, e = null) => eG(c, e).toStack(), QNe = (c, e = null) => eG(c, e, !0).toStack();
Ze("toVar", XNe);
Ze("toConst", QNe);
const ZNe = (c) => (console.warn('TSL: "temp( node )" is deprecated. Use "Var( node )" or "node.toVar()" instead.'), eG(c));
Ze("temp", ZNe);
class JNe extends yn {
  static get type() {
    return "VaryingNode";
  }
  /**
   * Constructs a new varying node.
   *
   * @param {Node} node - The node for which a varying should be created.
   * @param {?string} name - The name of the varying in the shader.
   */
  constructor(e, t = null) {
    super(), this.node = e, this.name = t, this.isVaryingNode = !0, this.interpolationType = null, this.interpolationSampling = null, this.global = !0;
  }
  /**
   * Defines the interpolation type of the varying.
   *
   * @param {string} type - The interpolation type.
   * @param {?string} sampling - The interpolation sampling type
   * @return {VaryingNode} A reference to this node.
   */
  setInterpolation(e, t = null) {
    return this.interpolationType = e, this.interpolationSampling = t, this;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  /**
   * This method performs the setup of a varying node with the current node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeVarying} The node varying from the node builder.
   */
  setupVarying(e) {
    const t = e.getNodeProperties(this);
    let n = t.varying;
    if (n === void 0) {
      const i = this.name, o = this.getNodeType(e), l = this.interpolationType, p = this.interpolationSampling;
      t.varying = n = e.getVaryingFromNode(this, i, o, l, p), t.node = this.node;
    }
    return n.needsInterpolation || (n.needsInterpolation = e.shaderStage === "fragment"), n;
  }
  setup(e) {
    this.setupVarying(e), e.flowNodeFromShaderStage(EN.VERTEX, this.node);
  }
  analyze(e) {
    this.setupVarying(e), e.flowNodeFromShaderStage(EN.VERTEX, this.node);
  }
  generate(e) {
    const t = e.getNodeProperties(this), n = this.setupVarying(e);
    if (t.propertyName === void 0) {
      const i = this.getNodeType(e), o = e.getPropertyName(n, EN.VERTEX);
      e.flowNodeFromShaderStage(EN.VERTEX, this.node, i, o), t.propertyName = o;
    }
    return e.getPropertyName(n);
  }
}
const pu = /* @__PURE__ */ lt(JNe).setParameterLength(1, 2), eOe = (c) => pu(c);
Ze("toVarying", pu);
Ze("toVertexStage", eOe);
Ze("varying", (...c) => (console.warn("THREE.TSL: .varying() has been renamed to .toVarying()."), pu(...c)));
Ze("vertexStage", (...c) => (console.warn("THREE.TSL: .vertexStage() has been renamed to .toVertexStage()."), pu(...c)));
const tOe = /* @__PURE__ */ at(([c]) => {
  const e = c.mul(0.9478672986).add(0.0521327014).pow(2.4), t = c.mul(0.0773993808), n = c.lessThanEqual(0.04045);
  return Vr(e, t, n);
}).setLayout({
  name: "sRGBTransferEOTF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), nOe = /* @__PURE__ */ at(([c]) => {
  const e = c.pow(0.41666).mul(1.055).sub(0.055), t = c.mul(12.92), n = c.lessThanEqual(31308e-7);
  return Vr(e, t, n);
}).setLayout({
  name: "sRGBTransferOETF",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" }
  ]
}), tG = "WorkingColorSpace", rOe = "OutputColorSpace";
class l0e extends Oi {
  static get type() {
    return "ColorSpaceNode";
  }
  /**
   * Constructs a new color space node.
   *
   * @param {Node} colorNode - Represents the color to convert.
   * @param {string} source - The source color space.
   * @param {string} target - The target color space.
   */
  constructor(e, t, n) {
    super("vec4"), this.colorNode = e, this.source = t, this.target = n;
  }
  /**
   * This method resolves the constants `WORKING_COLOR_SPACE` and
   * `OUTPUT_COLOR_SPACE` based on the current configuration of the
   * color management and renderer.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} colorSpace - The color space to resolve.
   * @return {string} The resolved color space.
   */
  resolveColorSpace(e, t) {
    return t === tG ? Ir.workingColorSpace : t === rOe ? e.context.outputColorSpace || e.renderer.outputColorSpace : t;
  }
  setup(e) {
    const { colorNode: t } = this, n = this.resolveColorSpace(e, this.source), i = this.resolveColorSpace(e, this.target);
    let o = t;
    return Ir.enabled === !1 || n === i || !n || !i || (Ir.getTransfer(n) === hn && (o = gn(tOe(o.rgb), o.a)), Ir.getPrimaries(n) !== Ir.getPrimaries(i) && (o = gn(
      bo(Ir._getMatrix(new Xo(), n, i)).mul(o.rgb),
      o.a
    )), Ir.getTransfer(i) === hn && (o = gn(nOe(o.rgb), o.a))), o;
  }
}
const iOe = (c, e) => ct(new l0e(ct(c), tG, e)), nG = (c, e) => ct(new l0e(ct(c), e, tG));
Ze("workingToColorSpace", iOe);
Ze("colorSpaceToWorking", nG);
let sOe = class extends OE {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {ReferenceBaseNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const t = super.generate(e), n = this.referenceNode.getNodeType(), i = this.getNodeType();
    return e.format(t, n, i);
  }
};
class u0e extends yn {
  static get type() {
    return "ReferenceBaseNode";
  }
  /**
   * Constructs a new reference base node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(e, t, n = null, i = null) {
    super(), this.property = e, this.uniformType = t, this.object = n, this.count = i, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.updateType = In.OBJECT;
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceBaseNode} A reference to this node.
   */
  setGroup(e) {
    return this.group = e, this;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(e) {
    return ct(new sOe(this, ct(e)));
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(e) {
    const t = on(null, e).getSelf();
    this.group !== null && t.setGroup(this.group), this.node = t;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(e = this.reference) {
    const { properties: t } = this;
    let n = e[t[0]];
    for (let i = 1; i < t.length; i++)
      n = n[t[i]];
    return n;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceBaseNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @return {UniformNode} The output node.
   */
  setup() {
    return this.updateValue(), this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const oOe = (c, e, t) => ct(new u0e(c, e, t));
class aOe extends u0e {
  static get type() {
    return "RendererReferenceNode";
  }
  /**
   * Constructs a new renderer reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Renderer} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   */
  constructor(e, t, n = null) {
    super(e, t, n), this.renderer = n, this.setGroup(sn);
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link RendererReferenceNode#renderer} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.renderer !== null ? this.renderer : e.renderer, this.reference;
  }
}
const lOe = (c, e, t = null) => ct(new aOe(c, e, t));
class uOe extends Oi {
  static get type() {
    return "ToneMappingNode";
  }
  /**
   * Constructs a new tone mapping node.
   *
   * @param {number} toneMapping - The tone mapping type.
   * @param {Node} exposureNode - The tone mapping exposure.
   * @param {Node} [colorNode=null] - The color node to process.
   */
  constructor(e, t = dOe, n = null) {
    super("vec3"), this.toneMapping = e, this.exposureNode = t, this.colorNode = n;
  }
  /**
   * Overwrites the default `customCacheKey()` implementation by including the tone
   * mapping type into the cache key.
   *
   * @return {number} The hash.
   */
  customCacheKey() {
    return DO(this.toneMapping);
  }
  setup(e) {
    const t = this.colorNode || e.context.color, n = this.toneMapping;
    if (n === Rb) return t;
    let i = null;
    const o = e.renderer.library.getToneMappingFunction(n);
    return o !== null ? i = gn(o(t.rgb, this.exposureNode), t.a) : (console.error("ToneMappingNode: Unsupported Tone Mapping configuration.", n), i = t), i;
  }
}
const cOe = (c, e, t) => ct(new uOe(c, ct(e), ct(t))), dOe = /* @__PURE__ */ lOe("toneMappingExposure", "float");
Ze("toneMapping", (c, e, t) => cOe(e, t, c));
const ho = /* @__PURE__ */ new Ue();
class rG {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(e, t, n, i = !1) {
    this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      ho.fromBufferAttribute(this, t), ho.applyMatrix4(e), this.setXYZ(t, ho.x, ho.y, ho.z);
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ho.fromBufferAttribute(this, t), ho.applyNormalMatrix(e), this.setXYZ(t, ho.x, ho.y, ho.z);
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      ho.fromBufferAttribute(this, t), ho.transformDirection(e), this.setXYZ(t, ho.x, ho.y, ho.z);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(e, t) {
    let n = this.array[e * this.data.stride + this.offset + t];
    return this.normalized && (n = go(n, this.array)), n;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(e, t, n) {
    return this.normalized && (n = xn(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(e, t) {
    return this.normalized && (t = xn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = go(t, this.array)), t;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(e, t, n) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(e, t, n, i) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(e, t, n, i, o) {
    return e = e * this.data.stride + this.offset, this.normalized && (t = xn(t, this.array), n = xn(n, this.array), i = xn(i, this.array), o = xn(o, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = o, this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return new ul(new this.array.constructor(t), this.itemSize, this.normalized);
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new rG(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(e) {
    if (e === void 0) {
      console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let o = 0; o < this.itemSize; o++)
          t.push(this.data.array[i + o]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized
      };
    } else
      return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
  }
}
class c0e {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(e, t) {
    this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = OO, this.updateRanges = [], this.version = 0, this.uuid = Bd();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(e) {
    return this.usage = e, this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(e, t) {
    this.updateRanges.push({ start: e, count: t });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(e) {
    return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(e, t, n) {
    e *= this.stride, n *= t.stride;
    for (let i = 0, o = this.stride; i < o; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bd()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(e) {
    return this.onUploadCallback = e, this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(e) {
    return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Bd()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
}
class hOe extends z6 {
  static get type() {
    return "BufferAttributeNode";
  }
  /**
   * Constructs a new buffer attribute node.
   *
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
   * @param {?string} [bufferType=null] - The buffer type (e.g. `'vec3'`).
   * @param {number} [bufferStride=0] - The buffer stride.
   * @param {number} [bufferOffset=0] - The buffer offset.
   */
  constructor(e, t = null, n = 0, i = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferStride = n, this.bufferOffset = i, this.usage = OO, this.instanced = !1, this.attribute = null, this.global = !0, e && e.isBufferAttribute === !0 && (this.attribute = e, this.usage = e.usage, this.instanced = e.isInstancedBufferAttribute);
  }
  /**
   * This method is overwritten since the attribute data might be shared
   * and thus the hash should be shared as well.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The hash.
   */
  getHash(e) {
    if (this.bufferStride === 0 && this.bufferOffset === 0) {
      let t = e.globalCache.getData(this.value);
      return t === void 0 && (t = {
        node: this
      }, e.globalCache.setData(this.value, t)), t.node.uuid;
    }
    return this.uuid;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the buffer attribute.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.bufferType === null && (this.bufferType = e.getTypeFromAttribute(this.attribute)), this.bufferType;
  }
  /**
   * Depending on which value was passed to the node, `setup()` behaves
   * differently. If no instance of `BufferAttribute` was passed, the method
   * creates an internal attribute and configures it respectively.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    if (this.attribute !== null) return;
    const t = this.getNodeType(e), n = this.value, i = e.getTypeLength(t), o = this.bufferStride || i, l = this.bufferOffset, p = n.isInterleavedBuffer === !0 ? n : new c0e(n, o), f = new rG(p, i, l);
    p.setUsage(this.usage), this.attribute = f, this.attribute.isInstancedBufferAttribute = this.instanced;
  }
  /**
   * Generates the code snippet of the buffer attribute node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(e) {
    const t = this.getNodeType(e), n = e.getBufferAttributeFromNode(this, t), i = e.getPropertyName(n);
    let o = null;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? (this.name = i, o = i) : o = pu(this).build(e, t), o;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "bufferAttribute";
  }
  /**
   * Sets the `usage` property to the given value.
   *
   * @param {number} value - The usage to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setUsage(e) {
    return this.usage = e, this.attribute && this.attribute.isBufferAttribute === !0 && (this.attribute.usage = e), this;
  }
  /**
   * Sets the `instanced` property to the given value.
   *
   * @param {boolean} value - The value to set.
   * @return {BufferAttributeNode} A reference to this node.
   */
  setInstanced(e) {
    return this.instanced = e, this;
  }
}
const iG = (c, e = null, t = 0, n = 0) => ct(new hOe(c, e, t, n)), pOe = (c, e = null, t = 0, n = 0) => iG(c, e, t, n).setUsage(Eb), Afe = (c, e = null, t = 0, n = 0) => iG(c, e, t, n).setInstanced(!0), kfe = (c, e = null, t = 0, n = 0) => pOe(c, e, t, n).setInstanced(!0);
Ze("toAttribute", (c) => iG(c.value));
class fOe extends yn {
  static get type() {
    return "ComputeNode";
  }
  /**
   * Constructs a new compute node.
   *
   * @param {Node} computeNode - TODO
   * @param {number} count - TODO.
   * @param {Array<number>} [workgroupSize=[64]] - TODO.
   */
  constructor(e, t, n = [64]) {
    super("void"), this.isComputeNode = !0, this.computeNode = e, this.count = t, this.workgroupSize = n, this.dispatchCount = 0, this.version = 1, this.name = "", this.updateBeforeType = In.OBJECT, this.onInitFunction = null, this.updateDispatchCount();
  }
  /**
   * Executes the `dispose` event for this node.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Sets the {@link ComputeNode#name} property.
   *
   * @param {string} name - The name of the uniform.
   * @return {ComputeNode} A reference to this node.
   */
  label(e) {
    return this.name = e, this;
  }
  /**
   * TODO
   */
  updateDispatchCount() {
    const { count: e, workgroupSize: t } = this;
    let n = t[0];
    for (let i = 1; i < t.length; i++)
      n *= t[i];
    this.dispatchCount = Math.ceil(e / n);
  }
  /**
   * TODO
   *
   * @param {Function} callback - TODO.
   * @return {ComputeNode} A reference to this node.
   */
  onInit(e) {
    return this.onInitFunction = e, this;
  }
  /**
   * The method execute the compute for this node.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore({ renderer: e }) {
    e.compute(this);
  }
  setup(e) {
    const t = this.computeNode.build(e);
    if (t) {
      const n = e.getNodeProperties(this);
      n.outputComputeNode = t.outputNode, t.outputNode = null;
    }
    return t;
  }
  generate(e, t) {
    const { shaderStage: n } = e;
    if (n === "compute") {
      const i = this.computeNode.build(e, "void");
      i !== "" && e.addLineFlowCode(i, this);
    } else {
      const o = e.getNodeProperties(this).outputComputeNode;
      if (o)
        return o.build(e, t);
    }
  }
}
const mOe = (c, e, t) => ct(new fOe(ct(c), e, t));
Ze("compute", mOe);
class gOe extends yn {
  static get type() {
    return "CacheNode";
  }
  /**
   * Constructs a new cache node.
   *
   * @param {Node} node - The node that should be cached.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   */
  constructor(e, t = !0) {
    super(), this.node = e, this.parent = t, this.isCacheNode = !0;
  }
  getNodeType(e) {
    const t = e.getCache(), n = e.getCacheFromNode(this, this.parent);
    e.setCache(n);
    const i = this.node.getNodeType(e);
    return e.setCache(t), i;
  }
  build(e, ...t) {
    const n = e.getCache(), i = e.getCacheFromNode(this, this.parent);
    e.setCache(i);
    const o = this.node.build(e, ...t);
    return e.setCache(n), o;
  }
}
const vO = (c, e) => ct(new gOe(ct(c), e)), yOe = (c, e) => c.context({ namespace: e });
Ze("cache", vO);
class vOe extends yn {
  static get type() {
    return "BypassNode";
  }
  /**
   * Constructs a new bypass node.
   *
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   */
  constructor(e, t) {
    super(), this.isBypassNode = !0, this.outputNode = e, this.callNode = t;
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return t !== "" && e.addLineFlowCode(t, this), this.outputNode.build(e);
  }
}
const bOe = /* @__PURE__ */ lt(vOe).setParameterLength(2);
Ze("bypass", bOe);
class d0e extends yn {
  static get type() {
    return "RemapNode";
  }
  /**
   * Constructs a new remap node.
   *
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   */
  constructor(e, t, n, i = et(0), o = et(1)) {
    super(), this.node = e, this.inLowNode = t, this.inHighNode = n, this.outLowNode = i, this.outHighNode = o, this.doClamp = !0;
  }
  setup() {
    const { node: e, inLowNode: t, inHighNode: n, outLowNode: i, outHighNode: o, doClamp: l } = this;
    let p = e.sub(t).div(n.sub(t));
    return l === !0 && (p = p.clamp()), p.mul(o.sub(i)).add(i);
  }
}
const xOe = /* @__PURE__ */ lt(d0e, null, null, { doClamp: !1 }).setParameterLength(3, 5), _Oe = /* @__PURE__ */ lt(d0e).setParameterLength(3, 5);
Ze("remap", xOe);
Ze("remapClamp", _Oe);
class bO extends yn {
  static get type() {
    return "ExpressionNode";
  }
  /**
   * Constructs a new expression node.
   *
   * @param {string} [snippet=''] - The native code snippet.
   * @param {string} [nodeType='void'] - The node type.
   */
  constructor(e = "", t = "void") {
    super(t), this.snippet = e;
  }
  generate(e, t) {
    const n = this.getNodeType(e), i = this.snippet;
    if (n === "void")
      e.addLineFlowCode(i, this);
    else
      return e.format(i, n, t);
  }
}
const $b = /* @__PURE__ */ lt(bO).setParameterLength(1, 2), SOe = (c) => (c ? Zs(c, $b("discard")) : $b("discard")).toStack();
Ze("discard", SOe);
class wOe extends Oi {
  static get type() {
    return "RenderOutputNode";
  }
  /**
   * Constructs a new render output node.
   *
   * @param {Node} colorNode - The color node to process.
   * @param {?number} toneMapping - The tone mapping type.
   * @param {?string} outputColorSpace - The output color space.
   */
  constructor(e, t, n) {
    super("vec4"), this.colorNode = e, this.toneMapping = t, this.outputColorSpace = n, this.isRenderOutputNode = !0;
  }
  setup({ context: e }) {
    let t = this.colorNode || e.color;
    const n = (this.toneMapping !== null ? this.toneMapping : e.toneMapping) || Rb, i = (this.outputColorSpace !== null ? this.outputColorSpace : e.outputColorSpace) || $d;
    return n !== Rb && (t = t.toneMapping(n)), i !== $d && i !== Ir.workingColorSpace && (t = t.workingToColorSpace(i)), t;
  }
}
const EOe = (c, e = null, t = null) => ct(new wOe(ct(c), e, t));
Ze("renderOutput", EOe);
class TOe extends Oi {
  static get type() {
    return "DebugNode";
  }
  constructor(e, t = null) {
    super(), this.node = e, this.callback = t;
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  setup(e) {
    return this.node.build(e);
  }
  analyze(e) {
    return this.node.build(e);
  }
  generate(e) {
    const t = this.callback, n = this.node.build(e), i = "--- TSL debug - " + e.shaderStage + " shader ---", o = "-".repeat(i.length);
    let l = "";
    return l += "// #" + i + `#
`, l += e.flow.code.replace(/^\t/mg, "") + `
`, l += "/* ... */ " + n + ` /* ... */
`, l += "// #" + o + `#
`, t !== null ? t(e, l) : console.log(l), n;
  }
}
const COe = (c, e = null) => ct(new TOe(ct(c), e));
Ze("debug", COe);
class h0e extends yn {
  static get type() {
    return "AttributeNode";
  }
  /**
   * Constructs a new attribute node.
   *
   * @param {string} attributeName - The name of the attribute.
   * @param {?string} nodeType - The node type.
   */
  constructor(e, t = null) {
    super(t), this.global = !0, this._attributeName = e;
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = this.nodeType;
    if (t === null) {
      const n = this.getAttributeName(e);
      if (e.hasGeometryAttribute(n)) {
        const i = e.geometry.getAttribute(n);
        t = e.getTypeFromAttribute(i);
      } else
        t = "float";
    }
    return t;
  }
  /**
   * Sets the attribute name to the given value. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {string} attributeName - The name of the attribute.
   * @return {AttributeNode} A reference to this node.
   */
  setAttributeName(e) {
    return this._attributeName = e, this;
  }
  /**
   * Returns the attribute name of this node. The method can be
   * overwritten in derived classes if the final name must be computed
   * analytically.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e), n = this.getNodeType(e);
    if (e.hasGeometryAttribute(t) === !0) {
      const o = e.geometry.getAttribute(t), l = e.getTypeFromAttribute(o), p = e.getAttribute(t, l);
      return e.shaderStage === "vertex" ? e.format(p.name, l, n) : pu(this).build(e, n);
    } else
      return console.warn(`AttributeNode: Vertex attribute "${t}" not found on geometry.`), e.generateConst(n);
  }
  serialize(e) {
    super.serialize(e), e.global = this.global, e._attributeName = this._attributeName;
  }
  deserialize(e) {
    super.deserialize(e), this.global = e.global, this._attributeName = e._attributeName;
  }
}
const tf = (c, e = null) => ct(new h0e(c, e));
class Gr extends yn {
  static get type() {
    return "IndexNode";
  }
  /**
   * Constructs a new index node.
   *
   * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
   */
  constructor(e) {
    super("uint"), this.scope = e, this.isIndexNode = !0;
  }
  generate(e) {
    const t = this.getNodeType(e), n = this.scope;
    let i;
    if (n === Gr.VERTEX)
      i = e.getVertexIndex();
    else if (n === Gr.INSTANCE)
      i = e.getInstanceIndex();
    else if (n === Gr.DRAW)
      i = e.getDrawIndex();
    else if (n === Gr.INVOCATION_LOCAL)
      i = e.getInvocationLocalIndex();
    else if (n === Gr.INVOCATION_SUBGROUP)
      i = e.getInvocationSubgroupIndex();
    else if (n === Gr.SUBGROUP)
      i = e.getSubgroupIndex();
    else
      throw new Error("THREE.IndexNode: Unknown scope: " + n);
    let o;
    return e.shaderStage === "vertex" || e.shaderStage === "compute" ? o = i : o = pu(this).build(e, t), o;
  }
}
Gr.VERTEX = "vertex";
Gr.INSTANCE = "instance";
Gr.SUBGROUP = "subgroup";
Gr.INVOCATION_LOCAL = "invocationLocal";
Gr.INVOCATION_SUBGROUP = "invocationSubgroup";
Gr.DRAW = "draw";
const POe = /* @__PURE__ */ bt(Gr, Gr.VERTEX), sG = /* @__PURE__ */ bt(Gr, Gr.INSTANCE);
Gr.SUBGROUP;
Gr.INVOCATION_SUBGROUP;
Gr.INVOCATION_LOCAL;
const AOe = /* @__PURE__ */ bt(Gr, Gr.DRAW);
class kOe extends ur {
  static get type() {
    return "ParameterNode";
  }
  /**
   * Constructs a new parameter node.
   *
   * @param {string} nodeType - The type of the node.
   * @param {?string} [name=null] - The name of the parameter in the shader.
   */
  constructor(e, t = null) {
    super(e, t), this.isParameterNode = !0;
  }
  getHash() {
    return this.uuid;
  }
  generate() {
    return this.name;
  }
}
class MOe extends yn {
  static get type() {
    return "StackNode";
  }
  /**
   * Constructs a new stack node.
   *
   * @param {?StackNode} [parent=null] - The parent stack node.
   */
  constructor(e = null) {
    super(), this.nodes = [], this.outputNode = null, this.parent = e, this._currentCond = null, this._expressionNode = null, this.isStackNode = !0;
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  getMemberType(e, t) {
    return this.outputNode ? this.outputNode.getMemberType(e, t) : "void";
  }
  /**
   * Adds a node to this stack.
   *
   * @param {Node} node - The node to add.
   * @return {StackNode} A reference to this stack node.
   */
  add(e) {
    return this.nodes.push(e), this;
  }
  /**
   * Represent an `if` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  If(e, t) {
    const n = new nE(t);
    return this._currentCond = Zs(e, n), this.add(this._currentCond);
  }
  /**
   * Represent an `elseif` statement in TSL.
   *
   * @param {Node} boolNode - Represents the condition.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  ElseIf(e, t) {
    const n = new nE(t), i = Zs(e, n);
    return this._currentCond.elseNode = i, this._currentCond = i, this;
  }
  /**
   * Represent an `else` statement in TSL.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Else(e) {
    return this._currentCond.elseNode = new nE(e), this;
  }
  /**
   * Represents a `switch` statement in TSL.
   *
   * @param {any} expression - Represents the expression.
   * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
   * @return {StackNode} A reference to this stack node.
   */
  Switch(e) {
    return this._expressionNode = ct(e), this;
  }
  /**
   * Represents a `case` statement in TSL. The TSL version accepts an arbitrary numbers of values.
   * The last parameter must be the callback method that should be executed in the `true` case.
   *
   * @param {...any} params - The values of the `Case()` statement as well as the callback method.
   * @return {StackNode} A reference to this stack node.
   */
  Case(...e) {
    const t = [];
    if (e.length >= 2)
      for (let p = 0; p < e.length - 1; p++)
        t.push(this._expressionNode.equal(ct(e[p])));
    else
      throw new Error("TSL: Invalid parameter length. Case() requires at least two parameters.");
    const n = e[e.length - 1], i = new nE(n);
    let o = t[0];
    for (let p = 1; p < t.length; p++)
      o = o.or(t[p]);
    const l = Zs(o, i);
    return this._currentCond === null ? (this._currentCond = l, this.add(this._currentCond)) : (this._currentCond.elseNode = l, this._currentCond = l, this);
  }
  /**
   * Represents the default code block of a Switch/Case statement.
   *
   * @param {Function} method - TSL code which is executed in the `else` case.
   * @return {StackNode} A reference to this stack node.
   */
  Default(e) {
    return this.Else(e), this;
  }
  build(e, ...t) {
    const n = Bye();
    LO(this);
    const i = e.buildStage;
    for (const o of this.nodes)
      if (i === "setup")
        o.build(e);
      else if (i === "analyze")
        o.build(e, this);
      else if (i === "generate") {
        const l = e.getDataFromNode(o, "any").stages, p = l && l[e.shaderStage];
        if (o.isVarNode && p && p.length === 1 && p[0] && p[0].isStackNode)
          continue;
        o.build(e, "void");
      }
    return LO(n), this.outputNode ? this.outputNode.build(e, ...t) : super.build(e, ...t);
  }
  // Deprecated
  /**
   * @function
   * @deprecated since r168. Use {@link StackNode#Else} instead.
   *
   * @param {...any} params
   * @returns {StackNode}
   */
  else(...e) {
    return console.warn("THREE.TSL: .else() has been renamed to .Else()."), this.Else(...e);
  }
  /**
   * @deprecated since r168. Use {@link StackNode#ElseIf} instead.
   *
   * @param {...any} params
   * @returns {StackNode}
   */
  elseif(...e) {
    return console.warn("THREE.TSL: .elseif() has been renamed to .ElseIf()."), this.ElseIf(...e);
  }
}
const x5 = /* @__PURE__ */ lt(MOe).setParameterLength(0, 1);
class ROe extends yn {
  static get type() {
    return "LoopNode";
  }
  /**
   * Constructs a new loop node.
   *
   * @param {Array<any>} params - Depending on the loop type, array holds different parameterization values for the loop.
   */
  constructor(e = []) {
    super(), this.params = e;
  }
  /**
   * Returns a loop variable name based on an index. The pattern is
   * `0` = `i`, `1`= `j`, `2`= `k` and so on.
   *
   * @param {number} index - The index.
   * @return {string} The loop variable name.
   */
  getVarName(e) {
    return String.fromCharCode(105 + e);
  }
  /**
   * Returns properties about this node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Object} The node properties.
   */
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (t.stackNode !== void 0) return t;
    const n = {};
    for (let l = 0, p = this.params.length - 1; l < p; l++) {
      const f = this.params[l], v = f.isNode !== !0 && f.name || this.getVarName(l), _ = f.isNode !== !0 && f.type || "int";
      n[v] = $b(v, _);
    }
    const i = e.addStack();
    t.returnsNode = this.params[this.params.length - 1](n, e), t.stackNode = i;
    const o = this.params[0];
    return o.isNode !== !0 && typeof o.update == "function" && (t.updateNode = at(this.params[0].update)(n)), e.removeStack(), t;
  }
  /**
   * This method is overwritten since the node type is inferred based on the loop configuration.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  setup(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e), n = this.params, i = t.stackNode;
    for (let p = 0, f = n.length - 1; p < f; p++) {
      const v = n[p];
      let _ = !1, E = null, A = null, I = null, j = null, q = null, L = null;
      v.isNode ? v.getNodeType(e) === "bool" ? (_ = !0, j = "bool", A = v.build(e, j)) : (j = "int", I = this.getVarName(p), E = "0", A = v.build(e, j), q = "<") : (j = v.type || "int", I = v.name || this.getVarName(p), E = v.start, A = v.end, q = v.condition, L = v.update, typeof E == "number" ? E = e.generateConst(j, E) : E && E.isNode && (E = E.build(e, j)), typeof A == "number" ? A = e.generateConst(j, A) : A && A.isNode && (A = A.build(e, j)), E !== void 0 && A === void 0 ? (E = E + " - 1", A = "0", q = ">=") : A !== void 0 && E === void 0 && (E = "0", q = "<"), q === void 0 && (Number(E) > Number(A) ? q = ">=" : q = "<"));
      let V;
      if (_)
        V = `while ( ${A} )`;
      else {
        const re = { start: E, end: A }, R = re.start, J = re.end;
        let ge;
        const _e = () => q.includes("<") ? "+=" : "-=";
        if (L != null)
          switch (typeof L) {
            case "function":
              ge = e.flowStagesNode(t.updateNode, "void").code.replace(/\t|;/g, "");
              break;
            case "number":
              ge = I + " " + _e() + " " + e.generateConst(j, L);
              break;
            case "string":
              ge = I + " " + L;
              break;
            default:
              L.isNode ? ge = I + " " + _e() + " " + L.build(e) : (console.error("THREE.TSL: 'Loop( { update: ... } )' is not a function, string or number."), ge = "break /* invalid update */");
          }
        else
          j === "int" || j === "uint" ? L = q.includes("<") ? "++" : "--" : L = _e() + " 1.", ge = I + " " + L;
        const Y = e.getVar(j, I) + " = " + R, Fe = I + " " + q + " " + J;
        V = `for ( ${Y}; ${Fe}; ${ge} )`;
      }
      e.addFlowCode((p === 0 ? `
` : "") + e.tab + V + ` {

`).addFlowTab();
    }
    const o = i.build(e, "void"), l = t.returnsNode ? t.returnsNode.build(e) : "";
    e.removeFlowTab().addFlowCode(`
` + e.tab + o);
    for (let p = 0, f = this.params.length - 1; p < f; p++)
      e.addFlowCode((p === 0 ? "" : e.tab) + `}

`).removeFlowTab();
    return e.addFlowTab(), l;
  }
}
const cu = (...c) => ct(new ROe(Ob(c, "int"))).toStack(), IOe = () => $b("break").toStack();
class FE {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(e = new Ue(1 / 0, 1 / 0, 1 / 0), t = new Ue(-1 / 0, -1 / 0, -1 / 0)) {
    this.isBox3 = !0, this.min = e, this.max = t;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(nu.fromArray(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(nu.fromBufferAttribute(e, t));
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++)
      this.expandByPoint(e[t]);
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(e, t) {
    const n = nu.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(e, t = !1) {
    e.updateWorldMatrix(!1, !1);
    const n = e.geometry;
    if (n !== void 0) {
      const o = n.getAttribute("position");
      if (t === !0 && o !== void 0 && e.isInstancedMesh !== !0)
        for (let l = 0, p = o.count; l < p; l++)
          e.isMesh === !0 ? e.getVertexPosition(l, nu) : nu.fromBufferAttribute(o, l), nu.applyMatrix4(e.matrixWorld), this.expandByPoint(nu);
      else
        e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), TN.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), TN.copy(n.boundingBox)), TN.applyMatrix4(e.matrixWorld), this.union(TN);
    }
    const i = e.children;
    for (let o = 0, l = i.length; o < l; o++)
      this.expandByObject(i[o], t);
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(e) {
    return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(e) {
    return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(e) {
    return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(e) {
    return this.clampPoint(e.center, nu), nu.distanceToSquared(e.center) <= e.radius * e.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(e) {
    let t, n;
    return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(e) {
    if (this.isEmpty())
      return !1;
    this.getCenter(Mw), CN.subVectors(this.max, Mw), rb.subVectors(e.a, Mw), ib.subVectors(e.b, Mw), sb.subVectors(e.c, Mw), Np.subVectors(ib, rb), Op.subVectors(sb, ib), eg.subVectors(rb, sb);
    let t = [
      0,
      -Np.z,
      Np.y,
      0,
      -Op.z,
      Op.y,
      0,
      -eg.z,
      eg.y,
      Np.z,
      0,
      -Np.x,
      Op.z,
      0,
      -Op.x,
      eg.z,
      0,
      -eg.x,
      -Np.y,
      Np.x,
      0,
      -Op.y,
      Op.x,
      0,
      -eg.y,
      eg.x,
      0
    ];
    return !_5(t, rb, ib, sb, CN) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !_5(t, rb, ib, sb, CN)) ? !1 : (PN.crossVectors(Np, Op), t = [PN.x, PN.y, PN.z], _5(t, rb, ib, sb, CN));
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(e) {
    return this.clampPoint(e, nu).distanceTo(e);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(e) {
    return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(nu).length() * 0.5), e;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(e) {
    return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(e) {
    return this.isEmpty() ? this : (kd[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), kd[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), kd[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), kd[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), kd[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), kd[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), kd[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), kd[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(kd), this);
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(e) {
    return this.min.fromArray(e.min), this.max.fromArray(e.max), this;
  }
}
const kd = [
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue(),
  /* @__PURE__ */ new Ue()
], nu = /* @__PURE__ */ new Ue(), TN = /* @__PURE__ */ new FE(), rb = /* @__PURE__ */ new Ue(), ib = /* @__PURE__ */ new Ue(), sb = /* @__PURE__ */ new Ue(), Np = /* @__PURE__ */ new Ue(), Op = /* @__PURE__ */ new Ue(), eg = /* @__PURE__ */ new Ue(), Mw = /* @__PURE__ */ new Ue(), CN = /* @__PURE__ */ new Ue(), PN = /* @__PURE__ */ new Ue(), tg = /* @__PURE__ */ new Ue();
function _5(c, e, t, n, i) {
  for (let o = 0, l = c.length - 3; o <= l; o += 3) {
    tg.fromArray(c, o);
    const p = i.x * Math.abs(tg.x) + i.y * Math.abs(tg.y) + i.z * Math.abs(tg.z), f = e.dot(tg), v = t.dot(tg), _ = n.dot(tg);
    if (Math.max(-Math.max(f, v, _), Math.min(f, v, _)) > p)
      return !1;
  }
  return !0;
}
const NOe = /* @__PURE__ */ new FE(), Rw = /* @__PURE__ */ new Ue(), S5 = /* @__PURE__ */ new Ue();
class i2 {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(e = new Ue(), t = -1) {
    this.isSphere = !0, this.center = e, this.radius = t;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(e, t) {
    return this.center.copy(e), this.radius = t, this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : NOe.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let o = 0, l = e.length; o < l; o++)
      i = Math.max(i, n.distanceToSquared(e[o]));
    return this.radius = Math.sqrt(i), this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(e) {
    return this.center.copy(e.center), this.radius = e.radius, this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    return this.center.set(0, 0, 0), this.radius = -1, this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(e) {
    return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(e) {
    return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(e) {
    return this.center.add(e), this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(e) {
    if (this.isEmpty())
      return this.center.copy(e), this.radius = 0, this;
    Rw.subVectors(e, this.center);
    const t = Rw.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t), i = (n - this.radius) * 0.5;
      this.center.addScaledVector(Rw, i / n), this.radius += i;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(e) {
    return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (S5.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Rw.copy(e.center).add(S5)), this.expandByPoint(Rw.copy(e.center).sub(S5))), this);
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Box3} A reference to this bounding sphere.
   */
  fromJSON(e) {
    return this.radius = e.radius, this.center.fromArray(e.center), this;
  }
}
const Mfe = /* @__PURE__ */ new i2();
class br extends yn {
  static get type() {
    return "Object3DNode";
  }
  /**
   * Constructs a new object 3D node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   * @param {?Object3D} [object3d=null] - The 3D object.
   */
  constructor(e, t = null) {
    super(), this.scope = e, this.object3d = t, this.updateType = In.OBJECT, this.uniformNode = new DE(null);
  }
  /**
   * Overwritten since the node type is inferred from the scope.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    const e = this.scope;
    if (e === br.WORLD_MATRIX)
      return "mat4";
    if (e === br.POSITION || e === br.VIEW_POSITION || e === br.DIRECTION || e === br.SCALE)
      return "vec3";
    if (e === br.RADIUS)
      return "float";
  }
  /**
   * Updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    const t = this.object3d, n = this.uniformNode, i = this.scope;
    if (i === br.WORLD_MATRIX)
      n.value = t.matrixWorld;
    else if (i === br.POSITION)
      n.value = n.value || new Ue(), n.value.setFromMatrixPosition(t.matrixWorld);
    else if (i === br.SCALE)
      n.value = n.value || new Ue(), n.value.setFromMatrixScale(t.matrixWorld);
    else if (i === br.DIRECTION)
      n.value = n.value || new Ue(), t.getWorldDirection(n.value);
    else if (i === br.VIEW_POSITION) {
      const o = e.camera;
      n.value = n.value || new Ue(), n.value.setFromMatrixPosition(t.matrixWorld), n.value.applyMatrix4(o.matrixWorldInverse);
    } else if (i === br.RADIUS) {
      const o = e.object.geometry;
      o.boundingSphere === null && o.computeBoundingSphere(), Mfe.copy(o.boundingSphere).applyMatrix4(t.matrixWorld), n.value = Mfe.radius;
    }
  }
  /**
   * Generates the code snippet of the uniform node. The node type of the uniform
   * node also depends on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate(e) {
    const t = this.scope;
    return t === br.WORLD_MATRIX ? this.uniformNode.nodeType = "mat4" : t === br.POSITION || t === br.VIEW_POSITION || t === br.DIRECTION || t === br.SCALE ? this.uniformNode.nodeType = "vec3" : t === br.RADIUS && (this.uniformNode.nodeType = "float"), this.uniformNode.build(e);
  }
  serialize(e) {
    super.serialize(e), e.scope = this.scope;
  }
  deserialize(e) {
    super.deserialize(e), this.scope = e.scope;
  }
}
br.WORLD_MATRIX = "worldMatrix";
br.POSITION = "position";
br.SCALE = "scale";
br.VIEW_POSITION = "viewPosition";
br.DIRECTION = "direction";
br.RADIUS = "radius";
const OOe = /* @__PURE__ */ lt(br, br.POSITION).setParameterLength(1);
class p0e extends DE {
  static get type() {
    return "BufferNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {Array<number>} value - Array-like buffer data.
   * @param {string} bufferType - The data type of the buffer.
   * @param {number} [bufferCount=0] - The count of buffer elements.
   */
  constructor(e, t, n = 0) {
    super(e, t), this.isBufferNode = !0, this.bufferType = t, this.bufferCount = n;
  }
  /**
   * The data type of the buffer elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType(e) {
    return this.getNodeType(e);
  }
  /**
   * Overwrites the default implementation to return a fixed value `'buffer'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "buffer";
  }
}
const f0e = (c, e, t) => ct(new p0e(c, e, t));
class DOe extends OE {
  static get type() {
    return "UniformArrayElementNode";
  }
  /**
   * Constructs a new buffer node.
   *
   * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
   * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
   */
  constructor(e, t) {
    super(e, t), this.isArrayBufferElementNode = !0;
  }
  generate(e) {
    const t = super.generate(e), n = this.getNodeType(), i = this.node.getPaddedType();
    return e.format(t, i, n);
  }
}
class FOe extends p0e {
  static get type() {
    return "UniformArrayNode";
  }
  /**
   * Constructs a new uniform array node.
   *
   * @param {Array<any>} value - Array holding the buffer data.
   * @param {?string} [elementType=null] - The data type of a buffer element.
   */
  constructor(e, t = null) {
    super(null), this.array = e, this.elementType = t === null ? BO(e[0]) : t, this.paddedType = this.getPaddedType(), this.updateType = In.RENDER, this.isArrayBufferNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from the
   * {@link UniformArrayNode#paddedType}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.paddedType;
  }
  /**
   * The data type of the array elements.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The element type.
   */
  getElementType() {
    return this.elementType;
  }
  /**
   * Returns the padded type based on the element type.
   *
   * @return {string} The padded type.
   */
  getPaddedType() {
    const e = this.elementType;
    let t = "vec4";
    return e === "mat2" ? t = "mat2" : /mat/.test(e) === !0 ? t = "mat4" : e.charAt(0) === "i" ? t = "ivec4" : e.charAt(0) === "u" && (t = "uvec4"), t;
  }
  /**
   * The update makes sure to correctly transfer the data from the (complex) objects
   * in the array to the internal, correctly padded value buffer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { array: e, value: t } = this, n = this.elementType;
    if (n === "float" || n === "int" || n === "uint")
      for (let i = 0; i < e.length; i++) {
        const o = i * 4;
        t[o] = e[i];
      }
    else if (n === "color")
      for (let i = 0; i < e.length; i++) {
        const o = i * 4, l = e[i];
        t[o] = l.r, t[o + 1] = l.g, t[o + 2] = l.b || 0;
      }
    else if (n === "mat2")
      for (let i = 0; i < e.length; i++) {
        const o = i * 4, l = e[i];
        t[o] = l.elements[0], t[o + 1] = l.elements[1], t[o + 2] = l.elements[2], t[o + 3] = l.elements[3];
      }
    else if (n === "mat3")
      for (let i = 0; i < e.length; i++) {
        const o = i * 16, l = e[i];
        t[o] = l.elements[0], t[o + 1] = l.elements[1], t[o + 2] = l.elements[2], t[o + 4] = l.elements[3], t[o + 5] = l.elements[4], t[o + 6] = l.elements[5], t[o + 8] = l.elements[6], t[o + 9] = l.elements[7], t[o + 10] = l.elements[8], t[o + 15] = 1;
      }
    else if (n === "mat4")
      for (let i = 0; i < e.length; i++) {
        const o = i * 16, l = e[i];
        for (let p = 0; p < l.elements.length; p++)
          t[o + p] = l.elements[p];
      }
    else
      for (let i = 0; i < e.length; i++) {
        const o = i * 4, l = e[i];
        t[o] = l.x, t[o + 1] = l.y, t[o + 2] = l.z || 0, t[o + 3] = l.w || 0;
      }
  }
  /**
   * Implement the value buffer creation based on the array data.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {null}
   */
  setup(e) {
    const t = this.array.length, n = this.elementType;
    let i = Float32Array;
    const o = this.paddedType, l = e.getTypeLength(o);
    return n.charAt(0) === "i" && (i = Int32Array), n.charAt(0) === "u" && (i = Uint32Array), this.value = new i(t * l), this.bufferCount = t, this.bufferType = o, super.setup(e);
  }
  /**
   * Overwrites the default `element()` method to provide element access
   * based on {@link UniformArrayNode}.
   *
   * @param {IndexNode} indexNode - The index node.
   * @return {UniformArrayElementNode}
   */
  element(e) {
    return ct(new DOe(this, ct(e)));
  }
}
const vc = (c, e) => ct(new FOe(c, e));
class BOe extends yn {
  /**
   * Constructs a new builtin node.
   *
   * @param {string} name - The name of the built-in shader variable.
   */
  constructor(e) {
    super("float"), this.name = e, this.isBuiltinNode = !0;
  }
  /**
   * Generates the code snippet of the builtin node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The generated code snippet.
   */
  generate() {
    return this.name;
  }
}
const s2 = lt(BOe).setParameterLength(1), m0e = /* @__PURE__ */ on(0, "uint").label("u_cameraIndex").setGroup(W6("cameraIndex")).toVarying("v_cameraIndex"), yg = /* @__PURE__ */ on("float").label("cameraNear").setGroup(sn).onRenderUpdate(({ camera: c }) => c.near), vg = /* @__PURE__ */ on("float").label("cameraFar").setGroup(sn).onRenderUpdate(({ camera: c }) => c.far), oG = /* @__PURE__ */ at(({ camera: c }) => {
  let e;
  if (c.isArrayCamera && c.cameras.length > 0) {
    const t = [];
    for (const i of c.cameras)
      t.push(i.projectionMatrix);
    e = vc(t).setGroup(sn).label("cameraProjectionMatrices").element(c.isMultiViewCamera ? s2("gl_ViewID_OVR") : m0e).toVar("cameraProjectionMatrix");
  } else
    e = on("mat4").label("cameraProjectionMatrix").setGroup(sn).onRenderUpdate(({ camera: t }) => t.projectionMatrix);
  return e;
}).once()(), Qd = /* @__PURE__ */ at(({ camera: c }) => {
  let e;
  if (c.isArrayCamera && c.cameras.length > 0) {
    const t = [];
    for (const i of c.cameras)
      t.push(i.matrixWorldInverse);
    e = vc(t).setGroup(sn).label("cameraViewMatrices").element(c.isMultiViewCamera ? s2("gl_ViewID_OVR") : m0e).toVar("cameraViewMatrix");
  } else
    e = on("mat4").label("cameraViewMatrix").setGroup(sn).onRenderUpdate(({ camera: t }) => t.matrixWorldInverse);
  return e;
}).once()(), LOe = /* @__PURE__ */ on(new Ue()).label("cameraPosition").setGroup(sn).onRenderUpdate(({ camera: c }, e) => e.value.setFromMatrixPosition(c.matrixWorld));
class pl extends br {
  static get type() {
    return "ModelNode";
  }
  /**
   * Constructs a new object model node.
   *
   * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
   */
  constructor(e) {
    super(e);
  }
  /**
   * Extracts the model reference from the frame state and then
   * updates the uniform value depending on the scope.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    this.object3d = e.object, super.update(e);
  }
}
pl.DIRECTION;
const Cg = /* @__PURE__ */ bt(pl, pl.WORLD_MATRIX);
pl.POSITION;
pl.SCALE;
pl.VIEW_POSITION;
pl.RADIUS;
const jOe = /* @__PURE__ */ on(new Xo()).onObjectUpdate(({ object: c }, e) => e.value.getNormalMatrix(c.matrixWorld)), o2 = /* @__PURE__ */ at((c) => c.renderer.overrideNodes.modelViewMatrix || UOe).once()().toVar("modelViewMatrix"), UOe = /* @__PURE__ */ Qd.mul(Cg), Rfe = /* @__PURE__ */ at((c) => (c.context.isHighPrecisionModelViewMatrix = !0, on("mat4").onObjectUpdate(({ object: e, camera: t }) => e.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, e.matrixWorld)))).once()().toVar("highpModelViewMatrix"), Ife = /* @__PURE__ */ at((c) => {
  const e = c.context.isHighPrecisionModelViewMatrix;
  return on("mat3").onObjectUpdate(({ object: t, camera: n }) => (e !== !0 && t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix)));
}).once()().toVar("highpModelNormalViewMatrix"), a2 = /* @__PURE__ */ tf("position", "vec3"), Qs = /* @__PURE__ */ a2.toVarying("positionLocal"), Nfe = /* @__PURE__ */ a2.toVarying("positionPrevious"), AE = /* @__PURE__ */ at((c) => Cg.mul(Qs).xyz.toVarying(c.getNamespace("v_positionWorld")), "vec3").once("POSITION")(), g0e = /* @__PURE__ */ at((c) => Qs.transformDirection(Cg).toVarying(c.getNamespace("v_positionWorldDirection")).normalize().toVar("positionWorldDirection"), "vec3").once("POSITION")(), Ii = /* @__PURE__ */ at((c) => c.context.setupPositionView().toVarying(c.getNamespace("v_positionView")), "vec3").once("POSITION")(), ii = /* @__PURE__ */ Ii.negate().toVarying("v_positionViewDirection").normalize().toVar("positionViewDirection");
class zOe extends Oi {
  static get type() {
    return "EquirectUVNode";
  }
  /**
   * Constructs a new equirect uv node.
   *
   * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
   */
  constructor(e = g0e) {
    super("vec2"), this.dirNode = e;
  }
  setup() {
    const e = this.dirNode, t = e.z.atan(e.x).mul(1 / (Math.PI * 2)).add(0.5), n = e.y.clamp(-1, 1).asin().mul(1 / Math.PI).add(0.5);
    return xt(t, n);
  }
}
const y0e = /* @__PURE__ */ lt(zOe).setParameterLength(0, 1);
class VOe extends yn {
  static get type() {
    return "FrontFacingNode";
  }
  /**
   * Constructs a new front facing node.
   */
  constructor() {
    super("bool"), this.isFrontFacingNode = !0;
  }
  generate(e) {
    const { renderer: t, material: n } = e;
    return t.coordinateSystem === Ho && n.side === Ko ? "false" : e.getFrontFacing();
  }
}
const GOe = /* @__PURE__ */ bt(VOe), l2 = /* @__PURE__ */ et(GOe).mul(2).sub(1), v0e = /* @__PURE__ */ tf("normal", "vec3"), wc = /* @__PURE__ */ at((c) => c.geometry.hasAttribute("normal") === !1 ? (console.warn('THREE.TSL: Vertex attribute "normal" not found on geometry.'), tt(0, 1, 0)) : v0e, "vec3").once()().toVar("normalLocal"), qOe = /* @__PURE__ */ Ii.dFdx().cross(Ii.dFdy()).normalize().toVar("normalFlat"), Ec = /* @__PURE__ */ at((c) => {
  let e;
  return c.material.flatShading === !0 ? e = qOe : e = pu(b0e(wc), "v_normalView").normalize(), e;
}, "vec3").once()().toVar("normalView"), aG = /* @__PURE__ */ at((c) => {
  let e = Ec.transformDirection(Qd);
  return c.material.flatShading !== !0 && (e = pu(e, "v_normalWorld")), e;
}, "vec3").once()().normalize().toVar("normalWorld"), Ri = /* @__PURE__ */ at((c) => {
  let e = c.context.setupNormal().context({ getUV: null });
  return c.material.flatShading !== !0 && (e = e.mul(l2)), e;
}, "vec3").once()().toVar("transformedNormalView"), lG = /* @__PURE__ */ Ri.transformDirection(Qd).toVar("transformedNormalWorld"), rE = /* @__PURE__ */ at((c) => {
  let e = c.context.setupClearcoatNormal().context({ getUV: null });
  return c.material.flatShading !== !0 && (e = e.mul(l2)), e;
}, "vec3").once()().toVar("transformedClearcoatNormalView"), HOe = /* @__PURE__ */ at(([c, e = Cg]) => {
  const t = bo(e), n = c.div(tt(t[0].dot(t[0]), t[1].dot(t[1]), t[2].dot(t[2])));
  return t.mul(n).xyz;
}), b0e = /* @__PURE__ */ at(([c], e) => {
  const t = e.renderer.overrideNodes.modelNormalViewMatrix;
  if (t !== null)
    return t.transformDirection(c);
  const n = jOe.mul(c);
  return Qd.transformDirection(n);
});
class $Oe extends Oi {
  static get type() {
    return "MatcapUVNode";
  }
  /**
   * Constructs a new matcap uv node.
   */
  constructor() {
    super("vec2");
  }
  setup() {
    const e = tt(ii.z, 0, ii.x.negate()).normalize(), t = ii.cross(e);
    return xt(e.dot(Ri), t.dot(Ri)).mul(0.495).add(0.5);
  }
}
const WOe = /* @__PURE__ */ bt($Oe);
class KOe extends DE {
  static get type() {
    return "MaxMipLevelNode";
  }
  /**
   * Constructs a new max mip level node.
   *
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   */
  constructor(e) {
    super(0), this._textureNode = e, this.updateType = In.FRAME;
  }
  /**
   * The texture node to compute the max mip level for.
   *
   * @readonly
   * @type {TextureNode}
   */
  get textureNode() {
    return this._textureNode;
  }
  /**
   * The texture.
   *
   * @readonly
   * @type {Texture}
   */
  get texture() {
    return this._textureNode.value;
  }
  update() {
    const e = this.texture, t = e.images, n = t && t.length > 0 ? t[0] && t[0].image || t[0] : e.image;
    if (n && n.width !== void 0) {
      const { width: i, height: o } = n;
      this.value = Math.log2(Math.max(i, o));
    }
  }
}
const YOe = /* @__PURE__ */ lt(KOe).setParameterLength(1), XOe = (c) => ct(c).mul(0.5).add(0.5);
class QOe extends Oi {
  static get type() {
    return "RotateNode";
  }
  /**
   * Constructs a new rotate node.
   *
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   */
  constructor(e, t) {
    super(), this.positionNode = e, this.rotationNode = t;
  }
  /**
   * The type of the {@link RotateNode#positionNode} defines the node's type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node's type.
   */
  getNodeType(e) {
    return this.positionNode.getNodeType(e);
  }
  setup(e) {
    const { rotationNode: t, positionNode: n } = this;
    if (this.getNodeType(e) === "vec2") {
      const o = t.cos(), l = t.sin();
      return $6(
        o,
        l,
        l.negate(),
        o
      ).mul(n);
    } else {
      const o = t, l = Db(gn(1, 0, 0, 0), gn(0, Gp(o.x), lu(o.x).negate(), 0), gn(0, lu(o.x), Gp(o.x), 0), gn(0, 0, 0, 1)), p = Db(gn(Gp(o.y), 0, lu(o.y), 0), gn(0, 1, 0, 0), gn(lu(o.y).negate(), 0, Gp(o.y), 0), gn(0, 0, 0, 1)), f = Db(gn(Gp(o.z), lu(o.z).negate(), 0, 0), gn(lu(o.z), Gp(o.z), 0, 0), gn(0, 0, 1, 0), gn(0, 0, 0, 1));
      return l.mul(p).mul(f).mul(gn(n, 1)).xyz;
    }
  }
}
const x0e = /* @__PURE__ */ lt(QOe).setParameterLength(2);
let Iw, Nw;
class Mi extends yn {
  static get type() {
    return "ScreenNode";
  }
  /**
   * Constructs a new screen node.
   *
   * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.
   */
  constructor(e) {
    super(), this.scope = e, this.isViewportNode = !0;
  }
  /**
   * This method is overwritten since the node type depends on the selected scope.
   *
   * @return {('vec2'|'vec4')} The node type.
   */
  getNodeType() {
    return this.scope === Mi.VIEWPORT ? "vec4" : "vec2";
  }
  /**
   * This method is overwritten since the node's update type depends on the selected scope.
   *
   * @return {NodeUpdateType} The update type.
   */
  getUpdateType() {
    let e = In.NONE;
    return (this.scope === Mi.SIZE || this.scope === Mi.VIEWPORT) && (e = In.RENDER), this.updateType = e, e;
  }
  /**
   * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
   * from the current renderer.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update({ renderer: e }) {
    const t = e.getRenderTarget();
    this.scope === Mi.VIEWPORT ? t !== null ? Nw.copy(t.viewport) : (e.getViewport(Nw), Nw.multiplyScalar(e.getPixelRatio())) : t !== null ? (Iw.width = t.width, Iw.height = t.height) : e.getDrawingBufferSize(Iw);
  }
  setup() {
    const e = this.scope;
    let t = null;
    return e === Mi.SIZE ? t = on(Iw || (Iw = new Pn())) : e === Mi.VIEWPORT ? t = on(Nw || (Nw = new Bn())) : t = xt(u2.div(c6)), t;
  }
  generate(e) {
    if (this.scope === Mi.COORDINATE) {
      let t = e.getFragCoord();
      if (e.isFlipY()) {
        const n = e.getNodeProperties(c6).outputNode.build(e);
        t = `${e.getType("vec2")}( ${t}.x, ${n}.y - ${t}.y )`;
      }
      return t;
    }
    return super.generate(e);
  }
}
Mi.COORDINATE = "coordinate";
Mi.VIEWPORT = "viewport";
Mi.SIZE = "size";
Mi.UV = "uv";
const Bb = /* @__PURE__ */ bt(Mi, Mi.UV), c6 = /* @__PURE__ */ bt(Mi, Mi.SIZE), u2 = /* @__PURE__ */ bt(Mi, Mi.COORDINATE), yE = /* @__PURE__ */ bt(Mi, Mi.VIEWPORT);
yE.zw;
yE.xy;
const BE = (c = 0) => tf("uv" + (c > 0 ? c : ""), "vec2");
class ZOe extends yn {
  static get type() {
    return "TextureSizeNode";
  }
  /**
   * Constructs a new texture size node.
   *
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {?Node<int>} [levelNode=null] - A level node which defines the requested mip.
   */
  constructor(e, t = null) {
    super("uvec2"), this.isTextureSizeNode = !0, this.textureNode = e, this.levelNode = t;
  }
  generate(e, t) {
    const n = this.textureNode.build(e, "property"), i = this.levelNode === null ? "0" : this.levelNode.build(e, "int");
    return e.format(`${e.getMethod("textureDimensions")}( ${n}, ${i} )`, this.getNodeType(e), t);
  }
}
const Lb = /* @__PURE__ */ lt(ZOe).setParameterLength(1, 2), _0e = /* @__PURE__ */ new Js();
class Qb extends DE {
  static get type() {
    return "TextureNode";
  }
  /**
   * Constructs a new texture node.
   *
   * @param {Texture} [value=EmptyTexture] - The texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(e = _0e, t = null, n = null, i = null) {
    super(e), this.isTextureNode = !0, this.uvNode = t, this.levelNode = n, this.biasNode = i, this.compareNode = null, this.depthNode = null, this.gradNode = null, this.sampler = !0, this.updateMatrix = !1, this.updateType = In.NONE, this.referenceNode = null, this._value = e, this._matrixUniform = null, this.setUpdateMatrix(t === null);
  }
  set value(e) {
    this.referenceNode ? this.referenceNode.value = e : this._value = e;
  }
  /**
   * The texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this.referenceNode ? this.referenceNode.value : this._value;
  }
  /**
   * Overwritten since the uniform hash is defined by the texture's UUID.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The uniform hash.
   */
  getUniformHash() {
    return this.value.uuid;
  }
  /**
   * Overwritten since the node type is inferred from the texture type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType() {
    return this.value.isDepthTexture === !0 ? "float" : this.value.type === xi ? "uvec4" : this.value.type === fo ? "ivec4" : "vec4";
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture";
  }
  /**
   * Returns a default uvs based on the current texture's channel.
   *
   * @return {AttributeNode<vec2>} The default uvs.
   */
  getDefaultUV() {
    return BE(this.value.channel);
  }
  /**
   * Overwritten to always return the texture reference of the node.
   *
   * @param {any} state - This method can be invocated in different contexts so `state` can refer to any object type.
   * @return {Texture} The texture reference.
   */
  updateReference() {
    return this.value;
  }
  /**
   * Transforms the given uv node with the texture transformation matrix.
   *
   * @param {Node} uvNode - The uv node to transform.
   * @return {Node} The transformed uv node.
   */
  getTransformedUV(e) {
    return this._matrixUniform === null && (this._matrixUniform = on(this.value.matrix)), this._matrixUniform.mul(tt(e, 1)).xy;
  }
  /**
   * Defines whether the uv transformation matrix should automatically be updated or not.
   *
   * @param {boolean} value - The update toggle.
   * @return {TextureNode} A reference to this node.
   */
  setUpdateMatrix(e) {
    return this.updateMatrix = e, this.updateType = e ? In.OBJECT : In.NONE, this;
  }
  /**
   * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(e, t) {
    const n = this.value;
    return e.isFlipY() && (n.image instanceof ImageBitmap && n.flipY === !0 || n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0 || n.isDepthTexture === !0) && (this.sampler ? t = t.flipY() : t = t.setY(Nr(Lb(this, this.levelNode).y).sub(t.y).sub(1))), t;
  }
  /**
   * Setups texture node by preparing the internal nodes for code generation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const t = e.getNodeProperties(this);
    t.referenceNode = this.referenceNode;
    const n = this.value;
    if (!n || n.isTexture !== !0)
      throw new Error("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().");
    let i = this.uvNode;
    (i === null || e.context.forceUVContext === !0) && e.context.getUV && (i = e.context.getUV(this, e)), i || (i = this.getDefaultUV()), this.updateMatrix === !0 && (i = this.getTransformedUV(i)), i = this.setupUV(e, i);
    let o = this.levelNode;
    o === null && e.context.getTextureLevel && (o = e.context.getTextureLevel(this)), t.uvNode = i, t.levelNode = o, t.biasNode = this.biasNode, t.compareNode = this.compareNode, t.gradNode = this.gradNode, t.depthNode = this.depthNode;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, this.sampler === !0 ? "vec2" : "ivec2");
  }
  /**
   * Generates the snippet for the texture sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} textureProperty - The texture property.
   * @param {string} uvSnippet - The uv snippet.
   * @param {?string} levelSnippet - The level snippet.
   * @param {?string} biasSnippet - The bias snippet.
   * @param {?string} depthSnippet - The depth snippet.
   * @param {?string} compareSnippet - The compare snippet.
   * @param {?Array<string>} gradSnippet - The grad snippet.
   * @return {string} The generated code snippet.
   */
  generateSnippet(e, t, n, i, o, l, p, f) {
    const v = this.value;
    let _;
    return i ? _ = e.generateTextureLevel(v, t, n, i, l) : o ? _ = e.generateTextureBias(v, t, n, o, l) : f ? _ = e.generateTextureGrad(v, t, n, f, l) : p ? _ = e.generateTextureCompare(v, t, n, p, l) : this.sampler === !1 ? _ = e.generateTextureLoad(v, t, n, l) : _ = e.generateTexture(v, t, n, l), _;
  }
  /**
   * Generates the code snippet of the texture node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(e, t) {
    const n = this.value, i = e.getNodeProperties(this), o = super.generate(e, "property");
    if (/^sampler/.test(t))
      return o + "_sampler";
    if (e.isReference(t))
      return o;
    {
      const l = e.getDataFromNode(this);
      let p = l.propertyName;
      if (p === void 0) {
        const { uvNode: _, levelNode: E, biasNode: A, compareNode: I, depthNode: j, gradNode: q } = i, L = this.generateUV(e, _), V = E ? E.build(e, "float") : null, re = A ? A.build(e, "float") : null, R = j ? j.build(e, "int") : null, J = I ? I.build(e, "float") : null, ge = q ? [q[0].build(e, "vec2"), q[1].build(e, "vec2")] : null, _e = e.getVarFromNode(this);
        p = e.getPropertyName(_e);
        const Y = this.generateSnippet(e, o, L, V, re, R, J, ge);
        e.addLineFlowCode(`${p} = ${Y}`, this), l.snippet = Y, l.propertyName = p;
      }
      let f = p;
      const v = this.getNodeType(e);
      return e.needsToWorkingColorSpace(n) && (f = nG($b(f, v), n.colorSpace).setup(e).build(e, v)), e.format(f, v, t);
    }
  }
  /**
   * Sets the sampler value.
   *
   * @param {boolean} value - The sampler value to set.
   * @return {TextureNode} A reference to this texture node.
   */
  setSampler(e) {
    return this.sampler = e, this;
  }
  /**
   * Returns the sampler value.
   *
   * @return {boolean} The sampler value.
   */
  getSampler() {
    return this.sampler;
  }
  // @TODO: Move to TSL
  /**
   * @function
   * @deprecated since r172. Use {@link TextureNode#sample} instead.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  uv(e) {
    return console.warn("THREE.TextureNode: .uv() has been renamed. Use .sample() instead."), this.sample(e);
  }
  /**
   * Samples the texture with the given uv node.
   *
   * @param {Node} uvNode - The uv node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  sample(e) {
    const t = this.clone();
    return t.uvNode = ct(e), t.referenceNode = this.getSelf(), ct(t);
  }
  /**
   * Samples a blurred version of the texture by defining an internal bias.
   *
   * @param {Node<float>} amountNode - How blurred the texture should be.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  blur(e) {
    const t = this.clone();
    t.biasNode = ct(e).mul(YOe(t)), t.referenceNode = this.getSelf();
    const n = t.value;
    return t.generateMipmaps === !1 && (n && n.generateMipmaps === !1 || n.minFilter === $i || n.magFilter === $i) && (console.warn("THREE.TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."), t.biasNode = null), ct(t);
  }
  /**
   * Samples a specific mip of the texture.
   *
   * @param {Node<int>} levelNode - The mip level to sample.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  level(e) {
    const t = this.clone();
    return t.levelNode = ct(e), t.referenceNode = this.getSelf(), ct(t);
  }
  /**
   * Returns the texture size of the requested level.
   *
   * @param {Node<int>} levelNode - The level to compute the size for.
   * @return {TextureSizeNode} The texture size.
   */
  size(e) {
    return Lb(this, e);
  }
  /**
   * Samples the texture with the given bias.
   *
   * @param {Node<float>} biasNode - The bias node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  bias(e) {
    const t = this.clone();
    return t.biasNode = ct(e), t.referenceNode = this.getSelf(), ct(t);
  }
  /**
   * Samples the texture by executing a compare operation.
   *
   * @param {Node<float>} compareNode - The node that defines the compare value.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  compare(e) {
    const t = this.clone();
    return t.compareNode = ct(e), t.referenceNode = this.getSelf(), ct(t);
  }
  /**
   * Samples the texture using an explicit gradient.
   *
   * @param {Node<vec2>} gradNodeX - The gradX node.
   * @param {Node<vec2>} gradNodeY - The gradY node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  grad(e, t) {
    const n = this.clone();
    return n.gradNode = [ct(e), ct(t)], n.referenceNode = this.getSelf(), ct(n);
  }
  /**
   * Samples the texture by defining a depth node.
   *
   * @param {Node<int>} depthNode - The depth node.
   * @return {TextureNode} A texture node representing the texture sample.
   */
  depth(e) {
    const t = this.clone();
    return t.depthNode = ct(e), t.referenceNode = this.getSelf(), ct(t);
  }
  // --
  serialize(e) {
    super.serialize(e), e.value = this.value.toJSON(e.meta).uuid, e.sampler = this.sampler, e.updateMatrix = this.updateMatrix, e.updateType = this.updateType;
  }
  deserialize(e) {
    super.deserialize(e), this.value = e.meta.textures[e.value], this.sampler = e.sampler, this.updateMatrix = e.updateMatrix, this.updateType = e.updateType;
  }
  /**
   * The update is used to implement the update of the uv transformation matrix.
   */
  update() {
    const e = this.value, t = this._matrixUniform;
    t !== null && (t.value = e.matrix), e.matrixAutoUpdate === !0 && e.updateMatrix();
  }
  /**
   * Clones the texture node.
   *
   * @return {TextureNode} The cloned texture node.
   */
  clone() {
    const e = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
    return e.sampler = this.sampler, e.depthNode = this.depthNode, e.compareNode = this.compareNode, e.gradNode = this.gradNode, e;
  }
}
const JOe = /* @__PURE__ */ lt(Qb).setParameterLength(1, 4).setName("texture"), Wn = (c = _0e, e = null, t = null, n = null) => {
  let i;
  return c && c.isTextureNode === !0 ? (i = ct(c.clone()), i.referenceNode = c.getSelf(), e !== null && (i.uvNode = ct(e)), t !== null && (i.levelNode = ct(t)), n !== null && (i.biasNode = ct(n))) : i = JOe(c, e, t, n), i;
}, ou = (...c) => Wn(...c).setSampler(!1);
class e2e extends Js {
  /**
   * Constructs a new framebuffer texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   */
  constructor(e, t) {
    super({ width: e, height: t }), this.isFramebufferTexture = !0, this.magFilter = $i, this.minFilter = $i, this.generateMipmaps = !1, this.needsUpdate = !0;
  }
}
const Ow = /* @__PURE__ */ new Pn();
class S0e extends Qb {
  static get type() {
    return "ViewportTextureNode";
  }
  /**
   * Constructs a new viewport texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   * @param {?Texture} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   */
  constructor(e = Bb, t = null, n = null) {
    n === null && (n = new e2e(), n.minFilter = Ud), super(n, e, t), this.generateMipmaps = !1, this.isOutputTextureNode = !0, this.updateBeforeType = In.FRAME;
  }
  updateBefore(e) {
    const t = e.renderer;
    t.getDrawingBufferSize(Ow);
    const n = this.value;
    (n.image.width !== Ow.width || n.image.height !== Ow.height) && (n.image.width = Ow.width, n.image.height = Ow.height, n.needsUpdate = !0);
    const i = n.generateMipmaps;
    n.generateMipmaps = this.generateMipmaps, t.copyFramebufferToTexture(n), n.generateMipmaps = i;
  }
  clone() {
    const e = new this.constructor(this.uvNode, this.levelNode, this.value);
    return e.generateMipmaps = this.generateMipmaps, e;
  }
}
const w0e = /* @__PURE__ */ lt(S0e, null, null, { generateMipmaps: !0 }).setParameterLength(0, 3);
let w5 = null;
class t2e extends S0e {
  static get type() {
    return "ViewportDepthTextureNode";
  }
  /**
   * Constructs a new viewport depth texture node.
   *
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {?Node} [levelNode=null] - The level node.
   */
  constructor(e = Bb, t = null) {
    w5 === null && (w5 = new _c()), super(e, t, w5);
  }
}
const n2e = /* @__PURE__ */ lt(t2e).setParameterLength(0, 2);
class $o extends yn {
  static get type() {
    return "ViewportDepthNode";
  }
  /**
   * Constructs a new viewport depth node.
   *
   * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
   * @param {?Node} [valueNode=null] - The value node.
   */
  constructor(e, t = null) {
    super("float"), this.scope = e, this.valueNode = t, this.isViewportDepthNode = !0;
  }
  generate(e) {
    const { scope: t } = this;
    return t === $o.DEPTH_BASE ? e.getFragDepth() : super.generate(e);
  }
  setup({ camera: e }) {
    const { scope: t } = this, n = this.valueNode;
    let i = null;
    if (t === $o.DEPTH_BASE)
      n !== null && (i = C0e().assign(n));
    else if (t === $o.DEPTH)
      e.isPerspectiveCamera ? i = r2e(Ii.z, yg, vg) : i = vE(Ii.z, yg, vg);
    else if (t === $o.LINEAR_DEPTH)
      if (n !== null)
        if (e.isPerspectiveCamera) {
          const o = E0e(n, yg, vg);
          i = vE(o, yg, vg);
        } else
          i = n;
      else
        i = vE(Ii.z, yg, vg);
    return i;
  }
}
$o.DEPTH_BASE = "depthBase";
$o.DEPTH = "depth";
$o.LINEAR_DEPTH = "linearDepth";
const vE = (c, e, t) => c.add(e).div(e.sub(t)), r2e = (c, e, t) => e.add(c).mul(t).div(t.sub(e).mul(c)), E0e = (c, e, t) => e.mul(t).div(t.sub(e).mul(c).sub(t)), T0e = (c, e, t) => {
  e = e.max(1e-6).toVar();
  const n = Gd(c.negate().div(e)), i = Gd(t.div(e));
  return n.div(i);
}, C0e = /* @__PURE__ */ lt($o, $o.DEPTH_BASE), P0e = /* @__PURE__ */ bt($o, $o.DEPTH), i2e = /* @__PURE__ */ lt($o, $o.LINEAR_DEPTH).setParameterLength(0, 1);
n2e();
P0e.assign = (c) => C0e(c);
const E5 = /* @__PURE__ */ new Ue(), s2e = /* @__PURE__ */ new Ue(), o2e = /* @__PURE__ */ new Xo();
class qp {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(e = new Ue(1, 0, 0), t = 0) {
    this.isPlane = !0, this.normal = e, this.constant = t;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(e, t) {
    return this.normal.copy(e), this.constant = t, this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), this.constant = i, this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), this.constant = -t.dot(this.normal), this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(e, t, n) {
    const i = E5.subVectors(n, t).cross(s2e.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(e) {
    return this.normal.copy(e.normal), this.constant = e.constant, this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), this.constant *= e, this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    return this.constant *= -1, this.normal.negate(), this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(e, t) {
    const n = e.delta(E5), i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const o = -(e.start.dot(this.normal) + this.constant) / i;
    return o < 0 || o > 1 ? null : t.copy(e.start).addScaledVector(n, o);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start), n = this.distanceToPoint(e.end);
    return t < 0 && n > 0 || n < 0 && t > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(e, t) {
    const n = t || o2e.getNormalMatrix(e), i = this.coplanarPoint(E5).applyMatrix4(e), o = this.normal.applyMatrix3(n).normalize();
    return this.constant = -i.dot(o), this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(e) {
    return this.constant -= e.dot(this.normal), this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
class Mg extends kg {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(), n = Object.assign({
      generateMipmaps: !1,
      internalFormat: null,
      minFilter: Ea,
      depthBuffer: !0,
      stencilBuffer: !1,
      resolveDepthBuffer: !0,
      resolveStencilBuffer: !0,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: !1
    }, n), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = n.depth, this.scissor = new Bn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Bn(0, 0, e, t);
    const i = { width: e, height: t, depth: n.depth }, o = new Js(i);
    this.textures = [];
    const l = n.count;
    for (let p = 0; p < l; p++)
      this.textures[p] = o.clone(), this.textures[p].isRenderTargetTexture = !0, this.textures[p].renderTarget = this;
    this._setTextureOptions(n), this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this._depthTexture = null, this.depthTexture = n.depthTexture, this.samples = n.samples, this.multiview = n.multiview;
  }
  _setTextureOptions(e = {}) {
    const t = {
      minFilter: Ea,
      generateMipmaps: !1,
      flipY: !1,
      internalFormat: null
    };
    e.mapping !== void 0 && (t.mapping = e.mapping), e.wrapS !== void 0 && (t.wrapS = e.wrapS), e.wrapT !== void 0 && (t.wrapT = e.wrapT), e.wrapR !== void 0 && (t.wrapR = e.wrapR), e.magFilter !== void 0 && (t.magFilter = e.magFilter), e.minFilter !== void 0 && (t.minFilter = e.minFilter), e.format !== void 0 && (t.format = e.format), e.type !== void 0 && (t.type = e.type), e.anisotropy !== void 0 && (t.anisotropy = e.anisotropy), e.colorSpace !== void 0 && (t.colorSpace = e.colorSpace), e.flipY !== void 0 && (t.flipY = e.flipY), e.generateMipmaps !== void 0 && (t.generateMipmaps = e.generateMipmaps), e.internalFormat !== void 0 && (t.internalFormat = e.internalFormat);
    for (let n = 0; n < this.textures.length; n++)
      this.textures[n].setValues(t);
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(e) {
    this.textures[0] = e;
  }
  set depthTexture(e) {
    this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(e, t, n = 1) {
    if (this.width !== e || this.height !== t || this.depth !== n) {
      this.width = e, this.height = t, this.depth = n;
      for (let i = 0, o = this.textures.length; i < o; i++)
        this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n, this.textures[i].isArrayTexture = this.textures[i].image.depth > 1;
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(e) {
    this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
    for (let t = 0, n = e.textures.length; t < n; t++) {
      this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
      const i = Object.assign({}, e.textures[t].image);
      this.textures[t].source = new j6(i);
    }
    return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
new qp();
new Ue();
new Ue();
new Ue();
new Pr();
new Ue(0, 0, -1);
new Bn();
new Ue();
new Ue();
new Bn();
new Pn();
const a2e = new Mg();
Bb.flipX();
a2e.depthTexture = new _c(1, 1);
let l2e = 0;
class Yo extends kg {
  /**
   * Constructs a new material.
   */
  constructor() {
    super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: l2e++ }), this.uuid = Bd(), this.name = "", this.type = "Material", this.blending = jd, this.side = Ld, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = kO, this.blendDst = MO, this.blendEquation = uu, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new er(0, 0, 0), this.blendAlpha = 0, this.depthFunc = RO, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = r6, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = pg, this.stencilZFail = pg, this.stencilZPass = pg, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL]{@link https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language}.
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
          continue;
        }
        i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n;
      }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {}
    });
    const n = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== jd && (n.blending = this.blending), this.side !== Ld && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== kO && (n.blendSrc = this.blendSrc), this.blendDst !== MO && (n.blendDst = this.blendDst), this.blendEquation !== uu && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== RO && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== r6 && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== pg && (n.stencilFail = this.stencilFail), this.stencilZFail !== pg && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== pg && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(o) {
      const l = [];
      for (const p in o) {
        const f = o[p];
        delete f.metadata, l.push(f);
      }
      return l;
    }
    if (t) {
      const o = i(e.textures), l = i(e.images);
      o.length > 0 && (n.textures = o), l.length > 0 && (n.images = l);
    }
    return n;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(e) {
    this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let o = 0; o !== i; ++o)
        n[o] = t[o].clone();
    }
    return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const Ofe = /* @__PURE__ */ new hl(), T5 = /* @__PURE__ */ new Pr(), u2e = /* @__PURE__ */ on(0).onReference(({ material: c }) => c).onObjectUpdate(({ material: c }) => c.refractionRatio), C5 = /* @__PURE__ */ on(1).onReference(({ material: c }) => c).onObjectUpdate(function({ material: c, scene: e }) {
  return c.envMap ? c.envMapIntensity : e.environmentIntensity;
}), A0e = /* @__PURE__ */ on(new Pr()).onReference(function(c) {
  return c.material;
}).onObjectUpdate(function({ material: c, scene: e }) {
  const t = e.environment !== null && c.envMap === null ? e.environmentRotation : c.envMapRotation;
  return t ? (Ofe.copy(t), T5.makeRotationFromEuler(Ofe)) : T5.identity(), T5;
}), c2e = /* @__PURE__ */ ii.negate().reflect(Ri), d2e = /* @__PURE__ */ ii.negate().refract(Ri, u2e), h2e = /* @__PURE__ */ c2e.transformDirection(Qd).toVar("reflectVector"), p2e = /* @__PURE__ */ d2e.transformDirection(Qd).toVar("reflectVector");
class c2 extends Js {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(e = [], t = wE, n, i, o, l, p, f, v, _) {
    super(e, t, n, i, o, l, p, f, v, _), this.isCubeTexture = !0, this.flipY = !1;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
const f2e = /* @__PURE__ */ new c2();
class m2e extends Qb {
  static get type() {
    return "CubeTextureNode";
  }
  /**
   * Constructs a new cube texture node.
   *
   * @param {CubeTexture} value - The cube texture.
   * @param {?Node<vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   * @param {?Node<float>} [biasNode=null] - The bias node.
   */
  constructor(e, t = null, n = null, i = null) {
    super(e, t, n, i), this.isCubeTextureNode = !0;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'cubeTexture'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "cubeTexture";
  }
  /**
   * Returns a default uvs based on the mapping type of the cube texture.
   *
   * @return {Node<vec3>} The default uv attribute.
   */
  getDefaultUV() {
    const e = this.value;
    return e.mapping === wE ? h2e : e.mapping === IO ? p2e : (console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', e.mapping), tt(0, 0, 0));
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for cube textures. The uv transformation matrix is not applied to cube textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for CubeTextureNode
  /**
   * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
   * to modify the uv node for correct sampling.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The updated uv node.
   */
  setupUV(e, t) {
    const n = this.value;
    return (e.renderer.coordinateSystem === Jp || !n.isRenderTargetTexture) && (t = tt(t.x.negate(), t.yz)), A0e.mul(t);
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} cubeUV - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, "vec3");
  }
}
const g2e = /* @__PURE__ */ lt(m2e).setParameterLength(1, 4).setName("cubeTexture"), kE = (c = f2e, e = null, t = null, n = null) => {
  let i;
  return c && c.isCubeTextureNode === !0 ? (i = ct(c.clone()), i.referenceNode = c.getSelf(), e !== null && (i.uvNode = ct(e)), t !== null && (i.levelNode = ct(t)), n !== null && (i.biasNode = ct(n))) : i = g2e(c, e, t, n), i;
};
class y2e extends OE {
  static get type() {
    return "ReferenceElementNode";
  }
  /**
   * Constructs a new reference element node.
   *
   * @param {?ReferenceNode} referenceNode - The reference node.
   * @param {Node} indexNode - The index node that defines the element access.
   */
  constructor(e, t) {
    super(e, t), this.referenceNode = e, this.isReferenceElementNode = !0;
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the uniform type of the reference node.
   *
   * @return {string} The node type.
   */
  getNodeType() {
    return this.referenceNode.uniformType;
  }
  generate(e) {
    const t = super.generate(e), n = this.referenceNode.getNodeType(), i = this.getNodeType();
    return e.format(t, n, i);
  }
}
class uG extends yn {
  static get type() {
    return "ReferenceNode";
  }
  /**
   * Constructs a new reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} uniformType - The uniform type that should be used to represent the property value.
   * @param {?Object} [object=null] - The object the property belongs to.
   * @param {?number} [count=null] - When the linked property is an array-like, this parameter defines its length.
   */
  constructor(e, t, n = null, i = null) {
    super(), this.property = e, this.uniformType = t, this.object = n, this.count = i, this.properties = e.split("."), this.reference = n, this.node = null, this.group = null, this.name = null, this.updateType = In.OBJECT;
  }
  /**
   * When the referred property is array-like, this method can be used
   * to access elements via an index node.
   *
   * @param {IndexNode} indexNode - indexNode.
   * @return {ReferenceElementNode} A reference to an element.
   */
  element(e) {
    return ct(new y2e(this, ct(e)));
  }
  /**
   * Sets the uniform group for this reference node.
   *
   * @param {UniformGroupNode} group - The uniform group to set.
   * @return {ReferenceNode} A reference to this node.
   */
  setGroup(e) {
    return this.group = e, this;
  }
  /**
   * Sets the label for the internal uniform.
   *
   * @param {string} name - The label to set.
   * @return {ReferenceNode} A reference to this node.
   */
  label(e) {
    return this.name = e, this;
  }
  /**
   * Sets the node type which automatically defines the internal
   * uniform type.
   *
   * @param {string} uniformType - The type to set.
   */
  setNodeType(e) {
    let t = null;
    this.count !== null ? t = f0e(null, e, this.count) : Array.isArray(this.getValueFromReference()) ? t = vc(null, e) : e === "texture" ? t = Wn(null) : e === "cubeTexture" ? t = kE(null) : t = on(null, e), this.group !== null && t.setGroup(this.group), this.name !== null && t.label(this.name), this.node = t.getSelf();
  }
  /**
   * This method is overwritten since the node type is inferred from
   * the type of the reference node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.node === null && (this.updateReference(e), this.updateValue()), this.node.getNodeType(e);
  }
  /**
   * Returns the property value from the given referred object.
   *
   * @param {Object} [object=this.reference] - The object to retrieve the property value from.
   * @return {any} The value.
   */
  getValueFromReference(e = this.reference) {
    const { properties: t } = this;
    let n = e[t[0]];
    for (let i = 1; i < t.length; i++)
      n = n[t[i]];
    return n;
  }
  /**
   * Allows to update the reference based on the given state. The state is only
   * evaluated {@link ReferenceNode#object} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.object !== null ? this.object : e.object, this.reference;
  }
  /**
   * The output of the reference node is the internal uniform node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {UniformNode} The output node.
   */
  setup() {
    return this.updateValue(), this.node;
  }
  /**
   * Overwritten to update the internal uniform value.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    this.updateValue();
  }
  /**
   * Retrieves the value from the referred object property and uses it
   * to updated the internal uniform.
   */
  updateValue() {
    this.node === null && this.setNodeType(this.uniformType);
    const e = this.getValueFromReference();
    Array.isArray(e) ? this.node.array = e : this.node.value = e;
  }
}
const Cr = (c, e, t) => ct(new uG(c, e, t)), Dfe = (c, e, t, n) => ct(new uG(c, e, n, t));
class v2e extends uG {
  static get type() {
    return "MaterialReferenceNode";
  }
  /**
   * Constructs a new material reference node.
   *
   * @param {string} property - The name of the property the node refers to.
   * @param {string} inputType - The uniform type that should be used to represent the property value.
   * @param {?Material} [material=null] - The material the property belongs to. When no material is set,
   * the node refers to the material of the current rendered object.
   */
  constructor(e, t, n = null) {
    super(e, t, n), this.material = n, this.isMaterialReferenceNode = !0;
  }
  /**
   * Updates the reference based on the given state. The state is only evaluated
   * {@link MaterialReferenceNode#material} is not set.
   *
   * @param {(NodeFrame|NodeBuilder)} state - The current state.
   * @return {Object} The updated reference.
   */
  updateReference(e) {
    return this.reference = this.material !== null ? this.material : e.material, this.reference;
  }
}
const $p = (c, e, t = null) => ct(new v2e(c, e, t)), k0e = /* @__PURE__ */ at((c) => (c.geometry.hasAttribute("tangent") === !1 && c.geometry.computeTangents(), tf("tangent", "vec4")))(), cG = /* @__PURE__ */ k0e.xyz.toVar("tangentLocal"), M0e = /* @__PURE__ */ o2.mul(gn(cG, 0)).xyz.toVarying("v_tangentView").normalize().toVar("tangentView"), b2e = /* @__PURE__ */ at(([c, e], t) => {
  let n = c.mul(k0e.w).xyz;
  return t.material.flatShading !== !0 && (n = pu(n, e)), n;
}).once(), x2e = b2e(Ec.cross(M0e), "v_bitangentView").normalize().toVar("bitangentView"), iE = /* @__PURE__ */ bo(M0e, x2e, Ec), _2e = /* @__PURE__ */ (() => {
  let c = Fb.cross(ii);
  return c = c.cross(Fb).normalize(), c = Vr(c, Ri, fg.mul(Dd.oneMinus()).oneMinus().pow2().pow2()).normalize(), c;
})(), S2e = /* @__PURE__ */ at((c) => {
  const { eye_pos: e, surf_norm: t, mapN: n, uv: i } = c, o = e.dFdx(), l = e.dFdy(), p = i.dFdx(), f = i.dFdy(), v = t, _ = l.cross(v), E = v.cross(o), A = _.mul(p.x).add(E.mul(f.x)), I = _.mul(p.y).add(E.mul(f.y)), j = A.dot(A).max(I.dot(I)), q = l2.mul(j.inverseSqrt());
  return xo(A.mul(n.x, q), I.mul(n.y, q), v.mul(n.z)).normalize();
});
class w2e extends Oi {
  static get type() {
    return "NormalMapNode";
  }
  /**
   * Constructs a new normal map node.
   *
   * @param {Node<vec3>} node - Represents the normal map data.
   * @param {?Node<vec2>} [scaleNode=null] - Controls the intensity of the effect.
   */
  constructor(e, t = null) {
    super("vec3"), this.node = e, this.scaleNode = t, this.normalMapType = Zp;
  }
  setup(e) {
    const { normalMapType: t, scaleNode: n } = this;
    let i = this.node.mul(2).sub(1);
    n !== null && (i = tt(i.xy.mul(n), i.z));
    let o = null;
    return t === oRe ? o = b0e(i) : t === Zp && (e.hasGeometryAttribute("tangent") === !0 ? o = iE.mul(i).normalize() : o = S2e({
      eye_pos: Ii,
      surf_norm: Ec,
      mapN: i,
      uv: BE()
    })), o;
  }
}
const Ffe = /* @__PURE__ */ lt(w2e).setParameterLength(1, 2), E2e = at(({ textureNode: c, bumpScale: e }) => {
  const t = (i) => c.cache().context({ getUV: (o) => i(o.uvNode || BE()), forceUVContext: !0 }), n = et(t((i) => i));
  return xt(
    et(t((i) => i.add(i.dFdx()))).sub(n),
    et(t((i) => i.add(i.dFdy()))).sub(n)
  ).mul(e);
}), T2e = at((c) => {
  const { surf_pos: e, surf_norm: t, dHdxy: n } = c, i = e.dFdx().normalize(), o = e.dFdy().normalize(), l = t, p = o.cross(l), f = l.cross(i), v = i.dot(p).mul(l2), _ = v.sign().mul(n.x.mul(p).add(n.y.mul(f)));
  return v.abs().mul(t).sub(_).normalize();
});
class C2e extends Oi {
  static get type() {
    return "BumpMapNode";
  }
  /**
   * Constructs a new bump map node.
   *
   * @param {Node<float>} textureNode - Represents the bump map data.
   * @param {?Node<float>} [scaleNode=null] - Controls the intensity of the bump effect.
   */
  constructor(e, t = null) {
    super("vec3"), this.textureNode = e, this.scaleNode = t;
  }
  setup() {
    const e = this.scaleNode !== null ? this.scaleNode : 1, t = E2e({ textureNode: this.textureNode, bumpScale: e });
    return T2e({
      surf_pos: Ii,
      surf_norm: Ec,
      dHdxy: t
    });
  }
}
const P2e = /* @__PURE__ */ lt(C2e).setParameterLength(1, 2), Bfe = /* @__PURE__ */ new Map();
class Qe extends yn {
  static get type() {
    return "MaterialNode";
  }
  /**
   * Constructs a new material node.
   *
   * @param {string} scope - The scope defines what kind of material property is referred by the node.
   */
  constructor(e) {
    super(), this.scope = e;
  }
  /**
   * Returns a cached reference node for the given property and type.
   *
   * @param {string} property - The name of the material property.
   * @param {string} type - The uniform type of the property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getCache(e, t) {
    let n = Bfe.get(e);
    return n === void 0 && (n = $p(e, t), Bfe.set(e, n)), n;
  }
  /**
   * Returns a float-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
   */
  getFloat(e) {
    return this.getCache(e, "float");
  }
  /**
   * Returns a color-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
   */
  getColor(e) {
    return this.getCache(e, "color");
  }
  /**
   * Returns a texture-typed material reference node for the given property name.
   *
   * @param {string} property - The name of the material property.
   * @return {MaterialReferenceNode} A material reference node representing the property access.
   */
  getTexture(e) {
    return this.getCache(e === "map" ? "map" : e + "Map", "texture");
  }
  /**
   * The node setup is done depending on the selected scope. Multiple material properties
   * might be grouped into a single node composition if they logically belong together.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The node representing the selected scope.
   */
  setup(e) {
    const t = e.context.material, n = this.scope;
    let i = null;
    if (n === Qe.COLOR) {
      const o = t.color !== void 0 ? this.getColor(n) : tt();
      t.map && t.map.isTexture === !0 ? i = o.mul(this.getTexture("map")) : i = o;
    } else if (n === Qe.OPACITY) {
      const o = this.getFloat(n);
      t.alphaMap && t.alphaMap.isTexture === !0 ? i = o.mul(this.getTexture("alpha")) : i = o;
    } else if (n === Qe.SPECULAR_STRENGTH)
      t.specularMap && t.specularMap.isTexture === !0 ? i = this.getTexture("specular").r : i = et(1);
    else if (n === Qe.SPECULAR_INTENSITY) {
      const o = this.getFloat(n);
      t.specularIntensityMap && t.specularIntensityMap.isTexture === !0 ? i = o.mul(this.getTexture(n).a) : i = o;
    } else if (n === Qe.SPECULAR_COLOR) {
      const o = this.getColor(n);
      t.specularColorMap && t.specularColorMap.isTexture === !0 ? i = o.mul(this.getTexture(n).rgb) : i = o;
    } else if (n === Qe.ROUGHNESS) {
      const o = this.getFloat(n);
      t.roughnessMap && t.roughnessMap.isTexture === !0 ? i = o.mul(this.getTexture(n).g) : i = o;
    } else if (n === Qe.METALNESS) {
      const o = this.getFloat(n);
      t.metalnessMap && t.metalnessMap.isTexture === !0 ? i = o.mul(this.getTexture(n).b) : i = o;
    } else if (n === Qe.EMISSIVE) {
      const o = this.getFloat("emissiveIntensity"), l = this.getColor(n).mul(o);
      t.emissiveMap && t.emissiveMap.isTexture === !0 ? i = l.mul(this.getTexture(n)) : i = l;
    } else if (n === Qe.NORMAL)
      t.normalMap ? (i = Ffe(this.getTexture("normal"), this.getCache("normalScale", "vec2")), i.normalMapType = t.normalMapType) : t.bumpMap ? i = P2e(this.getTexture("bump").r, this.getFloat("bumpScale")) : i = Ec;
    else if (n === Qe.CLEARCOAT) {
      const o = this.getFloat(n);
      t.clearcoatMap && t.clearcoatMap.isTexture === !0 ? i = o.mul(this.getTexture(n).r) : i = o;
    } else if (n === Qe.CLEARCOAT_ROUGHNESS) {
      const o = this.getFloat(n);
      t.clearcoatRoughnessMap && t.clearcoatRoughnessMap.isTexture === !0 ? i = o.mul(this.getTexture(n).r) : i = o;
    } else if (n === Qe.CLEARCOAT_NORMAL)
      t.clearcoatNormalMap ? i = Ffe(this.getTexture(n), this.getCache(n + "Scale", "vec2")) : i = Ec;
    else if (n === Qe.SHEEN) {
      const o = this.getColor("sheenColor").mul(this.getFloat("sheen"));
      t.sheenColorMap && t.sheenColorMap.isTexture === !0 ? i = o.mul(this.getTexture("sheenColor").rgb) : i = o;
    } else if (n === Qe.SHEEN_ROUGHNESS) {
      const o = this.getFloat(n);
      t.sheenRoughnessMap && t.sheenRoughnessMap.isTexture === !0 ? i = o.mul(this.getTexture(n).a) : i = o, i = i.clamp(0.07, 1);
    } else if (n === Qe.ANISOTROPY)
      if (t.anisotropyMap && t.anisotropyMap.isTexture === !0) {
        const o = this.getTexture(n);
        i = $6(Dw.x, Dw.y, Dw.y.negate(), Dw.x).mul(o.rg.mul(2).sub(xt(1)).normalize().mul(o.b));
      } else
        i = Dw;
    else if (n === Qe.IRIDESCENCE_THICKNESS) {
      const o = Cr("1", "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const l = Cr("0", "float", t.iridescenceThicknessRange);
        i = o.sub(l).mul(this.getTexture(n).g).add(l);
      } else
        i = o;
    } else if (n === Qe.TRANSMISSION) {
      const o = this.getFloat(n);
      t.transmissionMap ? i = o.mul(this.getTexture(n).r) : i = o;
    } else if (n === Qe.THICKNESS) {
      const o = this.getFloat(n);
      t.thicknessMap ? i = o.mul(this.getTexture(n).g) : i = o;
    } else if (n === Qe.IOR)
      i = this.getFloat(n);
    else if (n === Qe.LIGHT_MAP)
      i = this.getTexture(n).rgb.mul(this.getFloat("lightMapIntensity"));
    else if (n === Qe.AO)
      i = this.getTexture(n).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);
    else if (n === Qe.LINE_DASH_OFFSET)
      i = t.dashOffset ? this.getFloat(n) : et(0);
    else {
      const o = this.getNodeType(e);
      i = this.getCache(n, o);
    }
    return i;
  }
}
Qe.ALPHA_TEST = "alphaTest";
Qe.COLOR = "color";
Qe.OPACITY = "opacity";
Qe.SHININESS = "shininess";
Qe.SPECULAR = "specular";
Qe.SPECULAR_STRENGTH = "specularStrength";
Qe.SPECULAR_INTENSITY = "specularIntensity";
Qe.SPECULAR_COLOR = "specularColor";
Qe.REFLECTIVITY = "reflectivity";
Qe.ROUGHNESS = "roughness";
Qe.METALNESS = "metalness";
Qe.NORMAL = "normal";
Qe.CLEARCOAT = "clearcoat";
Qe.CLEARCOAT_ROUGHNESS = "clearcoatRoughness";
Qe.CLEARCOAT_NORMAL = "clearcoatNormal";
Qe.EMISSIVE = "emissive";
Qe.ROTATION = "rotation";
Qe.SHEEN = "sheen";
Qe.SHEEN_ROUGHNESS = "sheenRoughness";
Qe.ANISOTROPY = "anisotropy";
Qe.IRIDESCENCE = "iridescence";
Qe.IRIDESCENCE_IOR = "iridescenceIOR";
Qe.IRIDESCENCE_THICKNESS = "iridescenceThickness";
Qe.IOR = "ior";
Qe.TRANSMISSION = "transmission";
Qe.THICKNESS = "thickness";
Qe.ATTENUATION_DISTANCE = "attenuationDistance";
Qe.ATTENUATION_COLOR = "attenuationColor";
Qe.LINE_SCALE = "scale";
Qe.LINE_DASH_SIZE = "dashSize";
Qe.LINE_GAP_SIZE = "gapSize";
Qe.LINE_WIDTH = "linewidth";
Qe.LINE_DASH_OFFSET = "dashOffset";
Qe.POINT_SIZE = "size";
Qe.DISPERSION = "dispersion";
Qe.LIGHT_MAP = "light";
Qe.AO = "ao";
const A2e = /* @__PURE__ */ bt(Qe, Qe.ALPHA_TEST), k2e = /* @__PURE__ */ bt(Qe, Qe.COLOR), M2e = /* @__PURE__ */ bt(Qe, Qe.SHININESS), R2e = /* @__PURE__ */ bt(Qe, Qe.EMISSIVE), R0e = /* @__PURE__ */ bt(Qe, Qe.OPACITY), I2e = /* @__PURE__ */ bt(Qe, Qe.SPECULAR), Lfe = /* @__PURE__ */ bt(Qe, Qe.SPECULAR_INTENSITY), N2e = /* @__PURE__ */ bt(Qe, Qe.SPECULAR_COLOR), xO = /* @__PURE__ */ bt(Qe, Qe.SPECULAR_STRENGTH), P5 = /* @__PURE__ */ bt(Qe, Qe.REFLECTIVITY), O2e = /* @__PURE__ */ bt(Qe, Qe.ROUGHNESS), D2e = /* @__PURE__ */ bt(Qe, Qe.METALNESS), F2e = /* @__PURE__ */ bt(Qe, Qe.NORMAL), B2e = /* @__PURE__ */ bt(Qe, Qe.CLEARCOAT), L2e = /* @__PURE__ */ bt(Qe, Qe.CLEARCOAT_ROUGHNESS), j2e = /* @__PURE__ */ bt(Qe, Qe.CLEARCOAT_NORMAL), U2e = /* @__PURE__ */ bt(Qe, Qe.ROTATION), z2e = /* @__PURE__ */ bt(Qe, Qe.SHEEN), V2e = /* @__PURE__ */ bt(Qe, Qe.SHEEN_ROUGHNESS), G2e = /* @__PURE__ */ bt(Qe, Qe.ANISOTROPY), q2e = /* @__PURE__ */ bt(Qe, Qe.IRIDESCENCE), H2e = /* @__PURE__ */ bt(Qe, Qe.IRIDESCENCE_IOR), $2e = /* @__PURE__ */ bt(Qe, Qe.IRIDESCENCE_THICKNESS), W2e = /* @__PURE__ */ bt(Qe, Qe.TRANSMISSION), K2e = /* @__PURE__ */ bt(Qe, Qe.THICKNESS), Y2e = /* @__PURE__ */ bt(Qe, Qe.IOR), X2e = /* @__PURE__ */ bt(Qe, Qe.ATTENUATION_DISTANCE), Q2e = /* @__PURE__ */ bt(Qe, Qe.ATTENUATION_COLOR), Z2e = /* @__PURE__ */ bt(Qe, Qe.LINE_SCALE), J2e = /* @__PURE__ */ bt(Qe, Qe.LINE_DASH_SIZE), eDe = /* @__PURE__ */ bt(Qe, Qe.LINE_GAP_SIZE);
Qe.LINE_WIDTH;
const tDe = /* @__PURE__ */ bt(Qe, Qe.LINE_DASH_OFFSET), nDe = /* @__PURE__ */ bt(Qe, Qe.POINT_SIZE), rDe = /* @__PURE__ */ bt(Qe, Qe.DISPERSION), I0e = /* @__PURE__ */ bt(Qe, Qe.LIGHT_MAP), iDe = /* @__PURE__ */ bt(Qe, Qe.AO), Dw = /* @__PURE__ */ on(new Pn()).onReference(function(c) {
  return c.material;
}).onRenderUpdate(function({ material: c }) {
  this.value.set(c.anisotropy * Math.cos(c.anisotropyRotation), c.anisotropy * Math.sin(c.anisotropyRotation));
}), N0e = /* @__PURE__ */ at((c) => c.context.setupModelViewProjection(), "vec4").once()().toVarying("v_modelViewProjection");
class sDe extends c0e {
  /**
   * Constructs a new instanced interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   * @param {number} [meshPerAttribute=1] - Defines how often a value of this interleaved buffer should be repeated.
   */
  constructor(e, t, n = 1) {
    super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  clone(e) {
    const t = super.clone(e);
    return t.meshPerAttribute = this.meshPerAttribute, t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t;
  }
}
class oDe extends ul {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(e, t, n, i = 1) {
    super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i;
  }
  copy(e) {
    return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this;
  }
  toJSON() {
    const e = super.toJSON();
    return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e;
  }
}
class aDe extends yn {
  static get type() {
    return "InstanceNode";
  }
  /**
   * Constructs a new instance node.
   *
   * @param {number} count - The number of instances.
   * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {?InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   */
  constructor(e, t, n = null) {
    super("void"), this.count = e, this.instanceMatrix = t, this.instanceColor = n, this.instanceMatrixNode = null, this.instanceColorNode = null, this.updateType = In.FRAME, this.buffer = null, this.bufferColor = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const { count: t, instanceMatrix: n, instanceColor: i } = this;
    let { instanceMatrixNode: o, instanceColorNode: l } = this;
    if (o === null) {
      if (t <= 1e3)
        o = f0e(n.array, "mat4", Math.max(t, 1)).element(sG);
      else {
        const f = new sDe(n.array, 16, 1);
        this.buffer = f;
        const v = n.usage === Eb ? kfe : Afe, _ = [
          // F.Signature -> bufferAttribute( array, type, stride, offset )
          v(f, "vec4", 16, 0),
          v(f, "vec4", 16, 4),
          v(f, "vec4", 16, 8),
          v(f, "vec4", 16, 12)
        ];
        o = Db(..._);
      }
      this.instanceMatrixNode = o;
    }
    if (i && l === null) {
      const f = new oDe(i.array, 3), v = i.usage === Eb ? kfe : Afe;
      this.bufferColor = f, l = tt(v(f, "vec3", 3, 0)), this.instanceColorNode = l;
    }
    const p = o.mul(Qs).xyz;
    if (Qs.assign(p), e.hasGeometryAttribute("normal")) {
      const f = HOe(wc, o);
      wc.assign(f);
    }
    this.instanceColorNode !== null && jO("vec3", "vInstanceColor").assign(this.instanceColorNode);
  }
  /**
   * Checks if the internal buffers required an update.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    this.instanceMatrix.usage !== Eb && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version && (this.buffer.version = this.instanceMatrix.version), this.instanceColor && this.instanceColor.usage !== Eb && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version && (this.bufferColor.version = this.instanceColor.version);
  }
}
class lDe extends aDe {
  static get type() {
    return "InstancedMeshNode";
  }
  /**
   * Constructs a new instanced mesh node.
   *
   * @param {InstancedMesh} instancedMesh - The instanced mesh.
   */
  constructor(e) {
    const { count: t, instanceMatrix: n, instanceColor: i } = e;
    super(t, n, i), this.instancedMesh = e;
  }
}
const uDe = /* @__PURE__ */ lt(lDe).setParameterLength(1);
class cDe extends yn {
  static get type() {
    return "BatchNode";
  }
  /**
   * Constructs a new batch node.
   *
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   */
  constructor(e) {
    super("void"), this.batchMesh = e, this.batchingIdNode = null;
  }
  /**
   * Setups the internal buffers and nodes and assigns the transformed vertex data
   * to predefined node variables for accumulation. That follows the same patterns
   * like with morph and skinning nodes.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    this.batchingIdNode === null && (e.getDrawIndex() === null ? this.batchingIdNode = sG : this.batchingIdNode = AOe);
    const n = at(([j]) => {
      const q = Nr(Lb(ou(this.batchMesh._indirectTexture), 0).x), L = Nr(j).mod(q), V = Nr(j).div(q);
      return ou(this.batchMesh._indirectTexture, Nd(L, V)).x;
    }).setLayout({
      name: "getIndirectIndex",
      type: "uint",
      inputs: [
        { name: "id", type: "int" }
      ]
    })(Nr(this.batchingIdNode)), i = this.batchMesh._matricesTexture, o = Nr(Lb(ou(i), 0).x), l = et(n).mul(4).toInt().toVar(), p = l.mod(o), f = l.div(o), v = Db(
      ou(i, Nd(p, f)),
      ou(i, Nd(p.add(1), f)),
      ou(i, Nd(p.add(2), f)),
      ou(i, Nd(p.add(3), f))
    ), _ = this.batchMesh._colorsTexture;
    if (_ !== null) {
      const q = at(([L]) => {
        const V = Nr(Lb(ou(_), 0).x), re = L, R = re.mod(V), J = re.div(V);
        return ou(_, Nd(R, J)).rgb;
      }).setLayout({
        name: "getBatchingColor",
        type: "vec3",
        inputs: [
          { name: "id", type: "int" }
        ]
      })(n);
      jO("vec3", "vBatchColor").assign(q);
    }
    const E = bo(v);
    Qs.assign(v.mul(Qs));
    const A = wc.div(tt(E[0].dot(E[0]), E[1].dot(E[1]), E[2].dot(E[2]))), I = E.mul(A).xyz;
    wc.assign(I), e.hasGeometryAttribute("tangent") && cG.mulAssign(E);
  }
}
const dDe = /* @__PURE__ */ lt(cDe).setParameterLength(1), jfe = /* @__PURE__ */ new WeakMap();
class hDe extends yn {
  static get type() {
    return "SkinningNode";
  }
  /**
   * Constructs a new skinning node.
   *
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   */
  constructor(e) {
    super("void"), this.skinnedMesh = e, this.updateType = In.OBJECT, this.skinIndexNode = tf("skinIndex", "uvec4"), this.skinWeightNode = tf("skinWeight", "vec4"), this.bindMatrixNode = Cr("bindMatrix", "mat4"), this.bindMatrixInverseNode = Cr("bindMatrixInverse", "mat4"), this.boneMatricesNode = Dfe("skeleton.boneMatrices", "mat4", e.skeleton.bones.length), this.positionNode = Qs, this.toPositionNode = Qs, this.previousBoneMatricesNode = null;
  }
  /**
   * Transforms the given vertex position via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [position=this.positionNode] - The vertex position in local space.
   * @return {Node<vec3>} The transformed vertex position.
   */
  getSkinnedPosition(e = this.boneMatricesNode, t = this.positionNode) {
    const { skinIndexNode: n, skinWeightNode: i, bindMatrixNode: o, bindMatrixInverseNode: l } = this, p = e.element(n.x), f = e.element(n.y), v = e.element(n.z), _ = e.element(n.w), E = o.mul(t), A = xo(
      p.mul(i.x).mul(E),
      f.mul(i.y).mul(E),
      v.mul(i.z).mul(E),
      _.mul(i.w).mul(E)
    );
    return l.mul(A).xyz;
  }
  /**
   * Transforms the given vertex normal via skinning.
   *
   * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
   * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
   * @return {Node<vec3>} The transformed vertex normal.
   */
  getSkinnedNormal(e = this.boneMatricesNode, t = wc) {
    const { skinIndexNode: n, skinWeightNode: i, bindMatrixNode: o, bindMatrixInverseNode: l } = this, p = e.element(n.x), f = e.element(n.y), v = e.element(n.z), _ = e.element(n.w);
    let E = xo(
      i.x.mul(p),
      i.y.mul(f),
      i.z.mul(v),
      i.w.mul(_)
    );
    return E = l.mul(E).mul(o), E.transformDirection(t).xyz;
  }
  /**
   * Computes the transformed/skinned vertex position of the previous frame.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The skinned position from the previous frame.
   */
  getPreviousSkinnedPosition(e) {
    const t = e.object;
    return this.previousBoneMatricesNode === null && (t.skeleton.previousBoneMatrices = new Float32Array(t.skeleton.boneMatrices), this.previousBoneMatricesNode = Dfe("skeleton.previousBoneMatrices", "mat4", t.skeleton.bones.length)), this.getSkinnedPosition(this.previousBoneMatricesNode, Nfe);
  }
  /**
   * Returns `true` if bone matrices from the previous frame are required. Relevant
   * when computing motion vectors with {@link VelocityNode}.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether bone matrices from the previous frame are required or not.
   */
  needsPreviousBoneMatrices(e) {
    const t = e.renderer.getMRT();
    return t && t.has("velocity") || Cye(e.object).useVelocity === !0;
  }
  /**
   * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed vertex position.
   */
  setup(e) {
    this.needsPreviousBoneMatrices(e) && Nfe.assign(this.getPreviousSkinnedPosition(e));
    const t = this.getSkinnedPosition();
    if (this.toPositionNode && this.toPositionNode.assign(t), e.hasGeometryAttribute("normal")) {
      const n = this.getSkinnedNormal();
      wc.assign(n), e.hasGeometryAttribute("tangent") && cG.assign(n);
    }
    return t;
  }
  /**
   * Generates the code snippet of the skinning node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {string} output - The current output.
   * @return {string} The generated code snippet.
   */
  generate(e, t) {
    if (t !== "void")
      return super.generate(e, t);
  }
  /**
   * Updates the state of the skinned mesh by updating the skeleton once per frame.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update(e) {
    const t = e.object && e.object.skeleton ? e.object.skeleton : this.skinnedMesh.skeleton;
    jfe.get(t) !== e.frameId && (jfe.set(t, e.frameId), this.previousBoneMatricesNode !== null && t.previousBoneMatrices.set(t.boneMatrices), t.update());
  }
}
const pDe = (c) => ct(new hDe(c));
class fDe extends Js {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null), this.isDataArrayTexture = !0, this.image = { data: e, width: t, height: n, depth: i }, this.magFilter = $i, this.minFilter = $i, this.wrapR = Kp, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(e) {
    this.layerUpdates.add(e);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
}
const A5 = /* @__PURE__ */ new WeakMap(), ya = /* @__PURE__ */ new Bn(), Ufe = /* @__PURE__ */ at(({ bufferMap: c, influence: e, stride: t, width: n, depth: i, offset: o }) => {
  const l = Nr(POe).mul(t).add(o), p = l.div(n), f = l.sub(p.mul(n));
  return ou(c, Nd(f, p)).depth(i).xyz.mul(e);
});
function mDe(c) {
  const e = c.morphAttributes.position !== void 0, t = c.morphAttributes.normal !== void 0, n = c.morphAttributes.color !== void 0, i = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, o = i !== void 0 ? i.length : 0;
  let l = A5.get(c);
  if (l === void 0 || l.count !== o) {
    let V = function() {
      q.dispose(), A5.delete(c), c.removeEventListener("dispose", V);
    };
    l !== void 0 && l.texture.dispose();
    const p = c.morphAttributes.position || [], f = c.morphAttributes.normal || [], v = c.morphAttributes.color || [];
    let _ = 0;
    e === !0 && (_ = 1), t === !0 && (_ = 2), n === !0 && (_ = 3);
    let E = c.attributes.position.count * _, A = 1;
    const I = 4096;
    E > I && (A = Math.ceil(E / I), E = I);
    const j = new Float32Array(E * A * 4 * o), q = new fDe(j, E, A, o);
    q.type = wa, q.needsUpdate = !0;
    const L = _ * 4;
    for (let re = 0; re < o; re++) {
      const R = p[re], J = f[re], ge = v[re], _e = E * A * 4 * re;
      for (let Y = 0; Y < R.count; Y++) {
        const Fe = Y * L;
        e === !0 && (ya.fromBufferAttribute(R, Y), j[_e + Fe + 0] = ya.x, j[_e + Fe + 1] = ya.y, j[_e + Fe + 2] = ya.z, j[_e + Fe + 3] = 0), t === !0 && (ya.fromBufferAttribute(J, Y), j[_e + Fe + 4] = ya.x, j[_e + Fe + 5] = ya.y, j[_e + Fe + 6] = ya.z, j[_e + Fe + 7] = 0), n === !0 && (ya.fromBufferAttribute(ge, Y), j[_e + Fe + 8] = ya.x, j[_e + Fe + 9] = ya.y, j[_e + Fe + 10] = ya.z, j[_e + Fe + 11] = ge.itemSize === 4 ? ya.w : 1);
      }
    }
    l = {
      count: o,
      texture: q,
      stride: _,
      size: new Pn(E, A)
    }, A5.set(c, l), c.addEventListener("dispose", V);
  }
  return l;
}
class gDe extends yn {
  static get type() {
    return "MorphNode";
  }
  /**
   * Constructs a new morph node.
   *
   * @param {Mesh} mesh - The mesh holding the morph targets.
   */
  constructor(e) {
    super("void"), this.mesh = e, this.morphBaseInfluence = on(1), this.updateType = In.OBJECT;
  }
  /**
   * Setups the morph node by assigning the transformed vertex data to predefined node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    const { geometry: t } = e, n = t.morphAttributes.position !== void 0, i = t.hasAttribute("normal") && t.morphAttributes.normal !== void 0, o = t.morphAttributes.position || t.morphAttributes.normal || t.morphAttributes.color, l = o !== void 0 ? o.length : 0, { texture: p, stride: f, size: v } = mDe(t);
    n === !0 && Qs.mulAssign(this.morphBaseInfluence), i === !0 && wc.mulAssign(this.morphBaseInfluence);
    const _ = Nr(v.width);
    cu(l, ({ i: E }) => {
      const A = et(0).toVar();
      this.mesh.count > 1 && this.mesh.morphTexture !== null && this.mesh.morphTexture !== void 0 ? A.assign(ou(this.mesh.morphTexture, Nd(Nr(E).add(1), Nr(sG))).r) : A.assign(Cr("morphTargetInfluences", "float").element(E).toVar()), _i(A.notEqual(0), () => {
        n === !0 && Qs.addAssign(Ufe({
          bufferMap: p,
          influence: A,
          stride: f,
          width: _,
          depth: E,
          offset: Nr(0)
        })), i === !0 && wc.addAssign(Ufe({
          bufferMap: p,
          influence: A,
          stride: f,
          width: _,
          depth: E,
          offset: Nr(1)
        }));
      });
    });
  }
  /**
   * Updates the state of the morphed mesh by updating the base influence.
   *
   * @param {NodeFrame} frame - The current node frame.
   */
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative ? e.value = 1 : e.value = 1 - this.mesh.morphTargetInfluences.reduce((t, n) => t + n, 0);
  }
}
const yDe = /* @__PURE__ */ lt(gDe).setParameterLength(1);
class Zb extends yn {
  static get type() {
    return "LightingNode";
  }
  /**
   * Constructs a new lighting node.
   */
  constructor() {
    super("vec3"), this.isLightingNode = !0;
  }
}
class vDe extends Zb {
  static get type() {
    return "AONode";
  }
  /**
   * Constructs a new AO node.
   *
   * @param {?Node<float>} [aoNode=null] - The ambient occlusion node.
   */
  constructor(e = null) {
    super(), this.aoNode = e;
  }
  setup(e) {
    e.context.ambientOcclusion.mulAssign(this.aoNode);
  }
}
class bDe extends a0e {
  static get type() {
    return "LightingContextNode";
  }
  /**
   * Constructs a new lighting context node.
   *
   * @param {LightsNode} lightsNode - The lights node.
   * @param {?LightingModel} [lightingModel=null] - The current lighting model.
   * @param {?Node<vec3>} [backdropNode=null] - A backdrop node.
   * @param {?Node<float>} [backdropAlphaNode=null] - A backdrop alpha node.
   */
  constructor(e, t = null, n = null, i = null) {
    super(e), this.lightingModel = t, this.backdropNode = n, this.backdropAlphaNode = i, this._value = null;
  }
  /**
   * Returns a lighting context object.
   *
   * @return {{
   * radiance: Node<vec3>,
   * irradiance: Node<vec3>,
   * iblIrradiance: Node<vec3>,
   * ambientOcclusion: Node<float>,
   * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
   * backdrop: Node<vec3>,
   * backdropAlpha: Node<float>
   * }} The lighting context object.
   */
  getContext() {
    const { backdropNode: e, backdropAlphaNode: t } = this, n = tt().toVar("directDiffuse"), i = tt().toVar("directSpecular"), o = tt().toVar("indirectDiffuse"), l = tt().toVar("indirectSpecular"), p = {
      directDiffuse: n,
      directSpecular: i,
      indirectDiffuse: o,
      indirectSpecular: l
    };
    return {
      radiance: tt().toVar("radiance"),
      irradiance: tt().toVar("irradiance"),
      iblIrradiance: tt().toVar("iblIrradiance"),
      ambientOcclusion: et(1).toVar("ambientOcclusion"),
      reflectedLight: p,
      backdrop: e,
      backdropAlpha: t
    };
  }
  setup(e) {
    return this.value = this._value || (this._value = this.getContext()), this.value.lightingModel = this.lightingModel || e.context.lightingModel, super.setup(e);
  }
}
const xDe = /* @__PURE__ */ lt(bDe);
class _De extends Zb {
  static get type() {
    return "IrradianceNode";
  }
  /**
   * Constructs a new irradiance node.
   *
   * @param {Node<vec3>} node - A node contributing irradiance.
   */
  constructor(e) {
    super(), this.node = e;
  }
  setup(e) {
    e.context.irradiance.addAssign(this.node);
  }
}
class cl extends yn {
  static get type() {
    return "ClippingNode";
  }
  /**
   * Constructs a new clipping node.
   *
   * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
   * the selected scope influences the behavior of the node and what type of code is generated.
   */
  constructor(e = cl.DEFAULT) {
    super(), this.scope = e;
  }
  /**
   * Setups the node depending on the selected scope.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setup(e) {
    super.setup(e);
    const t = e.clippingContext, { intersectionPlanes: n, unionPlanes: i } = t;
    return this.hardwareClipping = e.material.hardwareClipping, this.scope === cl.ALPHA_TO_COVERAGE ? this.setupAlphaToCoverage(n, i) : this.scope === cl.HARDWARE ? this.setupHardwareClipping(i, e) : this.setupDefault(n, i);
  }
  /**
   * Setups alpha to coverage.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupAlphaToCoverage(e, t) {
    return at(() => {
      const n = et().toVar("distanceToPlane"), i = et().toVar("distanceToGradient"), o = et(1).toVar("clipOpacity"), l = t.length;
      if (this.hardwareClipping === !1 && l > 0) {
        const f = vc(t);
        cu(l, ({ i: v }) => {
          const _ = f.element(v);
          n.assign(Ii.dot(_.xyz).negate().add(_.w)), i.assign(n.fwidth().div(2)), o.mulAssign(ef(i.negate(), i, n));
        });
      }
      const p = e.length;
      if (p > 0) {
        const f = vc(e), v = et(1).toVar("intersectionClipOpacity");
        cu(p, ({ i: _ }) => {
          const E = f.element(_);
          n.assign(Ii.dot(E.xyz).negate().add(E.w)), i.assign(n.fwidth().div(2)), v.mulAssign(ef(i.negate(), i, n).oneMinus());
        }), o.mulAssign(v.oneMinus());
      }
      Jn.a.mulAssign(o), Jn.a.equal(0).discard();
    })();
  }
  /**
   * Setups the default clipping.
   *
   * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @return {Node} The result node.
   */
  setupDefault(e, t) {
    return at(() => {
      const n = t.length;
      if (this.hardwareClipping === !1 && n > 0) {
        const o = vc(t);
        cu(n, ({ i: l }) => {
          const p = o.element(l);
          Ii.dot(p.xyz).greaterThan(p.w).discard();
        });
      }
      const i = e.length;
      if (i > 0) {
        const o = vc(e), l = H6(!0).toVar("clipped");
        cu(i, ({ i: p }) => {
          const f = o.element(p);
          l.assign(Ii.dot(f.xyz).greaterThan(f.w).and(l));
        }), l.discard();
      }
    })();
  }
  /**
   * Setups hardware clipping.
   *
   * @param {Array<Vector4>} unionPlanes - The union planes.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The result node.
   */
  setupHardwareClipping(e, t) {
    const n = e.length;
    return t.enableHardwareClipping(n), at(() => {
      const i = vc(e), o = s2(t.getClipDistance());
      cu(n, ({ i: l }) => {
        const p = i.element(l), f = Ii.dot(p.xyz).sub(p.w).negate();
        o.element(l).assign(f);
      });
    })();
  }
}
cl.ALPHA_TO_COVERAGE = "alphaToCoverage";
cl.DEFAULT = "default";
cl.HARDWARE = "hardware";
const SDe = () => ct(new cl()), wDe = () => ct(new cl(cl.ALPHA_TO_COVERAGE)), EDe = () => ct(new cl(cl.HARDWARE)), TDe = [
  "alphaMap",
  "alphaTest",
  "anisotropy",
  "anisotropyMap",
  "anisotropyRotation",
  "aoMap",
  "aoMapIntensity",
  "attenuationColor",
  "attenuationDistance",
  "bumpMap",
  "clearcoat",
  "clearcoatMap",
  "clearcoatNormalMap",
  "clearcoatNormalScale",
  "clearcoatRoughness",
  "color",
  "dispersion",
  "displacementMap",
  "emissive",
  "emissiveIntensity",
  "emissiveMap",
  "envMap",
  "envMapIntensity",
  "gradientMap",
  "ior",
  "iridescence",
  "iridescenceIOR",
  "iridescenceMap",
  "iridescenceThicknessMap",
  "lightMap",
  "lightMapIntensity",
  "map",
  "matcap",
  "metalness",
  "metalnessMap",
  "normalMap",
  "normalScale",
  "opacity",
  "roughness",
  "roughnessMap",
  "sheen",
  "sheenColor",
  "sheenColorMap",
  "sheenRoughnessMap",
  "shininess",
  "specular",
  "specularColor",
  "specularColorMap",
  "specularIntensity",
  "specularIntensityMap",
  "specularMap",
  "thickness",
  "transmission",
  "transmissionMap"
];
class CDe {
  /**
   * Constructs a new node material observer.
   *
   * @param {NodeBuilder} builder - The node builder.
   */
  constructor(e) {
    this.renderObjects = /* @__PURE__ */ new WeakMap(), this.hasNode = this.containsNode(e), this.hasAnimation = e.object.isSkinnedMesh === !0, this.refreshUniforms = TDe, this.renderId = 0;
  }
  /**
   * Returns `true` if the given render object is verified for the first time of this observer.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object is verified for the first time of this observer.
   */
  firstInitialization(e) {
    return this.renderObjects.has(e) === !1 ? (this.getRenderObjectData(e), !0) : !1;
  }
  /**
   * Returns `true` if the current rendering produces motion vectors.
   *
   * @param {Renderer} renderer - The renderer.
   * @return {boolean} Whether the current rendering produces motion vectors or not.
   */
  needsVelocity(e) {
    const t = e.getMRT();
    return t !== null && t.has("velocity");
  }
  /**
   * Returns monitoring data for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Object} The monitoring data.
   */
  getRenderObjectData(e) {
    let t = this.renderObjects.get(e);
    if (t === void 0) {
      const { geometry: n, material: i, object: o } = e;
      if (t = {
        material: this.getMaterialData(i),
        geometry: {
          id: n.id,
          attributes: this.getAttributesData(n.attributes),
          indexVersion: n.index ? n.index.version : null,
          drawRange: { start: n.drawRange.start, count: n.drawRange.count }
        },
        worldMatrix: o.matrixWorld.clone()
      }, o.center && (t.center = o.center.clone()), o.morphTargetInfluences && (t.morphTargetInfluences = o.morphTargetInfluences.slice()), e.bundle !== null && (t.version = e.bundle.version), t.material.transmission > 0) {
        const { width: l, height: p } = e.context;
        t.bufferWidth = l, t.bufferHeight = p;
      }
      this.renderObjects.set(e, t);
    }
    return t;
  }
  /**
   * Returns an attribute data structure holding the attributes versions for
   * monitoring.
   *
   * @param {Object} attributes - The geometry attributes.
   * @return {Object} An object for monitoring the versions of attributes.
   */
  getAttributesData(e) {
    const t = {};
    for (const n in e) {
      const i = e[n];
      t[n] = {
        version: i.version
      };
    }
    return t;
  }
  /**
   * Returns `true` if the node builder's material uses
   * node properties.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {boolean} Whether the node builder's material uses node properties or not.
   */
  containsNode(e) {
    const t = e.material;
    for (const n in t)
      if (t[n] && t[n].isNode)
        return !0;
    return e.renderer.overrideNodes.modelViewMatrix !== null || e.renderer.overrideNodes.modelNormalViewMatrix !== null;
  }
  /**
   * Returns a material data structure holding the material property values for
   * monitoring.
   *
   * @param {Material} material - The material.
   * @return {Object} An object for monitoring material properties.
   */
  getMaterialData(e) {
    const t = {};
    for (const n of this.refreshUniforms) {
      const i = e[n];
      i != null && (typeof i == "object" && i.clone !== void 0 ? i.isTexture === !0 ? t[n] = { id: i.id, version: i.version } : t[n] = i.clone() : t[n] = i);
    }
    return t;
  }
  /**
   * Returns `true` if the given render object has not changed its state.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object has changed its state or not.
   */
  equals(e) {
    const { object: t, material: n, geometry: i } = e, o = this.getRenderObjectData(e);
    if (o.worldMatrix.equals(t.matrixWorld) !== !0)
      return o.worldMatrix.copy(t.matrixWorld), !1;
    const l = o.material;
    for (const q in l) {
      const L = l[q], V = n[q];
      if (L.equals !== void 0) {
        if (L.equals(V) === !1)
          return L.copy(V), !1;
      } else if (V.isTexture === !0) {
        if (L.id !== V.id || L.version !== V.version)
          return L.id = V.id, L.version = V.version, !1;
      } else if (L !== V)
        return l[q] = V, !1;
    }
    if (l.transmission > 0) {
      const { width: q, height: L } = e.context;
      if (o.bufferWidth !== q || o.bufferHeight !== L)
        return o.bufferWidth = q, o.bufferHeight = L, !1;
    }
    const p = o.geometry, f = i.attributes, v = p.attributes, _ = Object.keys(v), E = Object.keys(f);
    if (p.id !== i.id)
      return p.id = i.id, !1;
    if (_.length !== E.length)
      return o.geometry.attributes = this.getAttributesData(f), !1;
    for (const q of _) {
      const L = v[q], V = f[q];
      if (V === void 0)
        return delete v[q], !1;
      if (L.version !== V.version)
        return L.version = V.version, !1;
    }
    const A = i.index, I = p.indexVersion, j = A ? A.version : null;
    if (I !== j)
      return p.indexVersion = j, !1;
    if (p.drawRange.start !== i.drawRange.start || p.drawRange.count !== i.drawRange.count)
      return p.drawRange.start = i.drawRange.start, p.drawRange.count = i.drawRange.count, !1;
    if (o.morphTargetInfluences) {
      let q = !1;
      for (let L = 0; L < o.morphTargetInfluences.length; L++)
        o.morphTargetInfluences[L] !== t.morphTargetInfluences[L] && (q = !0);
      if (q) return !0;
    }
    return o.center && o.center.equals(t.center) === !1 ? (o.center.copy(t.center), !0) : (e.bundle !== null && (o.version = e.bundle.version), !0);
  }
  /**
   * Checks if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {NodeFrame} nodeFrame - The current node frame.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(e, t) {
    if (this.hasNode || this.hasAnimation || this.firstInitialization(e) || this.needsVelocity(t.renderer))
      return !0;
    const { renderId: n } = t;
    if (this.renderId !== n)
      return this.renderId = n, !0;
    const i = e.object.static === !0, o = e.bundle !== null && e.bundle.static === !0 && this.getRenderObjectData(e).version === e.bundle.version;
    return i || o ? !1 : this.equals(e) !== !0;
  }
}
const PDe = 0.05, zfe = /* @__PURE__ */ at(([c]) => rf(On(1e4, lu(On(17, c.x).add(On(0.1, c.y)))).mul(xo(0.1, sl(lu(On(13, c.y).add(c.x))))))), Vfe = /* @__PURE__ */ at(([c]) => zfe(xt(zfe(c.xy), c.z))), ADe = /* @__PURE__ */ at(([c]) => {
  const e = eo(
    qd(Jye(c.xyz)),
    qd(e0e(c.xyz))
  ), t = et(1).div(et(PDe).mul(e)).toVar("pixScale"), n = xt(
    CE(Eg(Gd(t))),
    CE(Q6(Gd(t)))
  ), i = xt(
    Vfe(Eg(n.x.mul(c.xyz))),
    Vfe(Eg(n.y.mul(c.xyz)))
  ), o = rf(Gd(t)), l = xo(On(o.oneMinus(), i.x), On(o, i.y)), p = Hb(o, o.oneMinus()), f = tt(
    l.mul(l).div(On(2, p).mul(mo(1, p))),
    l.sub(On(0.5, p)).div(mo(1, p)),
    mo(1, mo(1, l).mul(mo(1, l)).div(On(2, p).mul(mo(1, p))))
  ), v = l.lessThan(p.oneMinus()).select(l.lessThan(p).select(f.x, f.y), f.z);
  return Kd(v, 1e-6, 1);
}).setLayout({
  name: "getAlphaHashThreshold",
  type: "float",
  inputs: [
    { name: "position", type: "vec3" }
  ]
});
class kDe extends h0e {
  static get type() {
    return "VertexColorNode";
  }
  /**
   * Constructs a new vertex color node.
   *
   * @param {number} index - The attribute index.
   */
  constructor(e) {
    super(null, "vec4"), this.isVertexColorNode = !0, this.index = e;
  }
  /**
   * Overwrites the default implementation by honoring the attribute index.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The attribute name.
   */
  getAttributeName() {
    const e = this.index;
    return "color" + (e > 0 ? e : "");
  }
  generate(e) {
    const t = this.getAttributeName(e), n = e.hasGeometryAttribute(t);
    let i;
    return n === !0 ? i = super.generate(e) : i = e.generateConst(this.nodeType, new Bn(1, 1, 1, 1)), i;
  }
  serialize(e) {
    super.serialize(e), e.index = this.index;
  }
  deserialize(e) {
    super.deserialize(e), this.index = e.index;
  }
}
const MDe = (c = 0) => ct(new kDe(c));
class Ni extends Yo {
  static get type() {
    return "NodeMaterial";
  }
  /**
   * Represents the type of the node material.
   *
   * @type {string}
   */
  get type() {
    return this.constructor.type;
  }
  set type(e) {
  }
  /**
   * Constructs a new node material.
   */
  constructor() {
    super(), this.isNodeMaterial = !0, this.fog = !0, this.lights = !1, this.hardwareClipping = !1, this.lightsNode = null, this.envNode = null, this.aoNode = null, this.colorNode = null, this.normalNode = null, this.opacityNode = null, this.backdropNode = null, this.backdropAlphaNode = null, this.alphaTestNode = null, this.maskNode = null, this.positionNode = null, this.geometryNode = null, this.depthNode = null, this.receivedShadowPositionNode = null, this.castShadowPositionNode = null, this.receivedShadowNode = null, this.castShadowNode = null, this.outputNode = null, this.mrtNode = null, this.fragmentNode = null, this.vertexNode = null, Object.defineProperty(this, "shadowPositionNode", {
      // @deprecated, r176
      get: () => this.receivedShadowPositionNode,
      set: (e) => {
        console.warn('THREE.NodeMaterial: ".shadowPositionNode" was renamed to ".receivedShadowPositionNode".'), this.receivedShadowPositionNode = e;
      }
    });
  }
  /**
   * Allows to define a custom cache key that influence the material key computation
   * for render objects.
   *
   * @return {string} The custom cache key.
   */
  customProgramCacheKey() {
    return this.type + Eye(this);
  }
  /**
   * Builds this material with the given node builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  build(e) {
    this.setup(e);
  }
  /**
   * Setups a node material observer with the given builder.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeMaterialObserver} The node material observer.
   */
  setupObserver(e) {
    return new CDe(e);
  }
  /**
   * Setups the vertex and fragment stage of this node material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    e.context.setupNormal = () => this.setupNormal(e), e.context.setupPositionView = () => this.setupPositionView(e), e.context.setupModelViewProjection = () => this.setupModelViewProjection(e);
    const t = e.renderer, n = t.getRenderTarget();
    e.addStack();
    const i = this.setupVertex(e), o = this.vertexNode || i;
    e.stack.outputNode = o, this.setupHardwareClipping(e), this.geometryNode !== null && (e.stack.outputNode = e.stack.outputNode.bypass(this.geometryNode)), e.addFlow("vertex", e.removeStack()), e.addStack();
    let l;
    const p = this.setupClipping(e);
    if ((this.depthWrite === !0 || this.depthTest === !0) && (n !== null ? n.depthBuffer === !0 && this.setupDepth(e) : t.depth === !0 && this.setupDepth(e)), this.fragmentNode === null) {
      this.setupDiffuseColor(e), this.setupVariants(e);
      const f = this.setupLighting(e);
      p !== null && e.stack.add(p);
      const v = gn(f, Jn.a).max(0);
      l = this.setupOutput(e, v), gE.assign(l);
      const _ = this.outputNode !== null;
      if (_ && (l = this.outputNode), n !== null) {
        const E = t.getMRT(), A = this.mrtNode;
        E !== null ? (_ && gE.assign(l), l = E, A !== null && (l = E.merge(A))) : A !== null && (l = A);
      }
    } else {
      let f = this.fragmentNode;
      f.isOutputStructNode !== !0 && (f = gn(f)), l = this.setupOutput(e, f);
    }
    e.stack.outputNode = l, e.addFlow("fragment", e.removeStack()), e.observer = this.setupObserver(e);
  }
  /**
   * Setups the clipping node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {ClippingNode} The clipping node.
   */
  setupClipping(e) {
    if (e.clippingContext === null) return null;
    const { unionPlanes: t, intersectionPlanes: n } = e.clippingContext;
    let i = null;
    if (t.length > 0 || n.length > 0) {
      const o = e.renderer.samples;
      this.alphaToCoverage && o > 1 ? i = wDe() : e.stack.add(SDe());
    }
    return i;
  }
  /**
   * Setups the hardware clipping if available on the current device.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupHardwareClipping(e) {
    if (this.hardwareClipping = !1, e.clippingContext === null) return;
    const t = e.clippingContext.unionPlanes.length;
    t > 0 && t <= 8 && e.isAvailable("clipDistance") && (e.stack.add(EDe()), this.hardwareClipping = !0);
  }
  /**
   * Setups the depth of this material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupDepth(e) {
    const { renderer: t, camera: n } = e;
    let i = this.depthNode;
    if (i === null) {
      const o = t.getMRT();
      o && o.has("depth") ? i = o.get("depth") : t.logarithmicDepthBuffer === !0 && (n.isPerspectiveCamera ? i = T0e(Ii.z, yg, vg) : i = vE(Ii.z, yg, vg));
    }
    i !== null && P0e.assign(i).toStack();
  }
  /**
   * Setups the position node in view space. This method exists
   * so derived node materials can modify the implementation e.g. sprite materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView() {
    return o2.mul(Qs).xyz;
  }
  /**
   * Setups the position in clip space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in view space.
   */
  setupModelViewProjection() {
    return oG.mul(Ii);
  }
  /**
   * Setups the logic for the vertex stage.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The position in clip space.
   */
  setupVertex(e) {
    return e.addStack(), this.setupPosition(e), e.context.vertex = e.removeStack(), N0e;
  }
  /**
   * Setups the computation of the position in local space.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in local space.
   */
  setupPosition(e) {
    const { object: t, geometry: n } = e;
    if ((n.morphAttributes.position || n.morphAttributes.normal || n.morphAttributes.color) && yDe(t).toStack(), t.isSkinnedMesh === !0 && pDe(t).toStack(), this.displacementMap) {
      const i = $p("displacementMap", "texture"), o = $p("displacementScale", "float"), l = $p("displacementBias", "float");
      Qs.addAssign(wc.normalize().mul(i.x.mul(o).add(l)));
    }
    return t.isBatchedMesh && dDe(t).toStack(), t.isInstancedMesh && t.instanceMatrix && t.instanceMatrix.isInstancedBufferAttribute === !0 && uDe(t).toStack(), this.positionNode !== null && Qs.assign(yOe(this.positionNode, "POSITION")), Qs;
  }
  /**
   * Setups the computation of the material's diffuse color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {BufferGeometry} geometry - The geometry.
   */
  setupDiffuseColor({ object: e, geometry: t }) {
    this.maskNode !== null && H6(this.maskNode).not().discard();
    let n = this.colorNode ? gn(this.colorNode) : k2e;
    this.vertexColors === !0 && t.hasAttribute("color") && (n = n.mul(MDe())), e.instanceColor && (n = jO("vec3", "vInstanceColor").mul(n)), e.isBatchedMesh && e._colorsTexture && (n = jO("vec3", "vBatchColor").mul(n)), Jn.assign(n);
    const i = this.opacityNode ? et(this.opacityNode) : R0e;
    Jn.a.assign(Jn.a.mul(i));
    let o = null;
    (this.alphaTestNode !== null || this.alphaTest > 0) && (o = this.alphaTestNode !== null ? et(this.alphaTestNode) : A2e, Jn.a.lessThanEqual(o).discard()), this.alphaHash === !0 && Jn.a.lessThan(ADe(Qs)).discard(), this.transparent === !1 && this.blending === jd && this.alphaToCoverage === !1 ? Jn.a.assign(1) : o === null && Jn.a.lessThanEqual(0).discard();
  }
  /**
   * Abstract interface method that can be implemented by derived materials
   * to setup material-specific node variables.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
  }
  /**
   * Setups the outgoing light node variable
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return this.lights === !0 ? tt(0) : Jn.rgb;
  }
  /**
   * Setups the normal node from the material.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return this.normalNode ? tt(this.normalNode) : F2e;
  }
  /**
   * Setups the environment node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec4>} The environment node.
   */
  setupEnvironment() {
    let e = null;
    return this.envNode ? e = this.envNode : this.envMap && (e = this.envMap.isCubeTexture ? $p("envMap", "cubeTexture") : $p("envMap", "texture")), e;
  }
  /**
   * Setups the light map node from the material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The light map node.
   */
  setupLightMap(e) {
    let t = null;
    return e.material.lightMap && (t = new _De(I0e)), t;
  }
  /**
   * Setups the lights node based on the scene, environment and material.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightsNode} The lights node.
   */
  setupLights(e) {
    const t = [], n = this.setupEnvironment(e);
    n && n.isLightingNode && t.push(n);
    const i = this.setupLightMap(e);
    if (i && i.isLightingNode && t.push(i), this.aoNode !== null || e.material.aoMap) {
      const l = this.aoNode !== null ? this.aoNode : iDe;
      t.push(new vDe(l));
    }
    let o = this.lightsNode || e.lightsNode;
    return t.length > 0 && (o = e.renderer.lighting.createNode([...o.getLights(), ...t])), o;
  }
  /**
   * This method should be implemented by most derived materials
   * since it defines the material's lighting model.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   * @return {LightingModel} The lighting model.
   */
  setupLightingModel() {
  }
  /**
   * Setups the outgoing light node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The outgoing light node.
   */
  setupLighting(e) {
    const { material: t } = e, { backdropNode: n, backdropAlphaNode: i, emissiveNode: o } = this, p = this.lights === !0 || this.lightsNode !== null ? this.setupLights(e) : null;
    let f = this.setupOutgoingLight(e);
    if (p && p.getScope().hasLights) {
      const v = this.setupLightingModel(e) || null;
      f = xDe(p, v, n, i);
    } else n !== null && (f = tt(i !== null ? Vr(f, n, i) : n));
    return (o && o.isNode === !0 || t.emissive && t.emissive.isColor === !0) && (Cfe.assign(tt(o || R2e)), f = f.add(Cfe)), f;
  }
  /**
   * Setup the fog.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupFog(e, t) {
    const n = e.fogNode;
    return n && (gE.assign(t), t = gn(n)), t;
  }
  /**
   * Setups the output node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node<vec4>} outputNode - The existing output node.
   * @return {Node<vec4>} The output node.
   */
  setupOutput(e, t) {
    return this.fog === !0 && (t = this.setupFog(e, t)), t;
  }
  /**
   * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
   * there is `MeshBasicNodeMaterial`. This utility method is intended for
   * defining all material properties of the classic type in the node type.
   *
   * @param {Material} material - The material to copy properties with their values to this node material.
   */
  setDefaultValues(e) {
    for (const n in e) {
      const i = e[n];
      this[n] === void 0 && (this[n] = i, i && i.clone && (this[n] = i.clone()));
    }
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const n in t)
      Object.getOwnPropertyDescriptor(this.constructor.prototype, n) === void 0 && t[n].get !== void 0 && Object.defineProperty(this.constructor.prototype, n, t[n]);
  }
  /**
   * Serializes this material to JSON.
   *
   * @param {?(Object|string)} meta - The meta information for serialization.
   * @return {Object} The serialized node.
   */
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = {
      textures: {},
      images: {},
      nodes: {}
    });
    const n = Yo.prototype.toJSON.call(this, e), i = FO(this);
    n.inputNodes = {};
    for (const { property: l, childNode: p } of i)
      n.inputNodes[l] = p.toJSON(e).uuid;
    function o(l) {
      const p = [];
      for (const f in l) {
        const v = l[f];
        delete v.metadata, p.push(v);
      }
      return p;
    }
    if (t) {
      const l = o(e.textures), p = o(e.images), f = o(e.nodes);
      l.length > 0 && (n.textures = l), p.length > 0 && (n.images = p), f.length > 0 && (n.nodes = f);
    }
    return n;
  }
  /**
   * Copies the properties of the given node material to this instance.
   *
   * @param {NodeMaterial} source - The material to copy.
   * @return {NodeMaterial} A reference to this node material.
   */
  copy(e) {
    return this.lightsNode = e.lightsNode, this.envNode = e.envNode, this.colorNode = e.colorNode, this.normalNode = e.normalNode, this.opacityNode = e.opacityNode, this.backdropNode = e.backdropNode, this.backdropAlphaNode = e.backdropAlphaNode, this.alphaTestNode = e.alphaTestNode, this.maskNode = e.maskNode, this.positionNode = e.positionNode, this.geometryNode = e.geometryNode, this.depthNode = e.depthNode, this.receivedShadowPositionNode = e.receivedShadowPositionNode, this.castShadowPositionNode = e.castShadowPositionNode, this.receivedShadowNode = e.receivedShadowNode, this.castShadowNode = e.castShadowNode, this.outputNode = e.outputNode, this.mrtNode = e.mrtNode, this.fragmentNode = e.fragmentNode, this.vertexNode = e.vertexNode, super.copy(e);
  }
}
let RDe = 0;
const nl = /* @__PURE__ */ new Pr(), k5 = /* @__PURE__ */ new Wi(), ob = /* @__PURE__ */ new Ue(), va = /* @__PURE__ */ new FE(), Fw = /* @__PURE__ */ new FE(), as = /* @__PURE__ */ new Ue();
class Zd extends kg {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: RDe++ }), this.uuid = Bd(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(e) {
    return Array.isArray(e) ? this.index = new (Sye(e) ? Aye : Pye)(e, 1) : this.index = e, this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(e) {
    return this.indirect = e, this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(e) {
    return this.attributes[e];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(e, t) {
    return this.attributes[e] = t, this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(e, t, n = 0) {
    this.groups.push({
      start: e,
      count: t,
      materialIndex: n
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(e, t) {
    this.drawRange.start = e, this.drawRange.count = t;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
    const n = this.attributes.normal;
    if (n !== void 0) {
      const o = new Xo().getNormalMatrix(e);
      n.applyNormalMatrix(o), n.needsUpdate = !0;
    }
    const i = this.attributes.tangent;
    return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(e) {
    return nl.makeRotationFromQuaternion(e), this.applyMatrix4(nl), this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(e) {
    return nl.makeRotationX(e), this.applyMatrix4(nl), this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(e) {
    return nl.makeRotationY(e), this.applyMatrix4(nl), this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(e) {
    return nl.makeRotationZ(e), this.applyMatrix4(nl), this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(e, t, n) {
    return nl.makeTranslation(e, t, n), this.applyMatrix4(nl), this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(e, t, n) {
    return nl.makeScale(e, t, n), this.applyMatrix4(nl), this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(e) {
    return k5.lookAt(e), k5.updateMatrix(), this.applyMatrix4(k5.matrix), this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    return this.computeBoundingBox(), this.boundingBox.getCenter(ob).negate(), this.translate(ob.x, ob.y, ob.z), this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(e) {
    const t = this.getAttribute("position");
    if (t === void 0) {
      const n = [];
      for (let i = 0, o = e.length; i < o; i++) {
        const l = e[i];
        n.push(l.x, l.y, l.z || 0);
      }
      this.setAttribute("position", new vo(n, 3));
    } else {
      const n = Math.min(e.length, t.count);
      for (let i = 0; i < n; i++) {
        const o = e[i];
        t.setXYZ(i, o.x, o.y, o.z || 0);
      }
      e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new FE());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(
        new Ue(-1 / 0, -1 / 0, -1 / 0),
        new Ue(1 / 0, 1 / 0, 1 / 0)
      );
      return;
    }
    if (e !== void 0) {
      if (this.boundingBox.setFromBufferAttribute(e), t)
        for (let n = 0, i = t.length; n < i; n++) {
          const o = t[n];
          va.setFromBufferAttribute(o), this.morphTargetsRelative ? (as.addVectors(this.boundingBox.min, va.min), this.boundingBox.expandByPoint(as), as.addVectors(this.boundingBox.max, va.max), this.boundingBox.expandByPoint(as)) : (this.boundingBox.expandByPoint(va.min), this.boundingBox.expandByPoint(va.max));
        }
    } else
      this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new i2());
    const e = this.attributes.position, t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new Ue(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if (va.setFromBufferAttribute(e), t)
        for (let o = 0, l = t.length; o < l; o++) {
          const p = t[o];
          Fw.setFromBufferAttribute(p), this.morphTargetsRelative ? (as.addVectors(va.min, Fw.min), va.expandByPoint(as), as.addVectors(va.max, Fw.max), va.expandByPoint(as)) : (va.expandByPoint(Fw.min), va.expandByPoint(Fw.max));
        }
      va.getCenter(n);
      let i = 0;
      for (let o = 0, l = e.count; o < l; o++)
        as.fromBufferAttribute(e, o), i = Math.max(i, n.distanceToSquared(as));
      if (t)
        for (let o = 0, l = t.length; o < l; o++) {
          const p = t[o], f = this.morphTargetsRelative;
          for (let v = 0, _ = p.count; v < _; v++)
            as.fromBufferAttribute(p, v), f && (ob.fromBufferAttribute(e, v), as.add(ob)), i = Math.max(i, n.distanceToSquared(as));
        }
      this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const e = this.index, t = this.attributes;
    if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
      console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const n = t.position, i = t.normal, o = t.uv;
    this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ul(new Float32Array(4 * n.count), 4));
    const l = this.getAttribute("tangent"), p = [], f = [];
    for (let Fe = 0; Fe < n.count; Fe++)
      p[Fe] = new Ue(), f[Fe] = new Ue();
    const v = new Ue(), _ = new Ue(), E = new Ue(), A = new Pn(), I = new Pn(), j = new Pn(), q = new Ue(), L = new Ue();
    function V(Fe, Me, $) {
      v.fromBufferAttribute(n, Fe), _.fromBufferAttribute(n, Me), E.fromBufferAttribute(n, $), A.fromBufferAttribute(o, Fe), I.fromBufferAttribute(o, Me), j.fromBufferAttribute(o, $), _.sub(v), E.sub(v), I.sub(A), j.sub(A);
      const dt = 1 / (I.x * j.y - j.x * I.y);
      isFinite(dt) && (q.copy(_).multiplyScalar(j.y).addScaledVector(E, -I.y).multiplyScalar(dt), L.copy(E).multiplyScalar(I.x).addScaledVector(_, -j.x).multiplyScalar(dt), p[Fe].add(q), p[Me].add(q), p[$].add(q), f[Fe].add(L), f[Me].add(L), f[$].add(L));
    }
    let re = this.groups;
    re.length === 0 && (re = [{
      start: 0,
      count: e.count
    }]);
    for (let Fe = 0, Me = re.length; Fe < Me; ++Fe) {
      const $ = re[Fe], dt = $.start, wt = $.count;
      for (let St = dt, Ct = dt + wt; St < Ct; St += 3)
        V(
          e.getX(St + 0),
          e.getX(St + 1),
          e.getX(St + 2)
        );
    }
    const R = new Ue(), J = new Ue(), ge = new Ue(), _e = new Ue();
    function Y(Fe) {
      ge.fromBufferAttribute(i, Fe), _e.copy(ge);
      const Me = p[Fe];
      R.copy(Me), R.sub(ge.multiplyScalar(ge.dot(Me))).normalize(), J.crossVectors(_e, Me);
      const dt = J.dot(f[Fe]) < 0 ? -1 : 1;
      l.setXYZW(Fe, R.x, R.y, R.z, dt);
    }
    for (let Fe = 0, Me = re.length; Fe < Me; ++Fe) {
      const $ = re[Fe], dt = $.start, wt = $.count;
      for (let St = dt, Ct = dt + wt; St < Ct; St += 3)
        Y(e.getX(St + 0)), Y(e.getX(St + 1)), Y(e.getX(St + 2));
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const e = this.index, t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        n = new ul(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
      else
        for (let A = 0, I = n.count; A < I; A++)
          n.setXYZ(A, 0, 0, 0);
      const i = new Ue(), o = new Ue(), l = new Ue(), p = new Ue(), f = new Ue(), v = new Ue(), _ = new Ue(), E = new Ue();
      if (e)
        for (let A = 0, I = e.count; A < I; A += 3) {
          const j = e.getX(A + 0), q = e.getX(A + 1), L = e.getX(A + 2);
          i.fromBufferAttribute(t, j), o.fromBufferAttribute(t, q), l.fromBufferAttribute(t, L), _.subVectors(l, o), E.subVectors(i, o), _.cross(E), p.fromBufferAttribute(n, j), f.fromBufferAttribute(n, q), v.fromBufferAttribute(n, L), p.add(_), f.add(_), v.add(_), n.setXYZ(j, p.x, p.y, p.z), n.setXYZ(q, f.x, f.y, f.z), n.setXYZ(L, v.x, v.y, v.z);
        }
      else
        for (let A = 0, I = t.count; A < I; A += 3)
          i.fromBufferAttribute(t, A + 0), o.fromBufferAttribute(t, A + 1), l.fromBufferAttribute(t, A + 2), _.subVectors(l, o), E.subVectors(i, o), _.cross(E), n.setXYZ(A + 0, _.x, _.y, _.z), n.setXYZ(A + 1, _.x, _.y, _.z), n.setXYZ(A + 2, _.x, _.y, _.z);
      this.normalizeNormals(), n.needsUpdate = !0;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      as.fromBufferAttribute(e, t), as.normalize(), e.setXYZ(t, as.x, as.y, as.z);
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function e(p, f) {
      const v = p.array, _ = p.itemSize, E = p.normalized, A = new v.constructor(f.length * _);
      let I = 0, j = 0;
      for (let q = 0, L = f.length; q < L; q++) {
        p.isInterleavedBufferAttribute ? I = f[q] * p.data.stride + p.offset : I = f[q] * _;
        for (let V = 0; V < _; V++)
          A[j++] = v[I++];
      }
      return new ul(A, _, E);
    }
    if (this.index === null)
      return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
    const t = new Zd(), n = this.index.array, i = this.attributes;
    for (const p in i) {
      const f = i[p], v = e(f, n);
      t.setAttribute(p, v);
    }
    const o = this.morphAttributes;
    for (const p in o) {
      const f = [], v = o[p];
      for (let _ = 0, E = v.length; _ < E; _++) {
        const A = v[_], I = e(A, n);
        f.push(I);
      }
      t.morphAttributes[p] = f;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const l = this.groups;
    for (let p = 0, f = l.length; p < f; p++) {
      const v = l[p];
      t.addGroup(v.start, v.count, v.materialIndex);
    }
    return t;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const e = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
      const f = this.parameters;
      for (const v in f)
        f[v] !== void 0 && (e[v] = f[v]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null && (e.data.index = {
      type: t.array.constructor.name,
      array: Array.prototype.slice.call(t.array)
    });
    const n = this.attributes;
    for (const f in n) {
      const v = n[f];
      e.data.attributes[f] = v.toJSON(e.data);
    }
    const i = {};
    let o = !1;
    for (const f in this.morphAttributes) {
      const v = this.morphAttributes[f], _ = [];
      for (let E = 0, A = v.length; E < A; E++) {
        const I = v[E];
        _.push(I.toJSON(e.data));
      }
      _.length > 0 && (i[f] = _, o = !0);
    }
    o && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
    const l = this.groups;
    l.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(l)));
    const p = this.boundingSphere;
    return p !== null && (e.data.boundingSphere = p.toJSON()), e;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(e) {
    this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone());
    const i = e.attributes;
    for (const v in i) {
      const _ = i[v];
      this.setAttribute(v, _.clone(t));
    }
    const o = e.morphAttributes;
    for (const v in o) {
      const _ = [], E = o[v];
      for (let A = 0, I = E.length; A < I; A++)
        _.push(E[A].clone(t));
      this.morphAttributes[v] = _;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const l = e.groups;
    for (let v = 0, _ = l.length; v < _; v++) {
      const E = l[v];
      this.addGroup(E.start, E.count, E.materialIndex);
    }
    const p = e.boundingBox;
    p !== null && (this.boundingBox = p.clone());
    const f = e.boundingSphere;
    return f !== null && (this.boundingSphere = f.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Md = /* @__PURE__ */ new Ue(), M5 = /* @__PURE__ */ new Ue(), AN = /* @__PURE__ */ new Ue(), Dp = /* @__PURE__ */ new Ue(), R5 = /* @__PURE__ */ new Ue(), kN = /* @__PURE__ */ new Ue(), I5 = /* @__PURE__ */ new Ue();
class IDe {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(e = new Ue(), t = new Ue(0, 0, -1)) {
    this.origin = e, this.direction = t;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(e) {
    return this.origin.copy(this.at(e, Md)), this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(e) {
    const t = Md.subVectors(e, this.origin).dot(this.direction);
    return t < 0 ? this.origin.distanceToSquared(e) : (Md.copy(this.origin).addScaledVector(this.direction, t), Md.distanceToSquared(e));
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(e, t, n, i) {
    M5.copy(e).add(t).multiplyScalar(0.5), AN.copy(t).sub(e).normalize(), Dp.copy(this.origin).sub(M5);
    const o = e.distanceTo(t) * 0.5, l = -this.direction.dot(AN), p = Dp.dot(this.direction), f = -Dp.dot(AN), v = Dp.lengthSq(), _ = Math.abs(1 - l * l);
    let E, A, I, j;
    if (_ > 0)
      if (E = l * f - p, A = l * p - f, j = o * _, E >= 0)
        if (A >= -j)
          if (A <= j) {
            const q = 1 / _;
            E *= q, A *= q, I = E * (E + l * A + 2 * p) + A * (l * E + A + 2 * f) + v;
          } else
            A = o, E = Math.max(0, -(l * A + p)), I = -E * E + A * (A + 2 * f) + v;
        else
          A = -o, E = Math.max(0, -(l * A + p)), I = -E * E + A * (A + 2 * f) + v;
      else
        A <= -j ? (E = Math.max(0, -(-l * o + p)), A = E > 0 ? -o : Math.min(Math.max(-o, -f), o), I = -E * E + A * (A + 2 * f) + v) : A <= j ? (E = 0, A = Math.min(Math.max(-o, -f), o), I = A * (A + 2 * f) + v) : (E = Math.max(0, -(l * o + p)), A = E > 0 ? o : Math.min(Math.max(-o, -f), o), I = -E * E + A * (A + 2 * f) + v);
    else
      A = l > 0 ? -o : o, E = Math.max(0, -(l * A + p)), I = -E * E + A * (A + 2 * f) + v;
    return n && n.copy(this.origin).addScaledVector(this.direction, E), i && i.copy(M5).addScaledVector(AN, A), I;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(e, t) {
    Md.subVectors(e.center, this.origin);
    const n = Md.dot(this.direction), i = Md.dot(Md) - n * n, o = e.radius * e.radius;
    if (i > o) return null;
    const l = Math.sqrt(o - i), p = n - l, f = n + l;
    return f < 0 ? null : p < 0 ? this.at(f, t) : this.at(p, t);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(e) {
    return e.radius < 0 ? !1 : this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0)
      return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(e, t) {
    let n, i, o, l, p, f;
    const v = 1 / this.direction.x, _ = 1 / this.direction.y, E = 1 / this.direction.z, A = this.origin;
    return v >= 0 ? (n = (e.min.x - A.x) * v, i = (e.max.x - A.x) * v) : (n = (e.max.x - A.x) * v, i = (e.min.x - A.x) * v), _ >= 0 ? (o = (e.min.y - A.y) * _, l = (e.max.y - A.y) * _) : (o = (e.max.y - A.y) * _, l = (e.min.y - A.y) * _), n > l || o > i || ((o > n || isNaN(n)) && (n = o), (l < i || isNaN(i)) && (i = l), E >= 0 ? (p = (e.min.z - A.z) * E, f = (e.max.z - A.z) * E) : (p = (e.max.z - A.z) * E, f = (e.min.z - A.z) * E), n > f || p > i) || ((p > n || n !== n) && (n = p), (f < i || i !== i) && (i = f), i < 0) ? null : this.at(n >= 0 ? n : i, t);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(e) {
    return this.intersectBox(e, Md) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(e, t, n, i, o) {
    R5.subVectors(t, e), kN.subVectors(n, e), I5.crossVectors(R5, kN);
    let l = this.direction.dot(I5), p;
    if (l > 0) {
      if (i) return null;
      p = 1;
    } else if (l < 0)
      p = -1, l = -l;
    else
      return null;
    Dp.subVectors(this.origin, e);
    const f = p * this.direction.dot(kN.crossVectors(Dp, kN));
    if (f < 0)
      return null;
    const v = p * this.direction.dot(R5.cross(Dp));
    if (v < 0 || f + v > l)
      return null;
    const _ = -p * Dp.dot(I5);
    return _ < 0 ? null : this.at(_ / l, o);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(e) {
    return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const ru = /* @__PURE__ */ new Ue(), Rd = /* @__PURE__ */ new Ue(), N5 = /* @__PURE__ */ new Ue(), Id = /* @__PURE__ */ new Ue(), ab = /* @__PURE__ */ new Ue(), lb = /* @__PURE__ */ new Ue(), Gfe = /* @__PURE__ */ new Ue(), O5 = /* @__PURE__ */ new Ue(), D5 = /* @__PURE__ */ new Ue(), F5 = /* @__PURE__ */ new Ue(), B5 = /* @__PURE__ */ new Bn(), L5 = /* @__PURE__ */ new Bn(), j5 = /* @__PURE__ */ new Bn();
class du {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(e = new Ue(), t = new Ue(), n = new Ue()) {
    this.a = e, this.b = t, this.c = n;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), ru.subVectors(e, t), i.cross(ru);
    const o = i.lengthSq();
    return o > 0 ? i.multiplyScalar(1 / Math.sqrt(o)) : i.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(e, t, n, i, o) {
    ru.subVectors(i, t), Rd.subVectors(n, t), N5.subVectors(e, t);
    const l = ru.dot(ru), p = ru.dot(Rd), f = ru.dot(N5), v = Rd.dot(Rd), _ = Rd.dot(N5), E = l * v - p * p;
    if (E === 0)
      return o.set(0, 0, 0), null;
    const A = 1 / E, I = (v * f - p * _) * A, j = (l * _ - p * f) * A;
    return o.set(1 - I - j, j, I);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(e, t, n, i) {
    return this.getBarycoord(e, t, n, i, Id) === null ? !1 : Id.x >= 0 && Id.y >= 0 && Id.x + Id.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(e, t, n, i, o, l, p, f) {
    return this.getBarycoord(e, t, n, i, Id) === null ? (f.x = 0, f.y = 0, "z" in f && (f.z = 0), "w" in f && (f.w = 0), null) : (f.setScalar(0), f.addScaledVector(o, Id.x), f.addScaledVector(l, Id.y), f.addScaledVector(p, Id.z), f);
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(e, t, n, i, o, l) {
    return B5.setScalar(0), L5.setScalar(0), j5.setScalar(0), B5.fromBufferAttribute(e, t), L5.fromBufferAttribute(e, n), j5.fromBufferAttribute(e, i), l.setScalar(0), l.addScaledVector(B5, o.x), l.addScaledVector(L5, o.y), l.addScaledVector(j5, o.z), l;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(e, t, n, i) {
    return ru.subVectors(n, t), Rd.subVectors(e, t), ru.cross(Rd).dot(i) < 0;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(e, t, n, i) {
    return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    return ru.subVectors(this.c, this.b), Rd.subVectors(this.a, this.b), ru.cross(Rd).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(e) {
    return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(e) {
    return du.getNormal(this.a, this.b, this.c, e);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(e, t) {
    return du.getBarycoord(e, this.a, this.b, this.c, t);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(e, t, n, i, o) {
    return du.getInterpolation(e, this.a, this.b, this.c, t, n, i, o);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(e) {
    return du.containsPoint(e, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(e) {
    return du.isFrontFacing(this.a, this.b, this.c, e);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(e, t) {
    const n = this.a, i = this.b, o = this.c;
    let l, p;
    ab.subVectors(i, n), lb.subVectors(o, n), O5.subVectors(e, n);
    const f = ab.dot(O5), v = lb.dot(O5);
    if (f <= 0 && v <= 0)
      return t.copy(n);
    D5.subVectors(e, i);
    const _ = ab.dot(D5), E = lb.dot(D5);
    if (_ >= 0 && E <= _)
      return t.copy(i);
    const A = f * E - _ * v;
    if (A <= 0 && f >= 0 && _ <= 0)
      return l = f / (f - _), t.copy(n).addScaledVector(ab, l);
    F5.subVectors(e, o);
    const I = ab.dot(F5), j = lb.dot(F5);
    if (j >= 0 && I <= j)
      return t.copy(o);
    const q = I * v - f * j;
    if (q <= 0 && v >= 0 && j <= 0)
      return p = v / (v - j), t.copy(n).addScaledVector(lb, p);
    const L = _ * j - I * E;
    if (L <= 0 && E - _ >= 0 && I - j >= 0)
      return Gfe.subVectors(o, i), p = (E - _) / (E - _ + (I - j)), t.copy(i).addScaledVector(Gfe, p);
    const V = 1 / (L + q + A);
    return l = q * V, p = A * V, t.copy(n).addScaledVector(ab, l).addScaledVector(lb, p);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
class Wp extends Yo {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new er(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new hl(), this.combine = QO, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const qfe = /* @__PURE__ */ new Pr(), ng = /* @__PURE__ */ new IDe(), MN = /* @__PURE__ */ new i2(), Hfe = /* @__PURE__ */ new Ue(), RN = /* @__PURE__ */ new Ue(), IN = /* @__PURE__ */ new Ue(), NN = /* @__PURE__ */ new Ue(), U5 = /* @__PURE__ */ new Ue(), ON = /* @__PURE__ */ new Ue(), $fe = /* @__PURE__ */ new Ue(), DN = /* @__PURE__ */ new Ue();
class Yd extends Wi {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(e = new Zd(), t = new Wp()) {
    super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.count = 1, this.updateMorphTargets();
  }
  copy(e, t) {
    return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const t = this.geometry.morphAttributes, n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        this.morphTargetInfluences = [], this.morphTargetDictionary = {};
        for (let o = 0, l = i.length; o < l; o++) {
          const p = i[o].name || String(o);
          this.morphTargetInfluences.push(0), this.morphTargetDictionary[p] = o;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(e, t) {
    const n = this.geometry, i = n.attributes.position, o = n.morphAttributes.position, l = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const p = this.morphTargetInfluences;
    if (o && p) {
      ON.set(0, 0, 0);
      for (let f = 0, v = o.length; f < v; f++) {
        const _ = p[f], E = o[f];
        _ !== 0 && (U5.fromBufferAttribute(E, e), l ? ON.addScaledVector(U5, _) : ON.addScaledVector(U5.sub(t), _));
      }
      t.add(ON);
    }
    return t;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(e, t) {
    const n = this.geometry, i = this.material, o = this.matrixWorld;
    i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), MN.copy(n.boundingSphere), MN.applyMatrix4(o), ng.copy(e.ray).recast(e.near), !(MN.containsPoint(ng.origin) === !1 && (ng.intersectSphere(MN, Hfe) === null || ng.origin.distanceToSquared(Hfe) > (e.far - e.near) ** 2)) && (qfe.copy(o).invert(), ng.copy(e.ray).applyMatrix4(qfe), !(n.boundingBox !== null && ng.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, ng)));
  }
  _computeIntersections(e, t, n) {
    let i;
    const o = this.geometry, l = this.material, p = o.index, f = o.attributes.position, v = o.attributes.uv, _ = o.attributes.uv1, E = o.attributes.normal, A = o.groups, I = o.drawRange;
    if (p !== null)
      if (Array.isArray(l))
        for (let j = 0, q = A.length; j < q; j++) {
          const L = A[j], V = l[L.materialIndex], re = Math.max(L.start, I.start), R = Math.min(p.count, Math.min(L.start + L.count, I.start + I.count));
          for (let J = re, ge = R; J < ge; J += 3) {
            const _e = p.getX(J), Y = p.getX(J + 1), Fe = p.getX(J + 2);
            i = FN(this, V, e, n, v, _, E, _e, Y, Fe), i && (i.faceIndex = Math.floor(J / 3), i.face.materialIndex = L.materialIndex, t.push(i));
          }
        }
      else {
        const j = Math.max(0, I.start), q = Math.min(p.count, I.start + I.count);
        for (let L = j, V = q; L < V; L += 3) {
          const re = p.getX(L), R = p.getX(L + 1), J = p.getX(L + 2);
          i = FN(this, l, e, n, v, _, E, re, R, J), i && (i.faceIndex = Math.floor(L / 3), t.push(i));
        }
      }
    else if (f !== void 0)
      if (Array.isArray(l))
        for (let j = 0, q = A.length; j < q; j++) {
          const L = A[j], V = l[L.materialIndex], re = Math.max(L.start, I.start), R = Math.min(f.count, Math.min(L.start + L.count, I.start + I.count));
          for (let J = re, ge = R; J < ge; J += 3) {
            const _e = J, Y = J + 1, Fe = J + 2;
            i = FN(this, V, e, n, v, _, E, _e, Y, Fe), i && (i.faceIndex = Math.floor(J / 3), i.face.materialIndex = L.materialIndex, t.push(i));
          }
        }
      else {
        const j = Math.max(0, I.start), q = Math.min(f.count, I.start + I.count);
        for (let L = j, V = q; L < V; L += 3) {
          const re = L, R = L + 1, J = L + 2;
          i = FN(this, l, e, n, v, _, E, re, R, J), i && (i.faceIndex = Math.floor(L / 3), t.push(i));
        }
      }
  }
}
function NDe(c, e, t, n, i, o, l, p) {
  let f;
  if (e.side === Ko ? f = n.intersectTriangle(l, o, i, !0, p) : f = n.intersectTriangle(i, o, l, e.side === Ld, p), f === null) return null;
  DN.copy(p), DN.applyMatrix4(c.matrixWorld);
  const v = t.ray.origin.distanceTo(DN);
  return v < t.near || v > t.far ? null : {
    distance: v,
    point: DN.clone(),
    object: c
  };
}
function FN(c, e, t, n, i, o, l, p, f, v) {
  c.getVertexPosition(p, RN), c.getVertexPosition(f, IN), c.getVertexPosition(v, NN);
  const _ = NDe(c, e, t, n, RN, IN, NN, $fe);
  if (_) {
    const E = new Ue();
    du.getBarycoord($fe, RN, IN, NN, E), i && (_.uv = du.getInterpolatedAttribute(i, p, f, v, E, new Pn())), o && (_.uv1 = du.getInterpolatedAttribute(o, p, f, v, E, new Pn())), l && (_.normal = du.getInterpolatedAttribute(l, p, f, v, E, new Ue()), _.normal.dot(n.direction) > 0 && _.normal.multiplyScalar(-1));
    const A = {
      a: p,
      b: f,
      c: v,
      normal: new Ue(),
      materialIndex: 0
    };
    du.getNormal(RN, IN, NN, A.normal), _.face = A, _.barycoord = E;
  }
  return _;
}
class dG extends L6 {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = -1, t = 1, n = 1, i = -1, o = 0.1, l = 2e3) {
    super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = o, this.far = l, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(e, t, n, i, o, l) {
    this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom), t = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, i = (this.top + this.bottom) / 2;
    let o = n - e, l = n + e, p = i + t, f = i - t;
    if (this.view !== null && this.view.enabled) {
      const v = (this.right - this.left) / this.view.fullWidth / this.zoom, _ = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      o += v * this.view.offsetX, l = o + v * this.view.width, p -= _ * this.view.offsetY, f = p - _ * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(o, l, p, f, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t;
  }
}
const z5 = /* @__PURE__ */ new dG(-1, 1, 1, -1, 0, 1);
class ODe extends Zd {
  /**
   * Constructs a new quad geometry.
   *
   * @param {boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
   */
  constructor(e = !1) {
    super();
    const t = e === !1 ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
    this.setAttribute("position", new vo([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new vo(t, 2));
  }
}
const DDe = /* @__PURE__ */ new ODe();
class hG extends Yd {
  /**
   * Constructs a new quad mesh.
   *
   * @param {?Material} [material=null] - The material to render the quad mesh with.
   */
  constructor(e = null) {
    super(DDe, e), this.camera = z5, this.isQuadMesh = !0;
  }
  /**
   * Async version of `render()`.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(e) {
    return e.renderAsync(this, z5);
  }
  /**
   * Renders the quad mesh
   *
   * @param {Renderer} renderer - The renderer.
   */
  render(e) {
    e.render(this, z5);
  }
}
const d2 = 1 / 6, O0e = (c) => On(d2, On(c, On(c, c.negate().add(3)).sub(3)).add(1)), d6 = (c) => On(d2, On(c, On(c, On(3, c).sub(6))).add(4)), D0e = (c) => On(d2, On(c, On(c, On(-3, c).add(3)).add(3)).add(1)), h6 = (c) => On(d2, r2(c, 3)), Wfe = (c) => O0e(c).add(d6(c)), Kfe = (c) => D0e(c).add(h6(c)), Yfe = (c) => xo(-1, d6(c).div(O0e(c).add(d6(c)))), Xfe = (c) => xo(1, h6(c).div(D0e(c).add(h6(c)))), Qfe = (c, e, t) => {
  const n = c.uvNode, i = On(n, e.zw).add(0.5), o = Eg(i), l = rf(i), p = Wfe(l.x), f = Kfe(l.x), v = Yfe(l.x), _ = Xfe(l.x), E = Yfe(l.y), A = Xfe(l.y), I = xt(o.x.add(v), o.y.add(E)).sub(0.5).mul(e.xy), j = xt(o.x.add(_), o.y.add(E)).sub(0.5).mul(e.xy), q = xt(o.x.add(v), o.y.add(A)).sub(0.5).mul(e.xy), L = xt(o.x.add(_), o.y.add(A)).sub(0.5).mul(e.xy), V = Wfe(l.y).mul(xo(p.mul(c.sample(I).level(t)), f.mul(c.sample(j).level(t)))), re = Kfe(l.y).mul(xo(p.mul(c.sample(q).level(t)), f.mul(c.sample(L).level(t))));
  return V.add(re);
}, FDe = /* @__PURE__ */ at(([c, e = et(3)]) => {
  const t = xt(c.size(Nr(e))), n = xt(c.size(Nr(e.add(1)))), i = Sc(1, t), o = Sc(1, n), l = Qfe(c, gn(i, t), Eg(e)), p = Qfe(c, gn(o, n), Q6(e));
  return rf(e).mix(l, p);
}), Bw = /* @__PURE__ */ new hl(), V5 = /* @__PURE__ */ new Pr();
class Wo extends yn {
  static get type() {
    return "SceneNode";
  }
  /**
   * Constructs a new scene node.
   *
   * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
   * @param {?Scene} [scene=null] - A reference to the scene.
   */
  constructor(e = Wo.BACKGROUND_BLURRINESS, t = null) {
    super(), this.scope = e, this.scene = t;
  }
  /**
   * Depending on the scope, the method returns a different type of node that represents
   * the respective scene property.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The output node.
   */
  setup(e) {
    const t = this.scope, n = this.scene !== null ? this.scene : e.scene;
    let i;
    return t === Wo.BACKGROUND_BLURRINESS ? i = Cr("backgroundBlurriness", "float", n) : t === Wo.BACKGROUND_INTENSITY ? i = Cr("backgroundIntensity", "float", n) : t === Wo.BACKGROUND_ROTATION ? i = on("mat4").label("backgroundRotation").setGroup(sn).onRenderUpdate(() => {
      const o = n.background;
      return o !== null && o.isTexture && o.mapping !== P6 ? (Bw.copy(n.backgroundRotation), Bw.x *= -1, Bw.y *= -1, Bw.z *= -1, V5.makeRotationFromEuler(Bw)) : V5.identity(), V5;
    }) : console.error("THREE.SceneNode: Unknown scope:", t), i;
  }
}
Wo.BACKGROUND_BLURRINESS = "backgroundBlurriness";
Wo.BACKGROUND_INTENSITY = "backgroundIntensity";
Wo.BACKGROUND_ROTATION = "backgroundRotation";
const BDe = /* @__PURE__ */ bt(Wo, Wo.BACKGROUND_BLURRINESS), Zfe = /* @__PURE__ */ bt(Wo, Wo.BACKGROUND_INTENSITY), LDe = /* @__PURE__ */ bt(Wo, Wo.BACKGROUND_ROTATION), jDe = at(({ texture: c, uv: e }) => {
  const n = tt().toVar();
  return _i(e.x.lessThan(1e-4), () => {
    n.assign(tt(1, 0, 0));
  }).ElseIf(e.y.lessThan(1e-4), () => {
    n.assign(tt(0, 1, 0));
  }).ElseIf(e.z.lessThan(1e-4), () => {
    n.assign(tt(0, 0, 1));
  }).ElseIf(e.x.greaterThan(1 - 1e-4), () => {
    n.assign(tt(-1, 0, 0));
  }).ElseIf(e.y.greaterThan(1 - 1e-4), () => {
    n.assign(tt(0, -1, 0));
  }).ElseIf(e.z.greaterThan(1 - 1e-4), () => {
    n.assign(tt(0, 0, -1));
  }).Else(() => {
    const o = c.sample(e.add(tt(-0.01, 0, 0))).r.sub(c.sample(e.add(tt(0.01, 0, 0))).r), l = c.sample(e.add(tt(0, -0.01, 0))).r.sub(c.sample(e.add(tt(0, 0.01, 0))).r), p = c.sample(e.add(tt(0, 0, -0.01))).r.sub(c.sample(e.add(tt(0, 0, 0.01))).r);
    n.assign(tt(o, l, p));
  }), n.normalize();
});
class UDe extends Qb {
  static get type() {
    return "Texture3DNode";
  }
  /**
   * Constructs a new 3D texture node.
   *
   * @param {Data3DTexture} value - The 3D texture.
   * @param {?Node<vec2|vec3>} [uvNode=null] - The uv node.
   * @param {?Node<int>} [levelNode=null] - The level node.
   */
  constructor(e, t = null, n = null) {
    super(e, t, n), this.isTexture3DNode = !0;
  }
  /**
   * Overwrites the default implementation to return a fixed value `'texture3D'`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType() {
    return "texture3D";
  }
  /**
   * Returns a default uv node which is in context of 3D textures a three-dimensional
   * uv node.
   *
   * @return {Node<vec3>} The default uv node.
   */
  getDefaultUV() {
    return tt(0.5, 0.5, 0.5);
  }
  /**
   * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
   * for 3D textures. The uv transformation matrix is not applied to 3D textures.
   *
   * @param {boolean} value - The update toggle.
   */
  setUpdateMatrix() {
  }
  // Ignore .updateMatrix for 3d TextureNode
  /**
   * Overwrites the default implementation to return the unmodified uv node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to setup.
   * @return {Node} The unmodified uv node.
   */
  setupUV(e, t) {
    const n = this.value;
    return e.isFlipY() && (n.isRenderTargetTexture === !0 || n.isFramebufferTexture === !0) && (this.sampler ? t = t.flipY() : t = t.setY(Nr(Lb(this, this.levelNode).y).sub(t.y).sub(1))), t;
  }
  /**
   * Generates the uv code snippet.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @param {Node} uvNode - The uv node to generate code for.
   * @return {string} The generated code snippet.
   */
  generateUV(e, t) {
    return t.build(e, "vec3");
  }
  /**
   * TODO.
   *
   * @param {Node<vec3>} uvNode - The uv node .
   * @return {Node<vec3>} TODO.
   */
  normal(e) {
    return jDe({ texture: this, uv: e });
  }
}
const zDe = /* @__PURE__ */ lt(UDe).setParameterLength(1, 3), BN = /* @__PURE__ */ new Pn();
class VDe extends Qb {
  static get type() {
    return "PassTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {Texture} texture - The output texture.
   */
  constructor(e, t) {
    super(t), this.passNode = e, this.setUpdateMatrix(!1);
  }
  setup(e) {
    return e.object.isQuadMesh && this.passNode.build(e), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.value);
  }
}
class Jfe extends VDe {
  static get type() {
    return "PassMultipleTextureNode";
  }
  /**
   * Constructs a new pass texture node.
   *
   * @param {PassNode} passNode - The pass node.
   * @param {string} textureName - The output texture name.
   * @param {boolean} [previousTexture=false] - Whether previous frame data should be used or not.
   */
  constructor(e, t, n = !1) {
    super(e, null), this.textureName = t, this.previousTexture = n;
  }
  /**
   * Updates the texture reference of this node.
   */
  updateTexture() {
    this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
  }
  setup(e) {
    return this.updateTexture(), super.setup(e);
  }
  clone() {
    return new this.constructor(this.passNode, this.textureName, this.previousTexture);
  }
}
class h2 extends Oi {
  static get type() {
    return "PassNode";
  }
  /**
   * Constructs a new pass node.
   *
   * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   */
  constructor(e, t, n, i = {}) {
    super("vec4"), this.scope = e, this.scene = t, this.camera = n, this.options = i, this._pixelRatio = 1, this._width = 1, this._height = 1;
    const o = new _c();
    o.isRenderTargetTexture = !0, o.name = "depth";
    const l = new Mg(this._width * this._pixelRatio, this._height * this._pixelRatio, { type: ol, ...i });
    l.texture.name = "output", l.depthTexture = o, this.renderTarget = l, this._textures = {
      output: l.texture,
      depth: o
    }, this._textureNodes = {}, this._linearDepthNodes = {}, this._viewZNodes = {}, this._previousTextures = {}, this._previousTextureNodes = {}, this._cameraNear = on(0), this._cameraFar = on(0), this._mrt = null, this._layers = null, this._resolution = 1, this.isPassNode = !0, this.updateBeforeType = In.FRAME, this.global = !0;
  }
  /**
   * Sets the resolution for the pass.
   * The resolution is a factor that is multiplied with the renderer's width and height.
   *
   * @param {number} resolution - The resolution to set. A value of `1` means full resolution.
   * @return {PassNode} A reference to this pass.
   */
  setResolution(e) {
    return this._resolution = e, this;
  }
  /**
   * Gets the current resolution of the pass.
   *
   * @return {number} The current resolution. A value of `1` means full resolution.
   * @default 1
   */
  getResolution() {
    return this._resolution;
  }
  setLayers(e) {
    return this._layers = e, this;
  }
  getLayers() {
    return this._layers;
  }
  /**
   * Sets the given MRT node to setup MRT for this pass.
   *
   * @param {MRTNode} mrt - The MRT object.
   * @return {PassNode} A reference to this pass.
   */
  setMRT(e) {
    return this._mrt = e, this;
  }
  /**
   * Returns the current MRT node.
   *
   * @return {MRTNode} The current MRT node.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the texture for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture.
   */
  getTexture(e) {
    let t = this._textures[e];
    return t === void 0 && (t = this.renderTarget.texture.clone(), t.name = e, this._textures[e] = t, this.renderTarget.textures.push(t)), t;
  }
  /**
   * Returns the texture holding the data of the previous frame for the given output name.
   *
   * @param {string} name - The output name to get the texture for.
   * @return {Texture} The texture holding the data of the previous frame.
   */
  getPreviousTexture(e) {
    let t = this._previousTextures[e];
    return t === void 0 && (t = this.getTexture(e).clone(), this._previousTextures[e] = t), t;
  }
  /**
   * Switches current and previous textures for the given output name.
   *
   * @param {string} name - The output name.
   */
  toggleTexture(e) {
    const t = this._previousTextures[e];
    if (t !== void 0) {
      const n = this._textures[e], i = this.renderTarget.textures.indexOf(n);
      this.renderTarget.textures[i] = t, this._textures[e] = t, this._previousTextures[e] = n, this._textureNodes[e].updateTexture(), this._previousTextureNodes[e].updateTexture();
    }
  }
  /**
   * Returns the texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the texture node for.
   * @return {TextureNode} The texture node.
   */
  getTextureNode(e = "output") {
    let t = this._textureNodes[e];
    return t === void 0 && (t = ct(new Jfe(this, e)), t.updateTexture(), this._textureNodes[e] = t), t;
  }
  /**
   * Returns the previous texture node for the given output name.
   *
   * @param {string} [name='output'] - The output name to get the previous texture node for.
   * @return {TextureNode} The previous texture node.
   */
  getPreviousTextureNode(e = "output") {
    let t = this._previousTextureNodes[e];
    return t === void 0 && (this._textureNodes[e] === void 0 && this.getTextureNode(e), t = ct(new Jfe(this, e, !0)), t.updateTexture(), this._previousTextureNodes[e] = t), t;
  }
  /**
   * Returns a viewZ node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The viewZ node.
   */
  getViewZNode(e = "depth") {
    let t = this._viewZNodes[e];
    if (t === void 0) {
      const n = this._cameraNear, i = this._cameraFar;
      this._viewZNodes[e] = t = E0e(this.getTextureNode(e), n, i);
    }
    return t;
  }
  /**
   * Returns a linear depth node of this pass.
   *
   * @param {string} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
   * @return {Node} The linear depth node.
   */
  getLinearDepthNode(e = "depth") {
    let t = this._linearDepthNodes[e];
    if (t === void 0) {
      const n = this._cameraNear, i = this._cameraFar, o = this.getViewZNode(e);
      this._linearDepthNodes[e] = t = vE(o, n, i);
    }
    return t;
  }
  setup({ renderer: e }) {
    return this.renderTarget.samples = this.options.samples === void 0 ? e.samples : this.options.samples, e.backend.isWebGLBackend === !0 && (this.renderTarget.samples = 0), this.renderTarget.texture.type = e.getColorBufferType(), this.scope === h2.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
  }
  updateBefore(e) {
    const { renderer: t } = e, { scene: n } = this;
    let i, o;
    const l = t.getOutputRenderTarget();
    l && l.isXRRenderTarget === !0 ? (o = 1, i = t.xr.getCamera(), t.xr.updateCamera(i), BN.set(l.width, l.height)) : (i = this.camera, o = t.getPixelRatio(), t.getSize(BN)), this._pixelRatio = o, this.setSize(BN.width, BN.height);
    const p = t.getRenderTarget(), f = t.getMRT(), v = i.layers.mask;
    this._cameraNear.value = i.near, this._cameraFar.value = i.far, this._layers !== null && (i.layers.mask = this._layers.mask);
    for (const _ in this._previousTextures)
      this.toggleTexture(_);
    t.setRenderTarget(this.renderTarget), t.setMRT(this._mrt), t.render(n, i), t.setRenderTarget(p), t.setMRT(f), i.layers.mask = v;
  }
  /**
   * Sets the size of the pass's render target. Honors the pixel ratio.
   *
   * @param {number} width - The width to set.
   * @param {number} height - The height to set.
   */
  setSize(e, t) {
    this._width = e, this._height = t;
    const n = this._width * this._pixelRatio * this._resolution, i = this._height * this._pixelRatio * this._resolution;
    this.renderTarget.setSize(n, i);
  }
  /**
   * Sets the pixel ratio the pass's render target and updates the size.
   *
   * @param {number} pixelRatio - The pixel ratio to set.
   */
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  /**
   * Frees internal resources. Should be called when the node is no longer in use.
   */
  dispose() {
    this.renderTarget.dispose();
  }
}
h2.COLOR = "color";
h2.DEPTH = "depth";
const GDe = /* @__PURE__ */ at(([c, e]) => c.mul(e).clamp()).setLayout({
  name: "linearToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), qDe = /* @__PURE__ */ at(([c, e]) => (c = c.mul(e), c.div(c.add(1)).clamp())).setLayout({
  name: "reinhardToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), HDe = /* @__PURE__ */ at(([c, e]) => {
  c = c.mul(e), c = c.sub(4e-3).max(0);
  const t = c.mul(c.mul(6.2).add(0.5)), n = c.mul(c.mul(6.2).add(1.7)).add(0.06);
  return t.div(n).pow(2.2);
}).setLayout({
  name: "cineonToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), $De = /* @__PURE__ */ at(([c]) => {
  const e = c.mul(c.add(0.0245786)).sub(90537e-9), t = c.mul(c.add(0.432951).mul(0.983729)).add(0.238081);
  return e.div(t);
}), WDe = /* @__PURE__ */ at(([c, e]) => {
  const t = bo(
    0.59719,
    0.35458,
    0.04823,
    0.076,
    0.90834,
    0.01566,
    0.0284,
    0.13383,
    0.83777
  ), n = bo(
    1.60475,
    -0.53108,
    -0.07367,
    -0.10208,
    1.10813,
    -605e-5,
    -327e-5,
    -0.07276,
    1.07602
  );
  return c = c.mul(e).div(0.6), c = t.mul(c), c = $De(c), c = n.mul(c), c.clamp();
}).setLayout({
  name: "acesFilmicToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), KDe = /* @__PURE__ */ bo(tt(1.6605, -0.1246, -0.0182), tt(-0.5876, 1.1329, -0.1006), tt(-0.0728, -83e-4, 1.1187)), YDe = /* @__PURE__ */ bo(tt(0.6274, 0.0691, 0.0164), tt(0.3293, 0.9195, 0.088), tt(0.0433, 0.0113, 0.8956)), XDe = /* @__PURE__ */ at(([c]) => {
  const e = tt(c).toVar(), t = tt(e.mul(e)).toVar(), n = tt(t.mul(t)).toVar();
  return et(15.5).mul(n.mul(t)).sub(On(40.14, n.mul(e))).add(On(31.96, n).sub(On(6.868, t.mul(e))).add(On(0.4298, t).add(On(0.1191, e).sub(232e-5))));
}), QDe = /* @__PURE__ */ at(([c, e]) => {
  const t = tt(c).toVar(), n = bo(tt(0.856627153315983, 0.137318972929847, 0.11189821299995), tt(0.0951212405381588, 0.761241990602591, 0.0767994186031903), tt(0.0482516061458583, 0.101439036467562, 0.811302368396859)), i = bo(tt(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), tt(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), tt(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405)), o = et(-12.47393), l = et(4.026069);
  return t.mulAssign(e), t.assign(YDe.mul(t)), t.assign(n.mul(t)), t.assign(eo(t, 1e-10)), t.assign(Gd(t)), t.assign(t.sub(o).div(l.sub(o))), t.assign(Kd(t, 0, 1)), t.assign(XDe(t)), t.assign(i.mul(t)), t.assign(r2(eo(tt(0), t), tt(2.2))), t.assign(KDe.mul(t)), t.assign(Kd(t, 0, 1)), t;
}).setLayout({
  name: "agxToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
}), ZDe = /* @__PURE__ */ at(([c, e]) => {
  const t = et(0.76), n = et(0.15);
  c = c.mul(e);
  const i = Hb(c.r, Hb(c.g, c.b)), o = Zs(i.lessThan(0.08), i.sub(On(6.25, i.mul(i))), 0.04);
  c.subAssign(o);
  const l = eo(c.r, eo(c.g, c.b));
  _i(l.lessThan(t), () => c);
  const p = mo(1, t), f = mo(1, p.mul(p).div(l.add(p.sub(t))));
  c.mulAssign(f.div(l));
  const v = mo(1, Sc(1, n.mul(l.sub(f)).add(1)));
  return Vr(c, tt(f), v);
}).setLayout({
  name: "neutralToneMapping",
  type: "vec3",
  inputs: [
    { name: "color", type: "vec3" },
    { name: "exposure", type: "float" }
  ]
});
class qi extends yn {
  static get type() {
    return "CodeNode";
  }
  /**
   * Constructs a new code node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(e = "", t = [], n = "") {
    super("code"), this.isCodeNode = !0, this.global = !0, this.code = e, this.includes = t, this.language = n;
  }
  /**
   * Sets the includes of this code node.
   *
   * @param {Array<Node>} includes - The includes to set.
   * @return {CodeNode} A reference to this node.
   */
  setIncludes(e) {
    return this.includes = e, this;
  }
  /**
   * Returns the includes of this code node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<Node>} The includes.
   */
  getIncludes() {
    return this.includes;
  }
  generate(e) {
    const t = this.getIncludes(e);
    for (const i of t)
      i.build(e);
    const n = e.getCodeFromNode(this, this.getNodeType(e));
    return n.code = this.code, n.code;
  }
  serialize(e) {
    super.serialize(e), e.code = this.code, e.language = this.language;
  }
  deserialize(e) {
    super.deserialize(e), this.code = e.code, this.language = e.language;
  }
}
class JDe extends qi {
  static get type() {
    return "FunctionNode";
  }
  /**
   * Constructs a new function node.
   *
   * @param {string} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   */
  constructor(e = "", t = [], n = "") {
    super(e, t, n);
  }
  getNodeType(e) {
    return this.getNodeFunction(e).type;
  }
  /**
   * Returns the inputs of this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Array<NodeFunctionInput>} The inputs.
   */
  getInputs(e) {
    return this.getNodeFunction(e).inputs;
  }
  /**
   * Returns the node function for this function node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {NodeFunction} The node function.
   */
  getNodeFunction(e) {
    const t = e.getDataFromNode(this);
    let n = t.nodeFunction;
    return n === void 0 && (n = e.parser.parseFunction(this.code), t.nodeFunction = n), n;
  }
  generate(e, t) {
    super.generate(e);
    const n = this.getNodeFunction(e), i = n.name, o = n.type, l = e.getCodeFromNode(this, o);
    i !== "" && (l.name = i);
    const p = e.getPropertyName(l), f = this.getNodeFunction(e).getCode(p);
    return l.code = f + `
`, t === "property" ? p : e.format(`${p}()`, o, t);
  }
}
function F0e(c) {
  let e;
  const t = c.context.getViewZ;
  return t !== void 0 && (e = t(this)), (e || Ii.z).negate();
}
const eFe = at(([c, e], t) => {
  const n = F0e(t);
  return ef(c, e, n);
}), tFe = at(([c], e) => {
  const t = F0e(e);
  return c.mul(c, t, t).negate().exp().oneMinus();
}), eme = at(([c, e]) => gn(e.toFloat().mix(gE.rgb, c.toVec3()), gE.a));
class nFe extends yn {
  /**
   * Constructs a new barrier node.
   *
   * @param {string} scope - The scope defines the behavior of the node.
   */
  constructor(e) {
    super(), this.scope = e;
  }
  generate(e) {
    const { scope: t } = this, { renderer: n } = e;
    n.backend.isWebGLBackend === !0 ? e.addFlowCode(`	// ${t}Barrier 
`) : e.addLineFlowCode(`${t}Barrier()`, this);
  }
}
lt(nFe);
class Tc extends yn {
  static get type() {
    return "AtomicFunctionNode";
  }
  /**
   * Constructs a new atomic function node.
   *
   * @param {string} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   */
  constructor(e, t, n) {
    super("uint"), this.method = e, this.pointerNode = t, this.valueNode = n, this.parents = !0;
  }
  /**
   * Overwrites the default implementation to return the type of
   * the pointer node.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The input type.
   */
  getInputType(e) {
    return this.pointerNode.getNodeType(e);
  }
  /**
   * Overwritten since the node type is inferred from the input type.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {string} The node type.
   */
  getNodeType(e) {
    return this.getInputType(e);
  }
  generate(e) {
    const t = e.getNodeProperties(this), n = t.parents, i = this.method, o = this.getNodeType(e), l = this.getInputType(e), p = this.pointerNode, f = this.valueNode, v = [];
    v.push(`&${p.build(e, l)}`), f !== null && v.push(f.build(e, l));
    const _ = `${e.getMethod(i, o)}( ${v.join(", ")} )`;
    if (n.length === 1 && n[0].isStackNode === !0)
      e.addLineFlowCode(_, this);
    else
      return t.constNode === void 0 && (t.constNode = $b(_, o).toConst()), t.constNode.build(e);
  }
}
Tc.ATOMIC_LOAD = "atomicLoad";
Tc.ATOMIC_STORE = "atomicStore";
Tc.ATOMIC_ADD = "atomicAdd";
Tc.ATOMIC_SUB = "atomicSub";
Tc.ATOMIC_MAX = "atomicMax";
Tc.ATOMIC_MIN = "atomicMin";
Tc.ATOMIC_AND = "atomicAnd";
Tc.ATOMIC_OR = "atomicOr";
Tc.ATOMIC_XOR = "atomicXor";
lt(Tc);
let LN;
function p2(c) {
  LN = LN || /* @__PURE__ */ new WeakMap();
  let e = LN.get(c);
  return e === void 0 && LN.set(c, e = {}), e;
}
function B0e(c) {
  const e = p2(c);
  return e.shadowMatrix || (e.shadowMatrix = on("mat4").setGroup(sn).onRenderUpdate((t) => ((c.castShadow !== !0 || t.renderer.shadowMap.enabled === !1) && c.shadow.updateMatrices(c), c.shadow.matrix)));
}
function rFe(c, e = AE) {
  const t = B0e(c).mul(e);
  return t.xyz.div(t.w);
}
function L0e(c) {
  const e = p2(c);
  return e.position || (e.position = on(new Ue()).setGroup(sn).onRenderUpdate((t, n) => n.value.setFromMatrixPosition(c.matrixWorld)));
}
function iFe(c) {
  const e = p2(c);
  return e.targetPosition || (e.targetPosition = on(new Ue()).setGroup(sn).onRenderUpdate((t, n) => n.value.setFromMatrixPosition(c.target.matrixWorld)));
}
function j0e(c) {
  const e = p2(c);
  return e.viewPosition || (e.viewPosition = on(new Ue()).setGroup(sn).onRenderUpdate(({ camera: t }, n) => {
    n.value = n.value || new Ue(), n.value.setFromMatrixPosition(c.matrixWorld), n.value.applyMatrix4(t.matrixWorldInverse);
  }));
}
const U0e = (c) => Qd.transformDirection(L0e(c).sub(iFe(c))), sFe = (c) => c.sort((e, t) => e.id - t.id), oFe = (c, e) => {
  for (const t of e)
    if (t.isAnalyticLightNode && t.light.id === c)
      return t;
  return null;
}, G5 = /* @__PURE__ */ new WeakMap(), Lw = [];
class z0e extends yn {
  static get type() {
    return "LightsNode";
  }
  /**
   * Constructs a new lights node.
   */
  constructor() {
    super("vec3"), this.totalDiffuseNode = tt().toVar(), this.totalSpecularNode = tt().toVar(), this.outgoingLightNode = tt().toVar(), this._lights = [], this._lightNodes = null, this._lightNodesHash = null, this.global = !0;
  }
  /**
   * Overwrites the default {@link Node#customCacheKey} implementation by including
   * light data into the cache key.
   *
   * @return {number} The custom cache key.
   */
  customCacheKey() {
    const e = this._lights;
    for (let n = 0; n < e.length; n++) {
      const i = e[n];
      if (Lw.push(i.id), Lw.push(i.castShadow ? 1 : 0), i.isSpotLight === !0) {
        const o = i.map !== null ? i.map.id : -1, l = i.colorNode ? i.colorNode.getCacheKey() : -1;
        Lw.push(o, l);
      }
    }
    const t = F6(Lw);
    return Lw.length = 0, t;
  }
  /**
   * Computes a hash value for identifying the current light nodes setup.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {string} The computed hash.
   */
  getHash(e) {
    if (this._lightNodesHash === null) {
      this._lightNodes === null && this.setupLightsNode(e);
      const t = [];
      for (const n of this._lightNodes)
        t.push(n.getSelf().getHash());
      this._lightNodesHash = "lights-" + t.join(",");
    }
    return this._lightNodesHash;
  }
  analyze(e) {
    const t = e.getNodeProperties(this);
    for (const n of t.nodes)
      n.build(e);
    t.outputNode.build(e);
  }
  /**
   * Creates lighting nodes for each scene light. This makes it possible to further
   * process lights in the node system.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   */
  setupLightsNode(e) {
    const t = [], n = this._lightNodes, i = sFe(this._lights), o = e.renderer.library;
    for (const l of i)
      if (l.isNode)
        t.push(ct(l));
      else {
        let p = null;
        if (n !== null && (p = oFe(l.id, n)), p === null) {
          const f = o.getLightNodeClass(l.constructor);
          if (f === null) {
            console.warn(`LightsNode.setupNodeLights: Light node not found for ${l.constructor.name}`);
            continue;
          }
          let v = null;
          G5.has(l) ? v = G5.get(l) : (v = ct(new f(l)), G5.set(l, v)), t.push(v);
        }
      }
    this._lightNodes = t;
  }
  /**
   * Sets up a direct light in the lighting model.
   *
   * @param {Object} builder - The builder object containing the context and stack.
   * @param {Object} lightNode - The light node.
   * @param {Object} lightData - The light object containing color and direction properties.
   */
  setupDirectLight(e, t, n) {
    const { lightingModel: i, reflectedLight: o } = e.context;
    i.direct({
      ...n,
      lightNode: t,
      reflectedLight: o
    }, e);
  }
  setupDirectRectAreaLight(e, t, n) {
    const { lightingModel: i, reflectedLight: o } = e.context;
    i.directRectArea({
      ...n,
      lightNode: t,
      reflectedLight: o
    }, e);
  }
  /**
   * Setups the internal lights by building all respective
   * light nodes.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
   */
  setupLights(e, t) {
    for (const n of t)
      n.build(e);
  }
  getLightNodes(e) {
    return this._lightNodes === null && this.setupLightsNode(e), this._lightNodes;
  }
  /**
   * The implementation makes sure that for each light in the scene
   * there is a corresponding light node. By building the light nodes
   * and evaluating the lighting model the outgoing light is computed.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} A node representing the outgoing light.
   */
  setup(e) {
    const t = e.lightsNode;
    e.lightsNode = this;
    let n = this.outgoingLightNode;
    const i = e.context, o = i.lightingModel, l = e.getNodeProperties(this);
    if (o) {
      const { totalDiffuseNode: p, totalSpecularNode: f } = this;
      i.outgoingLight = n;
      const v = e.addStack();
      l.nodes = v.nodes, o.start(e);
      const { backdrop: _, backdropAlpha: E } = i, { directDiffuse: A, directSpecular: I, indirectDiffuse: j, indirectSpecular: q } = i.reflectedLight;
      let L = A.add(j);
      _ !== null && (E !== null ? L = tt(E.mix(L, _)) : L = tt(_), i.material.transparent = !0), p.assign(L), f.assign(I.add(q)), n.assign(p.add(f)), o.finish(e), n = n.bypass(e.removeStack());
    } else
      l.nodes = [];
    return e.lightsNode = t, n;
  }
  /**
   * Configures this node with an array of lights.
   *
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} A reference to this node.
   */
  setLights(e) {
    return this._lights = e, this._lightNodes = null, this._lightNodesHash = null, this;
  }
  /**
   * Returns an array of the scene's lights.
   *
   * @return {Array<Light>} The scene's lights.
   */
  getLights() {
    return this._lights;
  }
  /**
   * Whether the scene has lights or not.
   *
   * @type {boolean}
   */
  get hasLights() {
    return this._lights.length > 0;
  }
}
class aFe extends yn {
  static get type() {
    return "ShadowBaseNode";
  }
  /**
   * Constructs a new shadow base node.
   *
   * @param {Light} light - The shadow casting light.
   */
  constructor(e) {
    super(), this.light = e, this.updateBeforeType = In.RENDER, this.isShadowBaseNode = !0;
  }
  /**
   * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
   *
   * @param {NodeBuilder} object - A configuration object that must at least hold a material reference.
   */
  setupShadowPosition({ context: e, material: t }) {
    V0e.assign(t.receivedShadowPositionNode || e.shadowPositionWorld || AE);
  }
}
const V0e = /* @__PURE__ */ zye("vec3", "shadowPositionWorld");
function lFe(c, e = {}) {
  return e.toneMapping = c.toneMapping, e.toneMappingExposure = c.toneMappingExposure, e.outputColorSpace = c.outputColorSpace, e.renderTarget = c.getRenderTarget(), e.activeCubeFace = c.getActiveCubeFace(), e.activeMipmapLevel = c.getActiveMipmapLevel(), e.renderObjectFunction = c.getRenderObjectFunction(), e.pixelRatio = c.getPixelRatio(), e.mrt = c.getMRT(), e.clearColor = c.getClearColor(e.clearColor || new er()), e.clearAlpha = c.getClearAlpha(), e.autoClear = c.autoClear, e.scissorTest = c.getScissorTest(), e;
}
function uFe(c, e) {
  return e = lFe(c, e), c.setMRT(null), c.setRenderObjectFunction(null), c.setClearColor(0, 1), c.autoClear = !0, e;
}
function cFe(c, e) {
  c.toneMapping = e.toneMapping, c.toneMappingExposure = e.toneMappingExposure, c.outputColorSpace = e.outputColorSpace, c.setRenderTarget(e.renderTarget, e.activeCubeFace, e.activeMipmapLevel), c.setRenderObjectFunction(e.renderObjectFunction), c.setPixelRatio(e.pixelRatio), c.setMRT(e.mrt), c.setClearColor(e.clearColor, e.clearAlpha), c.autoClear = e.autoClear, c.setScissorTest(e.scissorTest);
}
function dFe(c, e = {}) {
  return e.background = c.background, e.backgroundNode = c.backgroundNode, e.overrideMaterial = c.overrideMaterial, e;
}
function hFe(c, e) {
  return e = dFe(c, e), c.background = null, c.backgroundNode = null, c.overrideMaterial = null, e;
}
function pFe(c, e) {
  c.background = e.background, c.backgroundNode = e.backgroundNode, c.overrideMaterial = e.overrideMaterial;
}
function fFe(c, e, t) {
  return t = uFe(c, t), t = hFe(e, t), t;
}
function mFe(c, e, t) {
  cFe(c, t), pFe(e, t);
}
const tme = /* @__PURE__ */ new WeakMap(), gFe = /* @__PURE__ */ at(({ depthTexture: c, shadowCoord: e, depthLayer: t }) => {
  let n = Wn(c, e.xy).label("t_basic");
  return c.isArrayTexture && (n = n.depth(t)), n.compare(e.z);
}), yFe = /* @__PURE__ */ at(({ depthTexture: c, shadowCoord: e, shadow: t, depthLayer: n }) => {
  const i = (L, V) => {
    let re = Wn(c, L);
    return c.isArrayTexture && (re = re.depth(n)), re.compare(V);
  }, o = Cr("mapSize", "vec2", t).setGroup(sn), l = Cr("radius", "float", t).setGroup(sn), p = xt(1).div(o), f = p.x.negate().mul(l), v = p.y.negate().mul(l), _ = p.x.mul(l), E = p.y.mul(l), A = f.div(2), I = v.div(2), j = _.div(2), q = E.div(2);
  return xo(
    i(e.xy.add(xt(f, v)), e.z),
    i(e.xy.add(xt(0, v)), e.z),
    i(e.xy.add(xt(_, v)), e.z),
    i(e.xy.add(xt(A, I)), e.z),
    i(e.xy.add(xt(0, I)), e.z),
    i(e.xy.add(xt(j, I)), e.z),
    i(e.xy.add(xt(f, 0)), e.z),
    i(e.xy.add(xt(A, 0)), e.z),
    i(e.xy, e.z),
    i(e.xy.add(xt(j, 0)), e.z),
    i(e.xy.add(xt(_, 0)), e.z),
    i(e.xy.add(xt(A, q)), e.z),
    i(e.xy.add(xt(0, q)), e.z),
    i(e.xy.add(xt(j, q)), e.z),
    i(e.xy.add(xt(f, E)), e.z),
    i(e.xy.add(xt(0, E)), e.z),
    i(e.xy.add(xt(_, E)), e.z)
  ).mul(1 / 17);
}), vFe = /* @__PURE__ */ at(({ depthTexture: c, shadowCoord: e, shadow: t, depthLayer: n }) => {
  const i = (E, A) => {
    let I = Wn(c, E);
    return c.isArrayTexture && (I = I.depth(n)), I.compare(A);
  }, o = Cr("mapSize", "vec2", t).setGroup(sn), l = xt(1).div(o), p = l.x, f = l.y, v = e.xy, _ = rf(v.mul(o).add(0.5));
  return v.subAssign(_.mul(l)), xo(
    i(v, e.z),
    i(v.add(xt(p, 0)), e.z),
    i(v.add(xt(0, f)), e.z),
    i(v.add(l), e.z),
    Vr(
      i(v.add(xt(p.negate(), 0)), e.z),
      i(v.add(xt(p.mul(2), 0)), e.z),
      _.x
    ),
    Vr(
      i(v.add(xt(p.negate(), f)), e.z),
      i(v.add(xt(p.mul(2), f)), e.z),
      _.x
    ),
    Vr(
      i(v.add(xt(0, f.negate())), e.z),
      i(v.add(xt(0, f.mul(2))), e.z),
      _.y
    ),
    Vr(
      i(v.add(xt(p, f.negate())), e.z),
      i(v.add(xt(p, f.mul(2))), e.z),
      _.y
    ),
    Vr(
      Vr(
        i(v.add(xt(p.negate(), f.negate())), e.z),
        i(v.add(xt(p.mul(2), f.negate())), e.z),
        _.x
      ),
      Vr(
        i(v.add(xt(p.negate(), f.mul(2))), e.z),
        i(v.add(xt(p.mul(2), f.mul(2))), e.z),
        _.x
      ),
      _.y
    )
  ).mul(1 / 9);
}), bFe = /* @__PURE__ */ at(({ depthTexture: c, shadowCoord: e, depthLayer: t }) => {
  const n = et(1).toVar();
  let i = Wn(c).sample(e.xy);
  c.isArrayTexture && (i = i.depth(t)), i = i.rg;
  const o = t0e(e.z, i.x);
  return _i(o.notEqual(et(1)), () => {
    const l = e.z.sub(i.x), p = eo(0, i.y.mul(i.y));
    let f = p.div(p.add(l.mul(l)));
    f = Kd(mo(f, 0.3).div(0.95 - 0.3)), n.assign(Kd(eo(o, f)));
  }), n;
}), xFe = /* @__PURE__ */ at(([c, e, t]) => {
  let n = AE.sub(c).length();
  return n = n.sub(e).div(t.sub(e)), n = n.saturate(), n;
}), _Fe = (c) => {
  const e = c.shadow.camera, t = Cr("near", "float", e).setGroup(sn), n = Cr("far", "float", e).setGroup(sn), i = OOe(c);
  return xFe(i, t, n);
}, SFe = (c) => {
  let e = tme.get(c);
  if (e === void 0) {
    const t = c.isPointLight ? _Fe(c) : null;
    e = new Ni(), e.colorNode = gn(0, 0, 0, 1), e.depthNode = t, e.isShadowPassMaterial = !0, e.name = "ShadowMaterial", e.fog = !1, tme.set(c, e);
  }
  return e;
}, nme = /* @__PURE__ */ new hu(), ub = [], wFe = (c, e, t, n) => {
  ub[0] = c, ub[1] = e;
  let i = nme.get(ub);
  return (i === void 0 || i.shadowType !== t || i.useVelocity !== n) && (i = (o, l, p, f, v, _, ...E) => {
    (o.castShadow === !0 || o.receiveShadow && t === dO) && (n && (Cye(o).useVelocity = !0), o.onBeforeShadow(c, o, p, e.camera, f, l.overrideMaterial, _), c.renderObject(o, l, p, f, v, _, ...E), o.onAfterShadow(c, o, p, e.camera, f, l.overrideMaterial, _));
  }, i.shadowType = t, i.useVelocity = n, nme.set(ub, i)), ub[0] = null, ub[1] = null, i;
}, EFe = /* @__PURE__ */ at(({ samples: c, radius: e, size: t, shadowPass: n, depthLayer: i }) => {
  const o = et(0).toVar("meanVertical"), l = et(0).toVar("squareMeanVertical"), p = c.lessThanEqual(et(1)).select(et(0), et(2).div(c.sub(1))), f = c.lessThanEqual(et(1)).select(et(0), et(-1));
  cu({ start: Nr(0), end: Nr(c), type: "int", condition: "<" }, ({ i: _ }) => {
    const E = f.add(et(_).mul(p));
    let A = n.sample(xo(u2.xy, xt(0, E).mul(e)).div(t));
    n.value.isArrayTexture && (A = A.depth(i)), A = A.x, o.addAssign(A), l.addAssign(A.mul(A));
  }), o.divAssign(c), l.divAssign(c);
  const v = X6(l.sub(o.mul(o)));
  return xt(o, v);
}), TFe = /* @__PURE__ */ at(({ samples: c, radius: e, size: t, shadowPass: n, depthLayer: i }) => {
  const o = et(0).toVar("meanHorizontal"), l = et(0).toVar("squareMeanHorizontal"), p = c.lessThanEqual(et(1)).select(et(0), et(2).div(c.sub(1))), f = c.lessThanEqual(et(1)).select(et(0), et(-1));
  cu({ start: Nr(0), end: Nr(c), type: "int", condition: "<" }, ({ i: _ }) => {
    const E = f.add(et(_).mul(p));
    let A = n.sample(xo(u2.xy, xt(E, 0).mul(e)).div(t));
    n.value.isArrayTexture && (A = A.depth(i)), o.addAssign(A.x), l.addAssign(xo(A.y.mul(A.y), A.x.mul(A.x)));
  }), o.divAssign(c), l.divAssign(c);
  const v = X6(l.sub(o.mul(o)));
  return xt(o, v);
}), CFe = [gFe, yFe, vFe, bFe];
let q5;
const jN = /* @__PURE__ */ new hG();
class G0e extends aFe {
  static get type() {
    return "ShadowNode";
  }
  /**
   * Constructs a new shadow node.
   *
   * @param {Light} light - The shadow casting light.
   * @param {?LightShadow} [shadow=null] - An optional light shadow.
   */
  constructor(e, t = null) {
    super(e), this.shadow = t || e.shadow, this.shadowMap = null, this.vsmShadowMapVertical = null, this.vsmShadowMapHorizontal = null, this.vsmMaterialVertical = null, this.vsmMaterialHorizontal = null, this._node = null, this._cameraFrameId = /* @__PURE__ */ new WeakMap(), this.isShadowNode = !0, this.depthLayer = 0;
  }
  /**
   * Setups the shadow filtering.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(e, { filterFn: t, depthTexture: n, shadowCoord: i, shadow: o, depthLayer: l }) {
    const p = i.x.greaterThanEqual(0).and(i.x.lessThanEqual(1)).and(i.y.greaterThanEqual(0)).and(i.y.lessThanEqual(1)).and(i.z.lessThanEqual(1)), f = t({ depthTexture: n, shadowCoord: i, shadow: o, depthLayer: l });
    return p.select(f, et(1));
  }
  /**
   * Setups the shadow coordinates.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(e, t) {
    const { shadow: n } = this, { renderer: i } = e, o = Cr("bias", "float", n).setGroup(sn);
    let l = t, p;
    if (n.camera.isOrthographicCamera || i.logarithmicDepthBuffer !== !0)
      l = l.xyz.div(l.w), p = l.z, i.coordinateSystem === Jp && (p = p.mul(2).sub(1));
    else {
      const f = l.w;
      l = l.xy.div(f);
      const v = Cr("near", "float", n.camera).setGroup(sn), _ = Cr("far", "float", n.camera).setGroup(sn);
      p = T0e(f.negate(), v, _);
    }
    return l = tt(
      l.x,
      l.y.oneMinus(),
      // follow webgpu standards
      p.add(o)
    ), l;
  }
  /**
   * Returns the shadow filtering function for the given shadow type.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(e) {
    return CFe[e];
  }
  setupRenderTarget(e, t) {
    const n = new _c(e.mapSize.width, e.mapSize.height);
    n.name = "ShadowDepthTexture", n.compareFunction = D6;
    const i = t.createRenderTarget(e.mapSize.width, e.mapSize.height);
    return i.texture.name = "ShadowMap", i.texture.type = e.mapType, i.depthTexture = n, { shadowMap: i, depthTexture: n };
  }
  /**
   * Setups the shadow output node.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {Node<vec3>} The shadow output node.
   */
  setupShadow(e) {
    const { renderer: t } = e, { light: n, shadow: i } = this, o = t.shadowMap.type, { depthTexture: l, shadowMap: p } = this.setupRenderTarget(i, e);
    if (i.camera.updateProjectionMatrix(), o === dO && i.isPointLightShadow !== !0) {
      l.compareFunction = null, p.depth > 1 ? (p._vsmShadowMapVertical || (p._vsmShadowMapVertical = e.createRenderTarget(i.mapSize.width, i.mapSize.height, { format: _g, type: ol, depth: p.depth, depthBuffer: !1 }), p._vsmShadowMapVertical.texture.name = "VSMVertical"), this.vsmShadowMapVertical = p._vsmShadowMapVertical, p._vsmShadowMapHorizontal || (p._vsmShadowMapHorizontal = e.createRenderTarget(i.mapSize.width, i.mapSize.height, { format: _g, type: ol, depth: p.depth, depthBuffer: !1 }), p._vsmShadowMapHorizontal.texture.name = "VSMHorizontal"), this.vsmShadowMapHorizontal = p._vsmShadowMapHorizontal) : (this.vsmShadowMapVertical = e.createRenderTarget(i.mapSize.width, i.mapSize.height, { format: _g, type: ol, depthBuffer: !1 }), this.vsmShadowMapHorizontal = e.createRenderTarget(i.mapSize.width, i.mapSize.height, { format: _g, type: ol, depthBuffer: !1 }));
      let V = Wn(l);
      l.isArrayTexture && (V = V.depth(this.depthLayer));
      let re = Wn(this.vsmShadowMapVertical.texture);
      l.isArrayTexture && (re = re.depth(this.depthLayer));
      const R = Cr("blurSamples", "float", i).setGroup(sn), J = Cr("radius", "float", i).setGroup(sn), ge = Cr("mapSize", "vec2", i).setGroup(sn);
      let _e = this.vsmMaterialVertical || (this.vsmMaterialVertical = new Ni());
      _e.fragmentNode = EFe({ samples: R, radius: J, size: ge, shadowPass: V, depthLayer: this.depthLayer }).context(e.getSharedContext()), _e.name = "VSMVertical", _e = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new Ni()), _e.fragmentNode = TFe({ samples: R, radius: J, size: ge, shadowPass: re, depthLayer: this.depthLayer }).context(e.getSharedContext()), _e.name = "VSMHorizontal";
    }
    const f = Cr("intensity", "float", i).setGroup(sn), v = Cr("normalBias", "float", i).setGroup(sn), _ = B0e(n).mul(V0e.add(lG.mul(v))), E = this.setupShadowCoord(e, _), A = i.filterNode || this.getShadowFilterFn(t.shadowMap.type) || null;
    if (A === null)
      throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");
    const I = o === dO && i.isPointLightShadow !== !0 ? this.vsmShadowMapHorizontal.texture : l, j = this.setupShadowFilter(e, { filterFn: A, shadowTexture: p.texture, depthTexture: I, shadowCoord: E, shadow: i, depthLayer: this.depthLayer });
    let q = Wn(p.texture, E);
    l.isArrayTexture && (q = q.depth(this.depthLayer));
    const L = Vr(1, j.rgb.mix(q, 1), f.mul(q.a)).toVar();
    return this.shadowMap = p, this.shadow.map = p, L;
  }
  /**
   * The implementation performs the setup of the output node. An output is only
   * produces if shadow mapping is globally enabled in the renderer.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @return {ShaderCallNodeInternal} The output node.
   */
  setup(e) {
    if (e.renderer.shadowMap.enabled !== !1)
      return at(() => {
        let t = this._node;
        return this.setupShadowPosition(e), t === null && (this._node = t = this.setupShadow(e)), e.material.shadowNode && console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.'), e.material.receivedShadowNode && (t = e.material.receivedShadowNode(t)), t;
      })();
  }
  /**
   * Renders the shadow. The logic of this function could be included
   * into {@link ShadowNode#updateShadow} however more specialized shadow
   * nodes might require a custom shadow map rendering. By having a
   * dedicated method, it's easier to overwrite the default behavior.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(e) {
    const { shadow: t, shadowMap: n, light: i } = this, { renderer: o, scene: l } = e;
    t.updateMatrices(i), n.setSize(t.mapSize.width, t.mapSize.height, n.depth), o.render(l, t.camera);
  }
  /**
   * Updates the shadow.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateShadow(e) {
    const { shadowMap: t, light: n, shadow: i } = this, { renderer: o, scene: l, camera: p } = e, f = o.shadowMap.type, v = t.depthTexture.version;
    this._depthVersionCached = v;
    const _ = i.camera.layers.mask;
    (i.camera.layers.mask & 4294967294) === 0 && (i.camera.layers.mask = p.layers.mask);
    const E = o.getRenderObjectFunction(), A = o.getMRT(), I = A ? A.has("velocity") : !1;
    q5 = fFe(o, l, q5), l.overrideMaterial = SFe(n), o.setRenderObjectFunction(wFe(o, i, f, I)), o.setClearColor(0, 0), o.setRenderTarget(t), this.renderShadow(e), o.setRenderObjectFunction(E), f === dO && i.isPointLightShadow !== !0 && this.vsmPass(o), i.camera.layers.mask = _, mFe(o, l, q5);
  }
  /**
   * For VSM additional render passes are required.
   *
   * @param {Renderer} renderer - A reference to the current renderer.
   */
  vsmPass(e) {
    const { shadow: t } = this, n = this.shadowMap.depth;
    this.vsmShadowMapVertical.setSize(t.mapSize.width, t.mapSize.height, n), this.vsmShadowMapHorizontal.setSize(t.mapSize.width, t.mapSize.height, n), e.setRenderTarget(this.vsmShadowMapVertical), jN.material = this.vsmMaterialVertical, jN.render(e), e.setRenderTarget(this.vsmShadowMapHorizontal), jN.material = this.vsmMaterialHorizontal, jN.render(e);
  }
  /**
   * Frees the internal resources of this shadow node.
   */
  dispose() {
    this.shadowMap.dispose(), this.shadowMap = null, this.vsmShadowMapVertical !== null && (this.vsmShadowMapVertical.dispose(), this.vsmShadowMapVertical = null, this.vsmMaterialVertical.dispose(), this.vsmMaterialVertical = null), this.vsmShadowMapHorizontal !== null && (this.vsmShadowMapHorizontal.dispose(), this.vsmShadowMapHorizontal = null, this.vsmMaterialHorizontal.dispose(), this.vsmMaterialHorizontal = null), super.dispose();
  }
  /**
   * The implementation performs the update of the shadow map if necessary.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  updateBefore(e) {
    const { shadow: t } = this;
    let n = t.needsUpdate || t.autoUpdate;
    n && (this._cameraFrameId[e.camera] === e.frameId && (n = !1), this._cameraFrameId[e.camera] = e.frameId), n && (this.updateShadow(e), this.shadowMap.depthTexture.version === this._depthVersionCached && (t.needsUpdate = !1));
  }
}
const PFe = (c, e) => ct(new G0e(c, e)), AFe = /* @__PURE__ */ new er(), fc = /* @__PURE__ */ at(([c, e]) => {
  const t = c.toVar(), n = sl(t), i = Sc(1, eo(n.x, eo(n.y, n.z)));
  n.mulAssign(i), t.mulAssign(i.mul(e.mul(2).oneMinus()));
  const o = xt(t.xy).toVar(), p = e.mul(1.5).oneMinus();
  return _i(n.z.greaterThanEqual(p), () => {
    _i(t.z.greaterThan(0), () => {
      o.x.assign(mo(4, t.x));
    });
  }).ElseIf(n.x.greaterThanEqual(p), () => {
    const f = GO(t.x);
    o.x.assign(t.z.mul(f).add(f.mul(2)));
  }).ElseIf(n.y.greaterThanEqual(p), () => {
    const f = GO(t.y);
    o.x.assign(t.x.add(f.mul(2)).add(2)), o.y.assign(t.z.mul(f).sub(2));
  }), xt(0.125, 0.25).mul(o).add(xt(0.375, 0.75)).flipY();
}).setLayout({
  name: "cubeToUV",
  type: "vec2",
  inputs: [
    { name: "pos", type: "vec3" },
    { name: "texelSizeY", type: "float" }
  ]
}), kFe = /* @__PURE__ */ at(({ depthTexture: c, bd3D: e, dp: t, texelSize: n }) => Wn(c, fc(e, n.y)).compare(t)), MFe = /* @__PURE__ */ at(({ depthTexture: c, bd3D: e, dp: t, texelSize: n, shadow: i }) => {
  const o = Cr("radius", "float", i).setGroup(sn), l = xt(-1, 1).mul(o).mul(n.y);
  return Wn(c, fc(e.add(l.xyy), n.y)).compare(t).add(Wn(c, fc(e.add(l.yyy), n.y)).compare(t)).add(Wn(c, fc(e.add(l.xyx), n.y)).compare(t)).add(Wn(c, fc(e.add(l.yyx), n.y)).compare(t)).add(Wn(c, fc(e, n.y)).compare(t)).add(Wn(c, fc(e.add(l.xxy), n.y)).compare(t)).add(Wn(c, fc(e.add(l.yxy), n.y)).compare(t)).add(Wn(c, fc(e.add(l.xxx), n.y)).compare(t)).add(Wn(c, fc(e.add(l.yxx), n.y)).compare(t)).mul(1 / 9);
}), RFe = /* @__PURE__ */ at(({ filterFn: c, depthTexture: e, shadowCoord: t, shadow: n }) => {
  const i = t.xyz.toVar(), o = i.length(), l = on("float").setGroup(sn).onRenderUpdate(() => n.camera.near), p = on("float").setGroup(sn).onRenderUpdate(() => n.camera.far), f = Cr("bias", "float", n).setGroup(sn), v = on(n.mapSize).setGroup(sn), _ = et(1).toVar();
  return _i(o.sub(p).lessThanEqual(0).and(o.sub(l).greaterThanEqual(0)), () => {
    const E = o.sub(l).div(p.sub(l)).toVar();
    E.addAssign(f);
    const A = i.normalize(), I = xt(1).div(v.mul(xt(4, 2)));
    _.assign(c({ depthTexture: e, bd3D: A, dp: E, texelSize: I, shadow: n }));
  }), _;
}), rme = /* @__PURE__ */ new Bn(), cb = /* @__PURE__ */ new Pn(), jw = /* @__PURE__ */ new Pn();
class IFe extends G0e {
  static get type() {
    return "PointShadowNode";
  }
  /**
   * Constructs a new point shadow node.
   *
   * @param {PointLight} light - The shadow casting point light.
   * @param {?PointLightShadow} [shadow=null] - An optional point light shadow.
   */
  constructor(e, t = null) {
    super(e, t);
  }
  /**
   * Overwrites the default implementation to return point light shadow specific
   * filtering functions.
   *
   * @param {number} type - The shadow type.
   * @return {Function} The filtering function.
   */
  getShadowFilterFn(e) {
    return e === GMe ? kFe : MFe;
  }
  /**
   * Overwrites the default implementation so the unaltered shadow position is used.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
   * @return {Node<vec3>} The shadow coordinates.
   */
  setupShadowCoord(e, t) {
    return t;
  }
  /**
   * Overwrites the default implementation to only use point light specific
   * shadow filter functions.
   *
   * @param {NodeBuilder} builder - A reference to the current node builder.
   * @param {Object} inputs - A configuration object that defines the shadow filtering.
   * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
   * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The result node of the shadow filtering.
   */
  setupShadowFilter(e, { filterFn: t, shadowTexture: n, depthTexture: i, shadowCoord: o, shadow: l }) {
    return RFe({ filterFn: t, shadowTexture: n, depthTexture: i, shadowCoord: o, shadow: l });
  }
  /**
   * Overwrites the default implementation with point light specific
   * rendering code.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  renderShadow(e) {
    const { shadow: t, shadowMap: n, light: i } = this, { renderer: o, scene: l } = e, p = t.getFrameExtents();
    jw.copy(t.mapSize), jw.multiply(p), n.setSize(jw.width, jw.height), cb.copy(t.mapSize);
    const f = o.autoClear, v = o.getClearColor(AFe), _ = o.getClearAlpha();
    o.autoClear = !1, o.setClearColor(t.clearColor, t.clearAlpha), o.clear();
    const E = t.getViewportCount();
    for (let A = 0; A < E; A++) {
      const I = t.getViewport(A), j = cb.x * I.x, q = jw.y - cb.y - cb.y * I.y;
      rme.set(
        j,
        q,
        cb.x * I.z,
        cb.y * I.w
      ), n.viewport.copy(rme), t.updateMatrices(i, A), o.render(l, t.camera);
    }
    o.autoClear = f, o.setClearColor(v, _);
  }
}
const NFe = (c, e) => ct(new IFe(c, e));
class Rg extends Zb {
  static get type() {
    return "AnalyticLightNode";
  }
  /**
   * Constructs a new analytic light node.
   *
   * @param {?Light} [light=null] - The light source.
   */
  constructor(e = null) {
    super(), this.light = e, this.color = new er(), this.colorNode = e && e.colorNode || on(this.color).setGroup(sn), this.baseColorNode = null, this.shadowNode = null, this.shadowColorNode = null, this.isAnalyticLightNode = !0, this.updateType = In.FRAME;
  }
  getHash() {
    return this.light.uuid;
  }
  /**
   * Returns a node representing a direction vector which points from the current
   * position in view space to the light's position in view space.
   *
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Node<vec3>} The light vector node.
   */
  getLightVector(e) {
    return j0e(this.light).sub(e.context.positionView || Ii);
  }
  /**
   * Sets up the direct lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct light data (color and direction).
   */
  setupDirect() {
  }
  /**
   * Sets up the direct rect area lighting for the analytic light node.
   *
   * @abstract
   * @param {NodeBuilder} builder - The builder object used for setting up the light.
   * @return {Object|undefined} The direct rect area light data.
   */
  setupDirectRectArea() {
  }
  /**
   * Setups the shadow node for this light. The method exists so concrete light classes
   * can setup different types of shadow nodes.
   *
   * @return {ShadowNode} The created shadow node.
   */
  setupShadowNode() {
    return PFe(this.light);
  }
  /**
   * Setups the shadow for this light. This method is only executed if the light
   * cast shadows and the current build object receives shadows. It incorporates
   * shadows into the lighting computation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupShadow(e) {
    const { renderer: t } = e;
    if (t.shadowMap.enabled === !1) return;
    let n = this.shadowColorNode;
    if (n === null) {
      const i = this.light.shadow.shadowNode;
      let o;
      i !== void 0 ? o = ct(i) : o = this.setupShadowNode(), this.shadowNode = o, this.shadowColorNode = n = this.colorNode.mul(o), this.baseColorNode = this.colorNode;
    }
    this.colorNode = n;
  }
  /**
   * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
   * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
   * invocate the respective interface methods.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setup(e) {
    this.colorNode = this.baseColorNode || this.colorNode, this.light.castShadow ? e.object.receiveShadow && this.setupShadow(e) : this.shadowNode !== null && (this.shadowNode.dispose(), this.shadowNode = null, this.shadowColorNode = null);
    const t = this.setupDirect(e), n = this.setupDirectRectArea(e);
    t && e.lightsNode.setupDirectLight(e, this, t), n && e.lightsNode.setupDirectRectAreaLight(e, this, n);
  }
  /**
   * The update method is used to update light uniforms per frame.
   * Potentially overwritten in concrete light nodes to update light
   * specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const q0e = /* @__PURE__ */ at(({ lightDistance: c, cutoffDistance: e, decayExponent: t }) => {
  const n = c.pow(t).max(0.01).reciprocal();
  return e.greaterThan(0).select(
    n.mul(c.div(e).pow4().oneMinus().clamp().pow2()),
    n
  );
}), OFe = ({ color: c, lightVector: e, cutoffDistance: t, decayExponent: n }) => {
  const i = e.normalize(), o = e.length(), l = q0e({
    lightDistance: o,
    cutoffDistance: t,
    decayExponent: n
  }), p = c.mul(l);
  return { lightDirection: i, lightColor: p };
};
class DFe extends Rg {
  static get type() {
    return "PointLightNode";
  }
  /**
   * Constructs a new point light node.
   *
   * @param {?PointLight} [light=null] - The point light source.
   */
  constructor(e = null) {
    super(e), this.cutoffDistanceNode = on(0).setGroup(sn), this.decayExponentNode = on(2).setGroup(sn);
  }
  /**
   * Overwritten to updated point light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  /**
   * Overwritten to setup point light specific shadow.
   *
   * @return {PointShadowNode}
   */
  setupShadowNode() {
    return NFe(this.light);
  }
  setupDirect(e) {
    return OFe({
      color: this.colorNode,
      lightVector: this.getLightVector(e),
      cutoffDistance: this.cutoffDistanceNode,
      decayExponent: this.decayExponentNode
    });
  }
}
const ime = /* @__PURE__ */ et(1), p6 = /* @__PURE__ */ et(-2), UN = /* @__PURE__ */ et(0.8), H5 = /* @__PURE__ */ et(-1), zN = /* @__PURE__ */ et(0.4), $5 = /* @__PURE__ */ et(2), VN = /* @__PURE__ */ et(0.305), W5 = /* @__PURE__ */ et(3), sme = /* @__PURE__ */ et(0.21), FFe = /* @__PURE__ */ et(4), ome = /* @__PURE__ */ et(4), BFe = /* @__PURE__ */ et(16), LFe = /* @__PURE__ */ at(([c]) => {
  const e = tt(sl(c)).toVar(), t = et(-1).toVar();
  return _i(e.x.greaterThan(e.z), () => {
    _i(e.x.greaterThan(e.y), () => {
      t.assign(Zs(c.x.greaterThan(0), 0, 3));
    }).Else(() => {
      t.assign(Zs(c.y.greaterThan(0), 1, 4));
    });
  }).Else(() => {
    _i(e.z.greaterThan(e.y), () => {
      t.assign(Zs(c.z.greaterThan(0), 2, 5));
    }).Else(() => {
      t.assign(Zs(c.y.greaterThan(0), 1, 4));
    });
  }), t;
}).setLayout({
  name: "getFace",
  type: "float",
  inputs: [
    { name: "direction", type: "vec3" }
  ]
}), jFe = /* @__PURE__ */ at(([c, e]) => {
  const t = xt().toVar();
  return _i(e.equal(0), () => {
    t.assign(xt(c.z, c.y).div(sl(c.x)));
  }).ElseIf(e.equal(1), () => {
    t.assign(xt(c.x.negate(), c.z.negate()).div(sl(c.y)));
  }).ElseIf(e.equal(2), () => {
    t.assign(xt(c.x.negate(), c.y).div(sl(c.z)));
  }).ElseIf(e.equal(3), () => {
    t.assign(xt(c.z.negate(), c.y).div(sl(c.x)));
  }).ElseIf(e.equal(4), () => {
    t.assign(xt(c.x.negate(), c.z).div(sl(c.y)));
  }).Else(() => {
    t.assign(xt(c.x, c.y).div(sl(c.z)));
  }), On(0.5, t.add(1));
}).setLayout({
  name: "getUV",
  type: "vec2",
  inputs: [
    { name: "direction", type: "vec3" },
    { name: "face", type: "float" }
  ]
}), UFe = /* @__PURE__ */ at(([c]) => {
  const e = et(0).toVar();
  return _i(c.greaterThanEqual(UN), () => {
    e.assign(ime.sub(c).mul(H5.sub(p6)).div(ime.sub(UN)).add(p6));
  }).ElseIf(c.greaterThanEqual(zN), () => {
    e.assign(UN.sub(c).mul($5.sub(H5)).div(UN.sub(zN)).add(H5));
  }).ElseIf(c.greaterThanEqual(VN), () => {
    e.assign(zN.sub(c).mul(W5.sub($5)).div(zN.sub(VN)).add($5));
  }).ElseIf(c.greaterThanEqual(sme), () => {
    e.assign(VN.sub(c).mul(FFe.sub(W5)).div(VN.sub(sme)).add(W5));
  }).Else(() => {
    e.assign(et(-2).mul(Gd(On(1.16, c))));
  }), e;
}).setLayout({
  name: "roughnessToMip",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" }
  ]
}), zFe = /* @__PURE__ */ at(([c, e]) => {
  const t = c.toVar();
  t.assign(On(2, t).sub(1));
  const n = tt(t, 1).toVar();
  return _i(e.equal(0), () => {
    n.assign(n.zyx);
  }).ElseIf(e.equal(1), () => {
    n.assign(n.xzy), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(2), () => {
    n.x.mulAssign(-1);
  }).ElseIf(e.equal(3), () => {
    n.assign(n.zyx), n.xz.mulAssign(-1);
  }).ElseIf(e.equal(4), () => {
    n.assign(n.xzy), n.xy.mulAssign(-1);
  }).ElseIf(e.equal(5), () => {
    n.z.mulAssign(-1);
  }), n;
}).setLayout({
  name: "getDirection",
  type: "vec3",
  inputs: [
    { name: "uv", type: "vec2" },
    { name: "face", type: "float" }
  ]
}), VFe = /* @__PURE__ */ at(([c, e, t, n, i, o]) => {
  const l = et(t), p = tt(e), f = Kd(UFe(l), p6, o), v = rf(f), _ = Eg(f), E = tt(f6(c, p, _, n, i, o)).toVar();
  return _i(v.notEqual(0), () => {
    const A = tt(f6(c, p, _.add(1), n, i, o)).toVar();
    E.assign(Vr(E, A, v));
  }), E;
}), f6 = /* @__PURE__ */ at(([c, e, t, n, i, o]) => {
  const l = et(t).toVar(), p = tt(e), f = et(LFe(p)).toVar(), v = et(eo(ome.sub(l), 0)).toVar();
  l.assign(eo(l, ome));
  const _ = et(CE(l)).toVar(), E = xt(jFe(p, f).mul(_.sub(2)).add(1)).toVar();
  return _i(f.greaterThan(2), () => {
    E.y.addAssign(_), f.subAssign(3);
  }), E.x.addAssign(f.mul(_)), E.x.addAssign(v.mul(On(3, BFe))), E.y.addAssign(On(4, CE(o).sub(_))), E.x.mulAssign(n), E.y.mulAssign(i), c.sample(E).grad(xt(), xt());
}), K5 = /* @__PURE__ */ at(({ envMap: c, mipInt: e, outputDirection: t, theta: n, axis: i, CUBEUV_TEXEL_WIDTH: o, CUBEUV_TEXEL_HEIGHT: l, CUBEUV_MAX_MIP: p }) => {
  const f = Gp(n), v = t.mul(f).add(i.cross(t).mul(lu(n))).add(i.mul(i.dot(t).mul(f.oneMinus())));
  return f6(c, v, e, o, l, p);
}), GFe = /* @__PURE__ */ at(({ n: c, latitudinal: e, poleAxis: t, outputDirection: n, weights: i, samples: o, dTheta: l, mipInt: p, envMap: f, CUBEUV_TEXEL_WIDTH: v, CUBEUV_TEXEL_HEIGHT: _, CUBEUV_MAX_MIP: E }) => {
  const A = tt(Zs(e, t, n0e(t, n))).toVar();
  _i(A.equal(tt(0)), () => {
    A.assign(tt(n.z, 0, n.x.negate()));
  }), A.assign(PE(A));
  const I = tt().toVar();
  return I.addAssign(i.element(0).mul(K5({ theta: 0, axis: A, outputDirection: n, mipInt: p, envMap: f, CUBEUV_TEXEL_WIDTH: v, CUBEUV_TEXEL_HEIGHT: _, CUBEUV_MAX_MIP: E }))), cu({ start: Nr(1), end: c }, ({ i: j }) => {
    _i(j.greaterThanEqual(o), () => {
      IOe();
    });
    const q = et(l.mul(et(j))).toVar();
    I.addAssign(i.element(j).mul(K5({ theta: q.mul(-1), axis: A, outputDirection: n, mipInt: p, envMap: f, CUBEUV_TEXEL_WIDTH: v, CUBEUV_TEXEL_HEIGHT: _, CUBEUV_MAX_MIP: E }))), I.addAssign(i.element(j).mul(K5({ theta: q, axis: A, outputDirection: n, mipInt: p, envMap: f, CUBEUV_TEXEL_WIDTH: v, CUBEUV_TEXEL_HEIGHT: _, CUBEUV_MAX_MIP: E })));
  }), gn(I, 1);
}), Fp = /* @__PURE__ */ new Ue(), ame = /* @__PURE__ */ new Pn(), lme = /* @__PURE__ */ new Pn();
class Sa extends L6 {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix();
  }
  copy(e, t) {
    return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(e) {
    const t = 0.5 * this.getFilmHeight() / e;
    this.fov = Ub * 2 * Math.atan(t), this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const e = Math.tan(hE * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / e;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return Ub * 2 * Math.atan(
      Math.tan(hE * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(e, t, n) {
    Fp.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse), t.set(Fp.x, Fp.y).multiplyScalar(-e / Fp.z), Fp.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse), n.set(Fp.x, Fp.y).multiplyScalar(-e / Fp.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(e, t) {
    return this.getViewBounds(e, ame, lme), t.subVectors(lme, ame);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(e, t, n, i, o, l) {
    this.aspect = e / t, this.view === null && (this.view = {
      enabled: !0,
      fullWidth: 1,
      fullHeight: 1,
      offsetX: 0,
      offsetY: 0,
      width: 1,
      height: 1
    }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = o, this.view.height = l, this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const e = this.near;
    let t = e * Math.tan(hE * 0.5 * this.fov) / this.zoom, n = 2 * t, i = this.aspect * n, o = -0.5 * i;
    const l = this.view;
    if (this.view !== null && this.view.enabled) {
      const f = l.fullWidth, v = l.fullHeight;
      o += l.offsetX * i / f, t -= l.offsetY * n / v, i *= l.width / f, n *= l.height / v;
    }
    const p = this.filmOffset;
    p !== 0 && (o += e * p / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t;
  }
}
class LE extends Zd {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(e = 1, t = 1, n = 1, i = 1, o = 1, l = 1) {
    super(), this.type = "BoxGeometry", this.parameters = {
      width: e,
      height: t,
      depth: n,
      widthSegments: i,
      heightSegments: o,
      depthSegments: l
    };
    const p = this;
    i = Math.floor(i), o = Math.floor(o), l = Math.floor(l);
    const f = [], v = [], _ = [], E = [];
    let A = 0, I = 0;
    j("z", "y", "x", -1, -1, n, t, e, l, o, 0), j("z", "y", "x", 1, -1, n, t, -e, l, o, 1), j("x", "z", "y", 1, 1, e, n, t, i, l, 2), j("x", "z", "y", 1, -1, e, n, -t, i, l, 3), j("x", "y", "z", 1, -1, e, t, n, i, o, 4), j("x", "y", "z", -1, -1, e, t, -n, i, o, 5), this.setIndex(f), this.setAttribute("position", new vo(v, 3)), this.setAttribute("normal", new vo(_, 3)), this.setAttribute("uv", new vo(E, 2));
    function j(q, L, V, re, R, J, ge, _e, Y, Fe, Me) {
      const $ = J / Y, dt = ge / Fe, wt = J / 2, St = ge / 2, Ct = _e / 2, pe = Y + 1, Tt = Fe + 1;
      let st = 0, Zt = 0;
      const $t = new Ue();
      for (let Ht = 0; Ht < Tt; Ht++) {
        const Gn = Ht * dt - St;
        for (let an = 0; an < pe; an++) {
          const An = an * $ - wt;
          $t[q] = An * re, $t[L] = Gn * R, $t[V] = Ct, v.push($t.x, $t.y, $t.z), $t[q] = 0, $t[L] = 0, $t[V] = _e > 0 ? 1 : -1, _.push($t.x, $t.y, $t.z), E.push(an / Y), E.push(1 - Ht / Fe), st += 1;
        }
      }
      for (let Ht = 0; Ht < Fe; Ht++)
        for (let Gn = 0; Gn < Y; Gn++) {
          const an = A + Gn + pe * Ht, An = A + Gn + pe * (Ht + 1), pr = A + (Gn + 1) + pe * (Ht + 1), Kn = A + (Gn + 1) + pe * Ht;
          f.push(an, An, Kn), f.push(An, pr, Kn), Zt += 6;
        }
      p.addGroup(I, Zt, Me), I += Zt, A += st;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(e) {
    return new LE(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments);
  }
}
const Pb = 4, ume = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582], bg = 20, Y5 = /* @__PURE__ */ new dG(-1, 1, 1, -1, 0, 1), qFe = /* @__PURE__ */ new Sa(90, 1), cme = /* @__PURE__ */ new er();
let X5 = null, Q5 = 0, Z5 = 0;
const mg = (1 + Math.sqrt(5)) / 2, db = 1 / mg, dme = [
  /* @__PURE__ */ new Ue(-mg, db, 0),
  /* @__PURE__ */ new Ue(mg, db, 0),
  /* @__PURE__ */ new Ue(-db, 0, mg),
  /* @__PURE__ */ new Ue(db, 0, mg),
  /* @__PURE__ */ new Ue(0, mg, -db),
  /* @__PURE__ */ new Ue(0, mg, db),
  /* @__PURE__ */ new Ue(-1, 1, -1),
  /* @__PURE__ */ new Ue(1, 1, -1),
  /* @__PURE__ */ new Ue(-1, 1, 1),
  /* @__PURE__ */ new Ue(1, 1, 1)
], HFe = /* @__PURE__ */ new Ue(), H0e = /* @__PURE__ */ new WeakMap(), $Fe = [
  3,
  1,
  5,
  0,
  4,
  2
], J5 = /* @__PURE__ */ zFe(BE(), tf("faceIndex")).normalize(), pG = /* @__PURE__ */ tt(J5.x, J5.y, J5.z);
class WFe {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e) {
    this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._lodMeshes = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._backgroundBox = null;
  }
  get _hasInitialized() {
    return this._renderer.hasInitialized();
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.renderTarget=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromSceneAsync}
   */
  fromScene(e, t = 0, n = 0.1, i = 100, o = {}) {
    const {
      size: l = 256,
      position: p = HFe,
      renderTarget: f = null
    } = o;
    if (this._setSize(l), this._hasInitialized === !1) {
      console.warn("THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.");
      const _ = f || this._allocateTarget();
      return o.renderTarget = _, this.fromSceneAsync(e, t, n, i, o), _;
    }
    X5 = this._renderer.getRenderTarget(), Q5 = this._renderer.getActiveCubeFace(), Z5 = this._renderer.getActiveMipmapLevel();
    const v = f || this._allocateTarget();
    return v.depthBuffer = !0, this._init(v), this._sceneToCubeUV(e, n, i, v, p), t > 0 && this._blur(v, 0, 0, t), this._applyPMREM(v), this._cleanup(v), v;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety (the cubeCamera
   * is placed at the origin).
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @param {?RenderTarget} [options.renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} A Promise that resolve with the PMREM when the generation has been finished.
   * @see {@link PMREMGenerator#fromScene}
   */
  async fromSceneAsync(e, t = 0, n = 0.1, i = 100, o = {}) {
    return this._hasInitialized === !1 && await this._renderer.init(), this.fromScene(e, t, n, i, o);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangularAsync}
   */
  fromEquirectangular(e, t = null) {
    if (this._hasInitialized === !1) {
      console.warn("THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead."), this._setSizeFromTexture(e);
      const n = t || this._allocateTarget();
      return this.fromEquirectangularAsync(e, n), n;
    }
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromEquirectangular}
   */
  async fromEquirectangularAsync(e, t = null) {
    return this._hasInitialized === !1 && await this._renderer.init(), this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {RenderTarget} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemapAsync}
   */
  fromCubemap(e, t = null) {
    if (this._hasInitialized === !1) {
      console.warn("THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."), this._setSizeFromTexture(e);
      const n = t || this._allocateTarget();
      return this.fromCubemapAsync(e, t), n;
    }
    return this._fromTexture(e, t);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?RenderTarget} [renderTarget=null] - The render target to use.
   * @return {Promise<RenderTarget>} The resulting PMREM.
   * @see {@link PMREMGenerator#fromCubemap}
   */
  async fromCubemapAsync(e, t = null) {
    return this._hasInitialized === !1 && await this._renderer.init(), this._fromTexture(e, t);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileCubemapShader() {
    this._cubemapMaterial === null && (this._cubemapMaterial = pme(), await this._compileMaterial(this._cubemapMaterial));
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   *
   * @returns {Promise}
   */
  async compileEquirectangularShader() {
    this._equirectMaterial === null && (this._equirectMaterial = fme(), await this._compileMaterial(this._equirectMaterial));
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose(), this._backgroundBox !== null && (this._backgroundBox.geometry.dispose(), this._backgroundBox.material.dispose());
  }
  // private interface
  _setSizeFromTexture(e) {
    e.mapping === wE || e.mapping === IO ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4);
  }
  _setSize(e) {
    this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(X5, Q5, Z5), e.scissorTest = !1, GN(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    this._setSizeFromTexture(e), X5 = this._renderer.getRenderTarget(), Q5 = this._renderer.getActiveCubeFace(), Z5 = this._renderer.getActiveMipmapLevel();
    const n = t || this._allocateTarget();
    return this._init(n), this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n;
  }
  _allocateTarget() {
    const e = 3 * Math.max(this._cubeSize, 112), t = 4 * this._cubeSize;
    return hme(e, t);
  }
  _init(e) {
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e.width || this._pingPongRenderTarget.height !== e.height) {
      this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = hme(e.width, e.height);
      const { _lodMax: t } = this;
      ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas, lodMeshes: this._lodMeshes } = KFe(t)), this._blurMaterial = YFe(t, e.width, e.height);
    }
  }
  async _compileMaterial(e) {
    const t = new Yd(this._lodPlanes[0], e);
    await this._renderer.compile(t, Y5);
  }
  _sceneToCubeUV(e, t, n, i, o) {
    const l = qFe;
    l.near = t, l.far = n;
    const p = [1, 1, 1, 1, -1, 1], f = [1, -1, 1, -1, 1, -1], v = this._renderer, _ = v.autoClear;
    v.getClearColor(cme), v.autoClear = !1;
    let E = this._backgroundBox;
    if (E === null) {
      const j = new Wp({
        name: "PMREM.Background",
        side: Ko,
        depthWrite: !1,
        depthTest: !1
      });
      E = new Yd(new LE(), j);
    }
    let A = !1;
    const I = e.background;
    I ? I.isColor && (E.material.color.copy(I), e.background = null, A = !0) : (E.material.color.copy(cme), A = !0), v.setRenderTarget(i), v.clear(), A && v.render(E, l);
    for (let j = 0; j < 6; j++) {
      const q = j % 3;
      q === 0 ? (l.up.set(0, p[j], 0), l.position.set(o.x, o.y, o.z), l.lookAt(o.x + f[j], o.y, o.z)) : q === 1 ? (l.up.set(0, 0, p[j]), l.position.set(o.x, o.y, o.z), l.lookAt(o.x, o.y + f[j], o.z)) : (l.up.set(0, p[j], 0), l.position.set(o.x, o.y, o.z), l.lookAt(o.x, o.y, o.z + f[j]));
      const L = this._cubeSize;
      GN(i, q * L, j > 2 ? L : 0, L, L), v.render(e, l);
    }
    v.autoClear = _, e.background = I;
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer, i = e.mapping === wE || e.mapping === IO;
    i ? this._cubemapMaterial === null && (this._cubemapMaterial = pme(e)) : this._equirectMaterial === null && (this._equirectMaterial = fme(e));
    const o = i ? this._cubemapMaterial : this._equirectMaterial;
    o.fragmentNode.value = e;
    const l = this._lodMeshes[0];
    l.material = o;
    const p = this._cubeSize;
    GN(t, 0, 0, 3 * p, 2 * p), n.setRenderTarget(t), n.render(l, Y5);
  }
  _applyPMREM(e) {
    const t = this._renderer, n = t.autoClear;
    t.autoClear = !1;
    const i = this._lodPlanes.length;
    for (let o = 1; o < i; o++) {
      const l = Math.sqrt(this._sigmas[o] * this._sigmas[o] - this._sigmas[o - 1] * this._sigmas[o - 1]), p = dme[(i - o - 1) % dme.length];
      this._blur(e, o - 1, o, l, p);
    }
    t.autoClear = n;
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * @private
   * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
   * @param {number} lodIn - The input level-of-detail.
   * @param {number} lodOut - The output level-of-detail.
   * @param {number} sigma - The blur radius in radians.
   * @param {Vector3} [poleAxis] - The pole axis.
   */
  _blur(e, t, n, i, o) {
    const l = this._pingPongRenderTarget;
    this._halfBlur(
      e,
      l,
      t,
      n,
      i,
      "latitudinal",
      o
    ), this._halfBlur(
      l,
      e,
      n,
      n,
      i,
      "longitudinal",
      o
    );
  }
  _halfBlur(e, t, n, i, o, l, p) {
    const f = this._renderer, v = this._blurMaterial;
    l !== "latitudinal" && l !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
    const _ = 3, E = this._lodMeshes[i];
    E.material = v;
    const A = H0e.get(v), I = this._sizeLods[n] - 1, j = isFinite(o) ? Math.PI / (2 * I) : 2 * Math.PI / (2 * bg - 1), q = o / j, L = isFinite(o) ? 1 + Math.floor(_ * q) : bg;
    L > bg && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${L} samples when the maximum is set to ${bg}`);
    const V = [];
    let re = 0;
    for (let Y = 0; Y < bg; ++Y) {
      const Fe = Y / q, Me = Math.exp(-Fe * Fe / 2);
      V.push(Me), Y === 0 ? re += Me : Y < L && (re += 2 * Me);
    }
    for (let Y = 0; Y < V.length; Y++)
      V[Y] = V[Y] / re;
    e.texture.frame = (e.texture.frame || 0) + 1, A.envMap.value = e.texture, A.samples.value = L, A.weights.array = V, A.latitudinal.value = l === "latitudinal" ? 1 : 0, p && (A.poleAxis.value = p);
    const { _lodMax: R } = this;
    A.dTheta.value = j, A.mipInt.value = R - n;
    const J = this._sizeLods[i], ge = 3 * J * (i > R - Pb ? i - R + Pb : 0), _e = 4 * (this._cubeSize - J);
    GN(t, ge, _e, 3 * J, 2 * J), f.setRenderTarget(t), f.render(E, Y5);
  }
}
function KFe(c) {
  const e = [], t = [], n = [], i = [];
  let o = c;
  const l = c - Pb + 1 + ume.length;
  for (let p = 0; p < l; p++) {
    const f = Math.pow(2, o);
    t.push(f);
    let v = 1 / f;
    p > c - Pb ? v = ume[p - c + Pb - 1] : p === 0 && (v = 0), n.push(v);
    const _ = 1 / (f - 2), E = -_, A = 1 + _, I = [E, E, A, E, A, A, E, E, A, A, E, A], j = 6, q = 6, L = 3, V = 2, re = 1, R = new Float32Array(L * q * j), J = new Float32Array(V * q * j), ge = new Float32Array(re * q * j);
    for (let Y = 0; Y < j; Y++) {
      const Fe = Y % 3 * 2 / 3 - 1, Me = Y > 2 ? 0 : -1, $ = [
        Fe,
        Me,
        0,
        Fe + 2 / 3,
        Me,
        0,
        Fe + 2 / 3,
        Me + 1,
        0,
        Fe,
        Me,
        0,
        Fe + 2 / 3,
        Me + 1,
        0,
        Fe,
        Me + 1,
        0
      ], dt = $Fe[Y];
      R.set($, L * q * dt), J.set(I, V * q * dt);
      const wt = [dt, dt, dt, dt, dt, dt];
      ge.set(wt, re * q * dt);
    }
    const _e = new Zd();
    _e.setAttribute("position", new ul(R, L)), _e.setAttribute("uv", new ul(J, V)), _e.setAttribute("faceIndex", new ul(ge, re)), e.push(_e), i.push(new Yd(_e, null)), o > Pb && o--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n, lodMeshes: i };
}
function hme(c, e) {
  const t = {
    magFilter: Ea,
    minFilter: Ea,
    generateMipmaps: !1,
    type: ol,
    format: al,
    colorSpace: Ib
    //depthBuffer: false
  }, n = new Mg(c, e, t);
  return n.texture.mapping = jV, n.texture.name = "PMREM.cubeUv", n.texture.isPMREMTexture = !0, n.scissorTest = !0, n;
}
function GN(c, e, t, n, i) {
  c.viewport.set(e, t, n, i), c.scissor.set(e, t, n, i);
}
function fG(c) {
  const e = new Ni();
  return e.depthTest = !1, e.depthWrite = !1, e.blending = zb, e.name = `PMREM_${c}`, e;
}
function YFe(c, e, t) {
  const n = vc(new Array(bg).fill(0)), i = on(new Ue(0, 1, 0)), o = on(0), l = et(bg), p = on(0), f = on(1), v = Wn(null), _ = on(0), E = et(1 / e), A = et(1 / t), I = et(c), j = {
    n: l,
    latitudinal: p,
    weights: n,
    poleAxis: i,
    outputDirection: pG,
    dTheta: o,
    samples: f,
    envMap: v,
    mipInt: _,
    CUBEUV_TEXEL_WIDTH: E,
    CUBEUV_TEXEL_HEIGHT: A,
    CUBEUV_MAX_MIP: I
  }, q = fG("blur");
  return q.fragmentNode = GFe({ ...j, latitudinal: p.equal(1) }), H0e.set(q, j), q;
}
function pme(c) {
  const e = fG("cubemap");
  return e.fragmentNode = kE(c, pG), e;
}
function fme(c) {
  const e = fG("equirect");
  return e.fragmentNode = Wn(c, y0e(pG), 0), e;
}
const mme = /* @__PURE__ */ new WeakMap();
function XFe(c) {
  const e = Math.log2(c) - 2, t = 1 / c;
  return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: t, maxMip: e };
}
function QFe(c, e, t) {
  const n = ZFe(e);
  let i = n.get(c);
  if ((i !== void 0 ? i.pmremVersion : -1) !== c.pmremVersion) {
    const l = c.image;
    if (c.isCubeTexture)
      if (eBe(l))
        i = t.fromCubemap(c, i);
      else
        return null;
    else if (tBe(l))
      i = t.fromEquirectangular(c, i);
    else
      return null;
    i.pmremVersion = c.pmremVersion, n.set(c, i);
  }
  return i.texture;
}
function ZFe(c) {
  let e = mme.get(c);
  return e === void 0 && (e = /* @__PURE__ */ new WeakMap(), mme.set(c, e)), e;
}
class JFe extends Oi {
  static get type() {
    return "PMREMNode";
  }
  /**
   * Constructs a new function overloading node.
   *
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   */
  constructor(e, t = null, n = null) {
    super("vec3"), this._value = e, this._pmrem = null, this.uvNode = t, this.levelNode = n, this._generator = null;
    const i = new Js();
    i.isRenderTargetTexture = !0, this._texture = Wn(i), this._width = on(0), this._height = on(0), this._maxMip = on(0), this.updateBeforeType = In.RENDER;
  }
  set value(e) {
    this._value = e, this._pmrem = null;
  }
  /**
   * The node's texture value.
   *
   * @type {Texture}
   */
  get value() {
    return this._value;
  }
  /**
   * Uses the given PMREM texture to update internal values.
   *
   * @param {Texture} texture - The PMREM texture.
   */
  updateFromTexture(e) {
    const t = XFe(e.image.height);
    this._texture.value = e, this._width.value = t.texelWidth, this._height.value = t.texelHeight, this._maxMip.value = t.maxMip;
  }
  updateBefore(e) {
    let t = this._pmrem;
    const n = t ? t.pmremVersion : -1, i = this._value;
    n !== i.pmremVersion && (i.isPMREMTexture === !0 ? t = i : t = QFe(i, e.renderer, this._generator), t !== null && (this._pmrem = t, this.updateFromTexture(t)));
  }
  setup(e) {
    this._generator === null && (this._generator = new WFe(e.renderer)), this.updateBefore(e);
    let t = this.uvNode;
    t === null && e.context.getUV && (t = e.context.getUV(this)), t = A0e.mul(tt(t.x, t.y.negate(), t.z));
    let n = this.levelNode;
    return n === null && e.context.getTextureLevel && (n = e.context.getTextureLevel(this)), VFe(this._texture, t, n, this._width, this._height, this._maxMip);
  }
  dispose() {
    super.dispose(), this._generator !== null && this._generator.dispose();
  }
}
function eBe(c) {
  if (c == null) return !1;
  let e = 0;
  const t = 6;
  for (let n = 0; n < t; n++)
    c[n] !== void 0 && e++;
  return e === t;
}
function tBe(c) {
  return c == null ? !1 : c.height > 0;
}
const $0e = /* @__PURE__ */ lt(JFe).setParameterLength(1, 3);
at(([c = BE()], { renderer: e, material: t }) => {
  const n = i0e(c.mul(2).sub(1));
  let i;
  if (t.alphaToCoverage && e.samples > 1) {
    const o = et(n.fwidth()).toVar();
    i = ef(o.oneMinus(), o.add(1), n).oneMinus();
  } else
    i = Zs(n.greaterThan(1), 0, 1);
  return i;
});
const ME = /* @__PURE__ */ at(({ f0: c, f90: e, dotVH: t }) => {
  const n = t.mul(-5.55473).sub(6.98316).mul(t).exp2();
  return c.mul(n.oneMinus()).add(e.mul(n));
}), nBe = /* @__PURE__ */ at(({ alpha: c, dotNL: e, dotNV: t }) => {
  const n = c.pow2(), i = e.mul(n.add(n.oneMinus().mul(t.pow2())).sqrt()), o = t.mul(n.add(n.oneMinus().mul(e.pow2())).sqrt());
  return Sc(0.5, i.add(o).max(vNe));
}).setLayout({
  name: "V_GGX_SmithCorrelated",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNL", type: "float" },
    { name: "dotNV", type: "float" }
  ]
}), rBe = /* @__PURE__ */ at(({ alphaT: c, alphaB: e, dotTV: t, dotBV: n, dotTL: i, dotBL: o, dotNV: l, dotNL: p }) => {
  const f = p.mul(tt(c.mul(t), e.mul(n), l).length()), v = l.mul(tt(c.mul(i), e.mul(o), p).length());
  return Sc(0.5, f.add(v)).saturate();
}).setLayout({
  name: "V_GGX_SmithCorrelated_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotTV", type: "float", qualifier: "in" },
    { name: "dotBV", type: "float", qualifier: "in" },
    { name: "dotTL", type: "float", qualifier: "in" },
    { name: "dotBL", type: "float", qualifier: "in" },
    { name: "dotNV", type: "float", qualifier: "in" },
    { name: "dotNL", type: "float", qualifier: "in" }
  ]
}), iBe = /* @__PURE__ */ at(({ alpha: c, dotNH: e }) => {
  const t = c.pow2(), n = e.pow2().mul(t.oneMinus()).oneMinus();
  return t.div(n.pow2()).mul(1 / Math.PI);
}).setLayout({
  name: "D_GGX",
  type: "float",
  inputs: [
    { name: "alpha", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), sBe = /* @__PURE__ */ et(1 / Math.PI), oBe = /* @__PURE__ */ at(({ alphaT: c, alphaB: e, dotNH: t, dotTH: n, dotBH: i }) => {
  const o = c.mul(e), l = tt(e.mul(n), c.mul(i), o.mul(t)), p = l.dot(l), f = o.div(p);
  return sBe.mul(o.mul(f.pow2()));
}).setLayout({
  name: "D_GGX_Anisotropic",
  type: "float",
  inputs: [
    { name: "alphaT", type: "float", qualifier: "in" },
    { name: "alphaB", type: "float", qualifier: "in" },
    { name: "dotNH", type: "float", qualifier: "in" },
    { name: "dotTH", type: "float", qualifier: "in" },
    { name: "dotBH", type: "float", qualifier: "in" }
  ]
}), gme = /* @__PURE__ */ at((c) => {
  const { lightDirection: e, f0: t, f90: n, roughness: i, f: o, USE_IRIDESCENCE: l, USE_ANISOTROPY: p } = c, f = c.normalView || Ri, v = i.pow2(), _ = e.add(ii).normalize(), E = f.dot(e).clamp(), A = f.dot(ii).clamp(), I = f.dot(_).clamp(), j = ii.dot(_).clamp();
  let q = ME({ f0: t, f90: n, dotVH: j }), L, V;
  if (Efe(l) && (q = Y6.mix(q, o)), Efe(p)) {
    const re = mO.dot(e), R = mO.dot(ii), J = mO.dot(_), ge = Fb.dot(e), _e = Fb.dot(ii), Y = Fb.dot(_);
    L = rBe({ alphaT: a6, alphaB: v, dotTV: R, dotBV: _e, dotTL: re, dotBL: ge, dotNV: A, dotNL: E }), V = oBe({ alphaT: a6, alphaB: v, dotNH: I, dotTH: J, dotBH: Y });
  } else
    L = nBe({ alpha: v, dotNL: E, dotNV: A }), V = iBe({ alpha: v, dotNH: I });
  return q.mul(L).mul(V);
}), Wb = /* @__PURE__ */ at((c) => c.diffuseColor.mul(1 / Math.PI)), W0e = /* @__PURE__ */ at(({ roughness: c, dotNV: e }) => {
  const t = gn(-1, -0.0275, -0.572, 0.022), n = gn(1, 0.0425, 1.04, -0.04), i = c.mul(t).add(n), o = i.x.mul(i.x).min(e.mul(-9.28).exp2()).mul(i.x).add(i.y);
  return xt(-1.04, 1.04).mul(o).add(i.zw);
}).setLayout({
  name: "DFGApprox",
  type: "vec2",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNV", type: "vec3" }
  ]
}), aBe = /* @__PURE__ */ at(({ f: c, f90: e, dotVH: t }) => {
  const n = t.oneMinus().saturate(), i = n.mul(n), o = n.mul(i, i).clamp(0, 0.9999);
  return c.sub(tt(e).mul(o)).div(o.oneMinus());
}).setLayout({
  name: "Schlick_to_F0",
  type: "vec3",
  inputs: [
    { name: "f", type: "vec3" },
    { name: "f90", type: "float" },
    { name: "dotVH", type: "float" }
  ]
}), lBe = /* @__PURE__ */ at((c) => {
  if (c.geometry.hasAttribute("normal") === !1)
    return et(0);
  const e = Ec.dFdx().abs().max(Ec.dFdy().abs());
  return e.x.max(e.y).max(e.z);
}), K0e = /* @__PURE__ */ at((c) => {
  const { roughness: e } = c, t = lBe();
  let n = e.max(0.0525);
  return n = n.add(t), n = n.min(1), n;
}), uBe = /* @__PURE__ */ at(([c, e]) => {
  const t = c.x, n = c.y, i = c.z;
  let o = e.element(0).mul(0.886227);
  return o = o.add(e.element(1).mul(2 * 0.511664).mul(n)), o = o.add(e.element(2).mul(2 * 0.511664).mul(i)), o = o.add(e.element(3).mul(2 * 0.511664).mul(t)), o = o.add(e.element(4).mul(2 * 0.429043).mul(t).mul(n)), o = o.add(e.element(5).mul(2 * 0.429043).mul(n).mul(i)), o = o.add(e.element(6).mul(i.mul(i).mul(0.743125).sub(0.247708))), o = o.add(e.element(7).mul(2 * 0.429043).mul(t).mul(i)), o = o.add(e.element(8).mul(0.429043).mul(On(t, t).sub(On(n, n)))), o;
});
class mG extends Zd {
  /**
   * Constructs a new sphere geometry.
   *
   * @param {number} [radius=1] - The sphere radius.
   * @param {number} [widthSegments=32] - The number of horizontal segments. Minimum value is `3`.
   * @param {number} [heightSegments=16] - The number of vertical segments. Minimum value is `2`.
   * @param {number} [phiStart=0] - The horizontal starting angle in radians.
   * @param {number} [phiLength=Math.PI*2] - The horizontal sweep angle size.
   * @param {number} [thetaStart=0] - The vertical starting angle in radians.
   * @param {number} [thetaLength=Math.PI] - The vertical sweep angle size.
   */
  constructor(e = 1, t = 32, n = 16, i = 0, o = Math.PI * 2, l = 0, p = Math.PI) {
    super(), this.type = "SphereGeometry", this.parameters = {
      radius: e,
      widthSegments: t,
      heightSegments: n,
      phiStart: i,
      phiLength: o,
      thetaStart: l,
      thetaLength: p
    }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
    const f = Math.min(l + p, Math.PI);
    let v = 0;
    const _ = [], E = new Ue(), A = new Ue(), I = [], j = [], q = [], L = [];
    for (let V = 0; V <= n; V++) {
      const re = [], R = V / n;
      let J = 0;
      V === 0 && l === 0 ? J = 0.5 / t : V === n && f === Math.PI && (J = -0.5 / t);
      for (let ge = 0; ge <= t; ge++) {
        const _e = ge / t;
        E.x = -e * Math.cos(i + _e * o) * Math.sin(l + R * p), E.y = e * Math.cos(l + R * p), E.z = e * Math.sin(i + _e * o) * Math.sin(l + R * p), j.push(E.x, E.y, E.z), A.copy(E).normalize(), q.push(A.x, A.y, A.z), L.push(_e + J, 1 - R), re.push(v++);
      }
      _.push(re);
    }
    for (let V = 0; V < n; V++)
      for (let re = 0; re < t; re++) {
        const R = _[V][re + 1], J = _[V][re], ge = _[V + 1][re], _e = _[V + 1][re + 1];
        (V !== 0 || l > 0) && I.push(R, J, _e), (V !== n - 1 || f < Math.PI) && I.push(J, ge, _e);
      }
    this.setIndex(I), this.setAttribute("position", new vo(j, 3)), this.setAttribute("normal", new vo(q, 3)), this.setAttribute("uv", new vo(L, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {SphereGeometry} A new instance.
   */
  static fromJSON(e) {
    return new mG(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength);
  }
}
const iu = /* @__PURE__ */ new U6();
class cBe extends nf {
  /**
   * Constructs a new background management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Nodes} nodes - Renderer component for managing nodes related logic.
   */
  constructor(e, t) {
    super(), this.renderer = e, this.nodes = t;
  }
  /**
   * Updates the background for the given scene. Depending on how `Scene.background`
   * or `Scene.backgroundNode` are configured, this method might configure a simple clear
   * or add a mesh to the render list for rendering the background as a textured plane
   * or skybox.
   *
   * @param {Scene} scene - The scene.
   * @param {RenderList} renderList - The current render list.
   * @param {RenderContext} renderContext - The current render context.
   */
  update(e, t, n) {
    const i = this.renderer, o = this.nodes.getBackgroundNode(e) || e.background;
    let l = !1;
    if (o === null)
      i._clearColor.getRGB(iu), iu.a = i._clearColor.a;
    else if (o.isColor === !0)
      o.getRGB(iu), iu.a = 1, l = !0;
    else if (o.isNode === !0) {
      const f = this.get(e), v = o;
      iu.copy(i._clearColor);
      let _ = f.backgroundMesh;
      if (_ === void 0) {
        let q = function() {
          o.removeEventListener("dispose", q), _.material.dispose(), _.geometry.dispose();
        };
        const A = J6(gn(v).mul(Zfe), {
          // @TODO: Add Texture2D support using node context
          getUV: () => LDe.mul(aG),
          getTextureLevel: () => BDe
        });
        let I = N0e;
        I = I.setZ(I.w);
        const j = new Ni();
        j.name = "Background.material", j.side = Ko, j.depthTest = !1, j.depthWrite = !1, j.allowOverride = !1, j.fog = !1, j.lights = !1, j.vertexNode = I, j.colorNode = A, f.backgroundMeshNode = A, f.backgroundMesh = _ = new Yd(new mG(1, 32, 32), j), _.frustumCulled = !1, _.name = "Background.mesh", _.onBeforeRender = function(L, V, re) {
          this.matrixWorld.copyPosition(re.matrixWorld);
        }, o.addEventListener("dispose", q);
      }
      const E = v.getCacheKey();
      f.backgroundCacheKey !== E && (f.backgroundMeshNode.node = gn(v).mul(Zfe), f.backgroundMeshNode.needsUpdate = !0, _.material.needsUpdate = !0, f.backgroundCacheKey = E), t.unshift(_, _.geometry, _.material, 0, 0, null, null);
    } else
      console.error("THREE.Renderer: Unsupported background configuration.", o);
    const p = i.xr.getEnvironmentBlendMode();
    if (p === "additive" ? iu.set(0, 0, 0, 1) : p === "alpha-blend" && iu.set(0, 0, 0, 0), i.autoClear === !0 || l === !0) {
      const f = n.clearColorValue;
      f.r = iu.r, f.g = iu.g, f.b = iu.b, f.a = iu.a, (i.backend.isWebGLBackend === !0 || i.alpha === !0) && (f.r *= f.a, f.g *= f.a, f.b *= f.a), n.depthClearValue = i._clearDepth, n.stencilClearValue = i._clearStencil, n.clearColor = i.autoClearColor === !0, n.clearDepth = i.autoClearDepth === !0, n.clearStencil = i.autoClearStencil === !0;
    } else
      n.clearColor = !1, n.clearDepth = !1, n.clearStencil = !1;
  }
}
let dBe = 0;
class m6 {
  /**
   * Constructs a new bind group.
   *
   * @param {string} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  constructor(e = "", t = [], n = 0, i = []) {
    this.name = e, this.bindings = t, this.index = n, this.bindingsReference = i, this.id = dBe++;
  }
}
class hBe {
  /**
   * Constructs a new node builder state.
   *
   * @param {string} vertexShader - The native vertex shader code.
   * @param {string} fragmentShader - The native fragment shader code.
   * @param {string} computeShader - The native compute shader code.
   * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
   * @param {Array<BindGroup>} bindings - An array of bind groups.
   * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
   * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
   * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
   * @param {NodeMaterialObserver} observer - A node material observer.
   * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
   */
  constructor(e, t, n, i, o, l, p, f, v, _ = []) {
    this.vertexShader = e, this.fragmentShader = t, this.computeShader = n, this.transforms = _, this.nodeAttributes = i, this.bindings = o, this.updateNodes = l, this.updateBeforeNodes = p, this.updateAfterNodes = f, this.observer = v, this.usedTimes = 0;
  }
  /**
   * This method is used to create a array of bind groups based
   * on the existing bind groups of this state. Shared groups are
   * not cloned.
   *
   * @return {Array<BindGroup>} A array of bind groups.
   */
  createBindings() {
    const e = [];
    for (const t of this.bindings)
      if (t.bindings[0].groupNode.shared !== !0) {
        const i = new m6(t.name, [], t.index, t);
        e.push(i);
        for (const o of t.bindings)
          i.bindings.push(o.clone());
      } else
        e.push(t);
    return e;
  }
}
function Y0e(c) {
  const e = {};
  for (const t in c) {
    e[t] = {};
    for (const n in c[t]) {
      const i = c[t][n];
      i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i;
    }
  }
  return e;
}
function pBe(c) {
  const e = [];
  for (let t = 0; t < c.length; t++)
    e.push(c[t].clone());
  return e;
}
const fBe = (
  /* glsl */
  `
void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}
`
), mBe = (
  /* glsl */
  `
void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}
`
);
class gBe extends Yo {
  /**
   * Constructs a new shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = fBe, this.fragmentShader = mBe, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
      clipCullDistance: !1,
      // set to use vertex shader clipping
      multiDraw: !1
      // set to use vertex shader multi_draw / enable gl_DrawID
    }, this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv1: [0, 0]
    }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = Y0e(e.uniforms), this.uniformsGroups = pBe(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    t.glslVersion = this.glslVersion, t.uniforms = {};
    for (const i in this.uniforms) {
      const l = this.uniforms[i].value;
      l && l.isTexture ? t.uniforms[i] = {
        type: "t",
        value: l.toJSON(e).uuid
      } : l && l.isColor ? t.uniforms[i] = {
        type: "c",
        value: l.getHex()
      } : l && l.isVector2 ? t.uniforms[i] = {
        type: "v2",
        value: l.toArray()
      } : l && l.isVector3 ? t.uniforms[i] = {
        type: "v3",
        value: l.toArray()
      } : l && l.isVector4 ? t.uniforms[i] = {
        type: "v4",
        value: l.toArray()
      } : l && l.isMatrix3 ? t.uniforms[i] = {
        type: "m3",
        value: l.toArray()
      } : l && l.isMatrix4 ? t.uniforms[i] = {
        type: "m4",
        value: l.toArray()
      } : t.uniforms[i] = {
        value: l
      };
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
    const n = {};
    for (const i in this.extensions)
      this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class yBe extends Mg {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isWebGLRenderTarget = !0;
  }
}
const hb = -90, pb = 1;
class X0e extends Wi {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(e, t, n) {
    super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
    const i = new Sa(hb, pb, e, t);
    i.layers = this.layers, this.add(i);
    const o = new Sa(hb, pb, e, t);
    o.layers = this.layers, this.add(o);
    const l = new Sa(hb, pb, e, t);
    l.layers = this.layers, this.add(l);
    const p = new Sa(hb, pb, e, t);
    p.layers = this.layers, this.add(p);
    const f = new Sa(hb, pb, e, t);
    f.layers = this.layers, this.add(f);
    const v = new Sa(hb, pb, e, t);
    v.layers = this.layers, this.add(v);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const e = this.coordinateSystem, t = this.children.concat(), [n, i, o, l, p, f] = t;
    for (const v of t) this.remove(v);
    if (e === Ho)
      n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), o.up.set(0, 0, -1), o.lookAt(0, 1, 0), l.up.set(0, 0, 1), l.lookAt(0, -1, 0), p.up.set(0, 1, 0), p.lookAt(0, 0, 1), f.up.set(0, 1, 0), f.lookAt(0, 0, -1);
    else if (e === Jp)
      n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), o.up.set(0, 0, 1), o.lookAt(0, 1, 0), l.up.set(0, 0, -1), l.lookAt(0, -1, 0), p.up.set(0, -1, 0), p.lookAt(0, 0, 1), f.up.set(0, -1, 0), f.lookAt(0, 0, -1);
    else
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
    for (const v of t)
      this.add(v), v.updateMatrixWorld();
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const { renderTarget: n, activeMipmapLevel: i } = this;
    this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
    const [o, l, p, f, v, _] = this.children, E = e.getRenderTarget(), A = e.getActiveCubeFace(), I = e.getActiveMipmapLevel(), j = e.xr.enabled;
    e.xr.enabled = !1;
    const q = n.texture.generateMipmaps;
    n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, o), e.setRenderTarget(n, 1, i), e.render(t, l), e.setRenderTarget(n, 2, i), e.render(t, p), e.setRenderTarget(n, 3, i), e.render(t, f), e.setRenderTarget(n, 4, i), e.render(t, v), n.texture.generateMipmaps = q, e.setRenderTarget(n, 5, i), e.render(t, _), e.setRenderTarget(E, A, I), e.xr.enabled = j, n.texture.needsPMREMUpdate = !0;
  }
}
class vBe extends yBe {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = {}) {
    super(e, e, t), this.isWebGLCubeRenderTarget = !0;
    const n = { width: e, height: e, depth: 1 }, i = [n, n, n, n, n, n];
    this.texture = new c2(i), this._setTextureOptions(t), this.texture.isRenderTargetTexture = !0;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {WebGLCubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(e, t) {
    this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const n = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    }, i = new LE(5, 5, 5), o = new gBe({
      name: "CubemapFromEquirect",
      uniforms: Y0e(n.uniforms),
      vertexShader: n.vertexShader,
      fragmentShader: n.fragmentShader,
      side: Ko,
      blending: zb
    });
    o.uniforms.tEquirect.value = t;
    const l = new Yd(i, o), p = t.minFilter;
    return t.minFilter === Ud && (t.minFilter = Ea), new X0e(1, 10, this).update(e, l), t.minFilter = p, l.geometry.dispose(), l.material.dispose(), this;
  }
  /**
   * Clears this cube render target.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(e, t = !0, n = !0, i = !0) {
    const o = e.getRenderTarget();
    for (let l = 0; l < 6; l++)
      e.setRenderTarget(this, l), e.clear(t, n, i);
    e.setRenderTarget(o);
  }
}
class Q0e extends vBe {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(e = 1, t = {}) {
    super(e, t), this.isCubeRenderTarget = !0;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {CubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(e, t) {
    const n = t.minFilter, i = t.generateMipmaps;
    t.generateMipmaps = !0, this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
    const o = new LE(5, 5, 5), l = y0e(g0e), p = new Ni();
    p.colorNode = Wn(t, l, 0), p.side = Ko, p.blending = zb;
    const f = new Yd(o, p), v = new B6();
    v.add(f), t.minFilter === Ud && (t.minFilter = Ea);
    const _ = new X0e(1, 10, this), E = e.getMRT();
    return e.setMRT(null), _.update(e, v), e.setMRT(E), t.minFilter = n, t.currentGenerateMipmaps = i, f.geometry.dispose(), f.material.dispose(), this;
  }
}
const bE = /* @__PURE__ */ new WeakMap();
class bBe extends Oi {
  static get type() {
    return "CubeMapNode";
  }
  /**
   * Constructs a new cube map node.
   *
   * @param {Node} envNode - The node representing the environment map.
   */
  constructor(e) {
    super("vec3"), this.envNode = e, this._cubeTexture = null, this._cubeTextureNode = kE(null);
    const t = new c2();
    t.isRenderTargetTexture = !0, this._defaultTexture = t, this.updateBeforeType = In.RENDER;
  }
  updateBefore(e) {
    const { renderer: t, material: n } = e, i = this.envNode;
    if (i.isTextureNode || i.isMaterialReferenceNode) {
      const o = i.isTextureNode ? i.value : n[i.property];
      if (o && o.isTexture) {
        const l = o.mapping;
        if (l === A6 || l === k6) {
          if (bE.has(o)) {
            const p = bE.get(o);
            yme(p, o.mapping), this._cubeTexture = p;
          } else {
            const p = o.image;
            if (xBe(p)) {
              const f = new Q0e(p.height);
              f.fromEquirectangularTexture(t, o), yme(f.texture, o.mapping), this._cubeTexture = f.texture, bE.set(o, f.texture), o.addEventListener("dispose", Z0e);
            } else
              this._cubeTexture = this._defaultTexture;
          }
          this._cubeTextureNode.value = this._cubeTexture;
        } else
          this._cubeTextureNode = this.envNode;
      }
    }
  }
  setup(e) {
    return this.updateBefore(e), this._cubeTextureNode;
  }
}
function xBe(c) {
  return c == null ? !1 : c.height > 0;
}
function Z0e(c) {
  const e = c.target;
  e.removeEventListener("dispose", Z0e);
  const t = bE.get(e);
  t !== void 0 && (bE.delete(e), t.dispose());
}
function yme(c, e) {
  e === A6 ? c.mapping = wE : e === k6 && (c.mapping = IO);
}
const J0e = /* @__PURE__ */ lt(bBe).setParameterLength(1);
class f2 {
  /**
   * This method is intended for setting up lighting model and context data
   * which are later used in the evaluation process.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(e) {
    e.lightsNode.setupLights(e, e.lightsNode.getLightNodes(e)), this.indirect(e);
  }
  /**
   * This method is intended for executing final tasks like final updates
   * to the outgoing light.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish() {
  }
  /**
   * This method is intended for implementing the direct light term and
   * executed during the build process of directional, point and spot light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct() {
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @abstract
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea() {
  }
  /**
   * This method is intended for implementing the indirect light term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect() {
  }
  /**
   * This method is intended for implementing the ambient occlusion term.
   * Unlike other methods, this method must be called manually by the lighting
   * model in its indirect term.
   *
   * @abstract
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion() {
  }
}
class vme {
  /**
   * Constructs a new node attribute.
   *
   * @param {string} name - The name of the attribute.
   * @param {string} type - The type of the attribute.
   * @param {?Node} node - An optional reference to the node.
   */
  constructor(e, t, n = null) {
    this.isNodeAttribute = !0, this.name = e, this.type = t, this.node = n;
  }
}
class _Be {
  /**
   * Constructs a new node uniform.
   *
   * @param {string} name - The name of the uniform.
   * @param {string} type - The type of the uniform.
   * @param {UniformNode} node - An reference to the node.
   */
  constructor(e, t, n) {
    this.isNodeUniform = !0, this.name = e, this.type = t, this.node = n.getSelf();
  }
  /**
   * The value of the uniform node.
   *
   * @type {any}
   */
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
  /**
   * The id of the uniform node.
   *
   * @type {number}
   */
  get id() {
    return this.node.id;
  }
  /**
   * The uniform node's group.
   *
   * @type {UniformGroupNode}
   */
  get groupNode() {
    return this.node.groupNode;
  }
}
class eve {
  /**
   * Constructs a new node variable.
   *
   * @param {string} name - The name of the variable.
   * @param {string} type - The type of the variable.
   * @param {boolean} [readOnly=false] - The read-only flag.
   * @param {?number} [count=null] - The size.
   */
  constructor(e, t, n = !1, i = null) {
    this.isNodeVar = !0, this.name = e, this.type = t, this.readOnly = n, this.count = i;
  }
}
class SBe extends eve {
  /**
   * Constructs a new node varying.
   *
   * @param {string} name - The name of the varying.
   * @param {string} type - The type of the varying.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   */
  constructor(e, t, n = null, i = null) {
    super(e, t), this.needsInterpolation = !1, this.isNodeVarying = !0, this.interpolationType = n, this.interpolationSampling = i;
  }
}
class wBe {
  /**
   * Constructs a new code node.
   *
   * @param {string} name - The name of the code.
   * @param {string} type - The node type.
   * @param {string} [code=''] - The native shader code.
   */
  constructor(e, t, n = "") {
    this.name = e, this.type = t, this.code = n, Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
}
let EBe = 0;
class eV {
  /**
   * Constructs a new node cache.
   *
   * @param {?NodeCache} parent - A reference to a parent cache.
   */
  constructor(e = null) {
    this.id = EBe++, this.nodesData = /* @__PURE__ */ new WeakMap(), this.parent = e;
  }
  /**
   * Returns the data for the given node.
   *
   * @param {Node} node - The node.
   * @return {?Object} The data for the node.
   */
  getData(e) {
    let t = this.nodesData.get(e);
    return t === void 0 && this.parent !== null && (t = this.parent.getData(e)), t;
  }
  /**
   * Sets the data for a given node.
   *
   * @param {Node} node - The node.
   * @param {Object} data - The data that should be cached.
   */
  setData(e, t) {
    this.nodesData.set(e, t);
  }
}
class TBe {
  constructor(e, t) {
    this.name = e, this.members = t, this.output = !1;
  }
}
class sf {
  /**
   * Constructs a new uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {any} value - The uniform's value.
   */
  constructor(e, t) {
    this.name = e, this.value = t, this.boundary = 0, this.itemSize = 0, this.offset = 0;
  }
  /**
   * Sets the uniform's value.
   *
   * @param {any} value - The value to set.
   */
  setValue(e) {
    this.value = e;
  }
  /**
   * Returns the uniform's value.
   *
   * @return {any} The value.
   */
  getValue() {
    return this.value;
  }
}
class CBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {number} value - The uniform's value.
   */
  constructor(e, t = 0) {
    super(e, t), this.isNumberUniform = !0, this.boundary = 4, this.itemSize = 1;
  }
}
class PBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector2} value - The uniform's value.
   */
  constructor(e, t = new Pn()) {
    super(e, t), this.isVector2Uniform = !0, this.boundary = 8, this.itemSize = 2;
  }
}
class ABe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector3} value - The uniform's value.
   */
  constructor(e, t = new Ue()) {
    super(e, t), this.isVector3Uniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class kBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Vector4} value - The uniform's value.
   */
  constructor(e, t = new Bn()) {
    super(e, t), this.isVector4Uniform = !0, this.boundary = 16, this.itemSize = 4;
  }
}
class MBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Color} value - The uniform's value.
   */
  constructor(e, t = new er()) {
    super(e, t), this.isColorUniform = !0, this.boundary = 16, this.itemSize = 3;
  }
}
class RBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix2} value - The uniform's value.
   */
  constructor(e, t = new ZO()) {
    super(e, t), this.isMatrix2Uniform = !0, this.boundary = 8, this.itemSize = 4;
  }
}
class IBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix3} value - The uniform's value.
   */
  constructor(e, t = new Xo()) {
    super(e, t), this.isMatrix3Uniform = !0, this.boundary = 48, this.itemSize = 12;
  }
}
class NBe extends sf {
  /**
   * Constructs a new Number uniform.
   *
   * @param {string} name - The uniform's name.
   * @param {Matrix4} value - The uniform's value.
   */
  constructor(e, t = new Pr()) {
    super(e, t), this.isMatrix4Uniform = !0, this.boundary = 64, this.itemSize = 16;
  }
}
class OBe extends CBe {
  /**
   * Constructs a new node-based Number uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {number} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class DBe extends PBe {
  /**
   * Constructs a new node-based Vector2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class FBe extends ABe {
  /**
   * Constructs a new node-based Vector3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class BBe extends kBe {
  /**
   * Constructs a new node-based Vector4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Vector4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class LBe extends MBe {
  /**
   * Constructs a new node-based Color uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Color} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class jBe extends RBe {
  /**
   * Constructs a new node-based Matrix2 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix2} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class UBe extends IBe {
  /**
   * Constructs a new node-based Matrix3 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix3} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
class zBe extends NBe {
  /**
   * Constructs a new node-based Matrix4 uniform.
   *
   * @param {NodeUniform} nodeUniform - The node uniform.
   */
  constructor(e) {
    super(e.name, e.value), this.nodeUniform = e;
  }
  /**
   * Overwritten to return the value of the node uniform.
   *
   * @return {Matrix4} The value.
   */
  getValue() {
    return this.nodeUniform.value;
  }
  /**
   * Returns the node uniform data type.
   *
   * @return {string} The data type.
   */
  getType() {
    return this.nodeUniform.type;
  }
}
const bme = /* @__PURE__ */ new WeakMap(), VBe = /* @__PURE__ */ new Map([
  [Int8Array, "int"],
  [Int16Array, "int"],
  [Int32Array, "int"],
  [Uint8Array, "uint"],
  [Uint16Array, "uint"],
  [Uint32Array, "uint"],
  [Float32Array, "float"]
]), qN = (c) => /e/g.test(c) ? String(c).replace(/\+/g, "") : (c = Number(c), c + (c % 1 ? "" : ".0"));
class tve {
  /**
   * Constructs a new node builder.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The current renderer.
   * @param {NodeParser} parser - A reference to a node parser.
   */
  constructor(e, t, n) {
    this.object = e, this.material = e && e.material || null, this.geometry = e && e.geometry || null, this.renderer = t, this.parser = n, this.scene = null, this.camera = null, this.nodes = [], this.sequentialNodes = [], this.updateNodes = [], this.updateBeforeNodes = [], this.updateAfterNodes = [], this.hashNodes = {}, this.observer = null, this.lightsNode = null, this.environmentNode = null, this.fogNode = null, this.clippingContext = null, this.vertexShader = null, this.fragmentShader = null, this.computeShader = null, this.flowNodes = { vertex: [], fragment: [], compute: [] }, this.flowCode = { vertex: "", fragment: "", compute: "" }, this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }, this.structs = { vertex: [], fragment: [], compute: [], index: 0 }, this.bindings = { vertex: {}, fragment: {}, compute: {} }, this.bindingsIndexes = {}, this.bindGroups = null, this.attributes = [], this.bufferAttributes = [], this.varyings = [], this.codes = {}, this.vars = {}, this.declarations = {}, this.flow = { code: "" }, this.chaining = [], this.stack = x5(), this.stacks = [], this.tab = "	", this.currentFunctionNode = null, this.context = {
      material: this.material
    }, this.cache = new eV(), this.globalCache = this.cache, this.flowsData = /* @__PURE__ */ new WeakMap(), this.shaderStage = null, this.buildStage = null;
  }
  /**
   * Returns the bind groups of the current renderer.
   *
   * @return {ChainMap} The cache.
   */
  getBindGroupsCache() {
    let e = bme.get(this.renderer);
    return e === void 0 && (e = new hu(), bme.set(this.renderer, e)), e;
  }
  /**
   * Factory method for creating an instance of {@link RenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} width - The width of the render target.
   * @param {number} height - The height of the render target.
   * @param {Object} options - The options of the render target.
   * @return {RenderTarget} The render target.
   */
  createRenderTarget(e, t, n) {
    return new Mg(e, t, n);
  }
  /**
   * Factory method for creating an instance of {@link CubeRenderTarget} with the given
   * dimensions and options.
   *
   * @param {number} size - The size of the cube render target.
   * @param {Object} options - The options of the cube render target.
   * @return {CubeRenderTarget} The cube render target.
   */
  createCubeRenderTarget(e, t) {
    return new Q0e(e, t);
  }
  /**
   * Whether the given node is included in the internal array of nodes or not.
   *
   * @param {Node} node - The node to test.
   * @return {boolean} Whether the given node is included in the internal array of nodes or not.
   */
  includes(e) {
    return this.nodes.includes(e);
  }
  /**
   * Returns the output struct name which is required by
   * {@link OutputStructNode}.
   *
   * @abstract
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
  }
  /**
   * Returns a bind group for the given group name and binding.
   *
   * @private
   * @param {string} groupName - The group name.
   * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
   * @return {BindGroup} The bind group
   */
  _getBindGroup(e, t) {
    const n = this.getBindGroupsCache(), i = [];
    let o = !0;
    for (const p of t)
      i.push(p), o = o && p.groupNode.shared !== !0;
    let l;
    return o ? (l = n.get(i), l === void 0 && (l = new m6(e, i, this.bindingsIndexes[e].group, i), n.set(i, l))) : l = new m6(e, i, this.bindingsIndexes[e].group, i), l;
  }
  /**
   * Returns an array of node uniform groups for the given group name and shader stage.
   *
   * @param {string} groupName - The group name.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
   */
  getBindGroupArray(e, t) {
    const n = this.bindings[t];
    let i = n[e];
    return i === void 0 && (this.bindingsIndexes[e] === void 0 && (this.bindingsIndexes[e] = { binding: 0, group: Object.keys(this.bindingsIndexes).length }), n[e] = i = []), i;
  }
  /**
   * Returns a list bindings of all shader stages separated by groups.
   *
   * @return {Array<BindGroup>} The list of bindings.
   */
  getBindings() {
    let e = this.bindGroups;
    if (e === null) {
      const t = {}, n = this.bindings;
      for (const i of vfe)
        for (const o in n[i]) {
          const l = n[i][o];
          (t[o] || (t[o] = [])).push(...l);
        }
      e = [];
      for (const i in t) {
        const o = t[i], l = this._getBindGroup(i, o);
        e.push(l);
      }
      this.bindGroups = e;
    }
    return e;
  }
  /**
   * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
   */
  sortBindingGroups() {
    const e = this.getBindings();
    e.sort((t, n) => t.bindings[0].groupNode.order - n.bindings[0].groupNode.order);
    for (let t = 0; t < e.length; t++) {
      const n = e[t];
      this.bindingsIndexes[n.name].group = t, n.index = t;
    }
  }
  /**
   * The builder maintains each node in a hash-based dictionary.
   * This method sets the given node (value) with the given hash (key) into this dictionary.
   *
   * @param {Node} node - The node to add.
   * @param {number} hash - The hash of the node.
   */
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  /**
   * Adds a node to this builder.
   *
   * @param {Node} node - The node to add.
   */
  addNode(e) {
    this.nodes.includes(e) === !1 && (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  /**
   * It is used to add Nodes that will be used as FRAME and RENDER events,
   * and need to follow a certain sequence in the calls to work correctly.
   * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
   *
   * @param {Node} node - The node to add.
   */
  addSequentialNode(e) {
    this.sequentialNodes.includes(e) === !1 && this.sequentialNodes.push(e);
  }
  /**
   * Checks the update types of nodes
   */
  buildUpdateNodes() {
    for (const e of this.nodes)
      e.getUpdateType() !== In.NONE && this.updateNodes.push(e.getSelf());
    for (const e of this.sequentialNodes) {
      const t = e.getUpdateBeforeType(), n = e.getUpdateAfterType();
      t !== In.NONE && this.updateBeforeNodes.push(e.getSelf()), n !== In.NONE && this.updateAfterNodes.push(e.getSelf());
    }
  }
  /**
   * A reference the current node which is the
   * last node in the chain of nodes.
   *
   * @type {Node}
   */
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  /**
   * Whether the given texture is filtered or not.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture is filtered or not.
   */
  isFilteredTexture(e) {
    return e.magFilter === Ea || e.magFilter === UV || e.magFilter === EE || e.magFilter === Ud || e.minFilter === Ea || e.minFilter === UV || e.minFilter === EE || e.minFilter === Ud;
  }
  /**
   * Adds the given node to the internal node chain.
   * This is used to check recursive calls in node-graph.
   *
   * @param {Node} node - The node to add.
   */
  addChain(e) {
    this.chaining.push(e);
  }
  /**
   * Removes the given node from the internal node chain.
   *
   * @param {Node} node - The node to remove.
   */
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  /**
   * Returns the native shader method name for a given generic name. E.g.
   * the method name `textureDimensions` matches the WGSL name but must be
   * resolved to `textureSize` in GLSL.
   *
   * @abstract
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved method name.
   */
  getMethod(e) {
    return e;
  }
  /**
   * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
   *
   * @param {number} hash - The hash of the node.
   * @return {Node} The found node.
   */
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  /**
   * Adds the Node to a target flow so that it can generate code in the 'generate' process.
   *
   * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
   * @param {Node} node - The node to add.
   * @return {Node} The node.
   */
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  /**
   * Sets builder's context.
   *
   * @param {Object} context - The context to set.
   */
  setContext(e) {
    this.context = e;
  }
  /**
   * Returns the builder's current context.
   *
   * @return {Object} The builder's current context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Gets a context used in shader construction that can be shared across different materials.
   * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
   *
   * @return {Object} The builder's current context without material.
   */
  getSharedContext() {
    return { ...this.context }, this.context;
  }
  /**
   * Sets builder's cache.
   *
   * @param {NodeCache} cache - The cache to set.
   */
  setCache(e) {
    this.cache = e;
  }
  /**
   * Returns the builder's current cache.
   *
   * @return {NodeCache} The builder's current cache.
   */
  getCache() {
    return this.cache;
  }
  /**
   * Returns a cache for the given node.
   *
   * @param {Node} node - The node.
   * @param {boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
   * @return {NodeCache} The cache.
   */
  getCacheFromNode(e, t = !0) {
    const n = this.getDataFromNode(e);
    return n.cache === void 0 && (n.cache = new eV(t ? this.getCache() : null)), n.cache;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @abstract
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable() {
    return !1;
  }
  /**
   * Returns the vertexIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the instanceIndex input variable as a native shader string.
   *
   * @abstract
   * @return {string} The instanceIndex shader string.
   */
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the drawIndex input variable as a native shader string.
   * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
   *
   * @abstract
   * @return {?string} The drawIndex shader string.
   */
  getDrawIndex() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the frontFacing input variable as a native shader string.
   *
   * @abstract
   * @return {string} The frontFacing shader string.
   */
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the fragCoord input variable as a native shader string.
   *
   * @abstract
   * @return {string} The fragCoord shader string.
   */
  getFragCoord() {
    console.warn("Abstract function.");
  }
  /**
   * Whether to flip texture data along its vertical axis or not. WebGL needs
   * this method evaluate to `true`, WebGPU to `false`.
   *
   * @abstract
   * @return {boolean} Whether to flip texture data along its vertical axis or not.
   */
  isFlipY() {
    return !1;
  }
  /**
   * Calling this method increases the usage count for the given node by one.
   *
   * @param {Node} node - The node to increase the usage count for.
   * @return {number} The updated usage count.
   */
  increaseUsage(e) {
    const t = this.getDataFromNode(e);
    return t.usageCount = t.usageCount === void 0 ? 1 : t.usageCount + 1, t.usageCount;
  }
  /**
   * Generates a texture sample shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @return {string} The generated shader string.
   */
  generateTexture() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a texture LOD shader string for the given texture data.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The texture property name.
   * @param {string} uvSnippet - Snippet defining the texture coordinates.
   * @param {?string} depthSnippet - Snippet defining the 0-based texture array index to sample.
   * @param {string} levelSnippet - Snippet defining the mip level.
   * @return {string} The generated shader string.
   */
  generateTextureLod() {
    console.warn("Abstract function.");
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(e, t) {
    return this.getType(e) + "[ " + t + " ]";
  }
  /**
   * Generates the array shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateArray(e, t, n = null) {
    let i = this.generateArrayDeclaration(e, t) + "( ";
    for (let o = 0; o < t; o++) {
      const l = n ? n[o] : null;
      l !== null ? i += l.build(this, e) : i += this.generateConst(e), o < t - 1 && (i += ", ");
    }
    return i += " )", i;
  }
  /**
   * Generates the struct shader string.
   *
   * @param {string} type - The type.
   * @param {Array<Object>} [membersLayout] - The count.
   * @param {?Array<Node>} [values=null] - The default values.
   * @return {string} The generated value as a shader string.
   */
  generateStruct(e, t, n = null) {
    const i = [];
    for (const o of t) {
      const { name: l, type: p } = o;
      n && n[l] && n[l].isNode ? i.push(n[l].build(this, p)) : i.push(this.generateConst(p));
    }
    return e + "( " + i.join(", ") + " )";
  }
  /**
   * Generates the shader string for the given type and value.
   *
   * @param {string} type - The type.
   * @param {?any} [value=null] - The value.
   * @return {string} The generated value as a shader string.
   */
  generateConst(e, t = null) {
    if (t === null && (e === "float" || e === "int" || e === "uint" ? t = 0 : e === "bool" ? t = !1 : e === "color" ? t = new er() : e === "vec2" ? t = new Pn() : e === "vec3" ? t = new Ue() : e === "vec4" && (t = new Bn())), e === "float") return qN(t);
    if (e === "int") return `${Math.round(t)}`;
    if (e === "uint") return t >= 0 ? `${Math.round(t)}u` : "0u";
    if (e === "bool") return t ? "true" : "false";
    if (e === "color") return `${this.getType("vec3")}( ${qN(t.r)}, ${qN(t.g)}, ${qN(t.b)} )`;
    const n = this.getTypeLength(e), i = this.getComponentType(e), o = (l) => this.generateConst(i, l);
    if (n === 2)
      return `${this.getType(e)}( ${o(t.x)}, ${o(t.y)} )`;
    if (n === 3)
      return `${this.getType(e)}( ${o(t.x)}, ${o(t.y)}, ${o(t.z)} )`;
    if (n === 4 && e !== "mat2")
      return `${this.getType(e)}( ${o(t.x)}, ${o(t.y)}, ${o(t.z)}, ${o(t.w)} )`;
    if (n >= 4 && t && (t.isMatrix2 || t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(o).join(", ")} )`;
    if (n > 4)
      return `${this.getType(e)}()`;
    throw new Error(`NodeBuilder: Type '${e}' not found in generate constant attempt.`);
  }
  /**
   * It might be necessary to convert certain data types to different ones
   * so this method can be used to hide the conversion.
   *
   * @param {string} type - The type.
   * @return {string} The updated type.
   */
  getType(e) {
    return e === "color" ? "vec3" : e;
  }
  /**
   * Whether the given attribute name is defined in the geometry or not.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether the given attribute name is defined in the geometry.
   */
  hasGeometryAttribute(e) {
    return this.geometry && this.geometry.getAttribute(e) !== void 0;
  }
  /**
   * Returns a node attribute for the given name and type.
   *
   * @param {string} name - The attribute's name.
   * @param {string} type - The attribute's type.
   * @return {NodeAttribute} The node attribute.
   */
  getAttribute(e, t) {
    const n = this.attributes;
    for (const o of n)
      if (o.name === e)
        return o;
    const i = new vme(e, t);
    return this.registerDeclaration(i), n.push(i), i;
  }
  /**
   * Returns for the given node and shader stage the property name for the shader.
   *
   * @param {Node} node - The node.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The property name.
   */
  getPropertyName(e) {
    return e.name;
  }
  /**
   * Whether the given type is a vector type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a vector type or not.
   */
  isVector(e) {
    return /vec\d/.test(e);
  }
  /**
   * Whether the given type is a matrix type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a matrix type or not.
   */
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  /**
   * Whether the given type is a reference type or not.
   *
   * @param {string} type - The type to check.
   * @return {boolean} Whether the given type is a reference type or not.
   */
  isReference(e) {
    return e === "void" || e === "property" || e === "sampler" || e === "samplerComparison" || e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "depthTexture" || e === "texture3D";
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @abstract
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace() {
    return !1;
  }
  /**
   * Returns the component type of a given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The component type.
   */
  getComponentTypeFromTexture(e) {
    const t = e.type;
    if (e.isDataTexture) {
      if (t === fo) return "int";
      if (t === xi) return "uint";
    }
    return "float";
  }
  /**
   * Returns the element type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The element type.
   */
  getElementType(e) {
    return e === "mat2" ? "vec2" : e === "mat3" ? "vec3" : e === "mat4" ? "vec4" : this.getComponentType(e);
  }
  /**
   * Returns the component type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The component type.
   */
  getComponentType(e) {
    if (e = this.getVectorType(e), e === "float" || e === "bool" || e === "int" || e === "uint") return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return t === null ? null : t[1] === "b" ? "bool" : t[1] === "i" ? "int" : t[1] === "u" ? "uint" : "float";
  }
  /**
   * Returns the vector type for a given type.
   *
   * @param {string} type - The type.
   * @return {string} The vector type.
   */
  getVectorType(e) {
    return e === "color" ? "vec3" : e === "texture" || e === "cubeTexture" || e === "storageTexture" || e === "texture3D" ? "vec4" : e;
  }
  /**
   * Returns the data type for the given the length and component type.
   *
   * @param {number} length - The length.
   * @param {string} [componentType='float'] - The component type.
   * @return {string} The type.
   */
  getTypeFromLength(e, t = "float") {
    if (e === 1) return t;
    let n = PRe(e);
    const i = t === "float" ? "" : t[0];
    return /mat2/.test(t) === !0 && (n = n.replace("vec", "mat")), i + n;
  }
  /**
   * Returns the type for a given typed array.
   *
   * @param {TypedArray} array - The typed array.
   * @return {string} The type.
   */
  getTypeFromArray(e) {
    return VBe.get(e.constructor);
  }
  /**
   * Returns the type is an integer type.
   *
   * @param {string} type - The type.
   * @return {boolean} Whether the type is an integer type or not.
   */
  isInteger(e) {
    return /int|uint|(i|u)vec/.test(e);
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const n = t.array, i = e.itemSize, o = e.normalized;
    let l;
    return !(e instanceof kye) && o !== !0 && (l = this.getTypeFromArray(n)), this.getTypeFromLength(i, l);
  }
  /**
   * Returns the length for the given data type.
   *
   * @param {string} type - The data type.
   * @return {number} The length.
   */
  getTypeLength(e) {
    const t = this.getVectorType(e), n = /vec([2-4])/.exec(t);
    return n !== null ? Number(n[1]) : t === "float" || t === "bool" || t === "int" || t === "uint" ? 1 : /mat2/.test(e) === !0 ? 4 : /mat3/.test(e) === !0 ? 9 : /mat4/.test(e) === !0 ? 16 : 0;
  }
  /**
   * Returns the vector type for a given matrix type.
   *
   * @param {string} type - The matrix type.
   * @return {string} The vector type.
   */
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  /**
   * For a given type this method changes the component type to the
   * given value. E.g. `vec4` should be changed to the new component type
   * `uint` which results in `uvec4`.
   *
   * @param {string} type - The type.
   * @param {string} newComponentType - The new component type.
   * @return {string} The new type.
   */
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  /**
   * Returns the integer type pendant for the given type.
   *
   * @param {string} type - The type.
   * @return {string} The integer type.
   */
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return t === "int" || t === "uint" ? e : this.changeComponentType(e, "int");
  }
  /**
   * Adds a stack node to the internal stack.
   *
   * @return {StackNode} The added stack node.
   */
  addStack() {
    return this.stack = x5(this.stack), this.stacks.push(Bye() || this.stack), LO(this.stack), this.stack;
  }
  /**
   * Removes the last stack node from the internal stack.
   *
   * @return {StackNode} The removed stack node.
   */
  removeStack() {
    const e = this.stack;
    return this.stack = e.parent, LO(this.stacks.pop()), e;
  }
  /**
   * The builder maintains (cached) data for each node during the building process. This method
   * can be used to get these data for a specific shader stage and cache.
   *
   * @param {Node} node - The node to get the data for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?NodeCache} cache - An optional cache.
   * @return {Object} The node data.
   */
  getDataFromNode(e, t = this.shaderStage, n = null) {
    n = n === null ? e.isGlobal(this) ? this.globalCache : this.cache : n;
    let i = n.getData(e);
    return i === void 0 && (i = {}, n.setData(e, i)), i[t] === void 0 && (i[t] = {}), i[t];
  }
  /**
   * Returns the properties for the given node and shader stage.
   *
   * @param {Node} node - The node to get the properties for.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
   * @return {Object} The node properties.
   */
  getNodeProperties(e, t = "any") {
    const n = this.getDataFromNode(e, t);
    return n.properties || (n.properties = { outputNode: null });
  }
  /**
   * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
   *
   * @param {BufferAttributeNode} node - The buffer attribute node.
   * @param {string} type - The node type.
   * @return {NodeAttribute} The node attribute.
   */
  getBufferAttributeFromNode(e, t) {
    const n = this.getDataFromNode(e);
    let i = n.bufferAttribute;
    if (i === void 0) {
      const o = this.uniforms.index++;
      i = new vme("nodeAttribute" + o, t, e), this.bufferAttributes.push(i), n.bufferAttribute = i;
    }
    return i;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @param {?string} [name=null] - The name of the struct.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {StructType} The struct type attribute.
   */
  getStructTypeFromNode(e, t, n = null, i = this.shaderStage) {
    const o = this.getDataFromNode(e, i, this.globalCache);
    let l = o.structType;
    if (l === void 0) {
      const p = this.structs.index++;
      n === null && (n = "StructType" + p), l = new TBe(n, t), this.structs[i].push(l), o.structType = l;
    }
    return l;
  }
  /**
   * Returns an instance of {@link StructType} for the given output struct node.
   *
   * @param {OutputStructNode} node - The output struct node.
   * @param {Array<Object>} membersLayout - The output struct types.
   * @return {StructType} The struct type attribute.
   */
  getOutputStructTypeFromNode(e, t) {
    const n = this.getStructTypeFromNode(e, t, "OutputType", "fragment");
    return n.output = !0, n;
  }
  /**
   * Returns an instance of {@link NodeUniform} for the given uniform node.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The uniform type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {?string} name - The name of the uniform.
   * @return {NodeUniform} The node uniform.
   */
  getUniformFromNode(e, t, n = this.shaderStage, i = null) {
    const o = this.getDataFromNode(e, n, this.globalCache);
    let l = o.uniform;
    if (l === void 0) {
      const p = this.uniforms.index++;
      l = new _Be(i || "nodeUniform" + p, t, e), this.uniforms[n].push(l), this.registerDeclaration(l), o.uniform = l;
    }
    return l;
  }
  /**
   * Returns the array length.
   *
   * @param {Node} node - The node.
   * @return {?number} The array length.
   */
  getArrayCount(e) {
    let t = null;
    return e.isArrayNode ? t = e.count : e.isVarNode && e.node.isArrayNode && (t = e.node.count), t;
  }
  /**
   * Returns an instance of {@link NodeVar} for the given variable node.
   *
   * @param {VarNode} node - The variable node.
   * @param {?string} name - The variable's name.
   * @param {string} [type=node.getNodeType( this )] - The variable's type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @param {boolean} [readOnly=false] - Whether the variable is read-only or not.
   *
   * @return {NodeVar} The node variable.
   */
  getVarFromNode(e, t = null, n = e.getNodeType(this), i = this.shaderStage, o = !1) {
    const l = this.getDataFromNode(e, i);
    let p = l.variable;
    if (p === void 0) {
      const f = o ? "_const" : "_var", v = this.vars[i] || (this.vars[i] = []), _ = this.vars[f] || (this.vars[f] = 0);
      t === null && (t = (o ? "nodeConst" : "nodeVar") + _, this.vars[f]++);
      const E = this.getArrayCount(e);
      p = new eve(t, n, o, E), o || v.push(p), this.registerDeclaration(p), l.variable = p;
    }
    return p;
  }
  /**
   * Returns whether a Node or its flow is deterministic, useful for use in `const`.
   *
   * @param {Node} node - The varying node.
   * @return {boolean} Returns true if deterministic.
   */
  isDeterministic(e) {
    if (e.isMathNode)
      return this.isDeterministic(e.aNode) && (e.bNode ? this.isDeterministic(e.bNode) : !0) && (e.cNode ? this.isDeterministic(e.cNode) : !0);
    if (e.isOperatorNode)
      return this.isDeterministic(e.aNode) && (e.bNode ? this.isDeterministic(e.bNode) : !0);
    if (e.isArrayNode) {
      if (e.values !== null) {
        for (const t of e.values)
          if (!this.isDeterministic(t))
            return !1;
      }
      return !0;
    } else if (e.isConstNode)
      return !0;
    return !1;
  }
  /**
   * Returns an instance of {@link NodeVarying} for the given varying node.
   *
   * @param {(VaryingNode|PropertyNode)} node - The varying node.
   * @param {?string} name - The varying's name.
   * @param {string} [type=node.getNodeType( this )] - The varying's type.
   * @param {?string} interpolationType - The interpolation type of the varying.
   * @param {?string} interpolationSampling - The interpolation sampling type of the varying.
   * @return {NodeVar} The node varying.
   */
  getVaryingFromNode(e, t = null, n = e.getNodeType(this), i = null, o = null) {
    const l = this.getDataFromNode(e, "any");
    let p = l.varying;
    if (p === void 0) {
      const f = this.varyings, v = f.length;
      t === null && (t = "nodeVarying" + v), p = new SBe(t, n, i, o), f.push(p), this.registerDeclaration(p), l.varying = p;
    }
    return p;
  }
  /**
   * Returns the current namespace for the node builder.
   *
   * @return {string} The current namespace.
   */
  get namespace() {
    return this.context.namespace;
  }
  /**
   * Returns the output namespace for the node builder, which is used for the current output node.
   *
   * @return {string} The output namespace.
   */
  getOutputNamespace() {
    return this.getNamespace("outputNode");
  }
  /**
   * Returns the namespace for the given property.
   *
   * If the property name is not set, it returns the namespace only.
   * If the namespace is not set, it returns the property name.
   * If the namespace is set, it returns the namespace concatenated with the property name.
   *
   * @param {string} [property=''] - The property name.
   * @return {string} The namespace for the property.
   */
  getNamespace(e = "") {
    const t = this.namespace;
    let n;
    return t ? n = e ? t + "_" + e : t : n = e, n;
  }
  /**
   * Registers a node declaration in the current shader stage.
   *
   * @param {Object} node - The node to be registered.
   */
  registerDeclaration(e) {
    const t = this.shaderStage, n = this.declarations[t] || (this.declarations[t] = {}), i = this.getPropertyName(e);
    let o = 1, l = i;
    for (; n[l] !== void 0; )
      l = i + "_" + o++;
    o > 1 && (e.name = l, console.warn(`THREE.TSL: Declaration name '${i}' of '${e.type}' already in use. Renamed to '${l}'.`)), n[l] = e;
  }
  /**
   * Returns an instance of {@link NodeCode} for the given code node.
   *
   * @param {CodeNode} node - The code node.
   * @param {string} type - The node type.
   * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
   * @return {NodeCode} The node code.
   */
  getCodeFromNode(e, t, n = this.shaderStage) {
    const i = this.getDataFromNode(e);
    let o = i.code;
    if (o === void 0) {
      const l = this.codes[n] || (this.codes[n] = []), p = l.length;
      o = new wBe("nodeCode" + p, t), l.push(o), i.code = o;
    }
    return o;
  }
  /**
  	 * Adds a code flow based on the code-block hierarchy.
  
  	 * This is used so that code-blocks like If,Else create their variables locally if the Node
  	 * is only used inside one of these conditionals in the current shader stage.
  	 *
  	 * @param {Node} node - The node to add.
  	 * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
  	 */
  addFlowCodeHierarchy(e, t) {
    const { flowCodes: n, flowCodeBlock: i } = this.getDataFromNode(e);
    let o = !0, l = t;
    for (; l; ) {
      if (i.get(l) === !0) {
        o = !1;
        break;
      }
      l = this.getDataFromNode(l).parentNodeBlock;
    }
    if (o)
      for (const p of n)
        this.addLineFlowCode(p);
  }
  /**
   * Add a inline-code to the current flow code-block.
   *
   * @param {Node} node - The node to add.
   * @param {string} code - The code to add.
   * @param {Node} nodeBlock - Current ConditionalNode
   */
  addLineFlowCodeBlock(e, t, n) {
    const i = this.getDataFromNode(e), o = i.flowCodes || (i.flowCodes = []), l = i.flowCodeBlock || (i.flowCodeBlock = /* @__PURE__ */ new WeakMap());
    o.push(t), l.set(n, !0);
  }
  /**
   * Add a inline-code to the current flow.
   *
   * @param {string} code - The code to add.
   * @param {?Node} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addLineFlowCode(e, t = null) {
    return e === "" ? this : (t !== null && this.context.nodeBlock && this.addLineFlowCodeBlock(t, e, this.context.nodeBlock), e = this.tab + e, /;\s*$/.test(e) || (e = e + `;
`), this.flow.code += e, this);
  }
  /**
   * Adds a code to the current code flow.
   *
   * @param {string} code - Shader code.
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowCode(e) {
    return this.flow.code += e, this;
  }
  /**
   * Add tab in the code that will be generated so that other snippets respect the current tabulation.
   * Typically used in codes with If,Else.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  addFlowTab() {
    return this.tab += "	", this;
  }
  /**
   * Removes a tab.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  removeFlowTab() {
    return this.tab = this.tab.slice(0, -1), this;
  }
  /**
   * Gets the current flow data based on a Node.
   *
   * @param {Node} node - Node that the flow was started.
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {Object} The flow data.
   */
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  /**
   * Executes the node flow based on a root node to generate the final shader code.
   *
   * @param {Node} node - The node to execute.
   * @return {Object} The code flow.
   */
  flowNode(e) {
    const t = e.getNodeType(this), n = this.flowChildNode(e, t);
    return this.flowsData.set(e, n), n;
  }
  /**
   * Includes a node in the current function node.
   *
   * @param {Node} node - The node to include.
   * @returns {void}
   */
  addInclude(e) {
    this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(e);
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
   * @return {FunctionNode} The build function node.
   */
  buildFunctionNode(e) {
    const t = new JDe(), n = this.currentFunctionNode;
    return this.currentFunctionNode = t, t.code = this.buildFunctionCode(e), this.currentFunctionNode = n, t;
  }
  /**
   * Generates a code flow based on a TSL function: Fn().
   *
   * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
   * @return {Object}
   */
  flowShaderNode(e) {
    const t = e.layout, n = {
      [Symbol.iterator]() {
        let l = 0;
        const p = Object.values(this);
        return {
          next: () => ({
            value: p[l],
            done: l++ >= p.length
          })
        };
      }
    };
    for (const l of t.inputs)
      n[l.name] = new kOe(l.type, l.name);
    e.layout = null;
    const i = e.call(n), o = this.flowStagesNode(i, t.type);
    return e.layout = t, o;
  }
  /**
   * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object}
   */
  flowStagesNode(e, t = null) {
    const n = this.flow, i = this.vars, o = this.declarations, l = this.cache, p = this.buildStage, f = this.stack, v = {
      code: ""
    };
    this.flow = v, this.vars = {}, this.declarations = {}, this.cache = new eV(), this.stack = x5();
    for (const _ of yfe)
      this.setBuildStage(_), v.result = e.build(this, t);
    return v.vars = this.getVars(this.shaderStage), this.flow = n, this.vars = i, this.declarations = o, this.cache = l, this.stack = f, this.setBuildStage(p), v;
  }
  /**
   * Returns the native shader operator name for a given generic name.
   * It is a similar type of method like {@link NodeBuilder#getMethod}.
   *
   * @abstract
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator() {
    return null;
  }
  /**
   * Builds the given shader node.
   *
   * @abstract
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The function code.
   */
  buildFunctionCode() {
    console.warn("Abstract function.");
  }
  /**
   * Generates a code flow based on a child Node.
   *
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @return {Object} The code flow.
   */
  flowChildNode(e, t = null) {
    const n = this.flow, i = {
      code: ""
    };
    return this.flow = i, i.result = e.build(this, t), this.flow = n, i;
  }
  /**
   * Executes a flow of code in a different stage.
   *
   * Some nodes like `varying()` have the ability to compute code in vertex-stage and
   * return the value in fragment-stage even if it is being executed in an input fragment.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @param {Node} node - The node to execute.
   * @param {?string} output - Expected output type. For example 'vec3'.
   * @param {?string} propertyName - The property name to assign the result.
   * @return {Object|Node|null} The code flow or node.build() result.
   */
  flowNodeFromShaderStage(e, t, n = null, i = null) {
    const o = this.tab, l = this.cache, p = this.shaderStage, f = this.context;
    this.setShaderStage(e);
    const v = { ...this.context };
    delete v.nodeBlock, this.cache = this.globalCache, this.tab = "	", this.context = v;
    let _ = null;
    if (this.buildStage === "generate") {
      const E = this.flowChildNode(t, n);
      i !== null && (E.code += `${this.tab + i} = ${E.result};
`), this.flowCode[e] = this.flowCode[e] + E.code, _ = E;
    } else
      _ = t.build(this);
    return this.setShaderStage(p), this.cache = l, this.tab = o, this.context = f, _;
  }
  /**
   * Returns an array holding all node attributes of this node builder.
   *
   * @return {Array<NodeAttribute>} The node attributes of this builder.
   */
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  /**
   * Returns the attribute definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The attribute code section.
   */
  getAttributes() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the varying definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The varying code section.
   */
  getVaryings() {
    console.warn("Abstract function.");
  }
  /**
   * Returns a single variable definition as a shader string for the given variable type and name.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The shader string.
   */
  getVar(e, t, n = null) {
    return `${n !== null ? this.generateArrayDeclaration(e, n) : this.getType(e)} ${t}`;
  }
  /**
   * Returns the variable definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The variable code section.
   */
  getVars(e) {
    let t = "";
    const n = this.vars[e];
    if (n !== void 0)
      for (const i of n)
        t += `${this.getVar(i.type, i.name)}; `;
    return t;
  }
  /**
   * Returns the uniform definitions as a shader string for the given shader stage.
   *
   * @abstract
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The uniform code section.
   */
  getUniforms() {
    console.warn("Abstract function.");
  }
  /**
   * Returns the native code definitions as a shader string for the given shader stage.
   *
   * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
   * @return {string} The native code section.
   */
  getCodes(e) {
    const t = this.codes[e];
    let n = "";
    if (t !== void 0)
      for (const i of t)
        n += i.code + `
`;
    return n;
  }
  /**
   * Returns the hash of this node builder.
   *
   * @return {string} The hash.
   */
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  /**
   * Sets the current shader stage.
   *
   * @param {?('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage to set.
   */
  setShaderStage(e) {
    this.shaderStage = e;
  }
  /**
   * Returns the current shader stage.
   *
   * @return {?('vertex'|'fragment'|'compute'|'any')} The current shader stage.
   */
  getShaderStage() {
    return this.shaderStage;
  }
  /**
   * Sets the current build stage.
   *
   * @param {?('setup'|'analyze'|'generate')} buildStage - The build stage to set.
   */
  setBuildStage(e) {
    this.buildStage = e;
  }
  /**
   * Returns the current build stage.
   *
   * @return {?('setup'|'analyze'|'generate')} The current build stage.
   */
  getBuildStage() {
    return this.buildStage;
  }
  /**
   * Controls the code build of the shader stages.
   *
   * @abstract
   */
  buildCode() {
    console.warn("Abstract function.");
  }
  /**
   * Central build method which controls the build for the given object.
   *
   * @return {NodeBuilder} A reference to this node builder.
   */
  build() {
    const { object: e, material: t, renderer: n } = this;
    if (t !== null) {
      let i = n.library.fromMaterial(t);
      i === null && (console.error(`NodeMaterial: Material "${t.type}" is not compatible.`), i = new Ni()), i.build(this);
    } else
      this.addFlow("compute", e);
    for (const i of yfe) {
      this.setBuildStage(i), this.context.vertex && this.context.vertex.isNode && this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const o of vfe) {
        this.setShaderStage(o);
        const l = this.flowNodes[o];
        for (const p of l)
          i === "generate" ? this.flowNode(p) : p.build(this);
      }
    }
    return this.setBuildStage(null), this.setShaderStage(null), this.buildCode(), this.buildUpdateNodes(), this;
  }
  /**
   * Returns a uniform representation which is later used for UBO generation and rendering.
   *
   * @param {NodeUniform} uniformNode - The uniform node.
   * @param {string} type - The requested type.
   * @return {Uniform} The uniform.
   */
  getNodeUniform(e, t) {
    if (t === "float" || t === "int" || t === "uint") return new OBe(e);
    if (t === "vec2" || t === "ivec2" || t === "uvec2") return new DBe(e);
    if (t === "vec3" || t === "ivec3" || t === "uvec3") return new FBe(e);
    if (t === "vec4" || t === "ivec4" || t === "uvec4") return new BBe(e);
    if (t === "color") return new LBe(e);
    if (t === "mat2") return new jBe(e);
    if (t === "mat3") return new UBe(e);
    if (t === "mat4") return new zBe(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  /**
   * Formats the given shader snippet from a given type into another one. E.g.
   * this method might be used to convert a simple float string `"1.0"` into a
   * `vec3` representation: `"vec3<f32>( 1.0 )"`.
   *
   * @param {string} snippet - The shader snippet.
   * @param {string} fromType - The source type.
   * @param {string} toType - The target type.
   * @return {string} The updated shader string.
   */
  format(e, t, n) {
    if (t = this.getVectorType(t), n = this.getVectorType(n), t === n || n === null || this.isReference(n))
      return e;
    const i = this.getTypeLength(t), o = this.getTypeLength(n);
    return i === 16 && o === 9 ? `${this.getType(n)}( ${e}[ 0 ].xyz, ${e}[ 1 ].xyz, ${e}[ 2 ].xyz )` : i === 9 && o === 4 ? `${this.getType(n)}( ${e}[ 0 ].xy, ${e}[ 1 ].xy )` : i > 4 || o > 4 || o === 0 ? e : i === o ? `${this.getType(n)}( ${e} )` : i > o ? (e = n === "bool" ? `all( ${e} )` : `${e}.${"xyz".slice(0, o)}`, this.format(e, this.getTypeFromLength(o, this.getComponentType(t)), n)) : o === 4 && i > 1 ? `${this.getType(n)}( ${this.format(e, t, "vec3")}, 1.0 )` : i === 2 ? `${this.getType(n)}( ${this.format(e, t, "vec2")}, 0.0 )` : (i === 1 && o > 1 && t !== this.getComponentType(n) && (e = `${this.getType(this.getComponentType(n))}( ${e} )`), `${this.getType(n)}( ${e} )`);
  }
  /**
   * Returns a signature with the engine's current revision.
   *
   * @return {string} The signature.
   */
  getSignature() {
    return `// Three.js r${Yge} - Node System
`;
  }
  /**
   * Prevents the node builder from being used as an iterable in TSL.Fn(), avoiding potential runtime errors.
   */
  *[Symbol.iterator]() {
  }
  // Deprecated
  /**
   * @function
   * @deprecated since r168. Use `new NodeMaterial()` instead, with targeted node material name.
   *
   * @param {string} [type='NodeMaterial'] - The node material type.
   * @throws {Error}
   */
  createNodeMaterial(e = "NodeMaterial") {
    throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${e}() instead.`);
  }
}
class xme {
  /**
   * Constructs a new node fame.
   */
  constructor() {
    this.time = 0, this.deltaTime = 0, this.frameId = 0, this.renderId = 0, this.updateMap = /* @__PURE__ */ new WeakMap(), this.updateBeforeMap = /* @__PURE__ */ new WeakMap(), this.updateAfterMap = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.material = null, this.camera = null, this.object = null, this.scene = null;
  }
  /**
   * Returns a dictionary for a given node and update map which
   * is used to correctly call node update methods per frame or render.
   *
   * @private
   * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
   * @param {Node} nodeRef - The reference to the current node.
   * @return {Object<string,WeakMap>} The dictionary.
   */
  _getMaps(e, t) {
    let n = e.get(t);
    return n === void 0 && (n = {
      renderMap: /* @__PURE__ */ new WeakMap(),
      frameMap: /* @__PURE__ */ new WeakMap()
    }, e.set(t, n)), n;
  }
  /**
   * This method executes the {@link Node#updateBefore} for the given node.
   * It makes sure {@link Node#updateBeforeType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType(), n = e.updateReference(this);
    if (t === In.FRAME) {
      const { frameMap: i } = this._getMaps(this.updateBeforeMap, n);
      i.get(n) !== this.frameId && e.updateBefore(this) !== !1 && i.set(n, this.frameId);
    } else if (t === In.RENDER) {
      const { renderMap: i } = this._getMaps(this.updateBeforeMap, n);
      i.get(n) !== this.renderId && e.updateBefore(this) !== !1 && i.set(n, this.renderId);
    } else t === In.OBJECT && e.updateBefore(this);
  }
  /**
   * This method executes the {@link Node#updateAfter} for the given node.
   * It makes sure {@link Node#updateAfterType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateAfterNode(e) {
    const t = e.getUpdateAfterType(), n = e.updateReference(this);
    if (t === In.FRAME) {
      const { frameMap: i } = this._getMaps(this.updateAfterMap, n);
      i.get(n) !== this.frameId && e.updateAfter(this) !== !1 && i.set(n, this.frameId);
    } else if (t === In.RENDER) {
      const { renderMap: i } = this._getMaps(this.updateAfterMap, n);
      i.get(n) !== this.renderId && e.updateAfter(this) !== !1 && i.set(n, this.renderId);
    } else t === In.OBJECT && e.updateAfter(this);
  }
  /**
   * This method executes the {@link Node#update} for the given node.
   * It makes sure {@link Node#updateType} is honored meaning the update
   * is only executed once per frame, render or object depending on the update
   * type.
   *
   * @param {Node} node - The node that should be updated.
   */
  updateNode(e) {
    const t = e.getUpdateType(), n = e.updateReference(this);
    if (t === In.FRAME) {
      const { frameMap: i } = this._getMaps(this.updateMap, n);
      i.get(n) !== this.frameId && e.update(this) !== !1 && i.set(n, this.frameId);
    } else if (t === In.RENDER) {
      const { renderMap: i } = this._getMaps(this.updateMap, n);
      i.get(n) !== this.renderId && e.update(this) !== !1 && i.set(n, this.renderId);
    } else t === In.OBJECT && e.update(this);
  }
  /**
   * Updates the internal state of the node frame. This method is
   * called by the renderer in its internal animation loop.
   */
  update() {
    this.frameId++, this.lastTime === void 0 && (this.lastTime = performance.now()), this.deltaTime = (performance.now() - this.lastTime) / 1e3, this.lastTime = performance.now(), this.time += this.deltaTime;
  }
}
class gG {
  /**
   * Constructs a new node function input.
   *
   * @param {string} type - The input type.
   * @param {string} name - The input name.
   * @param {?number} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  constructor(e, t, n = null, i = "", o = !1) {
    this.type = e, this.name = t, this.count = n, this.qualifier = i, this.isConst = o;
  }
}
gG.isNodeFunctionInput = !0;
class GBe extends Rg {
  static get type() {
    return "DirectionalLightNode";
  }
  /**
   * Constructs a new directional light node.
   *
   * @param {?DirectionalLight} [light=null] - The directional light source.
   */
  constructor(e = null) {
    super(e);
  }
  setupDirect() {
    const e = this.colorNode;
    return { lightDirection: U0e(this.light), lightColor: e };
  }
}
const tV = /* @__PURE__ */ new Pr(), HN = /* @__PURE__ */ new Pr();
let Uw = null;
class qBe extends Rg {
  static get type() {
    return "RectAreaLightNode";
  }
  /**
   * Constructs a new rect area light node.
   *
   * @param {?RectAreaLight} [light=null] - The rect area light source.
   */
  constructor(e = null) {
    super(e), this.halfHeight = on(new Ue()).setGroup(sn), this.halfWidth = on(new Ue()).setGroup(sn), this.updateType = In.RENDER;
  }
  /**
   * Overwritten to updated rect area light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    super.update(e);
    const { light: t } = this, n = e.camera.matrixWorldInverse;
    HN.identity(), tV.copy(t.matrixWorld), tV.premultiply(n), HN.extractRotation(tV), this.halfWidth.value.set(t.width * 0.5, 0, 0), this.halfHeight.value.set(0, t.height * 0.5, 0), this.halfWidth.value.applyMatrix4(HN), this.halfHeight.value.applyMatrix4(HN);
  }
  setupDirectRectArea(e) {
    let t, n;
    e.isAvailable("float32Filterable") ? (t = Wn(Uw.LTC_FLOAT_1), n = Wn(Uw.LTC_FLOAT_2)) : (t = Wn(Uw.LTC_HALF_1), n = Wn(Uw.LTC_HALF_2));
    const { colorNode: i, light: o } = this, l = j0e(o);
    return {
      lightColor: i,
      lightPosition: l,
      halfWidth: this.halfWidth,
      halfHeight: this.halfHeight,
      ltc_1: t,
      ltc_2: n
    };
  }
  /**
   * Used to configure the internal BRDF approximation texture data.
   *
   * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
   */
  static setLTC(e) {
    Uw = e;
  }
}
class yG extends Rg {
  static get type() {
    return "SpotLightNode";
  }
  /**
   * Constructs a new spot light node.
   *
   * @param {?SpotLight} [light=null] - The spot light source.
   */
  constructor(e = null) {
    super(e), this.coneCosNode = on(0).setGroup(sn), this.penumbraCosNode = on(0).setGroup(sn), this.cutoffDistanceNode = on(0).setGroup(sn), this.decayExponentNode = on(0).setGroup(sn), this.colorNode = on(this.color).setGroup(sn);
  }
  /**
   * Overwritten to updated spot light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    super.update(e);
    const { light: t } = this;
    this.coneCosNode.value = Math.cos(t.angle), this.penumbraCosNode.value = Math.cos(t.angle * (1 - t.penumbra)), this.cutoffDistanceNode.value = t.distance, this.decayExponentNode.value = t.decay;
  }
  /**
   * Computes the spot attenuation for the given angle.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e, t) {
    const { coneCosNode: n, penumbraCosNode: i } = this;
    return ef(n, i, t);
  }
  getLightCoord(e) {
    const t = e.getNodeProperties(this);
    let n = t.projectionUV;
    return n === void 0 && (n = rFe(this.light, e.context.positionWorld), t.projectionUV = n), n;
  }
  setupDirect(e) {
    const { colorNode: t, cutoffDistanceNode: n, decayExponentNode: i, light: o } = this, l = this.getLightVector(e), p = l.normalize(), f = p.dot(U0e(o)), v = this.getSpotAttenuation(e, f), _ = l.length(), E = q0e({
      lightDistance: _,
      cutoffDistance: n,
      decayExponent: i
    });
    let A = t.mul(v).mul(E), I, j;
    return o.colorNode ? (j = this.getLightCoord(e), I = o.colorNode(j)) : o.map && (j = this.getLightCoord(e), I = Wn(o.map, j.xy).onRenderUpdate(() => o.map)), I && (A = j.mul(2).sub(1).abs().lessThan(1).all().select(A.mul(I), A)), { lightColor: A, lightDirection: p };
  }
}
class HBe extends yG {
  static get type() {
    return "IESSpotLightNode";
  }
  /**
   * Overwrites the default implementation to compute an IES conform spot attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e, t) {
    const n = this.light.iesMap;
    let i = null;
    if (n && n.isTexture === !0) {
      const o = t.acos().mul(1 / Math.PI);
      i = Wn(n, xt(o, 0), 0).r;
    } else
      i = super.getSpotAttenuation(t);
    return i;
  }
}
const $Be = /* @__PURE__ */ at(([c, e]) => {
  const t = c.abs().sub(e);
  return qd(eo(t, 0)).add(Hb(eo(t.x, t.y), 0));
});
class WBe extends yG {
  static get type() {
    return "ProjectorLightNode";
  }
  update(e) {
    super.update(e);
    const t = this.light;
    if (this.penumbraCosNode.value = Math.min(Math.cos(t.angle * (1 - t.penumbra)), 0.99999), t.aspect === null) {
      let n = 1;
      t.map !== null && (n = t.map.width / t.map.height), t.shadow.aspect = n;
    } else
      t.shadow.aspect = t.aspect;
  }
  /**
   * Overwrites the default implementation to compute projection attenuation.
   *
   * @param {NodeBuilder} builder - The node builder.
   * @return {Node<float>} The spot attenuation.
   */
  getSpotAttenuation(e) {
    const t = this.penumbraCosNode, n = this.getLightCoord(e), i = n.xyz.div(n.w), o = $Be(i.xy.sub(xt(0.5)), xt(0.5)), l = Sc(-1, mo(1, Qye(t)).sub(1));
    return s0e(o.mul(-2).mul(l));
  }
}
class KBe extends Rg {
  static get type() {
    return "AmbientLightNode";
  }
  /**
   * Constructs a new ambient light node.
   *
   * @param {?AmbientLight} [light=null] - The ambient light source.
   */
  constructor(e = null) {
    super(e);
  }
  setup({ context: e }) {
    e.irradiance.addAssign(this.colorNode);
  }
}
class YBe extends Rg {
  static get type() {
    return "HemisphereLightNode";
  }
  /**
   * Constructs a new hemisphere light node.
   *
   * @param {?HemisphereLight} [light=null] - The hemisphere light source.
   */
  constructor(e = null) {
    super(e), this.lightPositionNode = L0e(e), this.lightDirectionNode = this.lightPositionNode.normalize(), this.groundColorNode = on(new er()).setGroup(sn);
  }
  /**
   * Overwritten to updated hemisphere light specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e), this.lightPositionNode.object3d = t, this.groundColorNode.value.copy(t.groundColor).multiplyScalar(t.intensity);
  }
  setup(e) {
    const { colorNode: t, groundColorNode: n, lightDirectionNode: i } = this, l = aG.dot(i).mul(0.5).add(0.5), p = Vr(n, t, l);
    e.context.irradiance.addAssign(p);
  }
}
class XBe extends Rg {
  static get type() {
    return "LightProbeNode";
  }
  /**
   * Constructs a new light probe node.
   *
   * @param {?LightProbe} [light=null] - The light probe.
   */
  constructor(e = null) {
    super(e);
    const t = [];
    for (let n = 0; n < 9; n++) t.push(new Ue());
    this.lightProbe = vc(t);
  }
  /**
   * Overwritten to updated light probe specific uniforms.
   *
   * @param {NodeFrame} frame - A reference to the current node frame.
   */
  update(e) {
    const { light: t } = this;
    super.update(e);
    for (let n = 0; n < 9; n++)
      this.lightProbe.array[n].copy(t.sh.coefficients[n]).multiplyScalar(t.intensity);
  }
  setup(e) {
    const t = uBe(aG, this.lightProbe);
    e.context.irradiance.addAssign(t);
  }
}
const _me = /* @__PURE__ */ new WeakMap();
class QBe extends Zb {
  static get type() {
    return "EnvironmentNode";
  }
  /**
   * Constructs a new environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    const { material: t } = e;
    let n = this.envNode;
    if (n.isTextureNode || n.isMaterialReferenceNode) {
      const E = n.isTextureNode ? n.value : t[n.property];
      let A = _me.get(E);
      A === void 0 && (A = $0e(E), _me.set(E, A)), n = A;
    }
    const o = t.useAnisotropy === !0 || t.anisotropy > 0 ? _2e : Ri, l = n.context(Sme(Dd, o)).mul(C5), p = n.context(ZBe(lG)).mul(Math.PI).mul(C5), f = vO(l), v = vO(p);
    e.context.radiance.addAssign(f), e.context.iblIrradiance.addAssign(v);
    const _ = e.context.lightingModel.clearcoatRadiance;
    if (_) {
      const E = n.context(Sme(zO, rE)).mul(C5), A = vO(E);
      _.addAssign(A);
    }
  }
}
const Sme = (c, e) => {
  let t = null;
  return {
    getUV: () => (t === null && (t = ii.negate().reflect(e), t = c.mul(c).mix(t, e).normalize(), t = t.transformDirection(Qd)), t),
    getTextureLevel: () => c
  };
}, ZBe = (c) => ({
  getUV: () => c,
  getTextureLevel: () => et(1)
});
class vG extends Zb {
  static get type() {
    return "BasicEnvironmentNode";
  }
  /**
   * Constructs a new basic environment node.
   *
   * @param {Node} [envNode=null] - A node representing the environment.
   */
  constructor(e = null) {
    super(), this.envNode = e;
  }
  setup(e) {
    e.context.environment = J0e(this.envNode);
  }
}
class nve {
  /**
   * The method parses the given native code an returns a node function.
   *
   * @abstract
   * @param {string} source - The native shader code.
   * @return {NodeFunction} A node function.
   */
  parseFunction() {
    console.warn("Abstract function.");
  }
}
class bG {
  /**
   * Constructs a new node function.
   *
   * @param {string} type - The node type. This type is the return type of the node function.
   * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
   * @param {string} [name=''] - The function's name.
   * @param {string} [precision=''] - The precision qualifier.
   */
  constructor(e, t, n = "", i = "") {
    this.type = e, this.inputs = t, this.name = n, this.precision = i;
  }
  /**
   * This method returns the native code of the node function.
   *
   * @abstract
   * @param {string} name - The function's name.
   * @return {string} A shader code.
   */
  getCode() {
    console.warn("Abstract function.");
  }
}
bG.isNodeFunction = !0;
const JBe = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i, eLe = /[a-z_0-9]+/ig, wme = "#pragma main", tLe = (c) => {
  c = c.trim();
  const e = c.indexOf(wme), t = e !== -1 ? c.slice(e + wme.length) : c, n = t.match(JBe);
  if (n !== null && n.length === 5) {
    const i = n[4], o = [];
    let l = null;
    for (; (l = eLe.exec(i)) !== null; )
      o.push(l);
    const p = [];
    let f = 0;
    for (; f < o.length; ) {
      const j = o[f][0] === "const";
      j === !0 && f++;
      let q = o[f][0];
      q === "in" || q === "out" || q === "inout" ? f++ : q = "";
      const L = o[f++][0];
      let V = Number.parseInt(o[f][0]);
      Number.isNaN(V) === !1 ? f++ : V = null;
      const re = o[f++][0];
      p.push(new gG(L, re, V, q, j));
    }
    const v = t.substring(n[0].length), _ = n[3] !== void 0 ? n[3] : "", E = n[2], A = n[1] !== void 0 ? n[1] : "", I = e !== -1 ? c.slice(0, e) : "";
    return {
      type: E,
      inputs: p,
      name: _,
      precision: A,
      inputsCode: i,
      blockCode: v,
      headerCode: I
    };
  } else
    throw new Error("FunctionNode: Function is not a GLSL code.");
};
class nLe extends bG {
  /**
   * Constructs a new GLSL node function.
   *
   * @param {string} source - The GLSL source.
   */
  constructor(e) {
    const { type: t, inputs: n, name: i, precision: o, inputsCode: l, blockCode: p, headerCode: f } = tLe(e);
    super(t, n, i, o), this.inputsCode = l, this.blockCode = p, this.headerCode = f;
  }
  /**
   * This method returns the GLSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(e = this.name) {
    let t;
    const n = this.blockCode;
    if (n !== "") {
      const { type: i, inputsCode: o, headerCode: l, precision: p } = this;
      let f = `${i} ${e} ( ${o.trim()} )`;
      p !== "" && (f = `${p} ${f}`), t = l + f + n;
    } else
      t = "";
    return t;
  }
}
class rLe extends nve {
  /**
   * The method parses the given GLSL code an returns a node function.
   *
   * @param {string} source - The GLSL code.
   * @return {GLSLNodeFunction} A node function.
   */
  parseFunction(e) {
    return new nLe(e);
  }
}
class rve extends f2 {
  /**
   * Constructs a new basic lighting model.
   */
  constructor() {
    super();
  }
  /**
   * Implements the baked indirect lighting with its modulation.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect({ context: e }) {
    const t = e.ambientOcclusion, n = e.reflectedLight, i = e.irradianceLightMap;
    n.indirectDiffuse.assign(gn(0)), i ? n.indirectDiffuse.addAssign(i) : n.indirectDiffuse.addAssign(gn(1, 1, 1, 0)), n.indirectDiffuse.mulAssign(t), n.indirectDiffuse.mulAssign(Jn.rgb);
  }
  /**
   * Implements the environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish(e) {
    const { material: t, context: n } = e, i = n.outgoingLight, o = e.context.environment;
    if (o)
      switch (t.combine) {
        case QO:
          i.rgb.assign(Vr(i.rgb, i.rgb.mul(o.rgb), xO.mul(P5)));
          break;
        case WMe:
          i.rgb.assign(Vr(i.rgb, o.rgb, xO.mul(P5)));
          break;
        case KMe:
          i.rgb.addAssign(o.rgb.mul(xO.mul(P5)));
          break;
        default:
          console.warn("THREE.BasicLightingModel: Unsupported .combine value:", t.combine);
          break;
      }
  }
}
const iLe = () => et(0.25), sLe = /* @__PURE__ */ at(({ dotNH: c }) => l6.mul(et(0.5)).add(1).mul(et(1 / Math.PI)).mul(c.pow(l6))), oLe = /* @__PURE__ */ at(({ lightDirection: c }) => {
  const e = c.add(ii).normalize(), t = Ri.dot(e).clamp(), n = ii.dot(e).clamp(), i = ME({ f0: ba, f90: 1, dotVH: n }), o = iLe(), l = sLe({ dotNH: t });
  return i.mul(o).mul(l);
});
class ive extends rve {
  /**
   * Constructs a new phong lighting model.
   *
   * @param {boolean} [specular=true] - Whether specular is supported or not.
   */
  constructor(e = !0) {
    super(), this.specular = e;
  }
  /**
   * Implements the direct lighting. The specular portion is optional an can be controlled
   * with the {@link PhongLightingModel#specular} flag.
   *
   * @param {Object} lightData - The light data.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }) {
    const o = Ri.dot(e).clamp().mul(t);
    n.directDiffuse.addAssign(o.mul(Wb({ diffuseColor: Jn.rgb }))), this.specular === !0 && n.directSpecular.addAssign(o.mul(oLe({ lightDirection: e })).mul(xO));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    const { ambientOcclusion: t, irradiance: n, reflectedLight: i } = e.context;
    i.indirectDiffuse.addAssign(n.mul(Wb({ diffuseColor: Jn }))), i.indirectDiffuse.mulAssign(t);
  }
}
const sve = /* @__PURE__ */ at((c) => {
  const { dotNV: e, specularColor: t, specularF90: n, roughness: i } = c, o = W0e({ dotNV: e, roughness: i });
  return t.mul(o.x).add(n.mul(o.y));
}), aLe = /* @__PURE__ */ at(({ roughness: c, dotNH: e }) => {
  const t = c.pow2(), n = et(1).div(t), o = e.pow2().oneMinus().max(78125e-7);
  return et(2).add(n).mul(o.pow(n.mul(0.5))).div(2 * Math.PI);
}).setLayout({
  name: "D_Charlie",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "dotNH", type: "float" }
  ]
}), lLe = /* @__PURE__ */ at(({ dotNV: c, dotNL: e }) => et(1).div(et(4).mul(e.add(c).sub(e.mul(c))))).setLayout({
  name: "V_Neubelt",
  type: "float",
  inputs: [
    { name: "dotNV", type: "float" },
    { name: "dotNL", type: "float" }
  ]
}), uLe = /* @__PURE__ */ at(({ lightDirection: c }) => {
  const e = c.add(ii).normalize(), t = Ri.dot(c).clamp(), n = Ri.dot(ii).clamp(), i = Ri.dot(e).clamp(), o = aLe({ roughness: K6, dotNH: i }), l = lLe({ dotNV: n, dotNL: t });
  return Cb.mul(o).mul(l);
}), cLe = /* @__PURE__ */ at(({ N: c, V: e, roughness: t }) => {
  const o = 78125e-7, l = c.dot(e).saturate(), p = xt(t, l.oneMinus().sqrt());
  return p.assign(p.mul(0.984375).add(o)), p;
}).setLayout({
  name: "LTC_Uv",
  type: "vec2",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "roughness", type: "float" }
  ]
}), dLe = /* @__PURE__ */ at(({ f: c }) => {
  const e = c.length();
  return eo(e.mul(e).add(c.z).div(e.add(1)), 0);
}).setLayout({
  name: "LTC_ClippedSphereFormFactor",
  type: "float",
  inputs: [
    { name: "f", type: "vec3" }
  ]
}), $N = /* @__PURE__ */ at(({ v1: c, v2: e }) => {
  const t = c.dot(e), n = t.abs().toVar(), i = n.mul(0.0145206).add(0.4965155).mul(n).add(0.8543985).toVar(), o = n.add(4.1616724).mul(n).add(3.417594).toVar(), l = i.div(o), p = t.greaterThan(0).select(l, eo(t.mul(t).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(l));
  return c.cross(e).mul(p);
}).setLayout({
  name: "LTC_EdgeVectorFormFactor",
  type: "vec3",
  inputs: [
    { name: "v1", type: "vec3" },
    { name: "v2", type: "vec3" }
  ]
}), Eme = /* @__PURE__ */ at(({ N: c, V: e, P: t, mInv: n, p0: i, p1: o, p2: l, p3: p }) => {
  const f = o.sub(i).toVar(), v = p.sub(i).toVar(), _ = f.cross(v), E = tt().toVar();
  return _i(_.dot(t.sub(i)).greaterThanEqual(0), () => {
    const A = e.sub(c.mul(e.dot(c))).normalize(), I = c.cross(A).negate(), j = n.mul(bo(A, I, c).transpose()).toVar(), q = j.mul(i.sub(t)).normalize().toVar(), L = j.mul(o.sub(t)).normalize().toVar(), V = j.mul(l.sub(t)).normalize().toVar(), re = j.mul(p.sub(t)).normalize().toVar(), R = tt(0).toVar();
    R.addAssign($N({ v1: q, v2: L })), R.addAssign($N({ v1: L, v2: V })), R.addAssign($N({ v1: V, v2: re })), R.addAssign($N({ v1: re, v2: q })), E.assign(tt(dLe({ f: R })));
  }), E;
}).setLayout({
  name: "LTC_Evaluate",
  type: "vec3",
  inputs: [
    { name: "N", type: "vec3" },
    { name: "V", type: "vec3" },
    { name: "P", type: "vec3" },
    { name: "mInv", type: "mat3" },
    { name: "p0", type: "vec3" },
    { name: "p1", type: "vec3" },
    { name: "p2", type: "vec3" },
    { name: "p3", type: "vec3" }
  ]
}), Tme = /* @__PURE__ */ at(([c, e, t, n, i]) => {
  const o = tt(o0e(e.negate(), PE(c), Sc(1, n))), l = tt(
    qd(i[0].xyz),
    qd(i[1].xyz),
    qd(i[2].xyz)
  );
  return PE(o).mul(t.mul(l));
}).setLayout({
  name: "getVolumeTransmissionRay",
  type: "vec3",
  inputs: [
    { name: "n", type: "vec3" },
    { name: "v", type: "vec3" },
    { name: "thickness", type: "float" },
    { name: "ior", type: "float" },
    { name: "modelMatrix", type: "mat4" }
  ]
}), hLe = /* @__PURE__ */ at(([c, e]) => c.mul(Kd(e.mul(2).sub(2), 0, 1))).setLayout({
  name: "applyIorToRoughness",
  type: "float",
  inputs: [
    { name: "roughness", type: "float" },
    { name: "ior", type: "float" }
  ]
}), pLe = /* @__PURE__ */ w0e(), fLe = /* @__PURE__ */ w0e(), Cme = /* @__PURE__ */ at(([c, e, t], { material: n }) => {
  const o = (n.side === Ko ? pLe : fLe).sample(c), l = Gd(c6.x).mul(hLe(e, t));
  return FDe(o, l);
}), Pme = /* @__PURE__ */ at(([c, e, t]) => (_i(t.notEqual(0), () => {
  const n = Xye(e).negate().div(t);
  return Yye(n.negate().mul(c));
}), tt(1))).setLayout({
  name: "volumeAttenuation",
  type: "vec3",
  inputs: [
    { name: "transmissionDistance", type: "float" },
    { name: "attenuationColor", type: "vec3" },
    { name: "attenuationDistance", type: "float" }
  ]
}), mLe = /* @__PURE__ */ at(([c, e, t, n, i, o, l, p, f, v, _, E, A, I, j]) => {
  let q, L;
  if (j) {
    q = gn().toVar(), L = tt().toVar();
    const ge = _.sub(1).mul(j.mul(0.025)), _e = tt(_.sub(ge), _, _.add(ge));
    cu({ start: 0, end: 3 }, ({ i: Y }) => {
      const Fe = _e.element(Y), Me = Tme(c, e, E, Fe, p), $ = l.add(Me), dt = v.mul(f.mul(gn($, 1))), wt = xt(dt.xy.div(dt.w)).toVar();
      wt.addAssign(1), wt.divAssign(2), wt.assign(xt(wt.x, wt.y.oneMinus()));
      const St = Cme(wt, t, Fe);
      q.element(Y).assign(St.element(Y)), q.a.addAssign(St.a), L.element(Y).assign(n.element(Y).mul(Pme(qd(Me), A, I).element(Y)));
    }), q.a.divAssign(3);
  } else {
    const ge = Tme(c, e, E, _, p), _e = l.add(ge), Y = v.mul(f.mul(gn(_e, 1))), Fe = xt(Y.xy.div(Y.w)).toVar();
    Fe.addAssign(1), Fe.divAssign(2), Fe.assign(xt(Fe.x, Fe.y.oneMinus())), q = Cme(Fe, t, _), L = n.mul(Pme(qd(ge), A, I));
  }
  const V = L.rgb.mul(q.rgb), re = c.dot(e).clamp(), R = tt(sve({
    // n, v, specularColor, specularF90, roughness
    dotNV: re,
    specularColor: i,
    specularF90: o,
    roughness: t
  })), J = L.r.add(L.g, L.b).div(3);
  return gn(R.oneMinus().mul(V), q.a.oneMinus().mul(J).oneMinus());
}), gLe = /* @__PURE__ */ bo(
  3.2404542,
  -0.969266,
  0.0556434,
  -1.5371385,
  1.8760108,
  -0.2040259,
  -0.4985314,
  0.041556,
  1.0572252
), yLe = (c) => {
  const e = c.sqrt();
  return tt(1).add(e).div(tt(1).sub(e));
}, Ame = (c, e) => c.sub(e).div(c.add(e)).pow2(), vLe = (c, e) => {
  const t = c.mul(2 * Math.PI * 1e-9), n = tt(54856e-17, 44201e-17, 52481e-17), i = tt(1681e3, 1795300, 2208400), o = tt(43278e5, 93046e5, 66121e5), l = et(9747e-17 * Math.sqrt(2 * Math.PI * 45282e5)).mul(t.mul(2239900).add(e.x).cos()).mul(t.pow2().mul(-45282e5).exp());
  let p = n.mul(o.mul(2 * Math.PI).sqrt()).mul(i.mul(t).add(e).cos()).mul(t.pow2().negate().mul(o).exp());
  return p = tt(p.x.add(l), p.y, p.z).div(10685e-11), gLe.mul(p);
}, bLe = /* @__PURE__ */ at(({ outsideIOR: c, eta2: e, cosTheta1: t, thinFilmThickness: n, baseF0: i }) => {
  const o = Vr(c, e, ef(0, 0.03, n)), p = c.div(o).pow2().mul(t.pow2().oneMinus()).oneMinus();
  _i(p.lessThan(0), () => tt(1));
  const f = p.sqrt(), v = Ame(o, c), _ = ME({ f0: v, f90: 1, dotVH: t }), E = _.oneMinus(), A = o.lessThan(c).select(Math.PI, 0), I = et(Math.PI).sub(A), j = yLe(i.clamp(0, 0.9999)), q = Ame(j, o.toVec3()), L = ME({ f0: q, f90: 1, dotVH: f }), V = tt(
    j.x.lessThan(o).select(Math.PI, 0),
    j.y.lessThan(o).select(Math.PI, 0),
    j.z.lessThan(o).select(Math.PI, 0)
  ), re = o.mul(n, f, 2), R = tt(I).add(V), J = _.mul(L).clamp(1e-5, 0.9999), ge = J.sqrt(), _e = E.pow2().mul(L).div(tt(1).sub(J)), Fe = _.add(_e).toVar(), Me = _e.sub(E).toVar();
  return cu({ start: 1, end: 2, condition: "<=", name: "m" }, ({ m: $ }) => {
    Me.mulAssign(ge);
    const dt = vLe(et($).mul(re), et($).mul(R)).mul(2);
    Fe.addAssign(Me.mul(dt));
  }), Fe.max(tt(0));
}).setLayout({
  name: "evalIridescence",
  type: "vec3",
  inputs: [
    { name: "outsideIOR", type: "float" },
    { name: "eta2", type: "float" },
    { name: "cosTheta1", type: "float" },
    { name: "thinFilmThickness", type: "float" },
    { name: "baseF0", type: "vec3" }
  ]
}), xLe = /* @__PURE__ */ at(({ normal: c, viewDir: e, roughness: t }) => {
  const n = c.dot(e).saturate(), i = t.pow2(), o = Zs(
    t.lessThan(0.25),
    et(-339.2).mul(i).add(et(161.4).mul(t)).sub(25.9),
    et(-8.48).mul(i).add(et(14.3).mul(t)).sub(9.95)
  ), l = Zs(
    t.lessThan(0.25),
    et(44).mul(i).sub(et(23.7).mul(t)).add(3.26),
    et(1.97).mul(i).sub(et(3.27).mul(t)).add(0.72)
  );
  return Zs(t.lessThan(0.25), 0, et(0.1).mul(t).sub(0.025)).add(o.mul(n).add(l).exp()).mul(1 / Math.PI).saturate();
}), nV = tt(0.04), rV = et(1);
class ove extends f2 {
  /**
   * Constructs a new physical lighting model.
   *
   * @param {boolean} [clearcoat=false] - Whether clearcoat is supported or not.
   * @param {boolean} [sheen=false] - Whether sheen is supported or not.
   * @param {boolean} [iridescence=false] - Whether iridescence is supported or not.
   * @param {boolean} [anisotropy=false] - Whether anisotropy is supported or not.
   * @param {boolean} [transmission=false] - Whether transmission is supported or not.
   * @param {boolean} [dispersion=false] - Whether dispersion is supported or not.
   */
  constructor(e = !1, t = !1, n = !1, i = !1, o = !1, l = !1) {
    super(), this.clearcoat = e, this.sheen = t, this.iridescence = n, this.anisotropy = i, this.transmission = o, this.dispersion = l, this.clearcoatRadiance = null, this.clearcoatSpecularDirect = null, this.clearcoatSpecularIndirect = null, this.sheenSpecularDirect = null, this.sheenSpecularIndirect = null, this.iridescenceFresnel = null, this.iridescenceF0 = null;
  }
  /**
   * Depending on what features are requested, the method prepares certain node variables
   * which are later used for lighting computations.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  start(e) {
    if (this.clearcoat === !0 && (this.clearcoatRadiance = tt().toVar("clearcoatRadiance"), this.clearcoatSpecularDirect = tt().toVar("clearcoatSpecularDirect"), this.clearcoatSpecularIndirect = tt().toVar("clearcoatSpecularIndirect")), this.sheen === !0 && (this.sheenSpecularDirect = tt().toVar("sheenSpecularDirect"), this.sheenSpecularIndirect = tt().toVar("sheenSpecularIndirect")), this.iridescence === !0) {
      const t = Ri.dot(ii).clamp();
      this.iridescenceFresnel = bLe({
        outsideIOR: et(1),
        eta2: Vye,
        cosTheta1: t,
        thinFilmThickness: Gye,
        baseF0: ba
      }), this.iridescenceF0 = aBe({ f: this.iridescenceFresnel, f90: 1, dotVH: t });
    }
    if (this.transmission === !0) {
      const t = AE, n = LOe.sub(AE).normalize(), i = lG, o = e.context;
      o.backdrop = mLe(
        i,
        n,
        Dd,
        Jn,
        ba,
        VO,
        // specularF90
        t,
        // positionWorld
        Cg,
        // modelMatrix
        Qd,
        // viewMatrix
        oG,
        // projMatrix
        gO,
        qye,
        $ye,
        Hye,
        this.dispersion ? Wye : null
      ), o.backdropAlpha = u6, Jn.a.mulAssign(Vr(1, o.backdrop.a, u6));
    }
    super.start(e);
  }
  // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
  // Approximates multi-scattering in order to preserve energy.
  // http://www.jcgt.org/published/0008/01/03/
  computeMultiscattering(e, t, n) {
    const i = Ri.dot(ii).clamp(), o = W0e({ roughness: Dd, dotNV: i }), p = (this.iridescenceF0 ? Y6.mix(ba, this.iridescenceF0) : ba).mul(o.x).add(n.mul(o.y)), v = o.x.add(o.y).oneMinus(), _ = ba.add(ba.oneMinus().mul(0.047619)), E = p.mul(_).div(v.mul(_).oneMinus());
    e.addAssign(p), t.addAssign(E.mul(v));
  }
  /**
   * Implements the direct light.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }) {
    const o = Ri.dot(e).clamp().mul(t);
    if (this.sheen === !0 && this.sheenSpecularDirect.addAssign(o.mul(uLe({ lightDirection: e }))), this.clearcoat === !0) {
      const p = rE.dot(e).clamp().mul(t);
      this.clearcoatSpecularDirect.addAssign(p.mul(gme({ lightDirection: e, f0: nV, f90: rV, roughness: zO, normalView: rE })));
    }
    n.directDiffuse.addAssign(o.mul(Wb({ diffuseColor: Jn.rgb }))), n.directSpecular.addAssign(o.mul(gme({ lightDirection: e, f0: ba, f90: 1, roughness: Dd, iridescence: this.iridescence, f: this.iridescenceFresnel, USE_IRIDESCENCE: this.iridescence, USE_ANISOTROPY: this.anisotropy })));
  }
  /**
   * This method is intended for implementing the direct light term for
   * rect area light nodes.
   *
   * @param {Object} input - The input data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  directRectArea({ lightColor: e, lightPosition: t, halfWidth: n, halfHeight: i, reflectedLight: o, ltc_1: l, ltc_2: p }) {
    const f = t.add(n).sub(i), v = t.sub(n).sub(i), _ = t.sub(n).add(i), E = t.add(n).add(i), A = Ri, I = ii, j = Ii.toVar(), q = cLe({ N: A, V: I, roughness: Dd }), L = l.sample(q).toVar(), V = p.sample(q).toVar(), re = bo(
      tt(L.x, 0, L.y),
      tt(0, 1, 0),
      tt(L.z, 0, L.w)
    ).toVar(), R = ba.mul(V.x).add(ba.oneMinus().mul(V.y)).toVar();
    o.directSpecular.addAssign(e.mul(R).mul(Eme({ N: A, V: I, P: j, mInv: re, p0: f, p1: v, p2: _, p3: E }))), o.directDiffuse.addAssign(e.mul(Jn).mul(Eme({ N: A, V: I, P: j, mInv: bo(1, 0, 0, 0, 1, 0, 0, 0, 1), p0: f, p1: v, p2: _, p3: E })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    this.indirectDiffuse(e), this.indirectSpecular(e), this.ambientOcclusion(e);
  }
  /**
   * Implements the indirect diffuse term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectDiffuse(e) {
    const { irradiance: t, reflectedLight: n } = e.context;
    n.indirectDiffuse.addAssign(t.mul(Wb({ diffuseColor: Jn })));
  }
  /**
   * Implements the indirect specular term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirectSpecular(e) {
    const { radiance: t, iblIrradiance: n, reflectedLight: i } = e.context;
    if (this.sheen === !0 && this.sheenSpecularIndirect.addAssign(n.mul(
      Cb,
      xLe({
        normal: Ri,
        viewDir: ii,
        roughness: K6
      })
    )), this.clearcoat === !0) {
      const _ = rE.dot(ii).clamp(), E = sve({
        dotNV: _,
        specularColor: nV,
        specularF90: rV,
        roughness: zO
      });
      this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(E));
    }
    const o = tt().toVar("singleScattering"), l = tt().toVar("multiScattering"), p = n.mul(1 / Math.PI);
    this.computeMultiscattering(o, l, VO);
    const f = o.add(l), v = Jn.mul(f.r.max(f.g).max(f.b).oneMinus());
    i.indirectSpecular.addAssign(t.mul(o)), i.indirectSpecular.addAssign(l.mul(p)), i.indirectDiffuse.addAssign(v.mul(p));
  }
  /**
   * Implements the ambient occlusion term.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  ambientOcclusion(e) {
    const { ambientOcclusion: t, reflectedLight: n } = e.context, o = Ri.dot(ii).clamp().add(t), l = Dd.mul(-16).oneMinus().negate().exp2(), p = t.sub(o.pow(l).oneMinus()).clamp();
    this.clearcoat === !0 && this.clearcoatSpecularIndirect.mulAssign(t), this.sheen === !0 && this.sheenSpecularIndirect.mulAssign(t), n.indirectDiffuse.mulAssign(t), n.indirectSpecular.mulAssign(p);
  }
  /**
   * Used for final lighting accumulations depending on the requested features.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: e }) {
    const { outgoingLight: t } = e;
    if (this.clearcoat === !0) {
      const n = rE.dot(ii).clamp(), i = ME({
        dotVH: n,
        f0: nV,
        f90: rV
      }), o = t.mul(o6.mul(i).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(o6));
      t.assign(o);
    }
    if (this.sheen === !0) {
      const n = Cb.r.max(Cb.g).max(Cb.b).mul(0.157).oneMinus(), i = t.mul(n).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
      t.assign(i);
    }
  }
}
const kme = /* @__PURE__ */ new WeakMap(), lc = [], rg = [];
class _Le extends nf {
  /**
   * Constructs a new nodes management component.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {Backend} backend - The renderer's backend.
   */
  constructor(e, t) {
    super(), this.renderer = e, this.backend = t, this.nodeFrame = new xme(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.callHashCache = new hu(), this.groupsData = new hu(), this.cacheLib = {};
  }
  /**
   * Returns `true` if the given node uniforms group must be updated or not.
   *
   * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
   * @return {boolean} Whether the node uniforms group requires an update or not.
   */
  updateGroup(e) {
    const t = e.groupNode, n = t.name;
    if (n === Uye.name) return !0;
    if (n === sn.name) {
      const o = this.get(e), l = this.nodeFrame.renderId;
      return o.renderId !== l ? (o.renderId = l, !0) : !1;
    }
    if (n === WIe.name) {
      const o = this.get(e), l = this.nodeFrame.frameId;
      return o.frameId !== l ? (o.frameId = l, !0) : !1;
    }
    lc[0] = t, lc[1] = e;
    let i = this.groupsData.get(lc);
    return i === void 0 && this.groupsData.set(lc, i = {}), lc.length = 0, i.version !== t.version ? (i.version = t.version, !0) : !1;
  }
  /**
   * Returns the cache key for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {number} The cache key.
   */
  getForRenderCacheKey(e) {
    return e.initialCacheKey;
  }
  /**
   * Returns a node builder state for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {NodeBuilderState} The node builder state.
   */
  getForRender(e) {
    const t = this.get(e);
    let n = t.nodeBuilderState;
    if (n === void 0) {
      const { nodeBuilderCache: i } = this, o = this.getForRenderCacheKey(e);
      if (n = i.get(o), n === void 0) {
        const l = this.backend.createNodeBuilder(e.object, this.renderer);
        l.scene = e.scene, l.material = e.material, l.camera = e.camera, l.context.material = e.material, l.lightsNode = e.lightsNode, l.environmentNode = this.getEnvironmentNode(e.scene), l.fogNode = this.getFogNode(e.scene), l.clippingContext = e.clippingContext, this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview && l.enableMultiview(), l.build(), n = this._createNodeBuilderState(l), i.set(o, n);
      }
      n.usedTimes++, t.nodeBuilderState = n;
    }
    return n;
  }
  /**
   * Deletes the given object from the internal data map
   *
   * @param {any} object - The object to delete.
   * @return {?Object} The deleted dictionary.
   */
  delete(e) {
    if (e.isRenderObject) {
      const t = this.get(e).nodeBuilderState;
      t.usedTimes--, t.usedTimes === 0 && this.nodeBuilderCache.delete(this.getForRenderCacheKey(e));
    }
    return super.delete(e);
  }
  /**
   * Returns a node builder state for the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   * @return {NodeBuilderState} The node builder state.
   */
  getForCompute(e) {
    const t = this.get(e);
    let n = t.nodeBuilderState;
    if (n === void 0) {
      const i = this.backend.createNodeBuilder(e, this.renderer);
      i.build(), n = this._createNodeBuilderState(i), t.nodeBuilderState = n;
    }
    return n;
  }
  /**
   * Creates a node builder state for the given node builder.
   *
   * @private
   * @param {NodeBuilder} nodeBuilder - The node builder.
   * @return {NodeBuilderState} The node builder state.
   */
  _createNodeBuilderState(e) {
    return new hBe(
      e.vertexShader,
      e.fragmentShader,
      e.computeShader,
      e.getAttributesArray(),
      e.getBindings(),
      e.updateNodes,
      e.updateBeforeNodes,
      e.updateAfterNodes,
      e.observer,
      e.transforms
    );
  }
  /**
   * Returns an environment node for the current configured
   * scene environment.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene environment.
   */
  getEnvironmentNode(e) {
    this.updateEnvironment(e);
    let t = null;
    if (e.environmentNode && e.environmentNode.isNode)
      t = e.environmentNode;
    else {
      const n = this.get(e);
      n.environmentNode && (t = n.environmentNode);
    }
    return t;
  }
  /**
   * Returns a background node for the current configured
   * scene background.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene background.
   */
  getBackgroundNode(e) {
    this.updateBackground(e);
    let t = null;
    if (e.backgroundNode && e.backgroundNode.isNode)
      t = e.backgroundNode;
    else {
      const n = this.get(e);
      n.backgroundNode && (t = n.backgroundNode);
    }
    return t;
  }
  /**
   * Returns a fog node for the current configured scene fog.
   *
   * @param {Scene} scene - The scene.
   * @return {Node} A node representing the current scene fog.
   */
  getFogNode(e) {
    return this.updateFog(e), e.fogNode || this.get(e).fogNode || null;
  }
  /**
   * Returns a cache key for the given scene and lights node.
   * This key is used by `RenderObject` as a part of the dynamic
   * cache key (a key that must be checked every time the render
   * objects is drawn).
   *
   * @param {Scene} scene - The scene.
   * @param {LightsNode} lightsNode - The lights node.
   * @return {number} The cache key.
   */
  getCacheKey(e, t) {
    lc[0] = e, lc[1] = t;
    const n = this.renderer.info.calls, i = this.callHashCache.get(lc) || {};
    if (i.callId !== n) {
      const o = this.getEnvironmentNode(e), l = this.getFogNode(e);
      t && rg.push(t.getCacheKey(!0)), o && rg.push(o.getCacheKey()), l && rg.push(l.getCacheKey()), rg.push(this.renderer.getOutputRenderTarget() && this.renderer.getOutputRenderTarget().multiview ? 1 : 0), rg.push(this.renderer.shadowMap.enabled ? 1 : 0), i.callId = n, i.cacheKey = F6(rg), this.callHashCache.set(lc, i), rg.length = 0;
    }
    return lc.length = 0, i.cacheKey;
  }
  /**
   * A boolean that indicates whether tone mapping should be enabled
   * or not.
   *
   * @type {boolean}
   */
  get isToneMappingState() {
    return !this.renderer.getRenderTarget();
  }
  /**
   * If a scene background is configured, this method makes sure to
   * represent the background with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateBackground(e) {
    const t = this.get(e), n = e.background;
    if (n) {
      const i = e.backgroundBlurriness === 0 && t.backgroundBlurriness > 0 || e.backgroundBlurriness > 0 && t.backgroundBlurriness === 0;
      if (t.background !== n || i) {
        const o = this.getCacheNode("background", n, () => {
          if (n.isCubeTexture === !0 || n.mapping === A6 || n.mapping === k6 || n.mapping === jV) {
            if (e.backgroundBlurriness > 0 || n.mapping === jV)
              return $0e(n);
            {
              let l;
              return n.isCubeTexture === !0 ? l = kE(n) : l = Wn(n), J0e(l);
            }
          } else {
            if (n.isTexture === !0)
              return Wn(n, Bb.flipY()).setUpdateMatrix(!0);
            n.isColor !== !0 && console.error("WebGPUNodes: Unsupported background configuration.", n);
          }
        }, i);
        t.backgroundNode = o, t.background = n, t.backgroundBlurriness = e.backgroundBlurriness;
      }
    } else t.backgroundNode && (delete t.backgroundNode, delete t.background);
  }
  /**
   * This method is part of the caching of nodes which are used to represents the
   * scene's background, fog or environment.
   *
   * @param {string} type - The type of object to cache.
   * @param {Object} object - The object.
   * @param {Function} callback - A callback that produces a node representation for the given object.
   * @param {boolean} [forceUpdate=false] - Whether an update should be enforced or not.
   * @return {Node} The node representation.
   */
  getCacheNode(e, t, n, i = !1) {
    const o = this.cacheLib[e] || (this.cacheLib[e] = /* @__PURE__ */ new WeakMap());
    let l = o.get(t);
    return (l === void 0 || i) && (l = n(), o.set(t, l)), l;
  }
  /**
   * If a scene fog is configured, this method makes sure to
   * represent the fog with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateFog(e) {
    const t = this.get(e), n = e.fog;
    if (n) {
      if (t.fog !== n) {
        const i = this.getCacheNode("fog", n, () => {
          if (n.isFogExp2) {
            const o = Cr("color", "color", n).setGroup(sn), l = Cr("density", "float", n).setGroup(sn);
            return eme(o, tFe(l));
          } else if (n.isFog) {
            const o = Cr("color", "color", n).setGroup(sn), l = Cr("near", "float", n).setGroup(sn), p = Cr("far", "float", n).setGroup(sn);
            return eme(o, eFe(l, p));
          } else
            console.error("THREE.Renderer: Unsupported fog configuration.", n);
        });
        t.fogNode = i, t.fog = n;
      }
    } else
      delete t.fogNode, delete t.fog;
  }
  /**
   * If a scene environment is configured, this method makes sure to
   * represent the environment with a corresponding node-based implementation.
   *
   * @param {Scene} scene - The scene.
   */
  updateEnvironment(e) {
    const t = this.get(e), n = e.environment;
    if (n) {
      if (t.environment !== n) {
        const i = this.getCacheNode("environment", n, () => {
          if (n.isCubeTexture === !0)
            return kE(n);
          if (n.isTexture === !0)
            return Wn(n);
          console.error("Nodes: Unsupported environment configuration.", n);
        });
        t.environmentNode = i, t.environment = n;
      }
    } else t.environmentNode && (delete t.environmentNode, delete t.environment);
  }
  getNodeFrame(e = this.renderer, t = null, n = null, i = null, o = null) {
    const l = this.nodeFrame;
    return l.renderer = e, l.scene = t, l.object = n, l.camera = i, l.material = o, l;
  }
  getNodeFrameForRender(e) {
    return this.getNodeFrame(e.renderer, e.scene, e.object, e.camera, e.material);
  }
  /**
   * Returns the current output cache key.
   *
   * @return {string} The output cache key.
   */
  getOutputCacheKey() {
    const e = this.renderer;
    return e.toneMapping + "," + e.currentColorSpace + "," + e.xr.isPresenting;
  }
  /**
   * Checks if the output configuration (tone mapping and color space) for
   * the given target has changed.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {boolean} Whether the output configuration has changed or not.
   */
  hasOutputChange(e) {
    return kme.get(e) !== this.getOutputCacheKey();
  }
  /**
   * Returns a node that represents the output configuration (tone mapping and
   * color space) for the current target.
   *
   * @param {Texture} outputTarget - The output target.
   * @return {Node} The output node.
   */
  getOutputNode(e) {
    const t = this.renderer, n = this.getOutputCacheKey(), i = e.isArrayTexture ? zDe(e, tt(Bb, s2("gl_ViewID_OVR"))).renderOutput(t.toneMapping, t.currentColorSpace) : Wn(e, Bb).renderOutput(t.toneMapping, t.currentColorSpace);
    return kme.set(e, n), i;
  }
  /**
   * Triggers the call of `updateBefore()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateBefore(e) {
    const t = e.getNodeBuilderState();
    for (const n of t.updateBeforeNodes)
      this.getNodeFrameForRender(e).updateBeforeNode(n);
  }
  /**
   * Triggers the call of `updateAfter()` methods
   * for all nodes of the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateAfter(e) {
    const t = e.getNodeBuilderState();
    for (const n of t.updateAfterNodes)
      this.getNodeFrameForRender(e).updateAfterNode(n);
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {Node} computeNode - The compute node.
   */
  updateForCompute(e) {
    const t = this.getNodeFrame(), n = this.getForCompute(e);
    for (const i of n.updateNodes)
      t.updateNode(i);
  }
  /**
   * Triggers the call of `update()` methods
   * for all nodes of the given compute node.
   *
   * @param {RenderObject} renderObject - The render object.
   */
  updateForRender(e) {
    const t = this.getNodeFrameForRender(e), n = e.getNodeBuilderState();
    for (const i of n.updateNodes)
      t.updateNode(i);
  }
  /**
   * Returns `true` if the given render object requires a refresh.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the given render object requires a refresh or not.
   */
  needsRefresh(e) {
    const t = this.getNodeFrameForRender(e);
    return e.getMonitor().needsRefresh(e, t);
  }
  /**
   * Frees the internal resources.
   */
  dispose() {
    super.dispose(), this.nodeFrame = new xme(), this.nodeBuilderCache = /* @__PURE__ */ new Map(), this.cacheLib = {};
  }
}
const iV = /* @__PURE__ */ new qp();
class qO {
  /**
   * Constructs a new clipping context.
   *
   * @param {?ClippingContext} [parentContext=null] - A reference to the parent clipping context.
   */
  constructor(e = null) {
    this.version = 0, this.clipIntersection = null, this.cacheKey = "", this.shadowPass = !1, this.viewNormalMatrix = new Xo(), this.clippingGroupContexts = /* @__PURE__ */ new WeakMap(), this.intersectionPlanes = [], this.unionPlanes = [], this.parentVersion = null, e !== null && (this.viewNormalMatrix = e.viewNormalMatrix, this.clippingGroupContexts = e.clippingGroupContexts, this.shadowPass = e.shadowPass, this.viewMatrix = e.viewMatrix);
  }
  /**
   * Projects the given source clipping planes and writes the result into the
   * destination array.
   *
   * @param {Array<Plane>} source - The source clipping planes.
   * @param {Array<Vector4>} destination - The destination.
   * @param {number} offset - The offset.
   */
  projectPlanes(e, t, n) {
    const i = e.length;
    for (let o = 0; o < i; o++) {
      iV.copy(e[o]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
      const l = t[n + o], p = iV.normal;
      l.x = -p.x, l.y = -p.y, l.z = -p.z, l.w = iV.constant;
    }
  }
  /**
   * Updates the root clipping context of a scene.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   */
  updateGlobal(e, t) {
    this.shadowPass = e.overrideMaterial !== null && e.overrideMaterial.isShadowPassMaterial, this.viewMatrix = t.matrixWorldInverse, this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
  }
  /**
   * Updates the clipping context.
   *
   * @param {ClippingContext} parentContext - The parent context.
   * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
   */
  update(e, t) {
    let n = !1;
    e.version !== this.parentVersion && (this.intersectionPlanes = Array.from(e.intersectionPlanes), this.unionPlanes = Array.from(e.unionPlanes), this.parentVersion = e.version), this.clipIntersection !== t.clipIntersection && (this.clipIntersection = t.clipIntersection, this.clipIntersection ? this.unionPlanes.length = e.unionPlanes.length : this.intersectionPlanes.length = e.intersectionPlanes.length);
    const i = t.clippingPlanes, o = i.length;
    let l, p;
    if (this.clipIntersection ? (l = this.intersectionPlanes, p = e.intersectionPlanes.length) : (l = this.unionPlanes, p = e.unionPlanes.length), l.length !== p + o) {
      l.length = p + o;
      for (let f = 0; f < o; f++)
        l[p + f] = new Bn();
      n = !0;
    }
    this.projectPlanes(i, l, p), n && (this.version++, this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`);
  }
  /**
   * Returns a clipping context for the given clipping group.
   *
   * @param {ClippingGroup} clippingGroup - The clipping group.
   * @return {ClippingContext} The clipping context.
   */
  getGroupContext(e) {
    if (this.shadowPass && !e.clipShadows) return this;
    let t = this.clippingGroupContexts.get(e);
    return t === void 0 && (t = new qO(this), this.clippingGroupContexts.set(e, t)), t.update(this, e), t;
  }
  /**
   * The count of union clipping planes.
   *
   * @type {number}
   * @readonly
   */
  get unionClippingCount() {
    return this.unionPlanes.length;
  }
}
class SLe {
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  constructor(e, t) {
    this.bundleGroup = e, this.camera = t;
  }
}
const zw = [];
class wLe {
  /**
   * Constructs a new render bundle management component.
   */
  constructor() {
    this.bundles = new hu();
  }
  /**
   * Returns a render bundle for the given bundle group and camera.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   * @return {RenderBundle} The render bundle.
   */
  get(e, t) {
    const n = this.bundles;
    zw[0] = e, zw[1] = t;
    let i = n.get(zw);
    return i === void 0 && (i = new SLe(e, t), n.set(zw, i)), zw.length = 0, i;
  }
  /**
   * Frees all internal resources.
   */
  dispose() {
    this.bundles = new hu();
  }
}
class ave {
  /**
   * Constructs a new node library.
   */
  constructor() {
    this.lightNodes = /* @__PURE__ */ new WeakMap(), this.materialNodes = /* @__PURE__ */ new Map(), this.toneMappingNodes = /* @__PURE__ */ new Map();
  }
  /**
   * Returns a matching node material instance for the given material object.
   *
   * This method also assigns/copies the properties of the given material object
   * to the node material. This is done to make sure the current material
   * configuration carries over to the node version.
   *
   * @param {Material} material - A material.
   * @return {NodeMaterial} The corresponding node material.
   */
  fromMaterial(e) {
    if (e.isNodeMaterial) return e;
    let t = null;
    const n = this.getMaterialNodeClass(e.type);
    if (n !== null) {
      t = new n();
      for (const i in e)
        t[i] = e[i];
    }
    return t;
  }
  /**
   * Adds a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {Function} toneMappingNode - The tone mapping node function.
   * @param {number} toneMapping - The tone mapping.
   */
  addToneMapping(e, t) {
    this.addType(e, t, this.toneMappingNodes);
  }
  /**
   * Returns a tone mapping node function for a tone mapping technique (constant).
   *
   * @param {number} toneMapping - The tone mapping.
   * @return {?Function} The tone mapping node function. Returns `null` if no node function is found.
   */
  getToneMappingFunction(e) {
    return this.toneMappingNodes.get(e) || null;
  }
  /**
   * Returns a node material class definition for a material type.
   *
   * @param {string} materialType - The material type.
   * @return {?NodeMaterial.constructor} The node material class definition. Returns `null` if no node material is found.
   */
  getMaterialNodeClass(e) {
    return this.materialNodes.get(e) || null;
  }
  /**
   * Adds a node material class definition for a given material type.
   *
   * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
   * @param {string} materialClassType - The material type.
   */
  addMaterial(e, t) {
    this.addType(e, t, this.materialNodes);
  }
  /**
   * Returns a light node class definition for a light class definition.
   *
   * @param {Light.constructor} light - The light class definition.
   * @return {?AnalyticLightNode.constructor} The light node class definition. Returns `null` if no light node is found.
   */
  getLightNodeClass(e) {
    return this.lightNodes.get(e) || null;
  }
  /**
   * Adds a light node class definition for a given light class definition.
   *
   * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
   * @param {Light.constructor} lightClass - The light class definition.
   */
  addLight(e, t) {
    this.addClass(e, t, this.lightNodes);
  }
  /**
   * Adds a node class definition for the given type to the provided type library.
   *
   * @param {any} nodeClass - The node class definition.
   * @param {number|string} type - The object type.
   * @param {Map} library - The type library.
   */
  addType(e, t, n) {
    if (n.has(t)) {
      console.warn(`Redefinition of node ${t}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof t == "function" || typeof t == "object") throw new Error(`Base class ${t} is not a class.`);
    n.set(t, e);
  }
  /**
   * Adds a node class definition for the given class definition to the provided type library.
   *
   * @param {any} nodeClass - The node class definition.
   * @param {any} baseClass - The class definition.
   * @param {WeakMap} library - The type library.
   */
  addClass(e, t, n) {
    if (n.has(t)) {
      console.warn(`Redefinition of node ${t.name}`);
      return;
    }
    if (typeof e != "function") throw new Error(`Node class ${e.name} is not a class.`);
    if (typeof t != "function") throw new Error(`Base class ${t.name} is not a class.`);
    n.set(t, e);
  }
}
const ELe = /* @__PURE__ */ new z0e(), Vw = [];
class TLe extends hu {
  /**
   * Constructs a lighting management component.
   */
  constructor() {
    super();
  }
  /**
   * Creates a new lights node for the given array of lights.
   *
   * @param {Array<Light>} lights - The render object.
   * @return {LightsNode} The lights node.
   */
  createNode(e = []) {
    return new z0e().setLights(e);
  }
  /**
   * Returns a lights node for the given scene and camera.
   *
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera.
   * @return {LightsNode} The lights node.
   */
  getNode(e, t) {
    if (e.isQuadMesh) return ELe;
    Vw[0] = e, Vw[1] = t;
    let n = this.get(Vw);
    return n === void 0 && (n = this.createNode(), this.set(Vw, n)), Vw.length = 0, n;
  }
}
class CLe extends Sa {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(e = []) {
    super(), this.isArrayCamera = !0, this.isMultiViewCamera = !1, this.cameras = e;
  }
}
class WN extends Wi {
  constructor() {
    super(), this.isGroup = !0, this.type = "Group";
  }
}
const PLe = { type: "move" };
class ALe {
  /**
   * Constructs a new XR controller.
   */
  constructor() {
    this._targetRay = null, this._grip = null, this._hand = null;
  }
  /**
   * Returns a group representing the hand space of the XR controller.
   *
   * @return {Group} A group representing the hand space of the XR controller.
   */
  getHandSpace() {
    return this._hand === null && (this._hand = new WN(), this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand;
  }
  /**
   * Returns a group representing the target ray space of the XR controller.
   *
   * @return {Group} A group representing the target ray space of the XR controller.
   */
  getTargetRaySpace() {
    return this._targetRay === null && (this._targetRay = new WN(), this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new Ue(), this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new Ue()), this._targetRay;
  }
  /**
   * Returns a group representing the grip space of the XR controller.
   *
   * @return {Group} A group representing the grip space of the XR controller.
   */
  getGripSpace() {
    return this._grip === null && (this._grip = new WN(), this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new Ue(), this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new Ue()), this._grip;
  }
  /**
   * Dispatches the given event to the groups representing
   * the different coordinate spaces of the XR controller.
   *
   * @param {Object} event - The event to dispatch.
   * @return {WebXRController} A reference to this instance.
   */
  dispatchEvent(e) {
    return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this;
  }
  /**
   * Connects the controller with the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t)
        for (const n of e.hand.values())
          this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  /**
   * Disconnects the controller from the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  disconnect(e) {
    return this.dispatchEvent({ type: "disconnected", data: e }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this;
  }
  /**
   * Updates the controller with the given input source, XR frame and reference space.
   * This updates the transformations of the groups that represent the different
   * coordinate systems of the controller.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @param {XRFrame} frame - The XR frame.
   * @param {XRReferenceSpace} referenceSpace - The reference space.
   * @return {WebXRController} A reference to this instance.
   */
  update(e, t, n) {
    let i = null, o = null, l = null;
    const p = this._targetRay, f = this._grip, v = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (v && e.hand) {
        l = !0;
        for (const q of e.hand.values()) {
          const L = t.getJointPose(q, n), V = this._getHandJoint(v, q);
          L !== null && (V.matrix.fromArray(L.transform.matrix), V.matrix.decompose(V.position, V.rotation, V.scale), V.matrixWorldNeedsUpdate = !0, V.jointRadius = L.radius), V.visible = L !== null;
        }
        const _ = v.joints["index-finger-tip"], E = v.joints["thumb-tip"], A = _.position.distanceTo(E.position), I = 0.02, j = 5e-3;
        v.inputState.pinching && A > I + j ? (v.inputState.pinching = !1, this.dispatchEvent({
          type: "pinchend",
          handedness: e.handedness,
          target: this
        })) : !v.inputState.pinching && A <= I - j && (v.inputState.pinching = !0, this.dispatchEvent({
          type: "pinchstart",
          handedness: e.handedness,
          target: this
        }));
      } else
        f !== null && e.gripSpace && (o = t.getPose(e.gripSpace, n), o !== null && (f.matrix.fromArray(o.transform.matrix), f.matrix.decompose(f.position, f.rotation, f.scale), f.matrixWorldNeedsUpdate = !0, o.linearVelocity ? (f.hasLinearVelocity = !0, f.linearVelocity.copy(o.linearVelocity)) : f.hasLinearVelocity = !1, o.angularVelocity ? (f.hasAngularVelocity = !0, f.angularVelocity.copy(o.angularVelocity)) : f.hasAngularVelocity = !1));
      p !== null && (i = t.getPose(e.targetRaySpace, n), i === null && o !== null && (i = o), i !== null && (p.matrix.fromArray(i.transform.matrix), p.matrix.decompose(p.position, p.rotation, p.scale), p.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (p.hasLinearVelocity = !0, p.linearVelocity.copy(i.linearVelocity)) : p.hasLinearVelocity = !1, i.angularVelocity ? (p.hasAngularVelocity = !0, p.angularVelocity.copy(i.angularVelocity)) : p.hasAngularVelocity = !1, this.dispatchEvent(PLe)));
    }
    return p !== null && (p.visible = i !== null), f !== null && (f.visible = o !== null), v !== null && (v.visible = l !== null), this;
  }
  /**
   * Returns a group representing the hand joint for the given input joint.
   *
   * @private
   * @param {Group} hand - The group representing the hand space.
   * @param {XRJointSpace} inputjoint - The hand joint data.
   * @return {Group} A group representing the hand joint for the given input joint.
   */
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new WN();
      n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class sE extends Mg {
  /**
   * Constructs a new XR render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {Object} [options={}] - The configuration options.
   */
  constructor(e = 1, t = 1, n = {}) {
    super(e, t, n), this.isXRRenderTarget = !0, this.hasExternalTextures = !1, this.autoAllocateDepthBuffer = !0;
  }
  copy(e) {
    return super.copy(e), this.hasExternalTextures = e.hasExternalTextures, this.autoAllocateDepthBuffer = e.autoAllocateDepthBuffer, this;
  }
}
class xG extends Zd {
  /**
   * Constructs a new cylinder geometry.
   *
   * @param {number} [radiusTop=1] - Radius of the cylinder at the top.
   * @param {number} [radiusBottom=1] - Radius of the cylinder at the bottom.
   * @param {number} [height=1] - Height of the cylinder.
   * @param {number} [radialSegments=32] - Number of segmented faces around the circumference of the cylinder.
   * @param {number} [heightSegments=1] - Number of rows of faces along the height of the cylinder.
   * @param {boolean} [openEnded=false] - Whether the base of the cylinder is open or capped.
   * @param {number} [thetaStart=0] - Start angle for first segment, in radians.
   * @param {number} [thetaLength=Math.PI*2] - The central angle, often called theta, of the circular sector, in radians.
   * The default value results in a complete cylinder.
   */
  constructor(e = 1, t = 1, n = 1, i = 32, o = 1, l = !1, p = 0, f = Math.PI * 2) {
    super(), this.type = "CylinderGeometry", this.parameters = {
      radiusTop: e,
      radiusBottom: t,
      height: n,
      radialSegments: i,
      heightSegments: o,
      openEnded: l,
      thetaStart: p,
      thetaLength: f
    };
    const v = this;
    i = Math.floor(i), o = Math.floor(o);
    const _ = [], E = [], A = [], I = [];
    let j = 0;
    const q = [], L = n / 2;
    let V = 0;
    re(), l === !1 && (e > 0 && R(!0), t > 0 && R(!1)), this.setIndex(_), this.setAttribute("position", new vo(E, 3)), this.setAttribute("normal", new vo(A, 3)), this.setAttribute("uv", new vo(I, 2));
    function re() {
      const J = new Ue(), ge = new Ue();
      let _e = 0;
      const Y = (t - e) / n;
      for (let Fe = 0; Fe <= o; Fe++) {
        const Me = [], $ = Fe / o, dt = $ * (t - e) + e;
        for (let wt = 0; wt <= i; wt++) {
          const St = wt / i, Ct = St * f + p, pe = Math.sin(Ct), Tt = Math.cos(Ct);
          ge.x = dt * pe, ge.y = -$ * n + L, ge.z = dt * Tt, E.push(ge.x, ge.y, ge.z), J.set(pe, Y, Tt).normalize(), A.push(J.x, J.y, J.z), I.push(St, 1 - $), Me.push(j++);
        }
        q.push(Me);
      }
      for (let Fe = 0; Fe < i; Fe++)
        for (let Me = 0; Me < o; Me++) {
          const $ = q[Me][Fe], dt = q[Me + 1][Fe], wt = q[Me + 1][Fe + 1], St = q[Me][Fe + 1];
          (e > 0 || Me !== 0) && (_.push($, dt, St), _e += 3), (t > 0 || Me !== o - 1) && (_.push(dt, wt, St), _e += 3);
        }
      v.addGroup(V, _e, 0), V += _e;
    }
    function R(J) {
      const ge = j, _e = new Pn(), Y = new Ue();
      let Fe = 0;
      const Me = J === !0 ? e : t, $ = J === !0 ? 1 : -1;
      for (let wt = 1; wt <= i; wt++)
        E.push(0, L * $, 0), A.push(0, $, 0), I.push(0.5, 0.5), j++;
      const dt = j;
      for (let wt = 0; wt <= i; wt++) {
        const Ct = wt / i * f + p, pe = Math.cos(Ct), Tt = Math.sin(Ct);
        Y.x = Me * Tt, Y.y = L * $, Y.z = Me * pe, E.push(Y.x, Y.y, Y.z), A.push(0, $, 0), _e.x = pe * 0.5 + 0.5, _e.y = Tt * 0.5 * $ + 0.5, I.push(_e.x, _e.y), j++;
      }
      for (let wt = 0; wt < i; wt++) {
        const St = ge + wt, Ct = dt + wt;
        J === !0 ? _.push(Ct, Ct + 1, St) : _.push(Ct + 1, Ct, St), Fe += 3;
      }
      v.addGroup(V, Fe, J === !0 ? 1 : 2), V += Fe;
    }
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {CylinderGeometry} A new instance.
   */
  static fromJSON(e) {
    return new xG(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength);
  }
}
class _G extends Zd {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(), this.type = "PlaneGeometry", this.parameters = {
      width: e,
      height: t,
      widthSegments: n,
      heightSegments: i
    };
    const o = e / 2, l = t / 2, p = Math.floor(n), f = Math.floor(i), v = p + 1, _ = f + 1, E = e / p, A = t / f, I = [], j = [], q = [], L = [];
    for (let V = 0; V < _; V++) {
      const re = V * A - l;
      for (let R = 0; R < v; R++) {
        const J = R * E - o;
        j.push(J, -re, 0), q.push(0, 0, 1), L.push(R / p), L.push(1 - V / f);
      }
    }
    for (let V = 0; V < f; V++)
      for (let re = 0; re < p; re++) {
        const R = re + v * V, J = re + v * (V + 1), ge = re + 1 + v * (V + 1), _e = re + 1 + v * V;
        I.push(R, J, _e), I.push(J, ge, _e);
      }
    this.setIndex(I), this.setAttribute("position", new vo(j, 3)), this.setAttribute("normal", new vo(q, 3)), this.setAttribute("uv", new vo(L, 2));
  }
  copy(e) {
    return super.copy(e), this.parameters = Object.assign({}, e.parameters), this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(e) {
    return new _G(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
const Mme = /* @__PURE__ */ new Ue(), Rme = /* @__PURE__ */ new Ue();
class kLe extends kg {
  /**
   * Constructs a new XR manager.
   *
   * @param {Renderer} renderer - The renderer.
   * @param {boolean} [multiview=false] - Enables multiview if the device supports it.
   */
  constructor(e, t = !1) {
    super(), this.enabled = !1, this.isPresenting = !1, this.cameraAutoUpdate = !0, this._renderer = e, this._cameraL = new Sa(), this._cameraL.viewport = new Bn(), this._cameraR = new Sa(), this._cameraR.viewport = new Bn(), this._cameras = [this._cameraL, this._cameraR], this._cameraXR = new CLe(), this._currentDepthNear = null, this._currentDepthFar = null, this._controllers = [], this._controllerInputSources = [], this._xrRenderTarget = null, this._layers = [], this._supportsLayers = !1, this._frameBufferTargets = null, this._createXRLayer = DLe.bind(this), this._gl = null, this._currentAnimationContext = null, this._currentAnimationLoop = null, this._currentPixelRatio = null, this._currentSize = new Pn(), this._onSessionEvent = ILe.bind(this), this._onSessionEnd = NLe.bind(this), this._onInputSourcesChange = OLe.bind(this), this._onAnimationFrame = FLe.bind(this), this._referenceSpace = null, this._referenceSpaceType = "local-floor", this._customReferenceSpace = null, this._framebufferScaleFactor = 1, this._foveation = 1, this._session = null, this._glBaseLayer = null, this._glBinding = null, this._glProjLayer = null, this._xrFrame = null, this._useLayers = typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype, this._useMultiviewIfPossible = t, this._useMultiview = !1;
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in target ray space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getController(e) {
    return this._getController(e).getTargetRaySpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in grip space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getControllerGrip(e) {
    return this._getController(e).getGripSpace();
  }
  /**
   * Returns an instance of `THREE.Group` that represents the transformation
   * of a XR controller in hand space. The requested controller is defined
   * by the given index.
   *
   * @param {number} index - The index of the XR controller.
   * @return {Group} A group that represents the controller's transformation.
   */
  getHand(e) {
    return this._getController(e).getHandSpace();
  }
  /**
   * Returns the foveation value.
   *
   * @return {number|undefined} The foveation value. Returns `undefined` if no base or projection layer is defined.
   */
  getFoveation() {
    if (!(this._glProjLayer === null && this._glBaseLayer === null))
      return this._foveation;
  }
  /**
   * Sets the foveation value.
   *
   * @param {number} foveation - A number in the range `[0,1]` where `0` means no foveation (full resolution)
   * and `1` means maximum foveation (the edges render at lower resolution).
   */
  setFoveation(e) {
    this._foveation = e, this._glProjLayer !== null && (this._glProjLayer.fixedFoveation = e), this._glBaseLayer !== null && this._glBaseLayer.fixedFoveation !== void 0 && (this._glBaseLayer.fixedFoveation = e);
  }
  /**
   * Returns the framebuffer scale factor.
   *
   * @return {number} The framebuffer scale factor.
   */
  getFramebufferScaleFactor() {
    return this._framebufferScaleFactor;
  }
  /**
   * Sets the framebuffer scale factor.
   *
   * This method can not be used during a XR session.
   *
   * @param {number} factor - The framebuffer scale factor.
   */
  setFramebufferScaleFactor(e) {
    this._framebufferScaleFactor = e, this.isPresenting === !0 && console.warn("THREE.XRManager: Cannot change framebuffer scale while presenting.");
  }
  /**
   * Returns the reference space type.
   *
   * @return {XRReferenceSpaceType} The reference space type.
   */
  getReferenceSpaceType() {
    return this._referenceSpaceType;
  }
  /**
   * Sets the reference space type.
   *
   * This method can not be used during a XR session.
   *
   * @param {XRReferenceSpaceType} type - The reference space type.
   */
  setReferenceSpaceType(e) {
    this._referenceSpaceType = e, this.isPresenting === !0 && console.warn("THREE.XRManager: Cannot change reference space type while presenting.");
  }
  /**
   * Returns the XR reference space.
   *
   * @return {XRReferenceSpace} The XR reference space.
   */
  getReferenceSpace() {
    return this._customReferenceSpace || this._referenceSpace;
  }
  /**
   * Sets a custom XR reference space.
   *
   * @param {XRReferenceSpace} space - The XR reference space.
   */
  setReferenceSpace(e) {
    this._customReferenceSpace = e;
  }
  /**
   * Returns the XR camera.
   *
   * @return {ArrayCamera} The XR camera.
   */
  getCamera() {
    return this._cameraXR;
  }
  /**
   * Returns the environment blend mode from the current XR session.
   *
   * @return {'opaque'|'additive'|'alpha-blend'|undefined} The environment blend mode. Returns `undefined` when used outside of a XR session.
   */
  getEnvironmentBlendMode() {
    if (this._session !== null)
      return this._session.environmentBlendMode;
  }
  /**
   * Returns the current XR frame.
   *
   * @return {?XRFrame} The XR frame. Returns `null` when used outside a XR session.
   */
  getFrame() {
    return this._xrFrame;
  }
  /**
   * Returns `true` if the engine renders to a multiview target.
   *
   * @return {boolean} Whether the engine renders to a multiview render target or not.
   */
  useMultiview() {
    return this._useMultiview;
  }
  /**
   * This method can be used in XR applications to create a quadratic layer that presents a separate
   * rendered scene.
   *
   * @param {number} width - The width of the layer plane in world units.
   * @param {number} height - The height of the layer plane in world units.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the quadratic XR layer. This mesh should be added to the XR scene.
   */
  createQuadLayer(e, t, n, i, o, l, p, f = {}) {
    const v = new _G(e, t), _ = new sE(
      o,
      l,
      {
        format: al,
        type: yo,
        depthTexture: new _c(
          o,
          l,
          f.stencil ? Xp : xi,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          f.stencil ? zd : xc
        ),
        stencilBuffer: f.stencil,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }
    );
    _.autoAllocateDepthBuffer = !0;
    const E = new Wp({ color: 16777215, side: Ld });
    E.map = _.texture, E.map.offset.y = 1, E.map.repeat.y = -1;
    const A = new Yd(v, E);
    A.position.copy(n), A.quaternion.copy(i);
    const I = {
      type: "quad",
      width: e,
      height: t,
      translation: n,
      quaternion: i,
      pixelwidth: o,
      pixelheight: l,
      plane: A,
      material: E,
      rendercall: p,
      renderTarget: _
    };
    if (this._layers.push(I), this._session !== null) {
      I.plane.material = new Wp({ color: 16777215, side: Ld }), I.plane.material.blending = pE, I.plane.material.blendEquation = uu, I.plane.material.blendSrc = Vp, I.plane.material.blendDst = Vp, I.xrlayer = this._createXRLayer(I);
      const j = this._session.renderState.layers;
      j.unshift(I.xrlayer), this._session.updateRenderState({ layers: j });
    } else
      _.isXRRenderTarget = !1;
    return A;
  }
  /**
   * This method can be used in XR applications to create a cylindrical layer that presents a separate
   * rendered scene.
   *
   * @param {number} radius - The radius of the cylinder in world units.
   * @param {number} centralAngle - The central angle of the cylinder in radians.
   * @param {number} aspectratio - The aspect ratio.
   * @param {Vector3} translation - The position/translation of the layer plane in world units.
   * @param {Quaternion} quaternion - The orientation of the layer plane expressed as a quaternion.
   * @param {number} pixelwidth - The width of the layer's render target in pixels.
   * @param {number} pixelheight - The height of the layer's render target in pixels.
   * @param {Function} rendercall - A callback function that renders the layer. Similar to code in
   * the default animation loop, this method can be used to update/transform 3D object in the layer's scene.
   * @param {Object} [attributes={}] - Allows to configure the layer's render target.
   * @return {Mesh} A mesh representing the cylindrical XR layer. This mesh should be added to the XR scene.
   */
  createCylinderLayer(e, t, n, i, o, l, p, f, v = {}) {
    const _ = new xG(e, e, e * t / n, 64, 64, !0, Math.PI - t / 2, t), E = new sE(
      l,
      p,
      {
        format: al,
        type: yo,
        depthTexture: new _c(
          l,
          p,
          v.stencil ? Xp : xi,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          void 0,
          v.stencil ? zd : xc
        ),
        stencilBuffer: v.stencil,
        resolveDepthBuffer: !1,
        resolveStencilBuffer: !1
      }
    );
    E.autoAllocateDepthBuffer = !0;
    const A = new Wp({ color: 16777215, side: Ko });
    A.map = E.texture, A.map.offset.y = 1, A.map.repeat.y = -1;
    const I = new Yd(_, A);
    I.position.copy(i), I.quaternion.copy(o);
    const j = {
      type: "cylinder",
      radius: e,
      centralAngle: t,
      aspectratio: n,
      translation: i,
      quaternion: o,
      pixelwidth: l,
      pixelheight: p,
      plane: I,
      material: A,
      rendercall: f,
      renderTarget: E
    };
    if (this._layers.push(j), this._session !== null) {
      j.plane.material = new Wp({ color: 16777215, side: Ko }), j.plane.material.blending = pE, j.plane.material.blendEquation = uu, j.plane.material.blendSrc = Vp, j.plane.material.blendDst = Vp, j.xrlayer = this._createXRLayer(j);
      const q = this._session.renderState.layers;
      q.unshift(j.xrlayer), this._session.updateRenderState({ layers: q });
    } else
      E.isXRRenderTarget = !1;
    return I;
  }
  /**
   * Renders the XR layers that have been previously added to the scene.
   *
   * This method is usually called in your animation loop before rendering
   * the actual scene via `renderer.render( scene, camera );`.
   */
  renderLayers() {
    const e = new Ue(), t = new Yb(), n = this._renderer, i = this.isPresenting, o = n.getOutputRenderTarget(), l = n._frameBufferTarget;
    this.isPresenting = !1;
    const p = new Pn();
    n.getSize(p);
    const f = n._quad;
    for (const v of this._layers)
      if (v.renderTarget.isXRRenderTarget = this._session !== null, v.renderTarget.hasExternalTextures = v.renderTarget.isXRRenderTarget, v.renderTarget.isXRRenderTarget && this._supportsLayers) {
        v.xrlayer.transform = new XRRigidTransform(v.plane.getWorldPosition(e), v.plane.getWorldQuaternion(t));
        const _ = this._glBinding.getSubImage(v.xrlayer, this._xrFrame);
        n.backend.setXRRenderTargetTextures(
          v.renderTarget,
          _.colorTexture,
          void 0
        ), n._setXRLayerSize(v.renderTarget.width, v.renderTarget.height), n.setOutputRenderTarget(v.renderTarget), n.setRenderTarget(null), n._frameBufferTarget = null, this._frameBufferTargets || (this._frameBufferTargets = /* @__PURE__ */ new WeakMap());
        const { frameBufferTarget: E, quad: A } = this._frameBufferTargets.get(v.renderTarget) || { frameBufferTarget: null, quad: null };
        E ? (n._frameBufferTarget = E, n._quad = A) : (n._quad = new hG(new Ni()), this._frameBufferTargets.set(v.renderTarget, { frameBufferTarget: n._getFrameBufferTarget(), quad: n._quad })), v.rendercall(), n._frameBufferTarget = null;
      } else
        n.setRenderTarget(v.renderTarget), v.rendercall();
    n.setRenderTarget(null), n.setOutputRenderTarget(o), n._frameBufferTarget = l, n._setXRLayerSize(p.x, p.y), n._quad = f, this.isPresenting = i;
  }
  /**
   * Returns the current XR session.
   *
   * @return {?XRSession} The XR session. Returns `null` when used outside a XR session.
   */
  getSession() {
    return this._session;
  }
  /**
   * After a XR session has been requested usually with one of the `*Button` modules, it
   * is injected into the renderer with this method. This method triggers the start of
   * the actual XR rendering.
   *
   * @async
   * @param {XRSession} session - The XR session to set.
   * @return {Promise} A Promise that resolves when the session has been set.
   */
  async setSession(e) {
    const t = this._renderer, n = t.backend;
    this._gl = t.getContext();
    const i = this._gl, o = i.getContextAttributes();
    if (this._session = e, e !== null) {
      if (n.isWebGPUBackend === !0) throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');
      if (e.addEventListener("select", this._onSessionEvent), e.addEventListener("selectstart", this._onSessionEvent), e.addEventListener("selectend", this._onSessionEvent), e.addEventListener("squeeze", this._onSessionEvent), e.addEventListener("squeezestart", this._onSessionEvent), e.addEventListener("squeezeend", this._onSessionEvent), e.addEventListener("end", this._onSessionEnd), e.addEventListener("inputsourceschange", this._onInputSourcesChange), await n.makeXRCompatible(), this._currentPixelRatio = t.getPixelRatio(), t.getSize(this._currentSize), this._currentAnimationContext = t._animation.getContext(), this._currentAnimationLoop = t._animation.getAnimationLoop(), t._animation.stop(), this._useLayers === !0) {
        let l = null, p = null, f = null;
        t.depth && (f = t.stencil ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24, l = t.stencil ? zd : xc, p = t.stencil ? Xp : xi);
        const v = {
          colorFormat: i.RGBA8,
          depthFormat: f,
          scaleFactor: this._framebufferScaleFactor,
          clearOnAccess: !1
        };
        this._useMultiviewIfPossible && t.hasFeature("OVR_multiview2") && (v.textureType = "texture-array", this._useMultiview = !0);
        const _ = new XRWebGLBinding(e, i), E = _.createProjectionLayer(v), A = [E];
        this._glBinding = _, this._glProjLayer = E, t.setPixelRatio(1), t._setXRLayerSize(E.textureWidth, E.textureHeight);
        const I = this._useMultiview ? 2 : 1, j = new _c(E.textureWidth, E.textureHeight, p, void 0, void 0, void 0, void 0, void 0, void 0, l, I);
        if (this._xrRenderTarget = new sE(
          E.textureWidth,
          E.textureHeight,
          {
            format: al,
            type: yo,
            colorSpace: t.outputColorSpace,
            depthTexture: j,
            stencilBuffer: t.stencil,
            samples: o.antialias ? 4 : 0,
            resolveDepthBuffer: E.ignoreDepthValues === !1,
            resolveStencilBuffer: E.ignoreDepthValues === !1,
            depth: this._useMultiview ? 2 : 1,
            multiview: this._useMultiview
          }
        ), this._xrRenderTarget.hasExternalTextures = !0, this._xrRenderTarget.depth = this._useMultiview ? 2 : 1, this._supportsLayers = e.enabledFeatures.includes("layers"), this._referenceSpace = await e.requestReferenceSpace(this.getReferenceSpaceType()), this._supportsLayers)
          for (const q of this._layers)
            q.plane.material = new Wp({ color: 16777215, side: q.type === "cylinder" ? Ko : Ld }), q.plane.material.blending = pE, q.plane.material.blendEquation = uu, q.plane.material.blendSrc = Vp, q.plane.material.blendDst = Vp, q.xrlayer = this._createXRLayer(q), A.unshift(q.xrlayer);
        e.updateRenderState({ layers: A });
      } else {
        const l = {
          antialias: t.samples > 0,
          alpha: !0,
          depth: t.depth,
          stencil: t.stencil,
          framebufferScaleFactor: this.getFramebufferScaleFactor()
        }, p = new XRWebGLLayer(e, i, l);
        this._glBaseLayer = p, e.updateRenderState({ baseLayer: p }), t.setPixelRatio(1), t._setXRLayerSize(p.framebufferWidth, p.framebufferHeight), this._xrRenderTarget = new sE(
          p.framebufferWidth,
          p.framebufferHeight,
          {
            format: al,
            type: yo,
            colorSpace: t.outputColorSpace,
            stencilBuffer: t.stencil,
            resolveDepthBuffer: p.ignoreDepthValues === !1,
            resolveStencilBuffer: p.ignoreDepthValues === !1
          }
        ), this._referenceSpace = await e.requestReferenceSpace(this.getReferenceSpaceType());
      }
      this.setFoveation(this.getFoveation()), t._animation.setAnimationLoop(this._onAnimationFrame), t._animation.setContext(e), t._animation.start(), this.isPresenting = !0, this.dispatchEvent({ type: "sessionstart" });
    }
  }
  /**
   * This method is called by the renderer per frame and updates the XR camera
   * and it sub cameras based on the given camera. The given camera is the "user"
   * camera created on application level and used for non-XR rendering.
   *
   * @param {PerspectiveCamera} camera - The camera.
   */
  updateCamera(e) {
    const t = this._session;
    if (t === null) return;
    const n = e.near, i = e.far, o = this._cameraXR, l = this._cameraL, p = this._cameraR;
    o.near = p.near = l.near = n, o.far = p.far = l.far = i, o.isMultiViewCamera = this._useMultiview, (this._currentDepthNear !== o.near || this._currentDepthFar !== o.far) && (t.updateRenderState({
      depthNear: o.near,
      depthFar: o.far
    }), this._currentDepthNear = o.near, this._currentDepthFar = o.far), l.layers.mask = e.layers.mask | 2, p.layers.mask = e.layers.mask | 4, o.layers.mask = l.layers.mask | p.layers.mask;
    const f = e.parent, v = o.cameras;
    Ime(o, f);
    for (let _ = 0; _ < v.length; _++)
      Ime(v[_], f);
    v.length === 2 ? MLe(o, l, p) : o.projectionMatrix.copy(l.projectionMatrix), RLe(e, o, f);
  }
  /**
   * Returns a WebXR controller for the given controller index.
   *
   * @private
   * @param {number} index - The controller index.
   * @return {WebXRController} The XR controller.
   */
  _getController(e) {
    let t = this._controllers[e];
    return t === void 0 && (t = new ALe(), this._controllers[e] = t), t;
  }
}
function MLe(c, e, t) {
  Mme.setFromMatrixPosition(e.matrixWorld), Rme.setFromMatrixPosition(t.matrixWorld);
  const n = Mme.distanceTo(Rme), i = e.projectionMatrix.elements, o = t.projectionMatrix.elements, l = i[14] / (i[10] - 1), p = i[14] / (i[10] + 1), f = (i[9] + 1) / i[5], v = (i[9] - 1) / i[5], _ = (i[8] - 1) / i[0], E = (o[8] + 1) / o[0], A = l * _, I = l * E, j = n / (-_ + E), q = j * -_;
  if (e.matrixWorld.decompose(c.position, c.quaternion, c.scale), c.translateX(q), c.translateZ(j), c.matrixWorld.compose(c.position, c.quaternion, c.scale), c.matrixWorldInverse.copy(c.matrixWorld).invert(), i[10] === -1)
    c.projectionMatrix.copy(e.projectionMatrix), c.projectionMatrixInverse.copy(e.projectionMatrixInverse);
  else {
    const L = l + j, V = p + j, re = A - q, R = I + (n - q), J = f * p / V * L, ge = v * p / V * L;
    c.projectionMatrix.makePerspective(re, R, J, ge, L, V), c.projectionMatrixInverse.copy(c.projectionMatrix).invert();
  }
}
function Ime(c, e) {
  e === null ? c.matrixWorld.copy(c.matrix) : c.matrixWorld.multiplyMatrices(e.matrixWorld, c.matrix), c.matrixWorldInverse.copy(c.matrixWorld).invert();
}
function RLe(c, e, t) {
  t === null ? c.matrix.copy(e.matrixWorld) : (c.matrix.copy(t.matrixWorld), c.matrix.invert(), c.matrix.multiply(e.matrixWorld)), c.matrix.decompose(c.position, c.quaternion, c.scale), c.updateMatrixWorld(!0), c.projectionMatrix.copy(e.projectionMatrix), c.projectionMatrixInverse.copy(e.projectionMatrixInverse), c.isPerspectiveCamera && (c.fov = Ub * 2 * Math.atan(1 / c.projectionMatrix.elements[5]), c.zoom = 1);
}
function ILe(c) {
  const e = this._controllerInputSources.indexOf(c.inputSource);
  if (e === -1)
    return;
  const t = this._controllers[e];
  if (t !== void 0) {
    const n = this.getReferenceSpace();
    t.update(c.inputSource, c.frame, n), t.dispatchEvent({ type: c.type, data: c.inputSource });
  }
}
function NLe() {
  const c = this._session, e = this._renderer;
  c.removeEventListener("select", this._onSessionEvent), c.removeEventListener("selectstart", this._onSessionEvent), c.removeEventListener("selectend", this._onSessionEvent), c.removeEventListener("squeeze", this._onSessionEvent), c.removeEventListener("squeezestart", this._onSessionEvent), c.removeEventListener("squeezeend", this._onSessionEvent), c.removeEventListener("end", this._onSessionEnd), c.removeEventListener("inputsourceschange", this._onInputSourcesChange);
  for (let t = 0; t < this._controllers.length; t++) {
    const n = this._controllerInputSources[t];
    n !== null && (this._controllerInputSources[t] = null, this._controllers[t].disconnect(n));
  }
  if (this._currentDepthNear = null, this._currentDepthFar = null, e._resetXRState(), this._session = null, this._xrRenderTarget = null, this._supportsLayers === !0)
    for (const t of this._layers)
      t.renderTarget = new sE(
        t.pixelwidth,
        t.pixelheight,
        {
          format: al,
          type: yo,
          depthTexture: new _c(
            t.pixelwidth,
            t.pixelheight,
            t.stencilBuffer ? Xp : xi,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            void 0,
            t.stencilBuffer ? zd : xc
          ),
          stencilBuffer: t.stencilBuffer,
          resolveDepthBuffer: !1,
          resolveStencilBuffer: !1
        }
      ), t.renderTarget.isXRRenderTarget = !1, t.plane.material = t.material, t.material.map = t.renderTarget.texture, t.material.map.offset.y = 1, t.material.map.repeat.y = -1, delete t.xrlayer;
  this.isPresenting = !1, this._useMultiview = !1, e._animation.stop(), e._animation.setAnimationLoop(this._currentAnimationLoop), e._animation.setContext(this._currentAnimationContext), e._animation.start(), e.setPixelRatio(this._currentPixelRatio), e.setSize(this._currentSize.width, this._currentSize.height, !1), this.dispatchEvent({ type: "sessionend" });
}
function OLe(c) {
  const e = this._controllers, t = this._controllerInputSources;
  for (let n = 0; n < c.removed.length; n++) {
    const i = c.removed[n], o = t.indexOf(i);
    o >= 0 && (t[o] = null, e[o].disconnect(i));
  }
  for (let n = 0; n < c.added.length; n++) {
    const i = c.added[n];
    let o = t.indexOf(i);
    if (o === -1) {
      for (let p = 0; p < e.length; p++)
        if (p >= t.length) {
          t.push(i), o = p;
          break;
        } else if (t[p] === null) {
          t[p] = i, o = p;
          break;
        }
      if (o === -1) break;
    }
    const l = e[o];
    l && l.connect(i);
  }
}
function DLe(c) {
  return c.type === "quad" ? this._glBinding.createQuadLayer({
    transform: new XRRigidTransform(c.translation, c.quaternion),
    width: c.width / 2,
    height: c.height / 2,
    space: this._referenceSpace,
    viewPixelWidth: c.pixelwidth,
    viewPixelHeight: c.pixelheight,
    clearOnAccess: !1
  }) : this._glBinding.createCylinderLayer({
    transform: new XRRigidTransform(c.translation, c.quaternion),
    radius: c.radius,
    centralAngle: c.centralAngle,
    aspectRatio: c.aspectRatio,
    space: this._referenceSpace,
    viewPixelWidth: c.pixelwidth,
    viewPixelHeight: c.pixelheight,
    clearOnAccess: !1
  });
}
function FLe(c, e) {
  if (e === void 0) return;
  const t = this._cameraXR, n = this._renderer, i = n.backend, o = this._glBaseLayer, l = this.getReferenceSpace(), p = e.getViewerPose(l);
  if (this._xrFrame = e, p !== null) {
    const f = p.views;
    this._glBaseLayer !== null && i.setXRTarget(o.framebuffer);
    let v = !1;
    f.length !== t.cameras.length && (t.cameras.length = 0, v = !0);
    for (let _ = 0; _ < f.length; _++) {
      const E = f[_];
      let A;
      if (this._useLayers === !0) {
        const j = this._glBinding.getViewSubImage(this._glProjLayer, E);
        A = j.viewport, _ === 0 && i.setXRRenderTargetTextures(
          this._xrRenderTarget,
          j.colorTexture,
          this._glProjLayer.ignoreDepthValues && !this._useMultiview ? void 0 : j.depthStencilTexture
        );
      } else
        A = o.getViewport(E);
      let I = this._cameras[_];
      I === void 0 && (I = new Sa(), I.layers.enable(_), I.viewport = new Bn(), this._cameras[_] = I), I.matrix.fromArray(E.transform.matrix), I.matrix.decompose(I.position, I.quaternion, I.scale), I.projectionMatrix.fromArray(E.projectionMatrix), I.projectionMatrixInverse.copy(I.projectionMatrix).invert(), I.viewport.set(A.x, A.y, A.width, A.height), _ === 0 && (t.matrix.copy(I.matrix), t.matrix.decompose(t.position, t.quaternion, t.scale)), v === !0 && t.cameras.push(I);
    }
    n.setOutputRenderTarget(this._xrRenderTarget);
  }
  for (let f = 0; f < this._controllers.length; f++) {
    const v = this._controllerInputSources[f], _ = this._controllers[f];
    v !== null && _ !== void 0 && _.update(v, e, l);
  }
  this._currentAnimationLoop && this._currentAnimationLoop(c, e), e.detectedPlanes && this.dispatchEvent({ type: "planesdetected", data: e }), this._xrFrame = null;
}
const ig = /* @__PURE__ */ new i2(), KN = /* @__PURE__ */ new Ue();
class SG {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(e = new qp(), t = new qp(), n = new qp(), i = new qp(), o = new qp(), l = new qp()) {
    this.planes = [e, t, n, i, o, l];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(e, t, n, i, o, l) {
    const p = this.planes;
    return p[0].copy(e), p[1].copy(t), p[2].copy(n), p[3].copy(i), p[4].copy(o), p[5].copy(l), this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      t[n].copy(e.planes[n]);
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(e, t = Ho) {
    const n = this.planes, i = e.elements, o = i[0], l = i[1], p = i[2], f = i[3], v = i[4], _ = i[5], E = i[6], A = i[7], I = i[8], j = i[9], q = i[10], L = i[11], V = i[12], re = i[13], R = i[14], J = i[15];
    if (n[0].setComponents(f - o, A - v, L - I, J - V).normalize(), n[1].setComponents(f + o, A + v, L + I, J + V).normalize(), n[2].setComponents(f + l, A + _, L + j, J + re).normalize(), n[3].setComponents(f - l, A - _, L - j, J - re).normalize(), n[4].setComponents(f - p, A - E, L - q, J - R).normalize(), t === Ho)
      n[5].setComponents(f + p, A + E, L + q, J + R).normalize();
    else if (t === Jp)
      n[5].setComponents(p, E, q, R).normalize();
    else
      throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(), ig.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(), ig.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(ig);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(e) {
    return ig.center.set(0, 0, 0), ig.radius = 0.7071067811865476, ig.applyMatrix4(e.matrixWorld), this.intersectsSphere(ig);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(e) {
    const t = this.planes, n = e.center, i = -e.radius;
    for (let o = 0; o < 6; o++)
      if (t[o].distanceToPoint(n) < i)
        return !1;
    return !0;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (KN.x = i.normal.x > 0 ? e.max.x : e.min.x, KN.y = i.normal.y > 0 ? e.max.y : e.min.y, KN.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(KN) < 0)
        return !1;
    }
    return !0;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++)
      if (t[n].distanceToPoint(e) < 0)
        return !1;
    return !0;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
}
const uc = /* @__PURE__ */ new Pr(), cc = /* @__PURE__ */ new SG();
class wG {
  /**
   * Constructs a new frustum array.
   *
   */
  constructor() {
    this.coordinateSystem = Ho;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Object3D} object - The 3D object to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the 3D object is visible in any camera.
   */
  intersectsObject(e, t) {
    if (!t.isArrayCamera || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const i = t.cameras[n];
      if (uc.multiplyMatrices(
        i.projectionMatrix,
        i.matrixWorldInverse
      ), cc.setFromProjectionMatrix(
        uc,
        this.coordinateSystem
      ), cc.intersectsObject(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given sprite is intersecting any frustum
   * from the camera array.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sprite is visible in any camera.
   */
  intersectsSprite(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const i = t.cameras[n];
      if (uc.multiplyMatrices(
        i.projectionMatrix,
        i.matrixWorldInverse
      ), cc.setFromProjectionMatrix(
        uc,
        this.coordinateSystem
      ), cc.intersectsSprite(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting any frustum
   * from the camera array.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the sphere is visible in any camera.
   */
  intersectsSphere(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const i = t.cameras[n];
      if (uc.multiplyMatrices(
        i.projectionMatrix,
        i.matrixWorldInverse
      ), cc.setFromProjectionMatrix(
        uc,
        this.coordinateSystem
      ), cc.intersectsSphere(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given bounding box is intersecting any frustum
   * from the camera array.
   *
   * @param {Box3} box - The bounding box to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the box is visible in any camera.
   */
  intersectsBox(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const i = t.cameras[n];
      if (uc.multiplyMatrices(
        i.projectionMatrix,
        i.matrixWorldInverse
      ), cc.setFromProjectionMatrix(
        uc,
        this.coordinateSystem
      ), cc.intersectsBox(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns `true` if the given point lies within any frustum
   * from the camera array.
   *
   * @param {Vector3} point - The point to test.
   * @param {Object} cameraArray - An object with a cameras property containing an array of cameras.
   * @return {boolean} Whether the point is visible in any camera.
   */
  containsPoint(e, t) {
    if (!t || !t.cameras || t.cameras.length === 0)
      return !1;
    for (let n = 0; n < t.cameras.length; n++) {
      const i = t.cameras[n];
      if (uc.multiplyMatrices(
        i.projectionMatrix,
        i.matrixWorldInverse
      ), cc.setFromProjectionMatrix(
        uc,
        this.coordinateSystem
      ), cc.containsPoint(e))
        return !0;
    }
    return !1;
  }
  /**
   * Returns a new frustum array with copied values from this instance.
   *
   * @return {FrustumArray} A clone of this instance.
   */
  clone() {
    return new wG();
  }
}
const Nme = /* @__PURE__ */ new B6(), YN = /* @__PURE__ */ new Pn(), sV = /* @__PURE__ */ new Bn(), oV = /* @__PURE__ */ new SG(), aV = /* @__PURE__ */ new wG(), XN = /* @__PURE__ */ new Pr(), Bp = /* @__PURE__ */ new Bn();
class BLe {
  /**
   * Renderer options.
   *
   * @typedef {Object} Renderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
   * to overwrite the default.
   * @property {?Function} [getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   */
  /**
  	 * Constructs a new renderer.
  	 *
  	 * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
  	 * @param {Renderer~Options} [parameters] - The configuration parameter.
  
  	 */
  constructor(e, t = {}) {
    this.isRenderer = !0;
    const {
      logarithmicDepthBuffer: n = !1,
      alpha: i = !0,
      depth: o = !0,
      stencil: l = !1,
      antialias: p = !1,
      samples: f = 0,
      getFallback: v = null,
      colorBufferType: _ = ol,
      multiview: E = !1
    } = t;
    this.domElement = e.getDomElement(), this.backend = e, this.samples = f || p === !0 ? 4 : 0, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.alpha = i, this.logarithmicDepthBuffer = n, this.outputColorSpace = _a, this.toneMapping = Rb, this.toneMappingExposure = 1, this.sortObjects = !0, this.depth = o, this.stencil = l, this.info = new URe(), this.overrideNodes = {
      modelViewMatrix: null,
      modelNormalViewMatrix: null
    }, this.library = new ave(), this.lighting = new TLe(), this._getFallback = v, this._pixelRatio = 1, this._width = this.domElement.width, this._height = this.domElement.height, this._viewport = new Bn(0, 0, this._width, this._height), this._scissor = new Bn(0, 0, this._width, this._height), this._scissorTest = !1, this._attributes = null, this._geometries = null, this._nodes = null, this._animation = null, this._bindings = null, this._objects = null, this._pipelines = null, this._bundles = null, this._renderLists = null, this._renderContexts = null, this._textures = null, this._background = null, this._quad = new hG(new Ni()), this._quad.material.name = "Renderer_output", this._currentRenderContext = null, this._opaqueSort = null, this._transparentSort = null, this._frameBufferTarget = null;
    const A = this.alpha === !0 ? 0 : 1;
    this._clearColor = new U6(0, 0, 0, A), this._clearDepth = 1, this._clearStencil = 0, this._renderTarget = null, this._activeCubeFace = 0, this._activeMipmapLevel = 0, this._outputRenderTarget = null, this._mrt = null, this._renderObjectFunction = null, this._currentRenderObjectFunction = null, this._currentRenderBundle = null, this._handleObjectFunction = this._renderObjectDirect, this._isDeviceLost = !1, this.onDeviceLost = this._onDeviceLost, this._colorBufferType = _, this._initialized = !1, this._initPromise = null, this._compilationPromises = null, this.transparent = !0, this.opaque = !0, this.shadowMap = {
      enabled: !1,
      type: qMe
    }, this.xr = new kLe(this, E), this.debug = {
      checkShaderErrors: !0,
      onShaderError: null,
      getShaderAsync: async (I, j, q) => {
        await this.compileAsync(I, j);
        const L = this._renderLists.get(I, j), V = this._renderContexts.get(I, j, this._renderTarget), re = I.overrideMaterial || q.material, R = this._objects.get(q, re, I, j, L.lightsNode, V, V.clippingContext), { fragmentShader: J, vertexShader: ge } = R.getNodeBuilderState();
        return { fragmentShader: J, vertexShader: ge };
      }
    };
  }
  /**
   * Initializes the renderer so it is ready for usage.
   *
   * @async
   * @return {Promise<this>} A Promise that resolves when the renderer has been initialized.
   */
  async init() {
    if (this._initialized)
      throw new Error("Renderer: Backend has already been initialized.");
    return this._initPromise !== null ? this._initPromise : (this._initPromise = new Promise(async (e, t) => {
      let n = this.backend;
      try {
        await n.init(this);
      } catch (i) {
        if (this._getFallback !== null)
          try {
            this.backend = n = this._getFallback(i), await n.init(this);
          } catch (o) {
            t(o);
            return;
          }
        else {
          t(i);
          return;
        }
      }
      this._nodes = new _Le(this, n), this._animation = new jMe(this._nodes, this.info), this._attributes = new FRe(n), this._background = new cBe(this, this._nodes), this._geometries = new jRe(this._attributes, this.info), this._textures = new uIe(this, n, this.info), this._pipelines = new qRe(n, this._nodes), this._bindings = new HRe(n, this._nodes, this._textures, this._attributes, this._pipelines, this.info), this._objects = new NRe(this, this._nodes, this._geometries, this._pipelines, this._bindings, this.info), this._renderLists = new KRe(this.lighting), this._bundles = new wLe(), this._renderContexts = new iIe(), this._animation.start(), this._initialized = !0, e(this);
    }), this._initPromise);
  }
  /**
   * The coordinate system of the renderer. The value of this property
   * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
   * `THREE.WebGPUCoordinateSystem`.
   *
   * @readonly
   * @type {number}
   */
  get coordinateSystem() {
    return this.backend.coordinateSystem;
  }
  /**
   * Compiles all materials in the given scene. This can be useful to avoid a
   * phenomenon which is called "shader compilation stutter", which occurs when
   * rendering an object with a new shader for the first time.
   *
   * If you want to add a 3D object to an existing scene, use the third optional
   * parameter for applying the target scene. Note that the (target) scene's lighting
   * and environment must be configured before calling this method.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {?Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {Promise<Array|undefined>} A Promise that resolves when the compile has been finished.
   */
  async compileAsync(e, t, n = null) {
    if (this._isDeviceLost === !0) return;
    this._initialized === !1 && await this.init();
    const i = this._nodes.nodeFrame, o = i.renderId, l = this._currentRenderContext, p = this._currentRenderObjectFunction, f = this._compilationPromises, v = e.isScene === !0 ? e : Nme;
    n === null && (n = e);
    const _ = this._renderTarget, E = this._renderContexts.get(n, t, _), A = this._activeMipmapLevel, I = [];
    this._currentRenderContext = E, this._currentRenderObjectFunction = this.renderObject, this._handleObjectFunction = this._createObjectPipeline, this._compilationPromises = I, i.renderId++, i.update(), E.depth = this.depth, E.stencil = this.stencil, E.clippingContext || (E.clippingContext = new qO()), E.clippingContext.updateGlobal(v, t), v.onBeforeRender(this, e, t, _);
    const j = this._renderLists.get(e, t);
    if (j.begin(), this._projectObject(e, t, 0, j, E.clippingContext), n !== e && n.traverseVisible(function(R) {
      R.isLight && R.layers.test(t.layers) && j.pushLight(R);
    }), j.finish(), _ !== null) {
      this._textures.updateRenderTarget(_, A);
      const R = this._textures.get(_);
      E.textures = R.textures, E.depthTexture = R.depthTexture;
    } else
      E.textures = null, E.depthTexture = null;
    this._background.update(v, j, E);
    const q = j.opaque, L = j.transparent, V = j.transparentDoublePass, re = j.lightsNode;
    this.opaque === !0 && q.length > 0 && this._renderObjects(q, t, v, re), this.transparent === !0 && L.length > 0 && this._renderTransparents(L, V, t, v, re), i.renderId = o, this._currentRenderContext = l, this._currentRenderObjectFunction = p, this._compilationPromises = f, this._handleObjectFunction = this._renderObjectDirect, await Promise.all(I);
  }
  /**
   * Renders the scene in an async fashion.
   *
   * @async
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera.
   * @return {Promise} A Promise that resolves when the render has been finished.
   */
  async renderAsync(e, t) {
    this._initialized === !1 && await this.init(), this._renderScene(e, t);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.backend.waitForGPU();
  }
  /**
   * Enables or disables high precision for model-view and normal-view matrices.
   * When enabled, will use CPU 64-bit precision for higher precision instead of GPU 32-bit for higher performance.
   *
   * NOTE: 64-bit precision is not compatible with `InstancedMesh` and `SkinnedMesh`.
   *
   * @param {boolean} value - Whether to enable or disable high precision.
   * @type {boolean}
   */
  set highPrecision(e) {
    e === !0 ? (this.overrideNodes.modelViewMatrix = Rfe, this.overrideNodes.modelNormalViewMatrix = Ife) : this.highPrecision && (this.overrideNodes.modelViewMatrix = null, this.overrideNodes.modelNormalViewMatrix = null);
  }
  /**
   * Returns whether high precision is enabled or not.
   *
   * @return {boolean} Whether high precision is enabled or not.
   * @type {boolean}
   */
  get highPrecision() {
    return this.overrideNodes.modelViewMatrix === Rfe && this.overrideNodes.modelNormalViewMatrix === Ife;
  }
  /**
   * Sets the given MRT configuration.
   *
   * @param {MRTNode} mrt - The MRT node to set.
   * @return {Renderer} A reference to this renderer.
   */
  setMRT(e) {
    return this._mrt = e, this;
  }
  /**
   * Returns the MRT configuration.
   *
   * @return {MRTNode} The MRT configuration.
   */
  getMRT() {
    return this._mrt;
  }
  /**
   * Returns the color buffer type.
   *
   * @return {number} The color buffer type.
   */
  getColorBufferType() {
    return this._colorBufferType;
  }
  /**
   * Default implementation of the device lost callback.
   *
   * @private
   * @param {Object} info - Information about the context lost.
   */
  _onDeviceLost(e) {
    let t = `THREE.WebGPURenderer: ${e.api} Device Lost:

Message: ${e.message}`;
    e.reason && (t += `
Reason: ${e.reason}`), console.error(t), this._isDeviceLost = !0;
  }
  /**
   * Renders the given render bundle.
   *
   * @private
   * @param {Object} bundle - Render bundle data.
   * @param {Scene} sceneRef - The scene the render bundle belongs to.
   * @param {LightsNode} lightsNode - The lights node.
   */
  _renderBundle(e, t, n) {
    const { bundleGroup: i, camera: o, renderList: l } = e, p = this._currentRenderContext, f = this._bundles.get(i, o), v = this.backend.get(f);
    v.renderContexts === void 0 && (v.renderContexts = /* @__PURE__ */ new Set());
    const _ = i.version !== v.version, E = v.renderContexts.has(p) === !1 || _;
    if (v.renderContexts.add(p), E) {
      this.backend.beginBundle(p), (v.renderObjects === void 0 || _) && (v.renderObjects = []), this._currentRenderBundle = f;
      const {
        transparentDoublePass: A,
        transparent: I,
        opaque: j
      } = l;
      this.opaque === !0 && j.length > 0 && this._renderObjects(j, o, t, n), this.transparent === !0 && I.length > 0 && this._renderTransparents(I, A, o, t, n), this._currentRenderBundle = null, this.backend.finishBundle(p, f), v.version = i.version;
    } else {
      const { renderObjects: A } = v;
      for (let I = 0, j = A.length; I < j; I++) {
        const q = A[I];
        this._nodes.needsRefresh(q) && (this._nodes.updateBefore(q), this._nodes.updateForRender(q), this._bindings.updateForRender(q), this._nodes.updateAfter(q));
      }
    }
    this.backend.addBundle(p, f);
  }
  /**
   * Renders the scene or 3D object with the given camera. This method can only be called
   * if the renderer has been initialized.
   *
   * The target of the method is the default framebuffer (meaning the canvas)
   * or alternatively a render target when specified via `setRenderTarget()`.
   *
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @return {?Promise} A Promise that resolve when the scene has been rendered.
   * Only returned when the renderer has not been initialized.
   */
  render(e, t) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead."), this.renderAsync(e, t);
    this._renderScene(e, t);
  }
  /**
   * Returns an internal render target which is used when computing the output tone mapping
   * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
   * pass and not inline to achieve more correct results.
   *
   * @private
   * @return {?RenderTarget} The render target. The method returns `null` if no output conversion should be applied.
   */
  _getFrameBufferTarget() {
    const { currentToneMapping: e, currentColorSpace: t } = this;
    if (e !== Rb === !1 && t !== Ib === !1) return null;
    const { width: o, height: l } = this.getDrawingBufferSize(YN), { depth: p, stencil: f } = this;
    let v = this._frameBufferTarget;
    v === null && (v = new Mg(o, l, {
      depthBuffer: p,
      stencilBuffer: f,
      type: this._colorBufferType,
      format: al,
      colorSpace: Ib,
      generateMipmaps: !1,
      minFilter: Ea,
      magFilter: Ea,
      samples: this.samples
    }), v.isPostProcessingRenderTarget = !0, this._frameBufferTarget = v);
    const _ = this.getOutputRenderTarget();
    return v.depthBuffer = p, v.stencilBuffer = f, _ !== null ? v.setSize(_.width, _.height, _.depth) : v.setSize(o, l, 1), v.viewport.copy(this._viewport), v.scissor.copy(this._scissor), v.viewport.multiplyScalar(this._pixelRatio), v.scissor.multiplyScalar(this._pixelRatio), v.scissorTest = this._scissorTest, v.multiview = _ !== null ? _.multiview : !1, v.resolveDepthBuffer = _ !== null ? _.resolveDepthBuffer : !0, v.autoAllocateDepthBuffer = _ !== null ? _.autoAllocateDepthBuffer : !1, v;
  }
  /**
   * Renders the scene or 3D object with the given camera.
   *
   * @private
   * @param {Object3D} scene - The scene or 3D object to render.
   * @param {Camera} camera - The camera to render the scene with.
   * @param {boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
   * @return {RenderContext} The current render context.
   */
  _renderScene(e, t, n = !0) {
    if (this._isDeviceLost === !0) return;
    const i = n ? this._getFrameBufferTarget() : null, o = this._nodes.nodeFrame, l = o.renderId, p = this._currentRenderContext, f = this._currentRenderObjectFunction, v = e.isScene === !0 ? e : Nme, _ = this._renderTarget || this._outputRenderTarget, E = this._activeCubeFace, A = this._activeMipmapLevel;
    let I;
    i !== null ? (I = i, this.setRenderTarget(I)) : I = _;
    const j = this._renderContexts.get(e, t, I);
    this._currentRenderContext = j, this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject, this.info.calls++, this.info.render.calls++, this.info.render.frameCalls++, o.renderId = this.info.calls;
    const q = this.coordinateSystem, L = this.xr;
    if (t.coordinateSystem !== q && L.isPresenting === !1 && (t.coordinateSystem = q, t.updateProjectionMatrix(), t.isArrayCamera))
      for (const St of t.cameras)
        St.coordinateSystem = q, St.updateProjectionMatrix();
    e.matrixWorldAutoUpdate === !0 && e.updateMatrixWorld(), t.parent === null && t.matrixWorldAutoUpdate === !0 && t.updateMatrixWorld(), L.enabled === !0 && L.isPresenting === !0 && (L.cameraAutoUpdate === !0 && L.updateCamera(t), t = L.getCamera());
    let V = this._viewport, re = this._scissor, R = this._pixelRatio;
    I !== null && (V = I.viewport, re = I.scissor, R = 1), this.getDrawingBufferSize(YN), sV.set(0, 0, YN.width, YN.height);
    const J = V.minDepth === void 0 ? 0 : V.minDepth, ge = V.maxDepth === void 0 ? 1 : V.maxDepth;
    j.viewportValue.copy(V).multiplyScalar(R).floor(), j.viewportValue.width >>= A, j.viewportValue.height >>= A, j.viewportValue.minDepth = J, j.viewportValue.maxDepth = ge, j.viewport = j.viewportValue.equals(sV) === !1, j.scissorValue.copy(re).multiplyScalar(R).floor(), j.scissor = this._scissorTest && j.scissorValue.equals(sV) === !1, j.scissorValue.width >>= A, j.scissorValue.height >>= A, j.clippingContext || (j.clippingContext = new qO()), j.clippingContext.updateGlobal(v, t), v.onBeforeRender(this, e, t, I);
    const _e = t.isArrayCamera ? aV : oV;
    t.isArrayCamera || (XN.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), _e.setFromProjectionMatrix(XN, q));
    const Y = this._renderLists.get(e, t);
    if (Y.begin(), this._projectObject(e, t, 0, Y, j.clippingContext), Y.finish(), this.sortObjects === !0 && Y.sort(this._opaqueSort, this._transparentSort), I !== null) {
      this._textures.updateRenderTarget(I, A);
      const St = this._textures.get(I);
      j.textures = St.textures, j.depthTexture = St.depthTexture, j.width = St.width, j.height = St.height, j.renderTarget = I, j.depth = I.depthBuffer, j.stencil = I.stencilBuffer;
    } else
      j.textures = null, j.depthTexture = null, j.width = this.domElement.width, j.height = this.domElement.height, j.depth = this.depth, j.stencil = this.stencil;
    j.width >>= A, j.height >>= A, j.activeCubeFace = E, j.activeMipmapLevel = A, j.occlusionQueryCount = Y.occlusionQueryCount, this._background.update(v, Y, j), j.camera = t, this.backend.beginRender(j);
    const {
      bundles: Fe,
      lightsNode: Me,
      transparentDoublePass: $,
      transparent: dt,
      opaque: wt
    } = Y;
    return Fe.length > 0 && this._renderBundles(Fe, v, Me), this.opaque === !0 && wt.length > 0 && this._renderObjects(wt, t, v, Me), this.transparent === !0 && dt.length > 0 && this._renderTransparents(dt, $, t, v, Me), this.backend.finishRender(j), o.renderId = l, this._currentRenderContext = p, this._currentRenderObjectFunction = f, i !== null && (this.setRenderTarget(_, E, A), this._renderOutput(I)), v.onAfterRender(this, e, t, I), j;
  }
  _setXRLayerSize(e, t) {
    this._width = e, this._height = t, this.setViewport(0, 0, e, t);
  }
  /**
   * The output pass performs tone mapping and color space conversion.
   *
   * @private
   * @param {RenderTarget} renderTarget - The current render target.
   */
  _renderOutput(e) {
    const t = this._quad;
    this._nodes.hasOutputChange(e.texture) && (t.material.fragmentNode = this._nodes.getOutputNode(e.texture), t.material.needsUpdate = !0);
    const n = this.autoClear, i = this.xr.enabled;
    this.autoClear = !1, this.xr.enabled = !1, this._renderScene(t, t.camera, !1), this.autoClear = n, this.xr.enabled = i;
  }
  /**
   * Returns the maximum available anisotropy for texture filtering.
   *
   * @return {number} The maximum available anisotropy.
   */
  getMaxAnisotropy() {
    return this.backend.getMaxAnisotropy();
  }
  /**
   * Returns the active cube face.
   *
   * @return {number} The active cube face.
   */
  getActiveCubeFace() {
    return this._activeCubeFace;
  }
  /**
   * Returns the active mipmap level.
   *
   * @return {number} The active mipmap level.
   */
  getActiveMipmapLevel() {
    return this._activeMipmapLevel;
  }
  /**
   * Applications are advised to always define the animation loop
   * with this method and not manually with `requestAnimationFrame()`
   * for best compatibility.
   *
   * @async
   * @param {?Function} callback - The application's animation loop.
   * @return {Promise} A Promise that resolves when the set has been executed.
   */
  async setAnimationLoop(e) {
    this._initialized === !1 && await this.init(), this._animation.setAnimationLoop(e);
  }
  /**
   * Can be used to transfer buffer data from a storage buffer attribute
   * from the GPU to the CPU in context of compute shaders.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.backend.getArrayBufferAsync(e);
  }
  /**
   * Returns the rendering context.
   *
   * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.backend.getContext();
  }
  /**
   * Returns the pixel ratio.
   *
   * @return {number} The pixel ratio.
   */
  getPixelRatio() {
    return this._pixelRatio;
  }
  /**
   * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize(e) {
    return e.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
  }
  /**
   * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
   *
   * @param {Vector2} target - The method writes the result in this target object.
   * @return {Vector2} The renderer's size in logical pixels.
   */
  getSize(e) {
    return e.set(this._width, this._height);
  }
  /**
   * Sets the given pixel ratio and resizes the canvas if necessary.
   *
   * @param {number} [value=1] - The pixel ratio.
   */
  setPixelRatio(e = 1) {
    this._pixelRatio !== e && (this._pixelRatio = e, this.setSize(this._width, this._height, !1));
  }
  /**
   * This method allows to define the drawing buffer size by specifying
   * width, height and pixel ratio all at once. The size of the drawing
   * buffer is computed with this formula:
   * ```js
   * size.x = width * pixelRatio;
   * size.y = height * pixelRatio;
   * ```
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {number} pixelRatio - The pixel ratio.
   */
  setDrawingBufferSize(e, t, n) {
    this.xr && this.xr.isPresenting || (this._width = e, this._height = t, this._pixelRatio = n, this.domElement.width = Math.floor(e * n), this.domElement.height = Math.floor(t * n), this.setViewport(0, 0, e, t), this._initialized && this.backend.updateSize());
  }
  /**
   * Sets the size of the renderer.
   *
   * @param {number} width - The width in logical pixels.
   * @param {number} height - The height in logical pixels.
   * @param {boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
   */
  setSize(e, t, n = !0) {
    this.xr && this.xr.isPresenting || (this._width = e, this._height = t, this.domElement.width = Math.floor(e * this._pixelRatio), this.domElement.height = Math.floor(t * this._pixelRatio), n === !0 && (this.domElement.style.width = e + "px", this.domElement.style.height = t + "px"), this.setViewport(0, 0, e, t), this._initialized && this.backend.updateSize());
  }
  /**
   * Defines a manual sort function for the opaque render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setOpaqueSort(e) {
    this._opaqueSort = e;
  }
  /**
   * Defines a manual sort function for the transparent render list.
   * Pass `null` to use the default sort.
   *
   * @param {Function} method - The sort function.
   */
  setTransparentSort(e) {
    this._transparentSort = e;
  }
  /**
   * Returns the scissor rectangle.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The scissor rectangle.
   */
  getScissor(e) {
    const t = this._scissor;
    return e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height, e;
  }
  /**
   * Defines the scissor rectangle.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
   * Instead of passing four arguments, the method also works with a single four-dimensional vector.
   * @param {number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
   * @param {number} width - The width of the scissor box in logical pixel unit.
   * @param {number} height - The height of the scissor box in logical pixel unit.
   */
  setScissor(e, t, n, i) {
    const o = this._scissor;
    e.isVector4 ? o.copy(e) : o.set(e, t, n, i);
  }
  /**
   * Returns the scissor test value.
   *
   * @return {boolean} Whether the scissor test should be enabled or not.
   */
  getScissorTest() {
    return this._scissorTest;
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    this._scissorTest = e, this.backend.setScissorTest(e);
  }
  /**
   * Returns the viewport definition.
   *
   * @param {Vector4} target - The method writes the result in this target object.
   * @return {Vector4} The viewport definition.
   */
  getViewport(e) {
    return e.copy(this._viewport);
  }
  /**
   * Defines the viewport.
   *
   * @param {number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
   * @param {number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
   * @param {number} width - The width of the viewport in logical pixel unit.
   * @param {number} height - The height of the viewport in logical pixel unit.
   * @param {number} minDepth - The minimum depth value of the viewport. WebGPU only.
   * @param {number} maxDepth - The maximum depth value of the viewport. WebGPU only.
   */
  setViewport(e, t, n, i, o = 0, l = 1) {
    const p = this._viewport;
    e.isVector4 ? p.copy(e) : p.set(e, t, n, i), p.minDepth = o, p.maxDepth = l;
  }
  /**
   * Returns the clear color.
   *
   * @param {Color} target - The method writes the result in this target object.
   * @return {Color} The clear color.
   */
  getClearColor(e) {
    return e.copy(this._clearColor);
  }
  /**
   * Defines the clear color and optionally the clear alpha.
   *
   * @param {Color} color - The clear color.
   * @param {number} [alpha=1] - The clear alpha.
   */
  setClearColor(e, t = 1) {
    this._clearColor.set(e), this._clearColor.a = t;
  }
  /**
   * Returns the clear alpha.
   *
   * @return {number} The clear alpha.
   */
  getClearAlpha() {
    return this._clearColor.a;
  }
  /**
   * Defines the clear alpha.
   *
   * @param {number} alpha - The clear alpha.
   */
  setClearAlpha(e) {
    this._clearColor.a = e;
  }
  /**
   * Returns the clear depth.
   *
   * @return {number} The clear depth.
   */
  getClearDepth() {
    return this._clearDepth;
  }
  /**
   * Defines the clear depth.
   *
   * @param {number} depth - The clear depth.
   */
  setClearDepth(e) {
    this._clearDepth = e;
  }
  /**
   * Returns the clear stencil.
   *
   * @return {number} The clear stencil.
   */
  getClearStencil() {
    return this._clearStencil;
  }
  /**
   * Defines the clear stencil.
   *
   * @param {number} stencil - The clear stencil.
   */
  setClearStencil(e) {
    this._clearStencil = e;
  }
  /**
   * This method performs an occlusion query for the given 3D object.
   * It returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e) {
    const t = this._currentRenderContext;
    return t && this.backend.isOccluded(t, e);
  }
  /**
   * Performs a manual clear operation. This method ignores `autoClear` properties.
   *
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clear(e = !0, t = !0, n = !0) {
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead."), this.clearAsync(e, t, n);
    const i = this._renderTarget || this._getFrameBufferTarget();
    let o = null;
    if (i !== null) {
      this._textures.updateRenderTarget(i);
      const l = this._textures.get(i);
      o = this._renderContexts.getForClear(i), o.textures = l.textures, o.depthTexture = l.depthTexture, o.width = l.width, o.height = l.height, o.renderTarget = i, o.depth = i.depthBuffer, o.stencil = i.stencilBuffer, o.clearColorValue = this.backend.getClearColor(), o.activeCubeFace = this.getActiveCubeFace(), o.activeMipmapLevel = this.getActiveMipmapLevel();
    }
    this.backend.clear(e, t, n, o), i !== null && this._renderTarget === null && this._renderOutput(i);
  }
  /**
   * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearColor() {
    return this.clear(!0, !1, !1);
  }
  /**
   * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearDepth() {
    return this.clear(!1, !0, !1);
  }
  /**
   * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
   *
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   * Only returned when the renderer has not been initialized.
   */
  clearStencil() {
    return this.clear(!1, !1, !0);
  }
  /**
   * Async version of {@link Renderer#clear}.
   *
   * @async
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearAsync(e = !0, t = !0, n = !0) {
    this._initialized === !1 && await this.init(), this.clear(e, t, n);
  }
  /**
   * Async version of {@link Renderer#clearColor}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearColorAsync() {
    this.clearAsync(!0, !1, !1);
  }
  /**
   * Async version of {@link Renderer#clearDepth}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearDepthAsync() {
    this.clearAsync(!1, !0, !1);
  }
  /**
   * Async version of {@link Renderer#clearStencil}.
   *
   * @async
   * @return {Promise} A Promise that resolves when the clear operation has been executed.
   */
  async clearStencilAsync() {
    this.clearAsync(!1, !1, !0);
  }
  /**
   * The current output tone mapping of the renderer. When a render target is set,
   * the output tone mapping is always `NoToneMapping`.
   *
   * @type {number}
   */
  get currentToneMapping() {
    return this.isOutputTarget ? this.toneMapping : Rb;
  }
  /**
   * The current output color space of the renderer. When a render target is set,
   * the output color space is always `LinearSRGBColorSpace`.
   *
   * @type {string}
   */
  get currentColorSpace() {
    return this.isOutputTarget ? this.outputColorSpace : Ib;
  }
  /**
   * Returns `true` if the rendering settings are set to screen output.
   *
   * @returns {boolean} True if the current render target is the same of output render target or `null`, otherwise false.
   */
  get isOutputTarget() {
    return this._renderTarget === this._outputRenderTarget || this._renderTarget === null;
  }
  /**
   * Frees all internal resources of the renderer. Call this method if the renderer
   * is no longer in use by your app.
   */
  dispose() {
    this.info.dispose(), this.backend.dispose(), this._animation.dispose(), this._objects.dispose(), this._pipelines.dispose(), this._nodes.dispose(), this._bindings.dispose(), this._renderLists.dispose(), this._renderContexts.dispose(), this._textures.dispose(), this._frameBufferTarget !== null && this._frameBufferTarget.dispose(), Object.values(this.backend.timestampQueryPool).forEach((e) => {
      e !== null && e.dispose();
    }), this.setRenderTarget(null), this.setAnimationLoop(null);
  }
  /**
   * Sets the given render target. Calling this method means the renderer does not
   * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
   * Use `null` as the first argument to reset the state.
   *
   * @param {?RenderTarget} renderTarget - The render target to set.
   * @param {number} [activeCubeFace=0] - The active cube face.
   * @param {number} [activeMipmapLevel=0] - The active mipmap level.
   */
  setRenderTarget(e, t = 0, n = 0) {
    this._renderTarget = e, this._activeCubeFace = t, this._activeMipmapLevel = n;
  }
  /**
   * Returns the current render target.
   *
   * @return {?RenderTarget} The render target. Returns `null` if no render target is set.
   */
  getRenderTarget() {
    return this._renderTarget;
  }
  /**
   * Sets the output render target for the renderer.
   *
   * @param {Object} renderTarget - The render target to set as the output target.
   */
  setOutputRenderTarget(e) {
    this._outputRenderTarget = e;
  }
  /**
   * Returns the current output target.
   *
   * @return {?RenderTarget} The current output render target. Returns `null` if no output target is set.
   */
  getOutputRenderTarget() {
    return this._outputRenderTarget;
  }
  /**
   * Resets the renderer to the initial state before WebXR started.
   *
   */
  _resetXRState() {
    this.backend.setXRTarget(null), this.setOutputRenderTarget(null), this.setRenderTarget(null), this._frameBufferTarget.dispose(), this._frameBufferTarget = null;
  }
  /**
   * Callback for {@link Renderer#setRenderObjectFunction}.
   *
   * @callback renderObjectFunction
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  /**
   * Sets the given render object function. Calling this method overwrites the default implementation
   * which is {@link Renderer#renderObject}. Defining a custom function can be useful
   * if you want to modify the way objects are rendered. For example you can define things like "every
   * object that has material of a certain type should perform a pre-pass with a special overwrite material".
   * The custom function must always call `renderObject()` in its implementation.
   *
   * Use `null` as the first argument to reset the state.
   *
   * @param {?renderObjectFunction} renderObjectFunction - The render object function.
   */
  setRenderObjectFunction(e) {
    this._renderObjectFunction = e;
  }
  /**
   * Returns the current render object function.
   *
   * @return {?Function} The current render object function. Returns `null` if no function is set.
   */
  getRenderObjectFunction() {
    return this._renderObjectFunction;
  }
  /**
   * Execute a single or an array of compute nodes. This method can only be called
   * if the renderer has been initialized.
   *
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @return {Promise|undefined} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
   */
  compute(e) {
    if (this._isDeviceLost === !0) return;
    if (this._initialized === !1)
      return console.warn("THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."), this.computeAsync(e);
    const t = this._nodes.nodeFrame, n = t.renderId;
    this.info.calls++, this.info.compute.calls++, this.info.compute.frameCalls++, t.renderId = this.info.calls;
    const i = this.backend, o = this._pipelines, l = this._bindings, p = this._nodes, f = Array.isArray(e) ? e : [e];
    if (f[0] === void 0 || f[0].isComputeNode !== !0)
      throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");
    i.beginCompute(e);
    for (const v of f) {
      if (o.has(v) === !1) {
        const A = () => {
          v.removeEventListener("dispose", A), o.delete(v), l.delete(v), p.delete(v);
        };
        v.addEventListener("dispose", A);
        const I = v.onInitFunction;
        I !== null && I.call(v, { renderer: this });
      }
      p.updateForCompute(v), l.updateForCompute(v);
      const _ = l.getForCompute(v), E = o.getForCompute(v, _);
      i.compute(e, v, _, E);
    }
    i.finishCompute(e), t.renderId = n;
  }
  /**
   * Execute a single or an array of compute nodes.
   *
   * @async
   * @param {Node|Array<Node>} computeNodes - The compute node(s).
   * @return {Promise} A Promise that resolve when the compute has finished.
   */
  async computeAsync(e) {
    this._initialized === !1 && await this.init(), this.compute(e);
  }
  /**
   * Checks if the given feature is supported by the selected backend.
   *
   * @async
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync(e) {
    return this._initialized === !1 && await this.init(), this.backend.hasFeature(e);
  }
  async resolveTimestampsAsync(e = "render") {
    return this._initialized === !1 && await this.init(), this.backend.resolveTimestampsAsync(e);
  }
  /**
   * Checks if the given feature is supported by the selected backend. If the
   * renderer has not been initialized, this method always returns `false`.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    return this._initialized === !1 ? (console.warn("THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead."), !1) : this.backend.hasFeature(e);
  }
  /**
   * Returns `true` when the renderer has been initialized.
   *
   * @return {boolean} Whether the renderer has been initialized or not.
   */
  hasInitialized() {
    return this._initialized;
  }
  /**
   * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * @async
   * @param {Texture} texture - The texture.
   * @return {Promise} A Promise that resolves when the texture has been initialized.
   */
  async initTextureAsync(e) {
    this._initialized === !1 && await this.init(), this._textures.updateTexture(e);
  }
  /**
   * Initializes the given texture. Useful for preloading a texture rather than waiting until first render
   * (which can cause noticeable lags due to decode and GPU upload overhead).
   *
   * This method can only be used if the renderer has been initialized.
   *
   * @param {Texture} texture - The texture.
   */
  initTexture(e) {
    this._initialized === !1 && console.warn("THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead."), this._textures.updateTexture(e);
  }
  /**
   * Copies the current bound framebuffer into the given texture.
   *
   * @param {FramebufferTexture} framebufferTexture - The texture.
   * @param {?Vector2|Vector4} [rectangle=null] - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
   */
  copyFramebufferToTexture(e, t = null) {
    if (t !== null)
      if (t.isVector2)
        t = Bp.set(t.x, t.y, e.image.width, e.image.height).floor();
      else if (t.isVector4)
        t = Bp.copy(t).floor();
      else {
        console.error("THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.");
        return;
      }
    else
      t = Bp.set(0, 0, e.image.width, e.image.height);
    let n = this._currentRenderContext, i;
    n !== null ? i = n.renderTarget : (i = this._renderTarget || this._getFrameBufferTarget(), i !== null && (this._textures.updateRenderTarget(i), n = this._textures.get(i))), this._textures.updateTexture(e, { renderTarget: i }), this.backend.copyFramebufferToTexture(e, n, t);
  }
  /**
   * Copies data of the given source texture into a destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
   * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, i = null, o = 0, l = 0) {
    this._textures.updateTexture(e), this._textures.updateTexture(t), this.backend.copyTextureToTexture(e, t, n, i, o, l);
  }
  /**
   * Reads pixel data from the given render target.
   *
   * @async
   * @param {RenderTarget} renderTarget - The render target to read from.
   * @param {number} x - The `x` coordinate of the copy region's origin.
   * @param {number} y - The `y` coordinate of the copy region's origin.
   * @param {number} width - The width of the copy region.
   * @param {number} height - The height of the copy region.
   * @param {number} [textureIndex=0] - The texture index of a MRT render target.
   * @param {number} [faceIndex=0] - The active cube face index.
   * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
   */
  async readRenderTargetPixelsAsync(e, t, n, i, o, l = 0, p = 0) {
    return this.backend.copyTextureToBuffer(e.textures[l], t, n, i, o, p);
  }
  /**
   * Analyzes the given 3D object's hierarchy and builds render lists from the
   * processed hierarchy.
   *
   * @param {Object3D} object - The 3D object to process (usually a scene).
   * @param {Camera} camera - The camera the object is rendered with.
   * @param {number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
   * @param {RenderList} renderList - The current render list.
   * @param {ClippingContext} clippingContext - The current clipping context.
   */
  _projectObject(e, t, n, i, o) {
    if (e.visible === !1) return;
    if (e.layers.test(t.layers)) {
      if (e.isGroup)
        n = e.renderOrder, e.isClippingGroup && e.enabled && (o = o.getGroupContext(e));
      else if (e.isLOD)
        e.autoUpdate === !0 && e.update(t);
      else if (e.isLight)
        i.pushLight(e);
      else if (e.isSprite) {
        const f = t.isArrayCamera ? aV : oV;
        if (!e.frustumCulled || f.intersectsSprite(e, t)) {
          this.sortObjects === !0 && Bp.setFromMatrixPosition(e.matrixWorld).applyMatrix4(XN);
          const { geometry: v, material: _ } = e;
          _.visible && i.push(e, v, _, n, Bp.z, null, o);
        }
      } else if (e.isLineLoop)
        console.error("THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");
      else if (e.isMesh || e.isLine || e.isPoints) {
        const f = t.isArrayCamera ? aV : oV;
        if (!e.frustumCulled || f.intersectsObject(e, t)) {
          const { geometry: v, material: _ } = e;
          if (this.sortObjects === !0 && (v.boundingSphere === null && v.computeBoundingSphere(), Bp.copy(v.boundingSphere.center).applyMatrix4(e.matrixWorld).applyMatrix4(XN)), Array.isArray(_)) {
            const E = v.groups;
            for (let A = 0, I = E.length; A < I; A++) {
              const j = E[A], q = _[j.materialIndex];
              q && q.visible && i.push(e, v, q, n, Bp.z, j, o);
            }
          } else _.visible && i.push(e, v, _, n, Bp.z, null, o);
        }
      }
    }
    if (e.isBundleGroup === !0 && this.backend.beginBundle !== void 0) {
      const f = i;
      i = this._renderLists.get(e, t), i.begin(), f.pushBundle({
        bundleGroup: e,
        camera: t,
        renderList: i
      }), i.finish();
    }
    const p = e.children;
    for (let f = 0, v = p.length; f < v; f++)
      this._projectObject(p[f], t, n, i, o);
  }
  /**
   * Renders the given render bundles.
   *
   * @private
   * @param {Array<Object>} bundles - Array with render bundle data.
   * @param {Scene} sceneRef - The scene the render bundles belong to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderBundles(e, t, n) {
    for (const i of e)
      this._renderBundle(i, t, n);
  }
  /**
   * Renders the transparent objects from the given render lists.
   *
   * @private
   * @param {Array<Object>} renderList - The transparent render list.
   * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   */
  _renderTransparents(e, t, n, i, o) {
    if (t.length > 0) {
      for (const { material: l } of t)
        l.side = Ko;
      this._renderObjects(t, n, i, o, "backSide");
      for (const { material: l } of t)
        l.side = Ld;
      this._renderObjects(e, n, i, o);
      for (const { material: l } of t)
        l.side = Mb;
    } else
      this._renderObjects(e, n, i, o);
  }
  /**
   * Renders the objects from the given render list.
   *
   * @private
   * @param {Array<Object>} renderList - The render list.
   * @param {Camera} camera - The camera the render list should be rendered with.
   * @param {Scene} scene - The scene the render list belongs to.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjects(e, t, n, i, o = null) {
    for (let l = 0, p = e.length; l < p; l++) {
      const { object: f, geometry: v, material: _, group: E, clippingContext: A } = e[l];
      this._currentRenderObjectFunction(f, n, t, v, _, E, i, A, o);
    }
  }
  /**
   * This method represents the default render object function that manages the render lifecycle
   * of the object.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {BufferGeometry} geometry - The object's geometry.
   * @param {Material} material - The object's material.
   * @param {?Object} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  renderObject(e, t, n, i, o, l, p, f = null, v = null) {
    let _, E, A;
    if (e.onBeforeRender(this, t, n, i, o, l), o.allowOverride === !0 && t.overrideMaterial !== null) {
      const I = t.overrideMaterial;
      o.positionNode && o.positionNode.isNode && (_ = I.positionNode, I.positionNode = o.positionNode), I.alphaTest = o.alphaTest, I.alphaMap = o.alphaMap, I.transparent = o.transparent || o.transmission > 0, I.isShadowPassMaterial && (I.side = o.shadowSide === null ? o.side : o.shadowSide, o.depthNode && o.depthNode.isNode && (A = I.depthNode, I.depthNode = o.depthNode), o.castShadowNode && o.castShadowNode.isNode && (E = I.colorNode, I.colorNode = o.castShadowNode), o.castShadowPositionNode && o.castShadowPositionNode.isNode && (_ = I.positionNode, I.positionNode = o.castShadowPositionNode)), o = I;
    }
    o.transparent === !0 && o.side === Mb && o.forceSinglePass === !1 ? (o.side = Ko, this._handleObjectFunction(e, o, t, n, p, l, f, "backSide"), o.side = Ld, this._handleObjectFunction(e, o, t, n, p, l, f, v), o.side = Mb) : this._handleObjectFunction(e, o, t, n, p, l, f, v), _ !== void 0 && (t.overrideMaterial.positionNode = _), A !== void 0 && (t.overrideMaterial.depthNode = A), E !== void 0 && (t.overrideMaterial.colorNode = E), e.onAfterRender(this, t, n, i, o, l);
  }
  /**
   * This method represents the default `_handleObjectFunction` implementation which creates
   * a render object from the given data and performs the draw command with the selected backend.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _renderObjectDirect(e, t, n, i, o, l, p, f) {
    const v = this._objects.get(e, t, n, i, o, this._currentRenderContext, p, f);
    v.drawRange = e.geometry.drawRange, v.group = l;
    const _ = this._nodes.needsRefresh(v);
    _ && (this._nodes.updateBefore(v), this._geometries.updateForRender(v), this._nodes.updateForRender(v), this._bindings.updateForRender(v)), this._pipelines.updateForRender(v), this._currentRenderBundle !== null && (this.backend.get(this._currentRenderBundle).renderObjects.push(v), v.bundle = this._currentRenderBundle.bundleGroup), this.backend.draw(v, this.info), _ && this._nodes.updateAfter(v);
  }
  /**
   * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
   * Used in `compileAsync()`.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The object's material.
   * @param {Scene} scene - The scene the 3D object belongs to.
   * @param {Camera} camera - The camera the object should be rendered with.
   * @param {LightsNode} lightsNode - The current lights node.
   * @param {?{start: number, count: number}} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
   * @param {ClippingContext} clippingContext - The clipping context.
   * @param {?string} [passId=null] - An optional ID for identifying the pass.
   */
  _createObjectPipeline(e, t, n, i, o, l, p, f) {
    const v = this._objects.get(e, t, n, i, o, this._currentRenderContext, p, f);
    v.drawRange = e.geometry.drawRange, v.group = l, this._nodes.updateBefore(v), this._geometries.updateForRender(v), this._nodes.updateForRender(v), this._bindings.updateForRender(v), this._pipelines.getForRender(v, this._compilationPromises), this._nodes.updateAfter(v);
  }
  /**
   * Alias for `compileAsync()`.
   *
   * @method
   * @param {Object3D} scene - The scene or 3D object to precompile.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
   * @return {function(Object3D, Camera, ?Scene): Promise|undefined} A Promise that resolves when the compile has been finished.
   */
  get compile() {
    return this.compileAsync;
  }
}
class EG {
  /**
   * Constructs a new binding.
   *
   * @param {string} [name=''] - The binding's name.
   */
  constructor(e = "") {
    this.name = e, this.visibility = 0;
  }
  /**
   * Makes sure binding's resource is visible for the given shader stage.
   *
   * @param {number} visibility - The shader stage.
   */
  setVisibility(e) {
    this.visibility |= e;
  }
  /**
   * Clones the binding.
   *
   * @return {Binding} The cloned binding.
   */
  clone() {
    return Object.assign(new this.constructor(), this);
  }
}
function LLe(c) {
  return c + (Hp - c % Hp) % Hp;
}
class lve extends EG {
  /**
   * Constructs a new buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(e, t = null) {
    super(e), this.isBuffer = !0, this.bytesPerElement = Float32Array.BYTES_PER_ELEMENT, this._buffer = t;
  }
  /**
   * The buffer's byte length.
   *
   * @type {number}
   * @readonly
   */
  get byteLength() {
    return LLe(this._buffer.byteLength);
  }
  /**
   * A reference to the internal buffer.
   *
   * @type {Float32Array}
   * @readonly
   */
  get buffer() {
    return this._buffer;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the buffer has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    return !0;
  }
}
class uve extends lve {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {TypedArray} [buffer=null] - The buffer.
   */
  constructor(e, t = null) {
    super(e, t), this.isUniformBuffer = !0;
  }
}
let jLe = 0;
class cve extends uve {
  /**
   * Constructs a new node-based uniform buffer.
   *
   * @param {BufferNode} nodeUniform - The uniform buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super("UniformBuffer_" + jLe++, e ? e.value : null), this.nodeUniform = e, this.groupNode = t;
  }
  /**
   * The uniform buffer.
   *
   * @type {Float32Array}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class ULe extends uve {
  /**
   * Constructs a new uniforms group.
   *
   * @param {string} name - The group's name.
   */
  constructor(e) {
    super(e), this.isUniformsGroup = !0, this._values = null, this.uniforms = [];
  }
  /**
   * Adds a uniform to this group.
   *
   * @param {Uniform} uniform - The uniform to add.
   * @return {UniformsGroup} A reference to this group.
   */
  addUniform(e) {
    return this.uniforms.push(e), this;
  }
  /**
   * Removes a uniform from this group.
   *
   * @param {Uniform} uniform - The uniform to remove.
   * @return {UniformsGroup} A reference to this group.
   */
  removeUniform(e) {
    const t = this.uniforms.indexOf(e);
    return t !== -1 && this.uniforms.splice(t, 1), this;
  }
  /**
   * An array with the raw uniform values.
   *
   * @type {Array<number>}
   */
  get values() {
    return this._values === null && (this._values = Array.from(this.buffer)), this._values;
  }
  /**
   * A Float32 array buffer with the uniform values.
   *
   * @type {Float32Array}
   */
  get buffer() {
    let e = this._buffer;
    if (e === null) {
      const t = this.byteLength;
      e = new Float32Array(new ArrayBuffer(t)), this._buffer = e;
    }
    return e;
  }
  /**
   * The byte length of the buffer with correct buffer alignment.
   *
   * @type {number}
   */
  get byteLength() {
    const e = this.bytesPerElement;
    let t = 0;
    for (let n = 0, i = this.uniforms.length; n < i; n++) {
      const o = this.uniforms[n], l = o.boundary, p = o.itemSize * e, f = t % Hp, v = f % l, _ = f + v;
      t += v, _ !== 0 && Hp - _ < p && (t += Hp - _), o.offset = t / e, t += p;
    }
    return Math.ceil(t / Hp) * Hp;
  }
  /**
   * Updates this group by updating each uniform object of
   * the internal uniform list. The uniform objects check if their
   * values has actually changed so this method only returns
   * `true` if there is a real value change.
   *
   * @return {boolean} Whether the uniforms have been updated and
   * must be uploaded to the GPU.
   */
  update() {
    let e = !1;
    for (const t of this.uniforms)
      this.updateByType(t) === !0 && (e = !0);
    return e;
  }
  /**
   * Updates a given uniform by calling an update method matching
   * the uniforms type.
   *
   * @param {Uniform} uniform - The uniform to update.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateByType(e) {
    if (e.isNumberUniform) return this.updateNumber(e);
    if (e.isVector2Uniform) return this.updateVector2(e);
    if (e.isVector3Uniform) return this.updateVector3(e);
    if (e.isVector4Uniform) return this.updateVector4(e);
    if (e.isColorUniform) return this.updateColor(e);
    if (e.isMatrix3Uniform) return this.updateMatrix3(e);
    if (e.isMatrix4Uniform) return this.updateMatrix4(e);
    console.error("THREE.WebGPUUniformsGroup: Unsupported uniform type.", e);
  }
  /**
   * Updates a given Number uniform.
   *
   * @param {NumberUniform} uniform - The Number uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateNumber(e) {
    let t = !1;
    const n = this.values, i = e.getValue(), o = e.offset, l = e.getType();
    if (n[o] !== i) {
      const p = this._getBufferForType(l);
      p[o] = n[o] = i, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector2 uniform.
   *
   * @param {Vector2Uniform} uniform - The Vector2 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector2(e) {
    let t = !1;
    const n = this.values, i = e.getValue(), o = e.offset, l = e.getType();
    if (n[o + 0] !== i.x || n[o + 1] !== i.y) {
      const p = this._getBufferForType(l);
      p[o + 0] = n[o + 0] = i.x, p[o + 1] = n[o + 1] = i.y, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector3 uniform.
   *
   * @param {Vector3Uniform} uniform - The Vector3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector3(e) {
    let t = !1;
    const n = this.values, i = e.getValue(), o = e.offset, l = e.getType();
    if (n[o + 0] !== i.x || n[o + 1] !== i.y || n[o + 2] !== i.z) {
      const p = this._getBufferForType(l);
      p[o + 0] = n[o + 0] = i.x, p[o + 1] = n[o + 1] = i.y, p[o + 2] = n[o + 2] = i.z, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Vector4 uniform.
   *
   * @param {Vector4Uniform} uniform - The Vector4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateVector4(e) {
    let t = !1;
    const n = this.values, i = e.getValue(), o = e.offset, l = e.getType();
    if (n[o + 0] !== i.x || n[o + 1] !== i.y || n[o + 2] !== i.z || n[o + 4] !== i.w) {
      const p = this._getBufferForType(l);
      p[o + 0] = n[o + 0] = i.x, p[o + 1] = n[o + 1] = i.y, p[o + 2] = n[o + 2] = i.z, p[o + 3] = n[o + 3] = i.w, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Color uniform.
   *
   * @param {ColorUniform} uniform - The Color uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateColor(e) {
    let t = !1;
    const n = this.values, i = e.getValue(), o = e.offset;
    if (n[o + 0] !== i.r || n[o + 1] !== i.g || n[o + 2] !== i.b) {
      const l = this.buffer;
      l[o + 0] = n[o + 0] = i.r, l[o + 1] = n[o + 1] = i.g, l[o + 2] = n[o + 2] = i.b, t = !0;
    }
    return t;
  }
  /**
   * Updates a given Matrix3 uniform.
   *
   * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix3(e) {
    let t = !1;
    const n = this.values, i = e.getValue().elements, o = e.offset;
    if (n[o + 0] !== i[0] || n[o + 1] !== i[1] || n[o + 2] !== i[2] || n[o + 4] !== i[3] || n[o + 5] !== i[4] || n[o + 6] !== i[5] || n[o + 8] !== i[6] || n[o + 9] !== i[7] || n[o + 10] !== i[8]) {
      const l = this.buffer;
      l[o + 0] = n[o + 0] = i[0], l[o + 1] = n[o + 1] = i[1], l[o + 2] = n[o + 2] = i[2], l[o + 4] = n[o + 4] = i[3], l[o + 5] = n[o + 5] = i[4], l[o + 6] = n[o + 6] = i[5], l[o + 8] = n[o + 8] = i[6], l[o + 9] = n[o + 9] = i[7], l[o + 10] = n[o + 10] = i[8], t = !0;
    }
    return t;
  }
  /**
   * Updates a given Matrix4 uniform.
   *
   * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
   * @return {boolean} Whether the uniform has been updated or not.
   */
  updateMatrix4(e) {
    let t = !1;
    const n = this.values, i = e.getValue().elements, o = e.offset;
    return VLe(n, i, o) === !1 && (this.buffer.set(i, o), zLe(n, i, o), t = !0), t;
  }
  /**
   * Returns a typed array that matches the given data type.
   *
   * @param {string} type - The data type.
   * @return {TypedArray} The typed array.
   */
  _getBufferForType(e) {
    return e === "int" || e === "ivec2" || e === "ivec3" || e === "ivec4" ? new Int32Array(this.buffer.buffer) : e === "uint" || e === "uvec2" || e === "uvec3" || e === "uvec4" ? new Uint32Array(this.buffer.buffer) : this.buffer;
  }
}
function zLe(c, e, t) {
  for (let n = 0, i = e.length; n < i; n++)
    c[t + n] = e[n];
}
function VLe(c, e, t) {
  for (let n = 0, i = e.length; n < i; n++)
    if (c[t + n] !== e[n]) return !1;
  return !0;
}
let GLe = 0;
class dve extends ULe {
  /**
   * Constructs a new node-based uniforms group.
   *
   * @param {string} name - The group's name.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super(e), this.id = GLe++, this.groupNode = t, this.isNodeUniformsGroup = !0;
  }
}
let qLe = 0;
class HLe extends EG {
  /**
   * Constructs a new sampled texture.
   *
   * @param {string} name - The sampled texture's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(e, t) {
    super(e), this.id = qLe++, this.texture = t, this.version = t ? t.version : 0, this.store = !1, this.generation = null, this.isSampledTexture = !0;
  }
  /**
   * Returns `true` whether this binding requires an update for the
   * given generation.
   *
   * @param {number} generation - The generation.
   * @return {boolean} Whether an update is required or not.
   */
  needsBindingsUpdate(e) {
    const { texture: t } = this;
    return e !== this.generation ? (this.generation = e, !0) : t.isVideoTexture;
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { texture: e, version: t } = this;
    return t !== e.version ? (this.version = e.version, !0) : !1;
  }
}
class m2 extends HLe {
  /**
   * Constructs a new node-based sampled texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, i = null) {
    super(e, t ? t.value : null), this.textureNode = t, this.groupNode = n, this.access = i;
  }
  /**
   * Overwrites the default to additionally check if the node value has changed.
   *
   * @param {number} generation - The generation.
   * @return {boolean} Whether an update is required or not.
   */
  needsBindingsUpdate(e) {
    return this.textureNode.value !== this.texture || super.needsBindingsUpdate(e);
  }
  /**
   * Updates the binding.
   *
   * @return {boolean} Whether the texture has been updated and must be
   * uploaded to the GPU.
   */
  update() {
    const { textureNode: e } = this;
    return this.texture !== e.value ? (this.texture = e.value, !0) : super.update();
  }
}
class hve extends m2 {
  /**
   * Constructs a new node-based sampled cube texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, i = null) {
    super(e, t, n, i), this.isSampledCubeTexture = !0;
  }
}
class pve extends m2 {
  /**
   * Constructs a new node-based sampled 3D texture.
   *
   * @param {string} name - The textures's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   * @param {?string} [access=null] - The access type.
   */
  constructor(e, t, n, i = null) {
    super(e, t, n, i), this.isSampledTexture3D = !0;
  }
}
class $Le extends Js {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(e = null, t = 1, n = 1, i, o, l, p, f, v = $i, _ = $i, E, A) {
    super(null, l, p, f, v, _, i, o, E, A), this.isDataTexture = !0, this.image = { data: e, width: t, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1;
  }
}
const WLe = {
  textureDimensions: "textureSize",
  equals: "equal"
}, KLe = {
  low: "lowp",
  medium: "mediump",
  high: "highp"
}, Ome = {
  swizzleAssign: !0,
  storageBuffer: !1
}, Dme = {
  perspective: "smooth",
  linear: "noperspective"
}, Fme = {
  centroid: "centroid",
  "flat first": "flat",
  "flat either": "flat"
}, Bme = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
precision lowp sampler2DArrayShadow;
precision lowp samplerCubeShadow;
`;
class YLe extends tve {
  /**
   * Constructs a new GLSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e, t) {
    super(e, t, new rLe()), this.uniformGroups = {}, this.transforms = [], this.extensions = {}, this.builtins = { vertex: [], fragment: [], compute: [] };
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== $d;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved GLSL method name.
   */
  getMethod(e) {
    return WLe[e] || e;
  }
  /**
   * Returns the output struct name. Not relevant for GLSL.
   *
   * @return {string}
   */
  getOutputStructName() {
    return "";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The GLSL function code.
   */
  buildFunctionCode(e) {
    const t = e.layout, n = this.flowShaderNode(e), i = [];
    for (const l of t.inputs)
      i.push(this.getType(l.type) + " " + l.name);
    return `${this.getType(t.type)} ${t.name}( ${i.join(", ")} ) {

	${n.vars}

${n.code}
	return ${n.result};

}`;
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   */
  setupPBO(e) {
    const t = e.value;
    if (t.pbo === void 0) {
      const n = t.array, i = t.count * t.itemSize, { itemSize: o } = t, l = t.array.constructor.name.toLowerCase().includes("int");
      let p = l ? I6 : R6;
      o === 2 ? p = l ? N6 : _g : o === 3 ? p = l ? iRe : M6 : o === 4 && (p = l ? O6 : al);
      const f = {
        Float32Array: wa,
        Uint8Array: yo,
        Uint16Array: wb,
        Uint32Array: xi,
        Int8Array: fE,
        Int16Array: mE,
        Int32Array: fo,
        Uint8ClampedArray: yo
      }, v = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(i / o))));
      let _ = Math.ceil(i / o / v);
      v * _ * o < i && _++;
      const E = v * _ * o, A = new n.constructor(E);
      A.set(n, 0), t.array = A;
      const I = new $Le(t.array, v, _, p, f[t.array.constructor.name] || wa);
      I.needsUpdate = !0, I.isPBOTexture = !0;
      const j = new Qb(I, null, null);
      j.setPrecision("high"), t.pboNode = j, t.pbo = j.value, this.getUniformFromNode(t.pboNode, "texture", this.shaderStage, this.context.label);
    }
  }
  /**
   * Returns a GLSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(e, t = this.shaderStage) {
    return e.isNodeUniform && e.node.isTextureNode !== !0 && e.node.isBufferNode !== !0 ? t.charAt(0) + "_" + e.name : super.getPropertyName(e, t);
  }
  /**
   * Setups the Pixel Buffer Object (PBO) for the given storage
   * buffer node.
   *
   * @param {StorageArrayElementNode} storageArrayElementNode - The storage array element node.
   * @return {string} The property name.
   */
  generatePBO(e) {
    const { node: t, indexNode: n } = e, i = t.value;
    if (this.renderer.backend.has(i)) {
      const _ = this.renderer.backend.get(i);
      _.pbo = i.pbo;
    }
    const o = this.getUniformFromNode(i.pboNode, "texture", this.shaderStage, this.context.label), l = this.getPropertyName(o);
    this.increaseUsage(n);
    const p = n.build(this, "uint"), f = this.getDataFromNode(e);
    let v = f.propertyName;
    if (v === void 0) {
      const _ = this.getVarFromNode(e);
      v = this.getPropertyName(_);
      const E = this.getDataFromNode(t);
      let A = E.propertySizeName;
      A === void 0 && (A = v + "Size", this.getVarFromNode(t, A, "uint"), this.addLineFlowCode(`${A} = uint( textureSize( ${l}, 0 ).x )`, e), E.propertySizeName = A);
      const { itemSize: I } = i, j = "." + Xb.join("").slice(0, I), q = `ivec2(${p} % ${A}, ${p} / ${A})`, L = this.generateTextureLoad(null, l, q, null, "0");
      let V = "vec4";
      i.pbo.type === xi ? V = "uvec4" : i.pbo.type === fo && (V = "ivec4"), this.addLineFlowCode(`${v} = ${V}(${L})${j}`, e), f.propertyName = v;
    }
    return v;
  }
  /**
   * Generates the GLSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A GLSL snippet that represents the 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLoad(e, t, n, i, o = "0") {
    return i ? `texelFetch( ${t}, ivec3( ${n}, ${i} ), ${o} )` : `texelFetch( ${t}, ${n}, ${o} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet -  A GLSL snippet that represents the 0-based texture array index to sample.
   * @return {string} The GLSL snippet.
   */
  generateTexture(e, t, n, i) {
    return e.isDepthTexture ? (i && (n = `vec4( ${n}, ${i} )`), `texture( ${t}, ${n} ).x`) : (i && (n = `vec3( ${n}, ${i} )`), `texture( ${t}, ${n} )`);
  }
  /**
   * Generates the GLSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A GLSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The GLSL snippet.
   */
  generateTextureLevel(e, t, n, i) {
    return `textureLod( ${t}, ${n}, ${i} )`;
  }
  /**
   * Generates the GLSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A GLSL snippet that represents the bias to apply to the mip level before sampling.
   * @return {string} The GLSL snippet.
   */
  generateTextureBias(e, t, n, i) {
    return `texture( ${t}, ${n}, ${i} )`;
  }
  /**
   * Generates the GLSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient GLSL snippets.
   * @return {string} The GLSL snippet.
   */
  generateTextureGrad(e, t, n, i) {
    return `textureGrad( ${t}, ${n}, ${i[0]}, ${i[1]} )`;
  }
  /**
   * Generates the GLSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A GLSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A GLSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A GLSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The GLSL snippet.
   */
  generateTextureCompare(e, t, n, i, o, l = this.shaderStage) {
    if (l === "fragment")
      return o ? `texture( ${t}, vec4( ${n}, ${o}, ${i} ) )` : `texture( ${t}, vec3( ${n}, ${i} ) )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${l} shader.`);
  }
  /**
   * Returns the variables of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the variables.
   */
  getVars(e) {
    const t = [], n = this.vars[e];
    if (n !== void 0)
      for (const i of n)
        t.push(`${this.getVar(i.type, i.name, i.count)};`);
    return t.join(`
	`);
  }
  /**
   * Returns the uniforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the uniforms.
   */
  getUniforms(e) {
    const t = this.uniforms[e], n = [], i = {};
    for (const l of t) {
      let p = null, f = !1;
      if (l.type === "texture" || l.type === "texture3D") {
        const _ = l.node.value;
        let E = "";
        (_.isDataTexture === !0 || _.isData3DTexture === !0) && (_.type === xi ? E = "u" : _.type === fo && (E = "i")), l.type === "texture3D" && _.isArrayTexture === !1 ? p = `${E}sampler3D ${l.name};` : _.compareFunction ? _.isArrayTexture === !0 ? p = `sampler2DArrayShadow ${l.name};` : p = `sampler2DShadow ${l.name};` : _.isArrayTexture === !0 || _.isDataArrayTexture === !0 || _.isCompressedArrayTexture === !0 ? p = `${E}sampler2DArray ${l.name};` : p = `${E}sampler2D ${l.name};`;
      } else if (l.type === "cubeTexture")
        p = `samplerCube ${l.name};`;
      else if (l.type === "buffer") {
        const _ = l.node, E = this.getType(_.bufferType), A = _.bufferCount, I = A > 0 ? A : "";
        p = `${_.name} {
	${E} ${l.name}[${I}];
};
`;
      } else
        p = `${this.getVectorType(l.type)} ${this.getPropertyName(l, e)};`, f = !0;
      const v = l.node.precision;
      if (v !== null && (p = KLe[v] + " " + p), f) {
        p = "	" + p;
        const _ = l.groupNode.name;
        (i[_] || (i[_] = [])).push(p);
      } else
        p = "uniform " + p, n.push(p);
    }
    let o = "";
    for (const l in i) {
      const p = i[l];
      o += this._getGLSLUniformStruct(e + "_" + l, p.join(`
`)) + `
`;
    }
    return o += n.join(`
`), o;
  }
  /**
   * Returns the type for a given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @return {string} The type.
   */
  getTypeFromAttribute(e) {
    let t = super.getTypeFromAttribute(e);
    if (/^[iu]/.test(t) && e.gpuType !== fo) {
      let n = e;
      e.isInterleavedBufferAttribute && (n = e.data);
      const i = n.array;
      i instanceof Uint32Array || i instanceof Int32Array || (t = t.slice(1));
    }
    return t;
  }
  /**
   * Returns the shader attributes of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the shader attributes.
   */
  getAttributes(e) {
    let t = "";
    if (e === "vertex" || e === "compute") {
      const n = this.getAttributesArray();
      let i = 0;
      for (const o of n)
        t += `layout( location = ${i++} ) in ${o.type} ${o.name};
`;
    }
    return t;
  }
  /**
   * Returns the members of the given struct type node as a GLSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The GLSL snippet that defines the struct members.
   */
  getStructMembers(e) {
    const t = [];
    for (const n of e.members)
      t.push(`	${n.type} ${n.name};`);
    return t.join(`
`);
  }
  /**
   * Returns the structs of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the structs.
   */
  getStructs(e) {
    const t = [], n = this.structs[e], i = [];
    for (const o of n)
      if (o.output)
        for (const l of o.members)
          i.push(`layout( location = ${l.index} ) out ${l.type} ${l.name};`);
      else {
        let l = "struct " + o.name + ` {
`;
        l += this.getStructMembers(o), l += `
};
`, t.push(l);
      }
    return i.length === 0 && i.push("layout( location = 0 ) out vec4 fragColor;"), `
` + i.join(`
`) + `

` + t.join(`
`);
  }
  /**
   * Returns the varyings of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the varyings.
   */
  getVaryings(e) {
    let t = "";
    const n = this.varyings;
    if (e === "vertex" || e === "compute")
      for (const i of n) {
        e === "compute" && (i.needsInterpolation = !0);
        const o = this.getType(i.type);
        if (i.needsInterpolation)
          if (i.interpolationType) {
            const l = Dme[i.interpolationType] || i.interpolationType, p = Fme[i.interpolationSampling] || "";
            t += `${l} ${p} out ${o} ${i.name};
`;
          } else {
            const l = o.includes("int") || o.includes("uv") || o.includes("iv") ? "flat " : "";
            t += `${l}out ${o} ${i.name};
`;
          }
        else
          t += `${o} ${i.name};
`;
      }
    else if (e === "fragment") {
      for (const i of n)
        if (i.needsInterpolation) {
          const o = this.getType(i.type);
          if (i.interpolationType) {
            const l = Dme[i.interpolationType] || i.interpolationType, p = Fme[i.interpolationSampling] || "";
            t += `${l} ${p} in ${o} ${i.name};
`;
          } else {
            const l = o.includes("int") || o.includes("uv") || o.includes("iv") ? "flat " : "";
            t += `${l}in ${o} ${i.name};
`;
          }
        }
    }
    for (const i of this.builtins[e])
      t += `${i};
`;
    return t;
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return "uint( gl_VertexID )";
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return "uint( gl_InstanceID )";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return `uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((n, i) => n * i, 1)}u`;
  }
  /**
   * Returns the draw index builtin.
   *
   * @return {?string} The drawIndex shader string. Returns `null` if `WEBGL_multi_draw` isn't supported by the device.
   */
  getDrawIndex() {
    return this.renderer.backend.extensions.has("WEBGL_multi_draw") ? "uint( gl_DrawID )" : null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return "gl_FragCoord.xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "gl_FragDepth";
  }
  /**
   * Enables the given extension.
   *
   * @param {string} name - The extension name.
   * @param {string} behavior - The extension behavior.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage.
   */
  enableExtension(e, t, n = this.shaderStage) {
    const i = this.extensions[n] || (this.extensions[n] = /* @__PURE__ */ new Map());
    i.has(e) === !1 && i.set(e, {
      name: e,
      behavior: t
    });
  }
  /**
   * Returns the enabled extensions of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the enabled extensions.
   */
  getExtensions(e) {
    const t = [];
    if (e === "vertex") {
      const i = this.renderer.backend.extensions;
      this.object.isBatchedMesh && i.has("WEBGL_multi_draw") && this.enableExtension("GL_ANGLE_multi_draw", "require", e);
    }
    const n = this.extensions[e];
    if (n !== void 0)
      for (const { name: i, behavior: o } of n.values())
        t.push(`#extension ${i} : ${o}`);
    return t.join(`
`);
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "gl_ClipDistance";
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(e) {
    let t = Ome[e];
    if (t === void 0) {
      let n;
      switch (t = !1, e) {
        case "float32Filterable":
          n = "OES_texture_float_linear";
          break;
        case "clipDistance":
          n = "WEBGL_clip_cull_distance";
          break;
      }
      if (n !== void 0) {
        const i = this.renderer.backend.extensions;
        i.has(n) && (i.get(n), t = !0);
      }
      Ome[e] = t;
    }
    return t;
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `true` in context of GLSL.
   */
  isFlipY() {
    return !0;
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(e) {
    this.enableExtension("GL_ANGLE_clip_cull_distance", "require"), this.builtins.vertex.push(`out float gl_ClipDistance[ ${e} ]`);
  }
  /**
   * Enables multiview.
   */
  enableMultiview() {
    this.enableExtension("GL_OVR_multiview2", "require", "fragment"), this.enableExtension("GL_OVR_multiview2", "require", "vertex"), this.builtins.vertex.push("layout(num_views = 2) in");
  }
  /**
   * Registers a transform in context of Transform Feedback.
   *
   * @param {string} varyingName - The varying name.
   * @param {AttributeNode} attributeNode - The attribute node.
   */
  registerTransform(e, t) {
    this.transforms.push({ varyingName: e, attributeNode: t });
  }
  /**
   * Returns the transforms of the given shader stage as a GLSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The GLSL snippet that defines the transforms.
   */
  getTransforms() {
    const e = this.transforms;
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const i = e[n], o = this.getPropertyName(i.attributeNode);
      o && (t += `${i.varyingName} = ${o};
	`);
    }
    return t;
  }
  /**
   * Returns a GLSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The GLSL snippet representing a struct.
   */
  _getGLSLUniformStruct(e, t) {
    return `
layout( std140 ) uniform ${e} {
${t}
};`;
  }
  /**
   * Returns a GLSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLVertexCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${Bme}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// attributes
${e.attributes}

// codes
${e.codes}

void main() {

	// vars
	${e.vars}

	// transforms
	${e.transforms}

	// flow
	${e.flow}

	gl_PointSize = 1.0;

}
`;
  }
  /**
   * Returns a GLSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getGLSLFragmentCode(e) {
    return `#version 300 es

${this.getSignature()}

// extensions
${e.extensions}

// precision
${Bme}

// uniforms
${e.uniforms}

// varyings
${e.varyings}

// codes
${e.codes}

// structs
${e.structs}

void main() {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const t in e) {
      let n = `// code

`;
      n += this.flowCode[t];
      const i = this.flowNodes[t], o = i[i.length - 1];
      for (const p of i) {
        const f = this.getFlowData(
          p
          /*, shaderStage*/
        ), v = p.name;
        v && (n.length > 0 && (n += `
`), n += `	// flow -> ${v}
	`), n += `${f.code}
	`, p === o && t !== "compute" && (n += `// result
	`, t === "vertex" ? (n += "gl_Position = ", n += `${f.result};`) : t === "fragment" && (p.outputNode.isOutputStructNode || (n += "fragColor = ", n += `${f.result};`)));
      }
      const l = e[t];
      l.extensions = this.getExtensions(t), l.uniforms = this.getUniforms(t), l.attributes = this.getAttributes(t), l.varyings = this.getVaryings(t), l.vars = this.getVars(t), l.structs = this.getStructs(t), l.codes = this.getCodes(t), l.transforms = this.getTransforms(t), l.flow = n;
    }
    this.material !== null ? (this.vertexShader = this._getGLSLVertexCode(e.vertex), this.fragmentShader = this._getGLSLFragmentCode(e.fragment)) : this.computeShader = this._getGLSLVertexCode(e.compute);
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(e, t, n, i = null) {
    const o = super.getUniformFromNode(e, t, n, i), l = this.getDataFromNode(e, n, this.globalCache);
    let p = l.uniformGPU;
    if (p === void 0) {
      const f = e.groupNode, v = f.name, _ = this.getBindGroupArray(v, n);
      if (t === "texture")
        p = new m2(o.name, o.node, f), _.push(p);
      else if (t === "cubeTexture")
        p = new hve(o.name, o.node, f), _.push(p);
      else if (t === "texture3D")
        p = new pve(o.name, o.node, f), _.push(p);
      else if (t === "buffer") {
        e.name = `NodeBuffer_${e.id}`, o.name = `buffer${e.id}`;
        const E = new cve(e, f);
        E.name = e.name, _.push(E), p = E;
      } else {
        const E = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let A = E[v];
        A === void 0 && (A = new dve(n + "_" + v, f), E[v] = A, _.push(A)), p = this.getNodeUniform(o, t), A.addUniform(p);
      }
      l.uniformGPU = p;
    }
    return o;
  }
}
let lV = null, fb = null;
class fve {
  /**
   * Constructs a new backend.
   *
   * @param {Object} parameters - An object holding parameters for the backend.
   */
  constructor(e = {}) {
    this.parameters = Object.assign({}, e), this.data = /* @__PURE__ */ new WeakMap(), this.renderer = null, this.domElement = null, this.timestampQueryPool = {
      render: null,
      compute: null
    }, this.trackTimestamp = e.trackTimestamp === !0;
  }
  /**
   * Initializes the backend so it is ready for usage. Concrete backends
   * are supposed to implement their rendering context creation and related
   * operations in this method.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(e) {
    this.renderer = e;
  }
  /**
   * The coordinate system of the backend.
   *
   * @abstract
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
  }
  // render context
  /**
   * This method is executed at the beginning of a render call and
   * can be used by the backend to prepare the state for upcoming
   * draw calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender() {
  }
  /**
   * This method is executed at the end of a render call and
   * can be used by the backend to finalize work after draw
   * calls.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender() {
  }
  /**
   * This method is executed at the beginning of a compute call and
   * can be used by the backend to prepare the state for upcoming
   * compute tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute() {
  }
  /**
   * This method is executed at the end of a compute call and
   * can be used by the backend to finalize work after compute
   * tasks.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute() {
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw() {
  }
  // compute node
  /**
   * Executes a compute command for the given compute node.
   *
   * @abstract
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   */
  compute() {
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram() {
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @abstract
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram() {
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings() {
  }
  /**
   * Updates the given bind group definition.
   *
   * @abstract
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings() {
  }
  /**
   * Updates a buffer binding.
   *
   * @abstract
   * @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding() {
  }
  // pipeline
  /**
   * Creates a render pipeline for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline() {
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @abstract
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline() {
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @abstract
   * @param {RenderObject} renderObject - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {NodeBuilder} The node builder.
   */
  createNodeBuilder() {
  }
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @abstract
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture() {
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture() {
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture() {
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  generateMipmaps() {
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @abstract
   * @param {Texture} texture - The texture.
   */
  destroyTexture() {
  }
  /**
   * Returns texture data as a typed array.
   *
   * @abstract
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer() {
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @abstract
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture() {
  }
  /**
  * Copies the current bound framebuffer to the given texture.
  *
  * @abstract
  * @param {Texture} texture - The destination texture.
  * @param {RenderContext} renderContext - The render context.
  * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
  */
  copyFramebufferToTexture() {
  }
  // attributes
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute() {
  }
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute() {
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute() {
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute() {
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @abstract
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute() {
  }
  // canvas
  /**
   * Returns the backend's rendering context.
   *
   * @abstract
   * @return {Object} The rendering context.
   */
  getContext() {
  }
  /**
   * Backends can use this method if they have to run
   * logic when the renderer gets resized.
   *
   * @abstract
   */
  updateSize() {
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport() {
  }
  // utils
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene. Backends must implement this method by using
   * a Occlusion Query API.
   *
   * @abstract
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded() {
  }
  /**
   * Resolves the time stamp for the given render context and type.
   *
   * @async
   * @abstract
   * @param {string} [type='render'] - The type of the time stamp.
   * @return {Promise<number>} A Promise that resolves with the time stamp.
   */
  async resolveTimestampsAsync(e = "render") {
    if (!this.trackTimestamp) {
      Wd("WebGPURenderer: Timestamp tracking is disabled.");
      return;
    }
    const t = this.timestampQueryPool[e];
    if (!t) {
      Wd(`WebGPURenderer: No timestamp query pool for type '${e}' found.`);
      return;
    }
    const n = await t.resolveQueriesAsync();
    return this.renderer.info[e].timestamp = n, n;
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @abstract
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync() {
  }
  /**
   * Checks if the given feature is supported by the backend.
   *
   * @async
   * @abstract
   * @param {string} name - The feature's name.
   * @return {Promise<boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
   */
  async hasFeatureAsync() {
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @abstract
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature() {
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @abstract
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
  }
  /**
   * Returns the drawing buffer size.
   *
   * @return {Vector2} The drawing buffer size.
   */
  getDrawingBufferSize() {
    return lV = lV || new Pn(), this.renderer.getDrawingBufferSize(lV);
  }
  /**
   * Defines the scissor test.
   *
   * @abstract
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest() {
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = this.renderer;
    return fb = fb || new U6(), e.getClearColor(fb), fb.getRGB(fb), fb;
  }
  /**
   * Returns the DOM element. If no DOM element exists, the backend
   * creates a new one.
   *
   * @return {HTMLCanvasElement} The DOM element.
   */
  getDomElement() {
    let e = this.domElement;
    return e === null && (e = this.parameters.canvas !== void 0 ? this.parameters.canvas : _Re(), "setAttribute" in e && e.setAttribute("data-engine", `three.js r${Yge} webgpu`), this.domElement = e), e;
  }
  /**
   * Sets a dictionary for the given object into the
   * internal data structure.
   *
   * @param {Object} object - The object.
   * @param {Object} value - The dictionary to set.
   */
  set(e, t) {
    this.data.set(e, t);
  }
  /**
   * Returns the dictionary for the given object.
   *
   * @param {Object} object - The object.
   * @return {Object} The object's dictionary.
   */
  get(e) {
    let t = this.data.get(e);
    return t === void 0 && (t = {}, this.data.set(e, t)), t;
  }
  /**
   * Checks if the given object has a dictionary
   * with data defined.
   *
   * @param {Object} object - The object.
   * @return {boolean} Whether a dictionary for the given object as been defined or not.
   */
  has(e) {
    return this.data.has(e);
  }
  /**
   * Deletes an object from the internal data structure.
   *
   * @param {Object} object - The object to delete.
   */
  delete(e) {
    this.data.delete(e);
  }
  /**
   * Frees internal resources.
   *
   * @abstract
   */
  dispose() {
  }
}
let XLe = 0;
class QLe {
  constructor(e, t) {
    this.buffers = [e.bufferGPU, t], this.type = e.type, this.bufferType = e.bufferType, this.pbo = e.pbo, this.byteLength = e.byteLength, this.bytesPerElement = e.BYTES_PER_ELEMENT, this.version = e.version, this.isInteger = e.isInteger, this.activeBufferIndex = 0, this.baseId = e.id;
  }
  get id() {
    return `${this.baseId}|${this.activeBufferIndex}`;
  }
  get bufferGPU() {
    return this.buffers[this.activeBufferIndex];
  }
  get transformBuffer() {
    return this.buffers[this.activeBufferIndex ^ 1];
  }
  switchBuffers() {
    this.activeBufferIndex ^= 1;
  }
}
class ZLe {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   */
  createAttribute(e, t) {
    const n = this.backend, { gl: i } = n, o = e.array, l = e.usage || i.STATIC_DRAW, p = e.isInterleavedBufferAttribute ? e.data : e, f = n.get(p);
    let v = f.bufferGPU;
    v === void 0 && (v = this._createBuffer(i, t, o, l), f.bufferGPU = v, f.bufferType = t, f.version = p.version);
    let _;
    if (o instanceof Float32Array)
      _ = i.FLOAT;
    else if (o instanceof Uint16Array)
      e.isFloat16BufferAttribute ? _ = i.HALF_FLOAT : _ = i.UNSIGNED_SHORT;
    else if (o instanceof Int16Array)
      _ = i.SHORT;
    else if (o instanceof Uint32Array)
      _ = i.UNSIGNED_INT;
    else if (o instanceof Int32Array)
      _ = i.INT;
    else if (o instanceof Int8Array)
      _ = i.BYTE;
    else if (o instanceof Uint8Array)
      _ = i.UNSIGNED_BYTE;
    else if (o instanceof Uint8ClampedArray)
      _ = i.UNSIGNED_BYTE;
    else
      throw new Error("THREE.WebGLBackend: Unsupported buffer data format: " + o);
    let E = {
      bufferGPU: v,
      bufferType: t,
      type: _,
      byteLength: o.byteLength,
      bytesPerElement: o.BYTES_PER_ELEMENT,
      version: e.version,
      pbo: e.pbo,
      isInteger: _ === i.INT || _ === i.UNSIGNED_INT || e.gpuType === fo,
      id: XLe++
    };
    if (e.isStorageBufferAttribute || e.isStorageInstancedBufferAttribute) {
      const A = this._createBuffer(i, t, o, l);
      E = new QLe(E, A);
    }
    n.set(e, E);
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(e) {
    const t = this.backend, { gl: n } = t, i = e.array, o = e.isInterleavedBufferAttribute ? e.data : e, l = t.get(o), p = l.bufferType, f = e.isInterleavedBufferAttribute ? e.data.updateRanges : e.updateRanges;
    if (n.bindBuffer(p, l.bufferGPU), f.length === 0)
      n.bufferSubData(p, 0, i);
    else {
      for (let v = 0, _ = f.length; v < _; v++) {
        const E = f[v];
        n.bufferSubData(
          p,
          E.start * i.BYTES_PER_ELEMENT,
          i,
          E.start,
          E.count
        );
      }
      o.clearUpdateRanges();
    }
    n.bindBuffer(p, null), l.version = o.version;
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(e) {
    const t = this.backend, { gl: n } = t;
    e.isInterleavedBufferAttribute && t.delete(e.data);
    const i = t.get(e);
    n.deleteBuffer(i.bufferGPU), t.delete(e);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    const t = this.backend, { gl: n } = t, i = e.isInterleavedBufferAttribute ? e.data : e, { bufferGPU: o } = t.get(i), l = e.array, p = l.byteLength;
    n.bindBuffer(n.COPY_READ_BUFFER, o);
    const f = n.createBuffer();
    n.bindBuffer(n.COPY_WRITE_BUFFER, f), n.bufferData(n.COPY_WRITE_BUFFER, p, n.STREAM_READ), n.copyBufferSubData(n.COPY_READ_BUFFER, n.COPY_WRITE_BUFFER, 0, 0, p), await t.utils._clientWaitAsync();
    const v = new e.array.constructor(l.length);
    return n.bindBuffer(n.COPY_WRITE_BUFFER, f), n.getBufferSubData(n.COPY_WRITE_BUFFER, 0, v), n.deleteBuffer(f), n.bindBuffer(n.COPY_READ_BUFFER, null), n.bindBuffer(n.COPY_WRITE_BUFFER, null), v.buffer;
  }
  /**
   * Creates a WebGL buffer with the given data.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {GLenum } bufferType - A flag that indicates the buffer type and thus binding point target.
   * @param {TypedArray} array - The array of the buffer attribute.
   * @param {GLenum} usage - The usage.
   * @return {WebGLBuffer} The WebGL buffer.
   */
  _createBuffer(e, t, n, i) {
    const o = e.createBuffer();
    return e.bindBuffer(t, o), e.bufferData(t, n, i), e.bindBuffer(t, null), o;
  }
}
let uV, Gw;
class JLe {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.enabled = {}, this.currentFlipSided = null, this.currentCullFace = null, this.currentProgram = null, this.currentBlendingEnabled = !1, this.currentBlending = null, this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentPremultipledAlpha = null, this.currentPolygonOffsetFactor = null, this.currentPolygonOffsetUnits = null, this.currentColorMask = null, this.currentDepthFunc = null, this.currentDepthMask = null, this.currentStencilFunc = null, this.currentStencilRef = null, this.currentStencilFuncMask = null, this.currentStencilFail = null, this.currentStencilZFail = null, this.currentStencilZPass = null, this.currentStencilMask = null, this.currentLineWidth = null, this.currentClippingPlanes = 0, this.currentVAO = null, this.currentIndex = null, this.currentBoundFramebuffers = {}, this.currentDrawbuffers = /* @__PURE__ */ new WeakMap(), this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS), this.currentTextureSlot = null, this.currentBoundTextures = {}, this.currentBoundBufferBases = {}, this._init();
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const e = this.gl;
    uV = {
      [uu]: e.FUNC_ADD,
      [Xge]: e.FUNC_SUBTRACT,
      [Qge]: e.FUNC_REVERSE_SUBTRACT
    }, Gw = {
      [Vp]: e.ZERO,
      [Zge]: e.ONE,
      [Jge]: e.SRC_COLOR,
      [kO]: e.SRC_ALPHA,
      [sye]: e.SRC_ALPHA_SATURATE,
      [rye]: e.DST_COLOR,
      [tye]: e.DST_ALPHA,
      [eye]: e.ONE_MINUS_SRC_COLOR,
      [MO]: e.ONE_MINUS_SRC_ALPHA,
      [iye]: e.ONE_MINUS_DST_COLOR,
      [nye]: e.ONE_MINUS_DST_ALPHA
    };
    const t = e.getParameter(e.SCISSOR_BOX), n = e.getParameter(e.VIEWPORT);
    this.currentScissor = new Bn().fromArray(t), this.currentViewport = new Bn().fromArray(n), this._tempVec4 = new Bn();
  }
  /**
   * Enables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.enable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  enable(e) {
    const { enabled: t } = this;
    t[e] !== !0 && (this.gl.enable(e), t[e] = !0);
  }
  /**
   * Disables the given WebGL capability.
   *
   * This method caches the capability state so
   * `gl.disable()` is only called when necessary.
   *
   * @param {GLenum} id - The capability to enable.
   */
  disable(e) {
    const { enabled: t } = this;
    t[e] !== !1 && (this.gl.disable(e), t[e] = !1);
  }
  /**
   * Specifies whether polygons are front- or back-facing
   * by setting the winding orientation.
   *
   * This method caches the state so `gl.frontFace()` is only
   * called when necessary.
   *
   * @param {boolean} flipSided - Whether triangles flipped their sides or not.
   */
  setFlipSided(e) {
    if (this.currentFlipSided !== e) {
      const { gl: t } = this;
      e ? t.frontFace(t.CW) : t.frontFace(t.CCW), this.currentFlipSided = e;
    }
  }
  /**
   * Specifies whether or not front- and/or back-facing
   * polygons can be culled.
   *
   * This method caches the state so `gl.cullFace()` is only
   * called when necessary.
   *
   * @param {number} cullFace - Defines which polygons are candidates for culling.
   */
  setCullFace(e) {
    const { gl: t } = this;
    e !== UMe ? (this.enable(t.CULL_FACE), e !== this.currentCullFace && (e === zMe ? t.cullFace(t.BACK) : e === VMe ? t.cullFace(t.FRONT) : t.cullFace(t.FRONT_AND_BACK))) : this.disable(t.CULL_FACE), this.currentCullFace = e;
  }
  /**
   * Specifies the width of line primitives.
   *
   * This method caches the state so `gl.lineWidth()` is only
   * called when necessary.
   *
   * @param {number} width - The line width.
   */
  setLineWidth(e) {
    const { currentLineWidth: t, gl: n } = this;
    e !== t && (n.lineWidth(e), this.currentLineWidth = e);
  }
  /**
   * Defines the blending.
   *
   * This method caches the state so `gl.blendEquation()`, `gl.blendEquationSeparate()`,
   * `gl.blendFunc()` and  `gl.blendFuncSeparate()` are only called when necessary.
   *
   * @param {number} blending - The blending type.
   * @param {number} blendEquation - The blending equation.
   * @param {number} blendSrc - Only relevant for custom blending. The RGB source blending factor.
   * @param {number} blendDst - Only relevant for custom blending. The RGB destination blending factor.
   * @param {number} blendEquationAlpha - Only relevant for custom blending. The blending equation for alpha.
   * @param {number} blendSrcAlpha - Only relevant for custom blending. The alpha source blending factor.
   * @param {number} blendDstAlpha - Only relevant for custom blending. The alpha destination blending factor.
   * @param {boolean} premultipliedAlpha - Whether premultiplied alpha is enabled or not.
   */
  setBlending(e, t, n, i, o, l, p, f) {
    const { gl: v } = this;
    if (e === zb) {
      this.currentBlendingEnabled === !0 && (this.disable(v.BLEND), this.currentBlendingEnabled = !1);
      return;
    }
    if (this.currentBlendingEnabled === !1 && (this.enable(v.BLEND), this.currentBlendingEnabled = !0), e !== pE) {
      if (e !== this.currentBlending || f !== this.currentPremultipledAlpha) {
        if ((this.currentBlendEquation !== uu || this.currentBlendEquationAlpha !== uu) && (v.blendEquation(v.FUNC_ADD), this.currentBlendEquation = uu, this.currentBlendEquationAlpha = uu), f)
          switch (e) {
            case jd:
              v.blendFuncSeparate(v.ONE, v.ONE_MINUS_SRC_ALPHA, v.ONE, v.ONE_MINUS_SRC_ALPHA);
              break;
            case CO:
              v.blendFunc(v.ONE, v.ONE);
              break;
            case PO:
              v.blendFuncSeparate(v.ZERO, v.ONE_MINUS_SRC_COLOR, v.ZERO, v.ONE);
              break;
            case AO:
              v.blendFuncSeparate(v.ZERO, v.SRC_COLOR, v.ZERO, v.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        else
          switch (e) {
            case jd:
              v.blendFuncSeparate(v.SRC_ALPHA, v.ONE_MINUS_SRC_ALPHA, v.ONE, v.ONE_MINUS_SRC_ALPHA);
              break;
            case CO:
              v.blendFunc(v.SRC_ALPHA, v.ONE);
              break;
            case PO:
              v.blendFuncSeparate(v.ZERO, v.ONE_MINUS_SRC_COLOR, v.ZERO, v.ONE);
              break;
            case AO:
              v.blendFunc(v.ZERO, v.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", e);
              break;
          }
        this.currentBlendSrc = null, this.currentBlendDst = null, this.currentBlendSrcAlpha = null, this.currentBlendDstAlpha = null, this.currentBlending = e, this.currentPremultipledAlpha = f;
      }
      return;
    }
    o = o || t, l = l || n, p = p || i, (t !== this.currentBlendEquation || o !== this.currentBlendEquationAlpha) && (v.blendEquationSeparate(uV[t], uV[o]), this.currentBlendEquation = t, this.currentBlendEquationAlpha = o), (n !== this.currentBlendSrc || i !== this.currentBlendDst || l !== this.currentBlendSrcAlpha || p !== this.currentBlendDstAlpha) && (v.blendFuncSeparate(Gw[n], Gw[i], Gw[l], Gw[p]), this.currentBlendSrc = n, this.currentBlendDst = i, this.currentBlendSrcAlpha = l, this.currentBlendDstAlpha = p), this.currentBlending = e, this.currentPremultipledAlpha = !1;
  }
  /**
   * Specifies whether colors can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.colorMask()` is only
   * called when necessary.
   *
   * @param {boolean} colorMask - The color mask.
   */
  setColorMask(e) {
    this.currentColorMask !== e && (this.gl.colorMask(e, e, e, e), this.currentColorMask = e);
  }
  /**
   * Specifies whether the depth test is enabled or not.
   *
   * @param {boolean} depthTest - Whether the depth test is enabled or not.
   */
  setDepthTest(e) {
    const { gl: t } = this;
    e ? this.enable(t.DEPTH_TEST) : this.disable(t.DEPTH_TEST);
  }
  /**
   * Specifies whether depth values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.depthMask()` is only
   * called when necessary.
   *
   * @param {boolean} depthMask - The depth mask.
   */
  setDepthMask(e) {
    this.currentDepthMask !== e && (this.gl.depthMask(e), this.currentDepthMask = e);
  }
  /**
   * Specifies the depth compare function.
   *
   * This method caches the state so `gl.depthFunc()` is only
   * called when necessary.
   *
   * @param {number} depthFunc - The depth compare function.
   */
  setDepthFunc(e) {
    if (this.currentDepthFunc !== e) {
      const { gl: t } = this;
      switch (e) {
        case oye:
          t.depthFunc(t.NEVER);
          break;
        case aye:
          t.depthFunc(t.ALWAYS);
          break;
        case lye:
          t.depthFunc(t.LESS);
          break;
        case RO:
          t.depthFunc(t.LEQUAL);
          break;
        case uye:
          t.depthFunc(t.EQUAL);
          break;
        case cye:
          t.depthFunc(t.GEQUAL);
          break;
        case dye:
          t.depthFunc(t.GREATER);
          break;
        case hye:
          t.depthFunc(t.NOTEQUAL);
          break;
        default:
          t.depthFunc(t.LEQUAL);
      }
      this.currentDepthFunc = e;
    }
  }
  /**
   * Specifies the scissor box.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  scissor(e, t, n, i) {
    const o = this._tempVec4.set(e, t, n, i);
    if (this.currentScissor.equals(o) === !1) {
      const { gl: l } = this;
      l.scissor(o.x, o.y, o.z, o.w), this.currentScissor.copy(o);
    }
  }
  /**
   * Specifies the viewport.
   *
   * @param {number} x - The x-coordinate of the lower left corner of the viewport.
   * @param {number} y - The y-coordinate of the lower left corner of the viewport.
   * @param {number} width - The width of the viewport.
   * @param {number} height - The height of the viewport.
   *
   */
  viewport(e, t, n, i) {
    const o = this._tempVec4.set(e, t, n, i);
    if (this.currentViewport.equals(o) === !1) {
      const { gl: l } = this;
      l.viewport(o.x, o.y, o.z, o.w), this.currentViewport.copy(o);
    }
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    const t = this.gl;
    e ? t.enable(t.SCISSOR_TEST) : t.disable(t.SCISSOR_TEST);
  }
  /**
   * Specifies whether the stencil test is enabled or not.
   *
   * @param {boolean} stencilTest - Whether the stencil test is enabled or not.
   */
  setStencilTest(e) {
    const { gl: t } = this;
    e ? this.enable(t.STENCIL_TEST) : this.disable(t.STENCIL_TEST);
  }
  /**
   * Specifies whether stencil values can be written when rendering
   * into a framebuffer or not.
   *
   * This method caches the state so `gl.stencilMask()` is only
   * called when necessary.
   *
   * @param {boolean} stencilMask - The stencil mask.
   */
  setStencilMask(e) {
    this.currentStencilMask !== e && (this.gl.stencilMask(e), this.currentStencilMask = e);
  }
  /**
   * Specifies whether the stencil test functions.
   *
   * This method caches the state so `gl.stencilFunc()` is only
   * called when necessary.
   *
   * @param {number} stencilFunc - The stencil compare function.
   * @param {number} stencilRef - The reference value for the stencil test.
   * @param {number} stencilMask - A bit-wise mask that is used to AND the reference value and the stored stencil value when the test is done.
   */
  setStencilFunc(e, t, n) {
    (this.currentStencilFunc !== e || this.currentStencilRef !== t || this.currentStencilFuncMask !== n) && (this.gl.stencilFunc(e, t, n), this.currentStencilFunc = e, this.currentStencilRef = t, this.currentStencilFuncMask = n);
  }
  /**
   * Specifies whether the stencil test operation.
   *
   * This method caches the state so `gl.stencilOp()` is only
   * called when necessary.
   *
   * @param {number} stencilFail - The function to use when the stencil test fails.
   * @param {number} stencilZFail - The function to use when the stencil test passes, but the depth test fail.
   * @param {number} stencilZPass - The function to use when both the stencil test and the depth test pass,
   * or when the stencil test passes and there is no depth buffer or depth testing is disabled.
   */
  setStencilOp(e, t, n) {
    (this.currentStencilFail !== e || this.currentStencilZFail !== t || this.currentStencilZPass !== n) && (this.gl.stencilOp(e, t, n), this.currentStencilFail = e, this.currentStencilZFail = t, this.currentStencilZPass = n);
  }
  /**
   * Configures the WebGL state for the given material.
   *
   * @param {Material} material - The material to configure the state for.
   * @param {number} frontFaceCW - Whether the front faces are counter-clockwise or not.
   * @param {number} hardwareClippingPlanes - The number of hardware clipping planes.
   */
  setMaterial(e, t, n) {
    const { gl: i } = this;
    e.side === Mb ? this.disable(i.CULL_FACE) : this.enable(i.CULL_FACE);
    let o = e.side === Ko;
    t && (o = !o), this.setFlipSided(o), e.blending === jd && e.transparent === !1 ? this.setBlending(zb) : this.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha), this.setDepthFunc(e.depthFunc), this.setDepthTest(e.depthTest), this.setDepthMask(e.depthWrite), this.setColorMask(e.colorWrite);
    const l = e.stencilWrite;
    if (this.setStencilTest(l), l && (this.setStencilMask(e.stencilWriteMask), this.setStencilFunc(e.stencilFunc, e.stencilRef, e.stencilFuncMask), this.setStencilOp(e.stencilFail, e.stencilZFail, e.stencilZPass)), this.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits), e.alphaToCoverage === !0 && this.backend.renderer.samples > 1 ? this.enable(i.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(i.SAMPLE_ALPHA_TO_COVERAGE), n > 0 && this.currentClippingPlanes !== n)
      for (let f = 0; f < 8; f++)
        f < n ? this.enable(12288 + f) : this.disable(12288 + f);
  }
  /**
   * Specifies the polygon offset.
   *
   * This method caches the state so `gl.polygonOffset()` is only
   * called when necessary.
   *
   * @param {boolean} polygonOffset - Whether polygon offset is enabled or not.
   * @param {number} factor - The scale factor for the variable depth offset for each polygon.
   * @param {number} units - The multiplier by which an implementation-specific value is multiplied with to create a constant depth offset.
   */
  setPolygonOffset(e, t, n) {
    const { gl: i } = this;
    e ? (this.enable(i.POLYGON_OFFSET_FILL), (this.currentPolygonOffsetFactor !== t || this.currentPolygonOffsetUnits !== n) && (i.polygonOffset(t, n), this.currentPolygonOffsetFactor = t, this.currentPolygonOffsetUnits = n)) : this.disable(i.POLYGON_OFFSET_FILL);
  }
  /**
   * Defines the usage of the given WebGL program.
   *
   * This method caches the state so `gl.useProgram()` is only
   * called when necessary.
   *
   * @param {WebGLProgram} program - The WebGL program to use.
   * @return {boolean} Whether a program change has been executed or not.
   */
  useProgram(e) {
    return this.currentProgram !== e ? (this.gl.useProgram(e), this.currentProgram = e, !0) : !1;
  }
  /**
   * Sets the vertex state by binding the given VAO and element buffer.
   *
   * @param {WebGLVertexArrayObject} vao - The VAO.
   * @param {WebGLBuffer} indexBuffer - The index buffer.
   * @return {boolean} Whether a vertex state has been changed or not.
   */
  setVertexState(e, t = null) {
    const n = this.gl;
    return this.currentVAO !== e || this.currentIndex !== t ? (n.bindVertexArray(e), t !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, t), this.currentVAO = e, this.currentIndex = t, !0) : !1;
  }
  /**
   * Resets the vertex array state by resetting the VAO and element buffer.
   */
  resetVertexState() {
    const e = this.gl;
    e.bindVertexArray(null), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, null), this.currentVAO = null, this.currentIndex = null;
  }
  // framebuffer
  /**
   * Binds the given framebuffer.
   *
   * This method caches the state so `gl.bindFramebuffer()` is only
   * called when necessary.
   *
   * @param {number} target - The binding point (target).
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer to bind.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindFramebuffer(e, t) {
    const { gl: n, currentBoundFramebuffers: i } = this;
    return i[e] !== t ? (n.bindFramebuffer(e, t), i[e] = t, e === n.DRAW_FRAMEBUFFER && (i[n.FRAMEBUFFER] = t), e === n.FRAMEBUFFER && (i[n.DRAW_FRAMEBUFFER] = t), !0) : !1;
  }
  /**
   * Defines draw buffers to which fragment colors are written into.
   * Configures the MRT setup of custom framebuffers.
   *
   * This method caches the state so `gl.drawBuffers()` is only
   * called when necessary.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {WebGLFramebuffer} framebuffer - The WebGL framebuffer.
   */
  drawBuffers(e, t) {
    const { gl: n } = this;
    let i = [], o = !1;
    if (e.textures !== null) {
      i = this.currentDrawbuffers.get(t), i === void 0 && (i = [], this.currentDrawbuffers.set(t, i));
      const l = e.textures;
      if (i.length !== l.length || i[0] !== n.COLOR_ATTACHMENT0) {
        for (let p = 0, f = l.length; p < f; p++)
          i[p] = n.COLOR_ATTACHMENT0 + p;
        i.length = l.length, o = !0;
      }
    } else
      i[0] !== n.BACK && (i[0] = n.BACK, o = !0);
    o && n.drawBuffers(i);
  }
  // texture
  /**
   * Makes the given texture unit active.
   *
   * This method caches the state so `gl.activeTexture()` is only
   * called when necessary.
   *
   * @param {number} webglSlot - The texture unit to make active.
   */
  activeTexture(e) {
    const { gl: t, currentTextureSlot: n, maxTextures: i } = this;
    e === void 0 && (e = t.TEXTURE0 + i - 1), n !== e && (t.activeTexture(e), this.currentTextureSlot = e);
  }
  /**
   * Binds the given WebGL texture to a target.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   *
   * @param {number} webglType - The binding point (target).
   * @param {WebGLTexture} webglTexture - The WebGL texture to bind.
   * @param {number} webglSlot - The texture.
   */
  bindTexture(e, t, n) {
    const { gl: i, currentTextureSlot: o, currentBoundTextures: l, maxTextures: p } = this;
    n === void 0 && (o === null ? n = i.TEXTURE0 + p - 1 : n = o);
    let f = l[n];
    f === void 0 && (f = { type: void 0, texture: void 0 }, l[n] = f), (f.type !== e || f.texture !== t) && (o !== n && (i.activeTexture(n), this.currentTextureSlot = n), i.bindTexture(e, t), f.type = e, f.texture = t);
  }
  /**
   * Binds a given WebGL buffer to a given binding point (target) at a given index.
   *
   * This method caches the state so `gl.bindBufferBase()` is only
   * called when necessary.
   *
   * @param {number} target - The target for the bind operation.
   * @param {number} index - The index of the target.
   * @param {WebGLBuffer} buffer - The WebGL buffer.
   * @return {boolean} Whether a bind has been executed or not.
   */
  bindBufferBase(e, t, n) {
    const { gl: i } = this, o = `${e}-${t}`;
    return this.currentBoundBufferBases[o] !== n ? (i.bindBufferBase(e, t, n), this.currentBoundBufferBases[o] = n, !0) : !1;
  }
  /**
   * Unbinds the current bound texture.
   *
   * This method caches the state so `gl.bindTexture()` is only
   * called when necessary.
   */
  unbindTexture() {
    const { gl: e, currentTextureSlot: t, currentBoundTextures: n } = this, i = n[t];
    i !== void 0 && i.type !== void 0 && (e.bindTexture(i.type, null), i.type = void 0, i.texture = void 0);
  }
}
class e3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.extensions = e.extensions;
  }
  /**
   * Converts the given three.js constant into a WebGL constant.
   * The method currently supports the conversion of texture formats
   * and types.
   *
   * @param {number} p - The three.js constant.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   * @return {?number} The corresponding WebGL constant.
   */
  convert(e, t = $d) {
    const { gl: n, extensions: i } = this;
    let o;
    const l = Ir.getTransfer(t);
    if (e === yo) return n.UNSIGNED_BYTE;
    if (e === tRe) return n.UNSIGNED_SHORT_4_4_4_4;
    if (e === nRe) return n.UNSIGNED_SHORT_5_5_5_1;
    if (e === fye) return n.UNSIGNED_INT_5_9_9_9_REV;
    if (e === fE) return n.BYTE;
    if (e === mE) return n.SHORT;
    if (e === wb) return n.UNSIGNED_SHORT;
    if (e === fo) return n.INT;
    if (e === xi) return n.UNSIGNED_INT;
    if (e === wa) return n.FLOAT;
    if (e === ol)
      return n.HALF_FLOAT;
    if (e === rRe) return n.ALPHA;
    if (e === M6) return n.RGB;
    if (e === al) return n.RGBA;
    if (e === xc) return n.DEPTH_COMPONENT;
    if (e === zd) return n.DEPTH_STENCIL;
    if (e === R6) return n.RED;
    if (e === I6) return n.RED_INTEGER;
    if (e === _g) return n.RG;
    if (e === N6) return n.RG_INTEGER;
    if (e === O6) return n.RGBA_INTEGER;
    if (e === u5 || e === hO || e === pO || e === fO)
      if (l === hn)
        if (o = i.get("WEBGL_compressed_texture_s3tc_srgb"), o !== null) {
          if (e === u5) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (e === hO) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (e === pO) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (e === fO) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else
          return null;
      else if (o = i.get("WEBGL_compressed_texture_s3tc"), o !== null) {
        if (e === u5) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (e === hO) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (e === pO) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (e === fO) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else
        return null;
    if (e === Kpe || e === Ype || e === Xpe || e === Qpe)
      if (o = i.get("WEBGL_compressed_texture_pvrtc"), o !== null) {
        if (e === Kpe) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (e === Ype) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (e === Xpe) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (e === Qpe) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else
        return null;
    if (e === Zpe || e === zV || e === VV)
      if (o = i.get("WEBGL_compressed_texture_etc"), o !== null) {
        if (e === Zpe || e === zV) return l === hn ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (e === VV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else
        return null;
    if (e === GV || e === qV || e === HV || e === $V || e === WV || e === KV || e === YV || e === XV || e === QV || e === ZV || e === JV || e === e6 || e === t6 || e === n6)
      if (o = i.get("WEBGL_compressed_texture_astc"), o !== null) {
        if (e === GV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (e === qV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (e === HV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (e === $V) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (e === WV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (e === KV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (e === YV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (e === XV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (e === QV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (e === ZV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (e === JV) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (e === e6) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (e === t6) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (e === n6) return l === hn ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else
        return null;
    if (e === c5)
      if (o = i.get("EXT_texture_compression_bptc"), o !== null) {
        if (e === c5) return l === hn ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else
        return null;
    if (e === sRe || e === Jpe || e === efe || e === tfe)
      if (o = i.get("EXT_texture_compression_rgtc"), o !== null) {
        if (e === c5) return o.COMPRESSED_RED_RGTC1_EXT;
        if (e === Jpe) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (e === efe) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (e === tfe) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else
        return null;
    return e === Xp ? n.UNSIGNED_INT_24_8 : n[e] !== void 0 ? n[e] : null;
  }
  /**
   * This method can be used to synchronize the CPU with the GPU by waiting until
   * ongoing GPU commands have been completed.
   *
   * @private
   * @return {Promise} A promise that resolves when all ongoing GPU commands have been completed.
   */
  _clientWaitAsync() {
    const { gl: e } = this, t = e.fenceSync(e.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return e.flush(), new Promise((n, i) => {
      function o() {
        const l = e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0);
        if (l === e.WAIT_FAILED) {
          e.deleteSync(t), i();
          return;
        }
        if (l === e.TIMEOUT_EXPIRED) {
          requestAnimationFrame(o);
          return;
        }
        e.deleteSync(t), n();
      }
      o();
    });
  }
}
let Lme = !1, QN, cV, jme;
class t3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = e.gl, this.extensions = e.extensions, this.defaultTextures = {}, Lme === !1 && (this._init(), Lme = !0);
  }
  /**
   * Inits the state of the utility.
   *
   * @private
   */
  _init() {
    const e = this.gl;
    QN = {
      [Vb]: e.REPEAT,
      [Kp]: e.CLAMP_TO_EDGE,
      [Gb]: e.MIRRORED_REPEAT
    }, cV = {
      [$i]: e.NEAREST,
      [pye]: e.NEAREST_MIPMAP_NEAREST,
      [EE]: e.NEAREST_MIPMAP_LINEAR,
      [Ea]: e.LINEAR,
      [UV]: e.LINEAR_MIPMAP_NEAREST,
      [Ud]: e.LINEAR_MIPMAP_LINEAR
    }, jme = {
      [mye]: e.NEVER,
      [_ye]: e.ALWAYS,
      [D6]: e.LESS,
      [yye]: e.LEQUAL,
      [gye]: e.EQUAL,
      [xye]: e.GEQUAL,
      [vye]: e.GREATER,
      [bye]: e.NOTEQUAL
    };
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {GLenum} The native texture type.
   */
  getGLTextureType(e) {
    const { gl: t } = this;
    let n;
    return e.isCubeTexture === !0 ? n = t.TEXTURE_CUBE_MAP : e.isArrayTexture === !0 || e.isDataArrayTexture === !0 || e.isCompressedArrayTexture === !0 ? n = t.TEXTURE_2D_ARRAY : e.isData3DTexture === !0 ? n = t.TEXTURE_3D : n = t.TEXTURE_2D, n;
  }
  /**
   * Returns the native texture type for the given texture.
   *
   * @param {?string} internalFormatName - The internal format name. When `null`, the internal format is derived from the subsequent parameters.
   * @param {GLenum} glFormat - The WebGL format.
   * @param {GLenum} glType - The WebGL type.
   * @param {string} colorSpace - The texture's color space.
   * @param {boolean} [forceLinearTransfer=false] - Whether to force a linear transfer or not.
   * @return {GLenum} The internal format.
   */
  getInternalFormat(e, t, n, i, o = !1) {
    const { gl: l, extensions: p } = this;
    if (e !== null) {
      if (l[e] !== void 0) return l[e];
      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + e + "'");
    }
    let f = t;
    if (t === l.RED && (n === l.FLOAT && (f = l.R32F), n === l.HALF_FLOAT && (f = l.R16F), n === l.UNSIGNED_BYTE && (f = l.R8), n === l.UNSIGNED_SHORT && (f = l.R16), n === l.UNSIGNED_INT && (f = l.R32UI), n === l.BYTE && (f = l.R8I), n === l.SHORT && (f = l.R16I), n === l.INT && (f = l.R32I)), t === l.RED_INTEGER && (n === l.UNSIGNED_BYTE && (f = l.R8UI), n === l.UNSIGNED_SHORT && (f = l.R16UI), n === l.UNSIGNED_INT && (f = l.R32UI), n === l.BYTE && (f = l.R8I), n === l.SHORT && (f = l.R16I), n === l.INT && (f = l.R32I)), t === l.RG && (n === l.FLOAT && (f = l.RG32F), n === l.HALF_FLOAT && (f = l.RG16F), n === l.UNSIGNED_BYTE && (f = l.RG8), n === l.UNSIGNED_SHORT && (f = l.RG16), n === l.UNSIGNED_INT && (f = l.RG32UI), n === l.BYTE && (f = l.RG8I), n === l.SHORT && (f = l.RG16I), n === l.INT && (f = l.RG32I)), t === l.RG_INTEGER && (n === l.UNSIGNED_BYTE && (f = l.RG8UI), n === l.UNSIGNED_SHORT && (f = l.RG16UI), n === l.UNSIGNED_INT && (f = l.RG32UI), n === l.BYTE && (f = l.RG8I), n === l.SHORT && (f = l.RG16I), n === l.INT && (f = l.RG32I)), t === l.RGB) {
      const v = o ? NO : Ir.getTransfer(i);
      n === l.FLOAT && (f = l.RGB32F), n === l.HALF_FLOAT && (f = l.RGB16F), n === l.UNSIGNED_BYTE && (f = l.RGB8), n === l.UNSIGNED_SHORT && (f = l.RGB16), n === l.UNSIGNED_INT && (f = l.RGB32UI), n === l.BYTE && (f = l.RGB8I), n === l.SHORT && (f = l.RGB16I), n === l.INT && (f = l.RGB32I), n === l.UNSIGNED_BYTE && (f = v === hn ? l.SRGB8 : l.RGB8), n === l.UNSIGNED_SHORT_5_6_5 && (f = l.RGB565), n === l.UNSIGNED_SHORT_5_5_5_1 && (f = l.RGB5_A1), n === l.UNSIGNED_SHORT_4_4_4_4 && (f = l.RGB4), n === l.UNSIGNED_INT_5_9_9_9_REV && (f = l.RGB9_E5);
    }
    if (t === l.RGB_INTEGER && (n === l.UNSIGNED_BYTE && (f = l.RGB8UI), n === l.UNSIGNED_SHORT && (f = l.RGB16UI), n === l.UNSIGNED_INT && (f = l.RGB32UI), n === l.BYTE && (f = l.RGB8I), n === l.SHORT && (f = l.RGB16I), n === l.INT && (f = l.RGB32I)), t === l.RGBA) {
      const v = o ? NO : Ir.getTransfer(i);
      n === l.FLOAT && (f = l.RGBA32F), n === l.HALF_FLOAT && (f = l.RGBA16F), n === l.UNSIGNED_BYTE && (f = l.RGBA8), n === l.UNSIGNED_SHORT && (f = l.RGBA16), n === l.UNSIGNED_INT && (f = l.RGBA32UI), n === l.BYTE && (f = l.RGBA8I), n === l.SHORT && (f = l.RGBA16I), n === l.INT && (f = l.RGBA32I), n === l.UNSIGNED_BYTE && (f = v === hn ? l.SRGB8_ALPHA8 : l.RGBA8), n === l.UNSIGNED_SHORT_4_4_4_4 && (f = l.RGBA4), n === l.UNSIGNED_SHORT_5_5_5_1 && (f = l.RGB5_A1);
    }
    return t === l.RGBA_INTEGER && (n === l.UNSIGNED_BYTE && (f = l.RGBA8UI), n === l.UNSIGNED_SHORT && (f = l.RGBA16UI), n === l.UNSIGNED_INT && (f = l.RGBA32UI), n === l.BYTE && (f = l.RGBA8I), n === l.SHORT && (f = l.RGBA16I), n === l.INT && (f = l.RGBA32I)), t === l.DEPTH_COMPONENT && (n === l.UNSIGNED_SHORT && (f = l.DEPTH_COMPONENT16), n === l.UNSIGNED_INT && (f = l.DEPTH_COMPONENT24), n === l.FLOAT && (f = l.DEPTH_COMPONENT32F)), t === l.DEPTH_STENCIL && n === l.UNSIGNED_INT_24_8 && (f = l.DEPTH24_STENCIL8), (f === l.R16F || f === l.R32F || f === l.RG16F || f === l.RG32F || f === l.RGBA16F || f === l.RGBA32F) && p.get("EXT_color_buffer_float"), f;
  }
  /**
   * Sets the texture parameters for the given texture.
   *
   * @param {GLenum} textureType - The texture type.
   * @param {Texture} texture - The texture.
   */
  setTextureParameters(e, t) {
    const { gl: n, extensions: i, backend: o } = this, l = Ir.getPrimaries(Ir.workingColorSpace), p = t.colorSpace === $d ? null : Ir.getPrimaries(t.colorSpace), f = t.colorSpace === $d || l === p ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
    n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, t.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, t.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, f), n.texParameteri(e, n.TEXTURE_WRAP_S, QN[t.wrapS]), n.texParameteri(e, n.TEXTURE_WRAP_T, QN[t.wrapT]), (e === n.TEXTURE_3D || e === n.TEXTURE_2D_ARRAY) && (t.isArrayTexture || n.texParameteri(e, n.TEXTURE_WRAP_R, QN[t.wrapR])), n.texParameteri(e, n.TEXTURE_MAG_FILTER, cV[t.magFilter]);
    const v = t.mipmaps !== void 0 && t.mipmaps.length > 0, _ = t.minFilter === Ea && v ? Ud : t.minFilter;
    if (n.texParameteri(e, n.TEXTURE_MIN_FILTER, cV[_]), t.compareFunction && (n.texParameteri(e, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(e, n.TEXTURE_COMPARE_FUNC, jme[t.compareFunction])), i.has("EXT_texture_filter_anisotropic") === !0) {
      if (t.magFilter === $i || t.minFilter !== EE && t.minFilter !== Ud || t.type === wa && i.has("OES_texture_float_linear") === !1) return;
      if (t.anisotropy > 1) {
        const E = i.get("EXT_texture_filter_anisotropic");
        n.texParameterf(e, E.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, o.getMaxAnisotropy()));
      }
    }
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    const { gl: t, backend: n, defaultTextures: i } = this, o = this.getGLTextureType(e);
    let l = i[o];
    l === void 0 && (l = t.createTexture(), n.state.bindTexture(o, l), t.texParameteri(o, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(o, t.TEXTURE_MAG_FILTER, t.NEAREST), i[o] = l), n.set(e, {
      textureGPU: l,
      glTextureType: o,
      isDefault: !0
    });
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   * @return {undefined}
   */
  createTexture(e, t) {
    const { gl: n, backend: i } = this, { levels: o, width: l, height: p, depth: f } = t, v = i.utils.convert(e.format, e.colorSpace), _ = i.utils.convert(e.type), E = this.getInternalFormat(e.internalFormat, v, _, e.colorSpace, e.isVideoTexture), A = n.createTexture(), I = this.getGLTextureType(e);
    i.state.bindTexture(I, A), this.setTextureParameters(I, e), e.isArrayTexture || e.isDataArrayTexture || e.isCompressedArrayTexture ? n.texStorage3D(n.TEXTURE_2D_ARRAY, o, E, l, p, f) : e.isData3DTexture ? n.texStorage3D(n.TEXTURE_3D, o, E, l, p, f) : e.isVideoTexture || n.texStorage2D(I, o, E, l, p), i.set(e, {
      textureGPU: A,
      glTextureType: I,
      glFormat: v,
      glType: _,
      glInternalFormat: E
    });
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @param {WebGLBuffer} buffer - The buffer data.
   * @param {Texture} texture - The texture,
   */
  copyBufferToTexture(e, t) {
    const { gl: n, backend: i } = this, { textureGPU: o, glTextureType: l, glFormat: p, glType: f } = i.get(t), { width: v, height: _ } = t.source.data;
    n.bindBuffer(n.PIXEL_UNPACK_BUFFER, e), i.state.bindTexture(l, o), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, !1), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, !1), n.texSubImage2D(l, 0, 0, 0, v, _, p, f, 0), n.bindBuffer(n.PIXEL_UNPACK_BUFFER, null), i.state.unbindTexture();
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    const { gl: n } = this, { width: i, height: o } = t, { textureGPU: l, glTextureType: p, glFormat: f, glType: v, glInternalFormat: _ } = this.backend.get(e);
    if (!(e.isRenderTargetTexture || l === void 0))
      if (this.backend.state.bindTexture(p, l), this.setTextureParameters(p, e), e.isCompressedTexture) {
        const E = e.mipmaps, A = t.image;
        for (let I = 0; I < E.length; I++) {
          const j = E[I];
          e.isCompressedArrayTexture ? e.format !== n.RGBA ? f !== null ? n.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, I, 0, 0, 0, j.width, j.height, A.depth, f, j.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : n.texSubImage3D(n.TEXTURE_2D_ARRAY, I, 0, 0, 0, j.width, j.height, A.depth, f, v, j.data) : f !== null ? n.compressedTexSubImage2D(n.TEXTURE_2D, I, 0, 0, j.width, j.height, f, j.data) : console.warn("Unsupported compressed texture format");
        }
      } else if (e.isCubeTexture) {
        const E = t.images;
        for (let A = 0; A < 6; A++) {
          const I = Ume(E[A]);
          n.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + A, 0, 0, 0, i, o, f, v, I);
        }
      } else if (e.isDataArrayTexture || e.isArrayTexture) {
        const E = t.image;
        n.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, E.width, E.height, E.depth, f, v, E.data);
      } else if (e.isData3DTexture) {
        const E = t.image;
        n.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, E.width, E.height, E.depth, f, v, E.data);
      } else if (e.isVideoTexture)
        e.update(), n.texImage2D(p, 0, _, f, v, t.image);
      else {
        const E = Ume(t.image);
        n.texSubImage2D(p, 0, 0, 0, i, o, f, v, E);
      }
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    const { gl: t, backend: n } = this, { textureGPU: i, glTextureType: o } = n.get(e);
    n.state.bindTexture(o, i), t.generateMipmap(o);
  }
  /**
   * Deallocates the render buffers of the given render target.
   *
   * @param {RenderTarget} renderTarget - The render target.
   */
  deallocateRenderBuffers(e) {
    const { gl: t, backend: n } = this;
    if (e) {
      const i = n.get(e);
      if (i.renderBufferStorageSetup = void 0, i.framebuffers) {
        for (const o in i.framebuffers)
          t.deleteFramebuffer(i.framebuffers[o]);
        delete i.framebuffers;
      }
      if (i.depthRenderbuffer && (t.deleteRenderbuffer(i.depthRenderbuffer), delete i.depthRenderbuffer), i.stencilRenderbuffer && (t.deleteRenderbuffer(i.stencilRenderbuffer), delete i.stencilRenderbuffer), i.msaaFrameBuffer && (t.deleteFramebuffer(i.msaaFrameBuffer), delete i.msaaFrameBuffer), i.msaaRenderbuffers) {
        for (let o = 0; o < i.msaaRenderbuffers.length; o++)
          t.deleteRenderbuffer(i.msaaRenderbuffers[o]);
        delete i.msaaRenderbuffers;
      }
    }
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(e) {
    const { gl: t, backend: n } = this, { textureGPU: i, renderTarget: o } = n.get(e);
    this.deallocateRenderBuffers(o), t.deleteTexture(i), n.delete(e);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, i = null, o = 0, l = 0) {
    const { gl: p, backend: f } = this, { state: v } = this.backend, { textureGPU: _, glTextureType: E, glType: A, glFormat: I } = f.get(t);
    v.bindTexture(E, _);
    let j, q, L, V, re, R, J, ge, _e;
    const Y = e.isCompressedTexture ? e.mipmaps[l] : e.image;
    if (n !== null)
      j = n.max.x - n.min.x, q = n.max.y - n.min.y, L = n.isBox3 ? n.max.z - n.min.z : 1, V = n.min.x, re = n.min.y, R = n.isBox3 ? n.min.z : 0;
    else {
      const Ct = Math.pow(2, -o);
      j = Math.floor(Y.width * Ct), q = Math.floor(Y.height * Ct), e.isDataArrayTexture || e.isArrayTexture ? L = Y.depth : e.isData3DTexture ? L = Math.floor(Y.depth * Ct) : L = 1, V = 0, re = 0, R = 0;
    }
    i !== null ? (J = i.x, ge = i.y, _e = i.z) : (J = 0, ge = 0, _e = 0), p.pixelStorei(p.UNPACK_FLIP_Y_WEBGL, t.flipY), p.pixelStorei(p.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultiplyAlpha), p.pixelStorei(p.UNPACK_ALIGNMENT, t.unpackAlignment);
    const Fe = p.getParameter(p.UNPACK_ROW_LENGTH), Me = p.getParameter(p.UNPACK_IMAGE_HEIGHT), $ = p.getParameter(p.UNPACK_SKIP_PIXELS), dt = p.getParameter(p.UNPACK_SKIP_ROWS), wt = p.getParameter(p.UNPACK_SKIP_IMAGES);
    p.pixelStorei(p.UNPACK_ROW_LENGTH, Y.width), p.pixelStorei(p.UNPACK_IMAGE_HEIGHT, Y.height), p.pixelStorei(p.UNPACK_SKIP_PIXELS, V), p.pixelStorei(p.UNPACK_SKIP_ROWS, re), p.pixelStorei(p.UNPACK_SKIP_IMAGES, R);
    const St = t.isDataArrayTexture || t.isData3DTexture || t.isArrayTexture;
    if (e.isRenderTargetTexture || e.isDepthTexture) {
      const Ct = f.get(e), pe = f.get(t), Tt = f.get(Ct.renderTarget), st = f.get(pe.renderTarget), Zt = Tt.framebuffers[Ct.cacheKey], $t = st.framebuffers[pe.cacheKey];
      v.bindFramebuffer(p.READ_FRAMEBUFFER, Zt), v.bindFramebuffer(p.DRAW_FRAMEBUFFER, $t);
      let Ht = p.COLOR_BUFFER_BIT;
      e.isDepthTexture && (Ht = p.DEPTH_BUFFER_BIT), p.blitFramebuffer(V, re, j, q, J, ge, j, q, Ht, p.NEAREST), v.bindFramebuffer(p.READ_FRAMEBUFFER, null), v.bindFramebuffer(p.DRAW_FRAMEBUFFER, null);
    } else
      St ? e.isDataTexture || e.isData3DTexture ? p.texSubImage3D(E, l, J, ge, _e, j, q, L, I, A, Y.data) : t.isCompressedArrayTexture ? p.compressedTexSubImage3D(E, l, J, ge, _e, j, q, L, I, Y.data) : p.texSubImage3D(E, l, J, ge, _e, j, q, L, I, A, Y) : e.isDataTexture ? p.texSubImage2D(E, l, J, ge, j, q, I, A, Y.data) : e.isCompressedTexture ? p.compressedTexSubImage2D(E, l, J, ge, Y.width, Y.height, I, Y.data) : p.texSubImage2D(E, l, J, ge, j, q, I, A, Y);
    p.pixelStorei(p.UNPACK_ROW_LENGTH, Fe), p.pixelStorei(p.UNPACK_IMAGE_HEIGHT, Me), p.pixelStorei(p.UNPACK_SKIP_PIXELS, $), p.pixelStorei(p.UNPACK_SKIP_ROWS, dt), p.pixelStorei(p.UNPACK_SKIP_IMAGES, wt), l === 0 && t.generateMipmaps && p.generateMipmap(E), v.unbindTexture();
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    const { gl: i } = this, { state: o } = this.backend, { textureGPU: l } = this.backend.get(e), { x: p, y: f, z: v, w: _ } = n, E = e.isDepthTexture === !0 || t.renderTarget && t.renderTarget.samples > 0, A = t.renderTarget ? t.renderTarget.height : this.backend.getDrawingBufferSize().y;
    if (E) {
      const I = p !== 0 || f !== 0;
      let j, q;
      if (e.isDepthTexture === !0 ? (j = i.DEPTH_BUFFER_BIT, q = i.DEPTH_ATTACHMENT, t.stencil && (j |= i.STENCIL_BUFFER_BIT)) : (j = i.COLOR_BUFFER_BIT, q = i.COLOR_ATTACHMENT0), I) {
        const L = this.backend.get(t.renderTarget), V = L.framebuffers[t.getCacheKey()], re = L.msaaFrameBuffer;
        o.bindFramebuffer(i.DRAW_FRAMEBUFFER, V), o.bindFramebuffer(i.READ_FRAMEBUFFER, re);
        const R = A - f - _;
        i.blitFramebuffer(p, R, p + v, R + _, p, R, p + v, R + _, j, i.NEAREST), o.bindFramebuffer(i.READ_FRAMEBUFFER, V), o.bindTexture(i.TEXTURE_2D, l), i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, p, R, v, _), o.unbindTexture();
      } else {
        const L = i.createFramebuffer();
        o.bindFramebuffer(i.DRAW_FRAMEBUFFER, L), i.framebufferTexture2D(i.DRAW_FRAMEBUFFER, q, i.TEXTURE_2D, l, 0), i.blitFramebuffer(0, 0, v, _, 0, 0, v, _, j, i.NEAREST), i.deleteFramebuffer(L);
      }
    } else
      o.bindTexture(i.TEXTURE_2D, l), i.copyTexSubImage2D(i.TEXTURE_2D, 0, 0, 0, p, A - _ - f, v, _), o.unbindTexture();
    e.generateMipmaps && this.generateMipmaps(e), this.backend._setFramebuffer(t);
  }
  /**
   * SetupS storage for internal depth/stencil buffers and bind to correct framebuffer.
   *
   * @param {WebGLRenderbuffer} renderbuffer - The render buffer.
   * @param {RenderContext} renderContext - The render context.
   * @param {number} samples - The MSAA sample count.
   * @param {boolean} [useMultisampledRTT=false] - Whether to use WEBGL_multisampled_render_to_texture or not.
   */
  setupRenderBufferStorage(e, t, n, i = !1) {
    const { gl: o } = this, l = t.renderTarget, { depthTexture: p, depthBuffer: f, stencilBuffer: v, width: _, height: E } = l;
    if (o.bindRenderbuffer(o.RENDERBUFFER, e), f && !v) {
      let A = o.DEPTH_COMPONENT24;
      i === !0 ? this.extensions.get("WEBGL_multisampled_render_to_texture").renderbufferStorageMultisampleEXT(o.RENDERBUFFER, l.samples, A, _, E) : n > 0 ? (p && p.isDepthTexture && p.type === o.FLOAT && (A = o.DEPTH_COMPONENT32F), o.renderbufferStorageMultisample(o.RENDERBUFFER, n, A, _, E)) : o.renderbufferStorage(o.RENDERBUFFER, A, _, E), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_ATTACHMENT, o.RENDERBUFFER, e);
    } else f && v && (n > 0 ? o.renderbufferStorageMultisample(o.RENDERBUFFER, n, o.DEPTH24_STENCIL8, _, E) : o.renderbufferStorage(o.RENDERBUFFER, o.DEPTH_STENCIL, _, E), o.framebufferRenderbuffer(o.FRAMEBUFFER, o.DEPTH_STENCIL_ATTACHMENT, o.RENDERBUFFER, e));
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, i, o, l) {
    const { backend: p, gl: f } = this, { textureGPU: v, glFormat: _, glType: E } = this.backend.get(e), A = f.createFramebuffer();
    f.bindFramebuffer(f.READ_FRAMEBUFFER, A);
    const I = e.isCubeTexture ? f.TEXTURE_CUBE_MAP_POSITIVE_X + l : f.TEXTURE_2D;
    f.framebufferTexture2D(f.READ_FRAMEBUFFER, f.COLOR_ATTACHMENT0, I, v, 0);
    const j = this._getTypedArrayType(E), q = this._getBytesPerTexel(E, _), V = i * o * q, re = f.createBuffer();
    f.bindBuffer(f.PIXEL_PACK_BUFFER, re), f.bufferData(f.PIXEL_PACK_BUFFER, V, f.STREAM_READ), f.readPixels(t, n, i, o, _, E, 0), f.bindBuffer(f.PIXEL_PACK_BUFFER, null), await p.utils._clientWaitAsync();
    const R = new j(V / j.BYTES_PER_ELEMENT);
    return f.bindBuffer(f.PIXEL_PACK_BUFFER, re), f.getBufferSubData(f.PIXEL_PACK_BUFFER, 0, R), f.bindBuffer(f.PIXEL_PACK_BUFFER, null), f.deleteFramebuffer(A), R;
  }
  /**
   * Returns the corresponding typed array type for the given WebGL data type.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(e) {
    const { gl: t } = this;
    if (e === t.UNSIGNED_BYTE) return Uint8Array;
    if (e === t.UNSIGNED_SHORT_4_4_4_4 || e === t.UNSIGNED_SHORT_5_5_5_1 || e === t.UNSIGNED_SHORT_5_6_5 || e === t.UNSIGNED_SHORT) return Uint16Array;
    if (e === t.UNSIGNED_INT) return Uint32Array;
    if (e === t.HALF_FLOAT) return Uint16Array;
    if (e === t.FLOAT) return Float32Array;
    throw new Error(`Unsupported WebGL type: ${e}`);
  }
  /**
   * Returns the bytes-per-texel value for the given WebGL data type and texture format.
   *
   * @private
   * @param {GLenum} glType - The WebGL data type.
   * @param {GLenum} glFormat - The WebGL texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(e, t) {
    const { gl: n } = this;
    let i = 0;
    if (e === n.UNSIGNED_BYTE && (i = 1), (e === n.UNSIGNED_SHORT_4_4_4_4 || e === n.UNSIGNED_SHORT_5_5_5_1 || e === n.UNSIGNED_SHORT_5_6_5 || e === n.UNSIGNED_SHORT || e === n.HALF_FLOAT) && (i = 2), (e === n.UNSIGNED_INT || e === n.FLOAT) && (i = 4), t === n.RGBA) return i * 4;
    if (t === n.RGB) return i * 3;
    if (t === n.ALPHA) return i;
  }
}
function Ume(c) {
  return c.isDataTexture ? c.image.data : typeof HTMLImageElement < "u" && c instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && c instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && c instanceof ImageBitmap || typeof OffscreenCanvas < "u" && c instanceof OffscreenCanvas ? c : c.data;
}
class n3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.gl = this.backend.gl, this.availableExtensions = this.gl.getSupportedExtensions(), this.extensions = {};
  }
  /**
   * Returns the extension object for the given extension name.
   *
   * @param {string} name - The extension name.
   * @return {Object} The extension object.
   */
  get(e) {
    let t = this.extensions[e];
    return t === void 0 && (t = this.gl.getExtension(e), this.extensions[e] = t), t;
  }
  /**
   * Returns `true` if the requested extension is available.
   *
   * @param {string} name - The extension name.
   * @return {boolean} Whether the given extension is available or not.
   */
  has(e) {
    return this.availableExtensions.includes(e);
  }
}
class r3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGLBackend} backend - The WebGL 2 backend.
   */
  constructor(e) {
    this.backend = e, this.maxAnisotropy = null;
  }
  /**
   * Returns the maximum anisotropy texture filtering value. This value
   * depends on the device and is reported by the `EXT_texture_filter_anisotropic`
   * WebGL extension.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    if (this.maxAnisotropy !== null) return this.maxAnisotropy;
    const e = this.backend.gl, t = this.backend.extensions;
    if (t.has("EXT_texture_filter_anisotropic") === !0) {
      const n = t.get("EXT_texture_filter_anisotropic");
      this.maxAnisotropy = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else
      this.maxAnisotropy = 0;
    return this.maxAnisotropy;
  }
}
const zme = {
  WEBGL_multi_draw: "WEBGL_multi_draw",
  WEBGL_compressed_texture_astc: "texture-compression-astc",
  WEBGL_compressed_texture_etc: "texture-compression-etc2",
  WEBGL_compressed_texture_etc1: "texture-compression-etc1",
  WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBKIT_WEBGL_compressed_texture_pvrtc: "texture-compression-pvrtc",
  WEBGL_compressed_texture_s3tc: "texture-compression-bc",
  EXT_texture_compression_bptc: "texture-compression-bptc",
  EXT_disjoint_timer_query_webgl2: "timestamp-query",
  OVR_multiview2: "OVR_multiview2"
};
class i3e {
  constructor(e) {
    this.gl = e.gl, this.extensions = e.extensions, this.info = e.renderer.info, this.mode = null, this.index = 0, this.type = null, this.object = null;
  }
  render(e, t) {
    const { gl: n, mode: i, object: o, type: l, info: p, index: f } = this;
    f !== 0 ? n.drawElements(i, t, l, e) : n.drawArrays(i, e, t), p.update(o, t, 1);
  }
  renderInstances(e, t, n) {
    const { gl: i, mode: o, type: l, index: p, object: f, info: v } = this;
    n !== 0 && (p !== 0 ? i.drawElementsInstanced(o, t, l, e, n) : i.drawArraysInstanced(o, e, t, n), v.update(f, t, n));
  }
  renderMultiDraw(e, t, n) {
    const { extensions: i, mode: o, object: l, info: p } = this;
    if (n === 0) return;
    const f = i.get("WEBGL_multi_draw");
    if (f === null)
      for (let v = 0; v < n; v++)
        this.render(e[v], t[v]);
    else {
      this.index !== 0 ? f.multiDrawElementsWEBGL(o, t, 0, this.type, e, 0, n) : f.multiDrawArraysWEBGL(o, e, 0, t, 0, n);
      let v = 0;
      for (let _ = 0; _ < n; _++)
        v += t[_];
      p.update(l, v, 1);
    }
  }
  renderMultiDrawInstances(e, t, n, i) {
    const { extensions: o, mode: l, object: p, info: f } = this;
    if (n === 0) return;
    const v = o.get("WEBGL_multi_draw");
    if (v === null)
      for (let _ = 0; _ < n; _++)
        this.renderInstances(e[_], t[_], i[_]);
    else {
      this.index !== 0 ? v.multiDrawElementsInstancedWEBGL(l, t, 0, this.type, e, 0, i, 0, n) : v.multiDrawArraysInstancedWEBGL(l, e, 0, t, 0, i, 0, n);
      let _ = 0;
      for (let E = 0; E < n; E++)
        _ += t[E] * i[E];
      f.update(p, _, 1);
    }
  }
  //
}
class mve {
  /**
   * Creates a new timestamp query pool.
   *
   * @param {number} [maxQueries=256] - Maximum number of queries this pool can hold.
   */
  constructor(e = 256) {
    this.trackTimestamp = !0, this.maxQueries = e, this.currentQueryIndex = 0, this.queryOffsets = /* @__PURE__ */ new Map(), this.isDisposed = !1, this.lastValue = 0, this.pendingResolve = !1;
  }
  /**
   * Allocate queries for a specific renderContext.
   *
   * @abstract
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number}
   */
  allocateQueriesForContext() {
  }
  /**
   * Resolve all timestamps and return data (or process them).
   *
   * @abstract
   * @async
   * @returns {Promise<number>|number} The resolved timestamp value.
   */
  async resolveQueriesAsync() {
  }
  /**
   * Dispose of the query pool.
   *
   * @abstract
   */
  dispose() {
  }
}
class s3e extends mve {
  /**
   * Creates a new WebGL timestamp query pool.
   *
   * @param {WebGLRenderingContext|WebGL2RenderingContext} gl - The WebGL context.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(e, t, n = 2048) {
    if (super(n), this.gl = e, this.type = t, this.ext = e.getExtension("EXT_disjoint_timer_query_webgl2") || e.getExtension("EXT_disjoint_timer_query"), !this.ext) {
      console.warn("EXT_disjoint_timer_query not supported; timestamps will be disabled."), this.trackTimestamp = !1;
      return;
    }
    this.queries = [];
    for (let i = 0; i < this.maxQueries; i++)
      this.queries.push(e.createQuery());
    this.activeQuery = null, this.queryStates = /* @__PURE__ */ new Map();
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(e) {
    if (!this.trackTimestamp) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries)
      return Wd(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`), null;
    const t = this.currentQueryIndex;
    return this.currentQueryIndex += 2, this.queryStates.set(t, "inactive"), this.queryOffsets.set(e.id, t), t;
  }
  /**
   * Begins a timestamp query for the specified render context.
   *
   * @param {Object} renderContext - The render context to begin timing for.
   */
  beginQuery(e) {
    if (!this.trackTimestamp || this.isDisposed)
      return;
    const t = this.queryOffsets.get(e.id);
    if (t == null || this.activeQuery !== null)
      return;
    const n = this.queries[t];
    if (n)
      try {
        this.queryStates.get(t) === "inactive" && (this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, n), this.activeQuery = t, this.queryStates.set(t, "started"));
      } catch (i) {
        console.error("Error in beginQuery:", i), this.activeQuery = null, this.queryStates.set(t, "inactive");
      }
  }
  /**
   * Ends the active timestamp query for the specified render context.
   *
   * @param {Object} renderContext - The render context to end timing for.
   * @param {string} renderContext.id - Unique identifier for the render context.
   */
  endQuery(e) {
    if (!this.trackTimestamp || this.isDisposed)
      return;
    const t = this.queryOffsets.get(e.id);
    if (t != null && this.activeQuery === t)
      try {
        this.gl.endQuery(this.ext.TIME_ELAPSED_EXT), this.queryStates.set(t, "ended"), this.activeQuery = null;
      } catch (n) {
        console.error("Error in endQuery:", n), this.queryStates.set(t, "inactive"), this.activeQuery = null;
      }
  }
  /**
   * Asynchronously resolves all completed queries and returns the total duration.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.pendingResolve)
      return this.lastValue;
    this.pendingResolve = !0;
    try {
      const e = [];
      for (const [i, o] of this.queryStates)
        if (o === "ended") {
          const l = this.queries[i];
          e.push(this.resolveQuery(l));
        }
      if (e.length === 0)
        return this.lastValue;
      const n = (await Promise.all(e)).reduce((i, o) => i + o, 0);
      return this.lastValue = n, this.currentQueryIndex = 0, this.queryOffsets.clear(), this.queryStates.clear(), this.activeQuery = null, n;
    } catch (e) {
      return console.error("Error resolving queries:", e), this.lastValue;
    } finally {
      this.pendingResolve = !1;
    }
  }
  /**
   * Resolves a single query, checking for completion and disjoint operation.
   *
   * @async
   * @param {WebGLQuery} query - The query object to resolve.
   * @returns {Promise<number>} The elapsed time in milliseconds.
   */
  async resolveQuery(e) {
    return new Promise((t) => {
      if (this.isDisposed) {
        t(this.lastValue);
        return;
      }
      let n, i = !1;
      const o = () => {
        n && (clearTimeout(n), n = null);
      }, l = (f) => {
        i || (i = !0, o(), t(f));
      }, p = () => {
        if (this.isDisposed) {
          l(this.lastValue);
          return;
        }
        try {
          if (this.gl.getParameter(this.ext.GPU_DISJOINT_EXT)) {
            l(this.lastValue);
            return;
          }
          if (!this.gl.getQueryParameter(e, this.gl.QUERY_RESULT_AVAILABLE)) {
            n = setTimeout(p, 1);
            return;
          }
          const _ = this.gl.getQueryParameter(e, this.gl.QUERY_RESULT);
          t(Number(_) / 1e6);
        } catch (f) {
          console.error("Error checking query:", f), t(this.lastValue);
        }
      };
      p();
    });
  }
  /**
   * Releases all resources held by this query pool.
   * This includes deleting all query objects and clearing internal state.
   */
  dispose() {
    if (!this.isDisposed && (this.isDisposed = !0, !!this.trackTimestamp)) {
      for (const e of this.queries)
        this.gl.deleteQuery(e);
      this.queries = [], this.queryStates.clear(), this.queryOffsets.clear(), this.lastValue = 0, this.activeQuery = null;
    }
  }
}
const Vme = /* @__PURE__ */ new Pn();
class Gme extends fve {
  /**
   * WebGLBackend options.
   *
   * @typedef {Object} WebGLBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {WebGL2RenderingContext} [context=undefined] - A WebGL 2 rendering context.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGLBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    super(e), this.isWebGLBackend = !0, this.attributeUtils = null, this.extensions = null, this.capabilities = null, this.textureUtils = null, this.bufferRenderer = null, this.gl = null, this.state = null, this.utils = null, this.vaoCache = {}, this.transformFeedbackCache = {}, this.discard = !1, this.disjoint = null, this.parallel = null, this._currentContext = null, this._knownBindings = /* @__PURE__ */ new WeakSet(), this._supportsInvalidateFramebuffer = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), this._xrFramebuffer = null;
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @param {Renderer} renderer - The renderer.
   */
  init(e) {
    super.init(e);
    const t = this.parameters, n = {
      antialias: e.samples > 0,
      alpha: !0,
      // always true for performance reasons
      depth: e.depth,
      stencil: e.stencil
    }, i = t.context !== void 0 ? t.context : e.domElement.getContext("webgl2", n);
    function o(l) {
      l.preventDefault();
      const p = {
        api: "WebGL",
        message: l.statusMessage || "Unknown reason",
        reason: null,
        originalEvent: l
      };
      e.onDeviceLost(p);
    }
    this._onContextLost = o, e.domElement.addEventListener("webglcontextlost", o, !1), this.gl = i, this.extensions = new n3e(this), this.capabilities = new r3e(this), this.attributeUtils = new ZLe(this), this.textureUtils = new t3e(this), this.bufferRenderer = new i3e(this), this.state = new JLe(this), this.utils = new e3e(this), this.extensions.get("EXT_color_buffer_float"), this.extensions.get("WEBGL_clip_cull_distance"), this.extensions.get("OES_texture_float_linear"), this.extensions.get("EXT_color_buffer_half_float"), this.extensions.get("WEBGL_multisampled_render_to_texture"), this.extensions.get("WEBGL_render_shared_exponent"), this.extensions.get("WEBGL_multi_draw"), this.extensions.get("OVR_multiview2"), this.disjoint = this.extensions.get("EXT_disjoint_timer_query_webgl2"), this.parallel = this.extensions.get("KHR_parallel_shader_compile");
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return Ho;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.utils._clientWaitAsync();
  }
  /**
   * Ensures the backend is XR compatible.
   *
   * @async
   * @return {Promise} A Promise that resolve when the renderer is XR compatible.
   */
  async makeXRCompatible() {
    this.gl.getContextAttributes().xrCompatible !== !0 && await this.gl.makeXRCompatible();
  }
  /**
   * Sets the XR rendering destination.
   *
   * @param {WebGLFramebuffer} xrFramebuffer - The XR framebuffer.
   */
  setXRTarget(e) {
    this._xrFramebuffer = e;
  }
  /**
   * Configures the given XR render target with external textures.
   *
   * This method is only relevant when using the WebXR Layers API.
   *
   * @param {XRRenderTarget} renderTarget - The XR render target.
   * @param {WebGLTexture} colorTexture - A native color texture.
   * @param {?WebGLTexture} [depthTexture=null] - A native depth texture.
   */
  setXRRenderTargetTextures(e, t, n = null) {
    const i = this.gl;
    if (this.set(e.texture, { textureGPU: t, glInternalFormat: i.RGBA8 }), n !== null) {
      const o = e.stencilBuffer ? i.DEPTH24_STENCIL8 : i.DEPTH_COMPONENT24;
      this.set(e.depthTexture, { textureGPU: n, glInternalFormat: o }), this.extensions.has("WEBGL_multisampled_render_to_texture") === !0 && e.autoAllocateDepthBuffer === !0 && e.multiview === !1 && console.warn("THREE.WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"), e.autoAllocateDepthBuffer = !1;
    }
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  initTimestampQuery(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const t = e.isComputeNode ? "compute" : "render";
    this.timestampQueryPool[t] || (this.timestampQueryPool[t] = new s3e(this.gl, t, 2048));
    const n = this.timestampQueryPool[t];
    n.allocateQueriesForContext(e) !== null && n.beginQuery(e);
  }
  // timestamp utils
  /**
   * Prepares the timestamp buffer.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  prepareTimestampBuffer(e) {
    if (!this.disjoint || !this.trackTimestamp) return;
    const t = e.isComputeNode ? "compute" : "render";
    this.timestampQueryPool[t].endQuery(e);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {WebGL2RenderingContext} The rendering context.
   */
  getContext() {
    return this.gl;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGL state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(e) {
    const { state: t } = this, n = this.get(e);
    if (e.viewport)
      this.updateViewport(e);
    else {
      const { width: o, height: l } = this.getDrawingBufferSize(Vme);
      t.viewport(0, 0, o, l);
    }
    if (e.scissor) {
      const { x: o, y: l, width: p, height: f } = e.scissorValue;
      t.scissor(o, e.height - f - l, p, f);
    }
    this.initTimestampQuery(e), n.previousContext = this._currentContext, this._currentContext = e, this._setFramebuffer(e), this.clear(e.clearColor, e.clearDepth, e.clearStencil, e, !1);
    const i = e.occlusionQueryCount;
    i > 0 && (n.currentOcclusionQueries = n.occlusionQueries, n.currentOcclusionQueryObjects = n.occlusionQueryObjects, n.lastOcclusionObject = null, n.occlusionQueries = new Array(i), n.occlusionQueryObjects = new Array(i), n.occlusionQueryIndex = 0);
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(e) {
    const { gl: t, state: n } = this, i = this.get(e), o = i.previousContext;
    n.resetVertexState();
    const l = e.occlusionQueryCount;
    l > 0 && (l > i.occlusionQueryIndex && t.endQuery(t.ANY_SAMPLES_PASSED), this.resolveOccludedAsync(e));
    const p = e.textures;
    if (p !== null)
      for (let f = 0; f < p.length; f++) {
        const v = p[f];
        v.generateMipmaps && this.generateMipmaps(v);
      }
    if (this._currentContext = o, e.textures !== null && e.renderTarget) {
      const f = this.get(e.renderTarget), { resolveDepthBuffer: v, samples: _ } = e.renderTarget;
      if (_ > 0 && this._useMultisampledExtension(e.renderTarget) === !1) {
        const E = f.framebuffers[e.getCacheKey()], A = t.COLOR_BUFFER_BIT, I = f.msaaFrameBuffer, j = e.textures;
        n.bindFramebuffer(t.READ_FRAMEBUFFER, I), n.bindFramebuffer(t.DRAW_FRAMEBUFFER, E);
        for (let q = 0; q < j.length; q++)
          if (e.scissor) {
            const { x: L, y: V, width: re, height: R } = e.scissorValue, J = e.height - R - V;
            t.blitFramebuffer(L, J, L + re, J + R, L, J, L + re, J + R, A, t.NEAREST), this._supportsInvalidateFramebuffer === !0 && t.invalidateSubFramebuffer(t.READ_FRAMEBUFFER, f.invalidationArray, L, J, re, R);
          } else
            t.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, A, t.NEAREST), this._supportsInvalidateFramebuffer === !0 && t.invalidateFramebuffer(t.READ_FRAMEBUFFER, f.invalidationArray);
      } else if (v === !1 && f.framebuffers) {
        const E = f.framebuffers[e.getCacheKey()];
        n.bindFramebuffer(t.DRAW_FRAMEBUFFER, E), t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER, f.depthInvalidationArray);
      }
    }
    if (o !== null)
      if (this._setFramebuffer(o), o.viewport)
        this.updateViewport(o);
      else {
        const { width: f, height: v } = this.getDrawingBufferSize(Vme);
        n.viewport(0, 0, f, v);
      }
    this.prepareTimestampBuffer(e);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   */
  resolveOccludedAsync(e) {
    const t = this.get(e), { currentOcclusionQueries: n, currentOcclusionQueryObjects: i } = t;
    if (n && i) {
      const o = /* @__PURE__ */ new WeakSet(), { gl: l } = this;
      t.currentOcclusionQueryObjects = null, t.currentOcclusionQueries = null;
      const p = () => {
        let f = 0;
        for (let v = 0; v < n.length; v++) {
          const _ = n[v];
          _ !== null && l.getQueryParameter(_, l.QUERY_RESULT_AVAILABLE) && (l.getQueryParameter(_, l.QUERY_RESULT) === 0 && o.add(i[v]), n[v] = null, l.deleteQuery(_), f++);
        }
        f < n.length ? requestAnimationFrame(p) : t.occluded = o;
      };
      p();
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e, t) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(t);
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(e) {
    const { state: t } = this, { x: n, y: i, width: o, height: l } = e.viewportValue;
    t.viewport(n, e.height - l - i, o, l);
  }
  /**
   * Defines the scissor test.
   *
   * @param {boolean} boolean - Whether the scissor test should be enabled or not.
   */
  setScissorTest(e) {
    this.state.setScissorTest(e);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = super.getClearColor();
    return e.r *= e.a, e.g *= e.a, e.b *= e.a, e;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?Object} [descriptor=null] - The render context of the current set render target.
   * @param {boolean} [setFrameBuffer=true] - TODO.
   */
  clear(e, t, n, i = null, o = !0) {
    const { gl: l, renderer: p } = this;
    i === null && (i = {
      textures: null,
      clearColorValue: this.getClearColor()
    });
    let f = 0;
    if (e && (f |= l.COLOR_BUFFER_BIT), t && (f |= l.DEPTH_BUFFER_BIT), n && (f |= l.STENCIL_BUFFER_BIT), f !== 0) {
      let v;
      i.clearColorValue ? v = i.clearColorValue : v = this.getClearColor();
      const _ = p.getClearDepth(), E = p.getClearStencil();
      if (t && this.state.setDepthMask(!0), i.textures === null)
        l.clearColor(v.r, v.g, v.b, v.a), l.clear(f);
      else {
        if (o && this._setFramebuffer(i), e)
          for (let A = 0; A < i.textures.length; A++)
            A === 0 ? l.clearBufferfv(l.COLOR, A, [v.r, v.g, v.b, v.a]) : l.clearBufferfv(l.COLOR, A, [0, 0, 0, 1]);
        t && n ? l.clearBufferfi(l.DEPTH_STENCIL, 0, _, E) : t ? l.clearBufferfv(l.DEPTH, 0, [_]) : n && l.clearBufferiv(l.STENCIL, 0, [E]);
      }
    }
  }
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(e) {
    const { state: t, gl: n } = this;
    t.bindFramebuffer(n.FRAMEBUFFER, null), this.initTimestampQuery(e);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   */
  compute(e, t, n, i) {
    const { state: o, gl: l } = this;
    this.discard === !1 && (l.enable(l.RASTERIZER_DISCARD), this.discard = !0);
    const { programGPU: p, transformBuffers: f, attributes: v } = this.get(i), _ = this._getVaoKey(v), E = this.vaoCache[_];
    E === void 0 ? this._createVao(v) : o.setVertexState(E), o.useProgram(p), this._bindUniforms(n);
    const A = this._getTransformFeedback(f);
    l.bindTransformFeedback(l.TRANSFORM_FEEDBACK, A), l.beginTransformFeedback(l.POINTS), v[0].isStorageInstancedBufferAttribute ? l.drawArraysInstanced(l.POINTS, 0, 1, t.count) : l.drawArrays(l.POINTS, 0, t.count), l.endTransformFeedback(), l.bindTransformFeedback(l.TRANSFORM_FEEDBACK, null);
    for (let I = 0; I < f.length; I++) {
      const j = f[I];
      j.pbo && this.textureUtils.copyBufferToTexture(j.transformBuffer, j.pbo), j.switchBuffers();
    }
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(e) {
    const t = this.gl;
    this.discard = !1, t.disable(t.RASTERIZER_DISCARD), this.prepareTimestampBuffer(e), this._currentContext && this._setFramebuffer(this._currentContext);
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(e) {
    return e.depthTexture && e.depthTexture.isArrayTexture && e.camera.isArrayCamera;
  }
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(e) {
    const { object: t, pipeline: n, material: i, context: o, hardwareClippingPlanes: l } = e, { programGPU: p } = this.get(n), { gl: f, state: v } = this, _ = this.get(o), E = e.getDrawParameters();
    if (E === null) return;
    this._bindUniforms(e.getBindings());
    const A = t.isMesh && t.matrixWorld.determinant() < 0;
    v.setMaterial(i, A, l), v.useProgram(p);
    const I = this.get(e);
    let j = I.staticVao;
    if (j === void 0 || I.geometryId !== e.geometry.id) {
      const Y = this._getVaoKey(e.getAttributes());
      if (j = this.vaoCache[Y], j === void 0) {
        let Fe;
        ({ vaoGPU: j, staticVao: Fe } = this._createVao(e.getAttributes())), Fe && (I.staticVao = j, I.geometryId = e.geometry.id);
      }
    }
    const q = e.getIndex(), L = q !== null ? this.get(q).bufferGPU : null;
    v.setVertexState(j, L);
    const V = _.lastOcclusionObject;
    if (V !== t && V !== void 0) {
      if (V !== null && V.occlusionTest === !0 && (f.endQuery(f.ANY_SAMPLES_PASSED), _.occlusionQueryIndex++), t.occlusionTest === !0) {
        const Y = f.createQuery();
        f.beginQuery(f.ANY_SAMPLES_PASSED, Y), _.occlusionQueries[_.occlusionQueryIndex] = Y, _.occlusionQueryObjects[_.occlusionQueryIndex] = t;
      }
      _.lastOcclusionObject = t;
    }
    const re = this.bufferRenderer;
    t.isPoints ? re.mode = f.POINTS : t.isLineSegments ? re.mode = f.LINES : t.isLine ? re.mode = f.LINE_STRIP : t.isLineLoop ? re.mode = f.LINE_LOOP : i.wireframe === !0 ? (v.setLineWidth(i.wireframeLinewidth * this.renderer.getPixelRatio()), re.mode = f.LINES) : re.mode = f.TRIANGLES;
    const { vertexCount: R, instanceCount: J } = E;
    let { firstVertex: ge } = E;
    if (re.object = t, q !== null) {
      ge *= q.array.BYTES_PER_ELEMENT;
      const Y = this.get(q);
      re.index = q.count, re.type = Y.type;
    } else
      re.index = 0;
    const _e = () => {
      t.isBatchedMesh ? t._multiDrawInstances !== null ? (Wd("THREE.WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), re.renderMultiDrawInstances(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount, t._multiDrawInstances)) : this.hasFeature("WEBGL_multi_draw") ? re.renderMultiDraw(t._multiDrawStarts, t._multiDrawCounts, t._multiDrawCount) : Wd("THREE.WebGLRenderer: WEBGL_multi_draw not supported.") : J > 1 ? re.renderInstances(ge, R, J) : re.render(ge, R);
    };
    if (e.camera.isArrayCamera === !0 && e.camera.cameras.length > 0 && e.camera.isMultiViewCamera === !1) {
      const Y = this.get(e.camera), Fe = e.camera.cameras, Me = e.getBindingGroup("cameraIndex").bindings[0];
      if (Y.indexesGPU === void 0 || Y.indexesGPU.length !== Fe.length) {
        const pe = new Uint32Array([0, 0, 0, 0]), Tt = [];
        for (let st = 0, Zt = Fe.length; st < Zt; st++) {
          const $t = f.createBuffer();
          pe[0] = st, f.bindBuffer(f.UNIFORM_BUFFER, $t), f.bufferData(f.UNIFORM_BUFFER, pe, f.STATIC_DRAW), Tt.push($t);
        }
        Y.indexesGPU = Tt;
      }
      const $ = this.get(Me), dt = this.renderer.getPixelRatio(), wt = this._currentContext.renderTarget, St = this._isRenderCameraDepthArray(this._currentContext), Ct = this._currentContext.activeCubeFace;
      if (St) {
        const pe = this.get(wt.depthTexture);
        if (pe.clearedRenderId !== this.renderer._nodes.nodeFrame.renderId) {
          pe.clearedRenderId = this.renderer._nodes.nodeFrame.renderId;
          const { stencilBuffer: Tt } = wt;
          for (let st = 0, Zt = Fe.length; st < Zt; st++)
            this.renderer._activeCubeFace = st, this._currentContext.activeCubeFace = st, this._setFramebuffer(this._currentContext), this.clear(!1, !0, Tt, this._currentContext, !1);
          this.renderer._activeCubeFace = Ct, this._currentContext.activeCubeFace = Ct;
        }
      }
      for (let pe = 0, Tt = Fe.length; pe < Tt; pe++) {
        const st = Fe[pe];
        if (t.layers.test(st.layers)) {
          St && (this.renderer._activeCubeFace = pe, this._currentContext.activeCubeFace = pe, this._setFramebuffer(this._currentContext));
          const Zt = st.viewport;
          if (Zt !== void 0) {
            const $t = Zt.x * dt, Ht = Zt.y * dt, Gn = Zt.width * dt, an = Zt.height * dt;
            v.viewport(
              Math.floor($t),
              Math.floor(e.context.height - an - Ht),
              Math.floor(Gn),
              Math.floor(an)
            );
          }
          v.bindBufferBase(f.UNIFORM_BUFFER, $.index, Y.indexesGPU[pe]), _e();
        }
        this._currentContext.activeCubeFace = Ct, this.renderer._activeCubeFace = Ct;
      }
    } else
      _e();
  }
  /**
   * Explain why always null is returned.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate() {
    return !1;
  }
  /**
   * Explain why no cache key is computed.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey() {
    return "";
  }
  // textures
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t) {
    this.textureUtils.createTexture(e, t);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    this.textureUtils.updateTexture(e, t);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, i, o, l) {
    return this.textureUtils.copyTextureToBuffer(e, t, n, i, o, l);
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler() {
  }
  /**
   * This method does nothing since WebGL 2 has no concept of samplers.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler() {
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {GLSLNodeBuilder} The node builder.
   */
  createNodeBuilder(e, t) {
    return new YLe(e, t);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(e) {
    const t = this.gl, { stage: n, code: i } = e, o = n === "fragment" ? t.createShader(t.FRAGMENT_SHADER) : t.createShader(t.VERTEX_SHADER);
    t.shaderSource(o, i), t.compileShader(o), this.set(e, {
      shaderGPU: o
    });
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(e) {
    this.delete(e);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    const n = this.gl, i = e.pipeline, { fragmentProgram: o, vertexProgram: l } = i, p = n.createProgram(), f = this.get(o).shaderGPU, v = this.get(l).shaderGPU;
    if (n.attachShader(p, f), n.attachShader(p, v), n.linkProgram(p), this.set(i, {
      programGPU: p,
      fragmentShader: f,
      vertexShader: v
    }), t !== null && this.parallel) {
      const _ = new Promise((E) => {
        const A = this.parallel, I = () => {
          n.getProgramParameter(p, A.COMPLETION_STATUS_KHR) ? (this._completeCompile(e, i), E()) : requestAnimationFrame(I);
        };
        I();
      });
      t.push(_);
      return;
    }
    this._completeCompile(e, i);
  }
  /**
   * Formats the source code of error messages.
   *
   * @private
   * @param {string} string - The code.
   * @param {number} errorLine - The error line.
   * @return {string} The formatted code.
   */
  _handleSource(e, t) {
    const n = e.split(`
`), i = [], o = Math.max(t - 6, 0), l = Math.min(t + 6, n.length);
    for (let p = o; p < l; p++) {
      const f = p + 1;
      i.push(`${f === t ? ">" : " "} ${f}: ${n[p]}`);
    }
    return i.join(`
`);
  }
  /**
   * Gets the shader compilation errors from the info log.
   *
   * @private
   * @param {WebGL2RenderingContext} gl - The rendering context.
   * @param {WebGLShader} shader - The WebGL shader object.
   * @param {string} type - The shader type.
   * @return {string} The shader errors.
   */
  _getShaderErrors(e, t, n) {
    const i = e.getShaderParameter(t, e.COMPILE_STATUS), o = e.getShaderInfoLog(t).trim();
    if (i && o === "") return "";
    const l = /ERROR: 0:(\d+)/.exec(o);
    if (l) {
      const p = parseInt(l[1]);
      return n.toUpperCase() + `

` + o + `

` + this._handleSource(e.getShaderSource(t), p);
    } else
      return o;
  }
  /**
   * Logs shader compilation errors.
   *
   * @private
   * @param {WebGLProgram} programGPU - The WebGL program.
   * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
   * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
   */
  _logProgramError(e, t, n) {
    if (this.renderer.debug.checkShaderErrors) {
      const i = this.gl, o = i.getProgramInfoLog(e).trim();
      if (i.getProgramParameter(e, i.LINK_STATUS) === !1)
        if (typeof this.renderer.debug.onShaderError == "function")
          this.renderer.debug.onShaderError(i, e, n, t);
        else {
          const l = this._getShaderErrors(i, n, "vertex"), p = this._getShaderErrors(i, t, "fragment");
          console.error(
            "THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(e, i.VALIDATE_STATUS) + `

Program Info Log: ` + o + `
` + l + `
` + p
          );
        }
      else o !== "" && console.warn("THREE.WebGLProgram: Program Info Log:", o);
    }
  }
  /**
   * Completes the shader program setup for the given render object.
   *
   * @private
   * @param {RenderObject} renderObject - The render object.
   * @param {RenderPipeline} pipeline - The render pipeline.
   */
  _completeCompile(e, t) {
    const { state: n, gl: i } = this, o = this.get(t), { programGPU: l, fragmentShader: p, vertexShader: f } = o;
    i.getProgramParameter(l, i.LINK_STATUS) === !1 && this._logProgramError(l, p, f), n.useProgram(l);
    const v = e.getBindings();
    this._setupBindings(v, l), this.set(t, {
      programGPU: l
    });
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    const { state: n, gl: i } = this, o = {
      stage: "fragment",
      code: `#version 300 es
precision highp float;
void main() {}`
    };
    this.createProgram(o);
    const { computeProgram: l } = e, p = i.createProgram(), f = this.get(o).shaderGPU, v = this.get(l).shaderGPU, _ = l.transforms, E = [], A = [];
    for (let L = 0; L < _.length; L++) {
      const V = _[L];
      E.push(V.varyingName), A.push(V.attributeNode);
    }
    i.attachShader(p, f), i.attachShader(p, v), i.transformFeedbackVaryings(
      p,
      E,
      i.SEPARATE_ATTRIBS
    ), i.linkProgram(p), i.getProgramParameter(p, i.LINK_STATUS) === !1 && this._logProgramError(p, f, v), n.useProgram(p), this._setupBindings(t, p);
    const I = l.attributes, j = [], q = [];
    for (let L = 0; L < I.length; L++) {
      const V = I[L].node.attribute;
      j.push(V), this.has(V) || this.attributeUtils.createAttribute(V, i.ARRAY_BUFFER);
    }
    for (let L = 0; L < A.length; L++) {
      const V = A[L].attribute;
      this.has(V) || this.attributeUtils.createAttribute(V, i.ARRAY_BUFFER);
      const re = this.get(V);
      q.push(re);
    }
    this.set(e, {
      programGPU: p,
      transformBuffers: q,
      attributes: j
    });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t) {
    if (this._knownBindings.has(t) === !1) {
      this._knownBindings.add(t);
      let n = 0, i = 0;
      for (const o of t) {
        this.set(o, {
          textures: i,
          uniformBuffers: n
        });
        for (const l of o.bindings)
          l.isUniformBuffer && n++, l.isSampledTexture && i++;
      }
    }
    this.updateBindings(e, t);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(e) {
    const { gl: t } = this, n = this.get(e);
    let i = n.uniformBuffers, o = n.textures;
    for (const l of e.bindings)
      if (l.isUniformsGroup || l.isUniformBuffer) {
        const p = l.buffer, f = t.createBuffer();
        t.bindBuffer(t.UNIFORM_BUFFER, f), t.bufferData(t.UNIFORM_BUFFER, p, t.DYNAMIC_DRAW), this.set(l, {
          index: i++,
          bufferGPU: f
        });
      } else if (l.isSampledTexture) {
        const { textureGPU: p, glTextureType: f } = this.get(l.texture);
        this.set(l, {
          index: o++,
          textureGPU: p,
          glTextureType: f
        });
      }
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    const t = this.gl;
    if (e.isUniformsGroup || e.isUniformBuffer) {
      const i = this.get(e).bufferGPU, o = e.buffer;
      t.bindBuffer(t.UNIFORM_BUFFER, i), t.bufferData(t.UNIFORM_BUFFER, o, t.DYNAMIC_DRAW);
    }
  }
  // attributes
  /**
   * Creates the GPU buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(e) {
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ELEMENT_ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(e) {
    if (this.has(e)) return;
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(e) {
    if (this.has(e)) return;
    const t = this.gl;
    this.attributeUtils.createAttribute(e, t.ARRAY_BUFFER);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    const t = Object.keys(zme).filter((i) => zme[i] === e), n = this.extensions;
    for (let i = 0; i < t.length; i++)
      if (n.has(t[i])) return !0;
    return !1;
  }
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return this.capabilities.getMaxAnisotropy();
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The source mip level to copy from.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, i = null, o = 0, l = 0) {
    this.textureUtils.copyTextureToTexture(e, t, n, i, o, l);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    this.textureUtils.copyFramebufferToTexture(e, t, n);
  }
  /**
   * Configures the active framebuffer from the given render context.
   *
   * @private
   * @param {RenderContext} descriptor - The render context.
   */
  _setFramebuffer(e) {
    const { gl: t, state: n } = this;
    let i = null;
    if (e.textures !== null) {
      const o = e.renderTarget, l = this.get(o), { samples: p, depthBuffer: f, stencilBuffer: v } = o, _ = o.isWebGLCubeRenderTarget === !0, E = o.isRenderTarget3D === !0, A = o.depth > 1, I = o.isXRRenderTarget === !0, j = I === !0 && o.hasExternalTextures === !0;
      let q = l.msaaFrameBuffer, L = l.depthRenderbuffer;
      const V = this.extensions.get("WEBGL_multisampled_render_to_texture"), re = this.extensions.get("OVR_multiview2"), R = this._useMultisampledExtension(o), J = Iye(e);
      let ge;
      if (_ ? (l.cubeFramebuffers || (l.cubeFramebuffers = {}), ge = l.cubeFramebuffers[J]) : I && j === !1 ? ge = this._xrFramebuffer : (l.framebuffers || (l.framebuffers = {}), ge = l.framebuffers[J]), ge === void 0) {
        ge = t.createFramebuffer(), n.bindFramebuffer(t.FRAMEBUFFER, ge);
        const _e = e.textures, Y = [];
        if (_) {
          l.cubeFramebuffers[J] = ge;
          const { textureGPU: Me } = this.get(_e[0]), $ = this.renderer._activeCubeFace;
          t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_CUBE_MAP_POSITIVE_X + $, Me, 0);
        } else {
          l.framebuffers[J] = ge;
          for (let Me = 0; Me < _e.length; Me++) {
            const $ = _e[Me], dt = this.get($);
            dt.renderTarget = e.renderTarget, dt.cacheKey = J;
            const wt = t.COLOR_ATTACHMENT0 + Me;
            if (o.multiview)
              re.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, wt, dt.textureGPU, 0, p, 0, 2);
            else if (E || A) {
              const St = this.renderer._activeCubeFace;
              t.framebufferTextureLayer(t.FRAMEBUFFER, wt, dt.textureGPU, 0, St);
            } else
              R ? V.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, wt, t.TEXTURE_2D, dt.textureGPU, 0, p) : t.framebufferTexture2D(t.FRAMEBUFFER, wt, t.TEXTURE_2D, dt.textureGPU, 0);
          }
          n.drawBuffers(e, ge);
        }
        const Fe = v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
        if (o.autoAllocateDepthBuffer === !0) {
          const Me = t.createRenderbuffer();
          this.textureUtils.setupRenderBufferStorage(Me, e, 0, R), l.xrDepthRenderbuffer = Me, Y.push(v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT), t.bindRenderbuffer(t.RENDERBUFFER, Me), t.framebufferRenderbuffer(t.FRAMEBUFFER, Fe, t.RENDERBUFFER, Me);
        } else if (e.depthTexture !== null) {
          Y.push(v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT);
          const Me = this.get(e.depthTexture);
          if (Me.renderTarget = e.renderTarget, Me.cacheKey = J, o.multiview)
            re.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, Fe, Me.textureGPU, 0, p, 0, 2);
          else if (j && R)
            V.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Fe, t.TEXTURE_2D, Me.textureGPU, 0, p);
          else if (e.depthTexture.isArrayTexture) {
            const $ = this.renderer._activeCubeFace;
            t.framebufferTextureLayer(t.FRAMEBUFFER, Fe, Me.textureGPU, 0, $);
          } else
            t.framebufferTexture2D(t.FRAMEBUFFER, Fe, t.TEXTURE_2D, Me.textureGPU, 0);
        }
        l.depthInvalidationArray = Y;
      } else {
        if (this._isRenderCameraDepthArray(e)) {
          n.bindFramebuffer(t.FRAMEBUFFER, ge);
          const Y = this.renderer._activeCubeFace, Fe = this.get(e.depthTexture), Me = v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
          t.framebufferTextureLayer(
            t.FRAMEBUFFER,
            Me,
            Fe.textureGPU,
            0,
            Y
          );
        }
        if (I || R || o.multiview) {
          n.bindFramebuffer(t.FRAMEBUFFER, ge);
          const Y = this.get(e.textures[0]);
          o.multiview ? re.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, Y.textureGPU, 0, p, 0, 2) : R ? V.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, Y.textureGPU, 0, p) : t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, Y.textureGPU, 0);
          const Fe = v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
          if (o.autoAllocateDepthBuffer === !0) {
            const Me = l.xrDepthRenderbuffer;
            t.bindRenderbuffer(t.RENDERBUFFER, Me), t.framebufferRenderbuffer(t.FRAMEBUFFER, Fe, t.RENDERBUFFER, Me);
          } else {
            const Me = this.get(e.depthTexture);
            o.multiview ? re.framebufferTextureMultisampleMultiviewOVR(t.FRAMEBUFFER, Fe, Me.textureGPU, 0, p, 0, 2) : R ? V.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER, Fe, t.TEXTURE_2D, Me.textureGPU, 0, p) : t.framebufferTexture2D(t.FRAMEBUFFER, Fe, t.TEXTURE_2D, Me.textureGPU, 0);
          }
        }
      }
      if (p > 0 && R === !1 && !o.multiview) {
        if (q === void 0) {
          const _e = [];
          q = t.createFramebuffer(), n.bindFramebuffer(t.FRAMEBUFFER, q);
          const Y = [], Fe = e.textures;
          for (let Me = 0; Me < Fe.length; Me++) {
            if (Y[Me] = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, Y[Me]), _e.push(t.COLOR_ATTACHMENT0 + Me), f) {
              const wt = v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
              _e.push(wt);
            }
            const $ = e.textures[Me], dt = this.get($);
            t.renderbufferStorageMultisample(t.RENDERBUFFER, p, dt.glInternalFormat, e.width, e.height), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0 + Me, t.RENDERBUFFER, Y[Me]);
          }
          if (l.msaaFrameBuffer = q, l.msaaRenderbuffers = Y, L === void 0) {
            L = t.createRenderbuffer(), this.textureUtils.setupRenderBufferStorage(L, e, p), l.depthRenderbuffer = L;
            const Me = v ? t.DEPTH_STENCIL_ATTACHMENT : t.DEPTH_ATTACHMENT;
            _e.push(Me);
          }
          l.invalidationArray = _e;
        }
        i = l.msaaFrameBuffer;
      } else
        i = ge;
    }
    n.bindFramebuffer(t.FRAMEBUFFER, i);
  }
  /**
   * Computes the VAO key for the given index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {string} The VAO key.
   */
  _getVaoKey(e) {
    let t = "";
    for (let n = 0; n < e.length; n++) {
      const i = this.get(e[n]);
      t += ":" + i.id;
    }
    return t;
  }
  /**
   * Creates a VAO from the index and attributes.
   *
   * @private
   * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
   * @return {Object} The VAO data.
   */
  _createVao(e) {
    const { gl: t } = this, n = t.createVertexArray();
    let i = "", o = !0;
    t.bindVertexArray(n);
    for (let l = 0; l < e.length; l++) {
      const p = e[l], f = this.get(p);
      i += ":" + f.id, t.bindBuffer(t.ARRAY_BUFFER, f.bufferGPU), t.enableVertexAttribArray(l), (p.isStorageBufferAttribute || p.isStorageInstancedBufferAttribute) && (o = !1);
      let v, _;
      p.isInterleavedBufferAttribute === !0 ? (v = p.data.stride * f.bytesPerElement, _ = p.offset * f.bytesPerElement) : (v = 0, _ = 0), f.isInteger ? t.vertexAttribIPointer(l, p.itemSize, f.type, v, _) : t.vertexAttribPointer(l, p.itemSize, f.type, p.normalized, v, _), p.isInstancedBufferAttribute && !p.isInterleavedBufferAttribute ? t.vertexAttribDivisor(l, p.meshPerAttribute) : p.isInterleavedBufferAttribute && p.data.isInstancedInterleavedBuffer && t.vertexAttribDivisor(l, p.data.meshPerAttribute);
    }
    return t.bindBuffer(t.ARRAY_BUFFER, null), this.vaoCache[i] = n, { vaoGPU: n, staticVao: o };
  }
  /**
   * Creates a transform feedback from the given transform buffers.
   *
   * @private
   * @param {Array<DualAttributeData>} transformBuffers - The transform buffers.
   * @return {WebGLTransformFeedback} The transform feedback.
   */
  _getTransformFeedback(e) {
    let t = "";
    for (let o = 0; o < e.length; o++)
      t += ":" + e[o].id;
    let n = this.transformFeedbackCache[t];
    if (n !== void 0)
      return n;
    const { gl: i } = this;
    n = i.createTransformFeedback(), i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, n);
    for (let o = 0; o < e.length; o++) {
      const l = e[o];
      i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, o, l.transformBuffer);
    }
    return i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, null), this.transformFeedbackCache[t] = n, n;
  }
  /**
   * Setups the given bindings.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {WebGLProgram} programGPU - The WebGL program.
   */
  _setupBindings(e, t) {
    const n = this.gl;
    for (const i of e)
      for (const o of i.bindings) {
        const p = this.get(o).index;
        if (o.isUniformsGroup || o.isUniformBuffer) {
          const f = n.getUniformBlockIndex(t, o.name);
          n.uniformBlockBinding(t, f, p);
        } else if (o.isSampledTexture) {
          const f = n.getUniformLocation(t, o.name);
          n.uniform1i(f, p);
        }
      }
  }
  /**
   * Binds the given uniforms.
   *
   * @private
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  _bindUniforms(e) {
    const { gl: t, state: n } = this;
    for (const i of e)
      for (const o of i.bindings) {
        const l = this.get(o), p = l.index;
        o.isUniformsGroup || o.isUniformBuffer ? n.bindBufferBase(t.UNIFORM_BUFFER, p, l.bufferGPU) : o.isSampledTexture && n.bindTexture(l.glTextureType, l.textureGPU, t.TEXTURE0 + p);
      }
  }
  /**
   * Returns `true` if the `WEBGL_multisampled_render_to_texture` extension
   * should be used when MSAA is enabled.
   *
   * @private
   * @param {RenderTarget} renderTarget - The render target that should be multisampled.
   * @return {boolean} Whether to use the `WEBGL_multisampled_render_to_texture` extension for MSAA or not.
   */
  _useMultisampledExtension(e) {
    return e.multiview === !0 ? !0 : e.samples > 0 && this.extensions.has("WEBGL_multisampled_render_to_texture") === !0 && e.autoAllocateDepthBuffer !== !1;
  }
  /**
   * Frees internal resources.
   */
  dispose() {
    const e = this.extensions.get("WEBGL_lose_context");
    e && e.loseContext(), this.renderer.domElement.removeEventListener("webglcontextlost", this._onContextLost);
  }
}
const Ab = {
  PointList: "point-list",
  LineList: "line-list",
  LineStrip: "line-strip",
  TriangleList: "triangle-list",
  TriangleStrip: "triangle-strip"
}, Ps = {
  Never: "never",
  Less: "less",
  Equal: "equal",
  LessEqual: "less-equal",
  Greater: "greater",
  NotEqual: "not-equal",
  GreaterEqual: "greater-equal",
  Always: "always"
}, po = {
  Store: "store"
}, tr = {
  Load: "load",
  Clear: "clear"
}, dV = {
  CCW: "ccw"
}, hV = {
  None: "none",
  Front: "front",
  Back: "back"
}, Kb = {
  Uint16: "uint16",
  Uint32: "uint32"
}, we = {
  // 8-bit formats
  R8Unorm: "r8unorm",
  R8Snorm: "r8snorm",
  R8Uint: "r8uint",
  R8Sint: "r8sint",
  // 16-bit formats
  R16Uint: "r16uint",
  R16Sint: "r16sint",
  R16Float: "r16float",
  RG8Unorm: "rg8unorm",
  RG8Snorm: "rg8snorm",
  RG8Uint: "rg8uint",
  RG8Sint: "rg8sint",
  // 32-bit formats
  R32Uint: "r32uint",
  R32Sint: "r32sint",
  R32Float: "r32float",
  RG16Uint: "rg16uint",
  RG16Sint: "rg16sint",
  RG16Float: "rg16float",
  RGBA8Unorm: "rgba8unorm",
  RGBA8UnormSRGB: "rgba8unorm-srgb",
  RGBA8Snorm: "rgba8snorm",
  RGBA8Uint: "rgba8uint",
  RGBA8Sint: "rgba8sint",
  BGRA8Unorm: "bgra8unorm",
  BGRA8UnormSRGB: "bgra8unorm-srgb",
  // Packed 32-bit formats
  RGB9E5UFloat: "rgb9e5ufloat",
  RGB10A2Unorm: "rgb10a2unorm",
  RG11B10UFloat: "rgb10a2unorm",
  // 64-bit formats
  RG32Uint: "rg32uint",
  RG32Sint: "rg32sint",
  RG32Float: "rg32float",
  RGBA16Uint: "rgba16uint",
  RGBA16Sint: "rgba16sint",
  RGBA16Float: "rgba16float",
  // 128-bit formats
  RGBA32Uint: "rgba32uint",
  RGBA32Sint: "rgba32sint",
  RGBA32Float: "rgba32float",
  Depth16Unorm: "depth16unorm",
  Depth24Plus: "depth24plus",
  Depth24PlusStencil8: "depth24plus-stencil8",
  Depth32Float: "depth32float",
  // 'depth32float-stencil8' extension
  Depth32FloatStencil8: "depth32float-stencil8",
  // BC compressed formats usable if 'texture-compression-bc' is both
  // supported by the device/user agent and enabled in requestDevice.
  BC1RGBAUnorm: "bc1-rgba-unorm",
  BC1RGBAUnormSRGB: "bc1-rgba-unorm-srgb",
  BC2RGBAUnorm: "bc2-rgba-unorm",
  BC2RGBAUnormSRGB: "bc2-rgba-unorm-srgb",
  BC3RGBAUnorm: "bc3-rgba-unorm",
  BC3RGBAUnormSRGB: "bc3-rgba-unorm-srgb",
  BC4RUnorm: "bc4-r-unorm",
  BC4RSnorm: "bc4-r-snorm",
  BC5RGUnorm: "bc5-rg-unorm",
  BC5RGSnorm: "bc5-rg-snorm",
  BC6HRGBUFloat: "bc6h-rgb-ufloat",
  BC6HRGBFloat: "bc6h-rgb-float",
  BC7RGBAUnorm: "bc7-rgba-unorm",
  BC7RGBAUnormSRGB: "bc7-rgba-srgb",
  // ETC2 compressed formats usable if 'texture-compression-etc2' is both
  // supported by the device/user agent and enabled in requestDevice.
  ETC2RGB8Unorm: "etc2-rgb8unorm",
  ETC2RGB8UnormSRGB: "etc2-rgb8unorm-srgb",
  ETC2RGB8A1Unorm: "etc2-rgb8a1unorm",
  ETC2RGB8A1UnormSRGB: "etc2-rgb8a1unorm-srgb",
  ETC2RGBA8Unorm: "etc2-rgba8unorm",
  ETC2RGBA8UnormSRGB: "etc2-rgba8unorm-srgb",
  EACR11Unorm: "eac-r11unorm",
  EACR11Snorm: "eac-r11snorm",
  EACRG11Unorm: "eac-rg11unorm",
  EACRG11Snorm: "eac-rg11snorm",
  // ASTC compressed formats usable if 'texture-compression-astc' is both
  // supported by the device/user agent and enabled in requestDevice.
  ASTC4x4Unorm: "astc-4x4-unorm",
  ASTC4x4UnormSRGB: "astc-4x4-unorm-srgb",
  ASTC5x4Unorm: "astc-5x4-unorm",
  ASTC5x4UnormSRGB: "astc-5x4-unorm-srgb",
  ASTC5x5Unorm: "astc-5x5-unorm",
  ASTC5x5UnormSRGB: "astc-5x5-unorm-srgb",
  ASTC6x5Unorm: "astc-6x5-unorm",
  ASTC6x5UnormSRGB: "astc-6x5-unorm-srgb",
  ASTC6x6Unorm: "astc-6x6-unorm",
  ASTC6x6UnormSRGB: "astc-6x6-unorm-srgb",
  ASTC8x5Unorm: "astc-8x5-unorm",
  ASTC8x5UnormSRGB: "astc-8x5-unorm-srgb",
  ASTC8x6Unorm: "astc-8x6-unorm",
  ASTC8x6UnormSRGB: "astc-8x6-unorm-srgb",
  ASTC8x8Unorm: "astc-8x8-unorm",
  ASTC8x8UnormSRGB: "astc-8x8-unorm-srgb",
  ASTC10x5Unorm: "astc-10x5-unorm",
  ASTC10x5UnormSRGB: "astc-10x5-unorm-srgb",
  ASTC10x6Unorm: "astc-10x6-unorm",
  ASTC10x6UnormSRGB: "astc-10x6-unorm-srgb",
  ASTC10x8Unorm: "astc-10x8-unorm",
  ASTC10x8UnormSRGB: "astc-10x8-unorm-srgb",
  ASTC10x10Unorm: "astc-10x10-unorm",
  ASTC10x10UnormSRGB: "astc-10x10-unorm-srgb",
  ASTC12x10Unorm: "astc-12x10-unorm",
  ASTC12x10UnormSRGB: "astc-12x10-unorm-srgb",
  ASTC12x12Unorm: "astc-12x12-unorm",
  ASTC12x12UnormSRGB: "astc-12x12-unorm-srgb"
}, pV = {
  ClampToEdge: "clamp-to-edge",
  Repeat: "repeat",
  MirrorRepeat: "mirror-repeat"
}, xg = {
  Linear: "linear",
  Nearest: "nearest"
}, pn = {
  Zero: "zero",
  One: "one",
  Src: "src",
  OneMinusSrc: "one-minus-src",
  SrcAlpha: "src-alpha",
  OneMinusSrcAlpha: "one-minus-src-alpha",
  Dst: "dst",
  OneMinusDst: "one-minus-dst",
  DstAlpha: "dst-alpha",
  OneMinusDstAlpha: "one-minus-dst-alpha",
  SrcAlphaSaturated: "src-alpha-saturated",
  Constant: "constant",
  OneMinusConstant: "one-minus-constant"
}, sg = {
  Add: "add",
  Subtract: "subtract",
  ReverseSubtract: "reverse-subtract",
  Min: "min",
  Max: "max"
}, qme = {
  None: 0,
  All: 15
}, Lp = {
  Keep: "keep",
  Zero: "zero",
  Replace: "replace",
  Invert: "invert",
  IncrementClamp: "increment-clamp",
  DecrementClamp: "decrement-clamp",
  IncrementWrap: "increment-wrap",
  DecrementWrap: "decrement-wrap"
}, fV = {
  Storage: "storage",
  ReadOnlyStorage: "read-only-storage"
}, mV = {
  WriteOnly: "write-only",
  ReadOnly: "read-only",
  ReadWrite: "read-write"
}, Hme = {
  NonFiltering: "non-filtering",
  Comparison: "comparison"
}, og = {
  Float: "float",
  UnfilterableFloat: "unfilterable-float",
  Depth: "depth",
  SInt: "sint",
  UInt: "uint"
}, $me = {
  TwoD: "2d",
  ThreeD: "3d"
}, us = {
  TwoD: "2d",
  TwoDArray: "2d-array",
  Cube: "cube",
  ThreeD: "3d"
}, o3e = {
  All: "all"
}, ZN = {
  Vertex: "vertex",
  Instance: "instance"
}, g6 = {
  DepthClipControl: "depth-clip-control",
  Depth32FloatStencil8: "depth32float-stencil8",
  TextureCompressionBC: "texture-compression-bc",
  TextureCompressionETC2: "texture-compression-etc2",
  TextureCompressionASTC: "texture-compression-astc",
  TimestampQuery: "timestamp-query",
  IndirectFirstInstance: "indirect-first-instance",
  ShaderF16: "shader-f16",
  RG11B10UFloat: "rg11b10ufloat-renderable",
  BGRA8UNormStorage: "bgra8unorm-storage",
  Float32Filterable: "float32-filterable",
  ClipDistances: "clip-distances",
  DualSourceBlending: "dual-source-blending",
  Subgroups: "subgroups"
};
class a3e extends EG {
  /**
   * Constructs a new sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {?Texture} texture - The texture this binding is referring to.
   */
  constructor(e, t) {
    super(e), this.texture = t, this.version = t ? t.version : 0, this.isSampler = !0;
  }
}
class l3e extends a3e {
  /**
   * Constructs a new node-based sampler.
   *
   * @param {string} name - The samplers's name.
   * @param {TextureNode} textureNode - The texture node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t, n) {
    super(e, t ? t.value : null), this.textureNode = t, this.groupNode = n;
  }
  /**
   * Updates the texture value of this sampler.
   */
  update() {
    this.texture = this.textureNode.value;
  }
}
class u3e extends lve {
  /**
   * Constructs a new uniform buffer.
   *
   * @param {string} name - The buffer's name.
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  constructor(e, t) {
    super(e, t ? t.array : null), this.attribute = t, this.isStorageBuffer = !0;
  }
}
let c3e = 0;
class d3e extends u3e {
  /**
   * Constructs a new node-based storage buffer.
   *
   * @param {StorageBufferNode} nodeUniform - The storage buffer node.
   * @param {UniformGroupNode} groupNode - The uniform group node.
   */
  constructor(e, t) {
    super("StorageBuffer_" + c3e++, e ? e.value : null), this.nodeUniform = e, this.access = e ? e.access : Fd.READ_WRITE, this.groupNode = t;
  }
  /**
   * The storage buffer.
   *
   * @type {BufferAttribute}
   */
  get buffer() {
    return this.nodeUniform.value;
  }
}
class h3e extends nf {
  /**
   * Constructs a new utility object.
   *
   * @param {GPUDevice} device - The WebGPU device.
   */
  constructor(e) {
    super(), this.device = e;
    const t = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`, n = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`, i = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
    this.mipmapSampler = e.createSampler({ minFilter: xg.Linear }), this.flipYSampler = e.createSampler({ minFilter: xg.Nearest }), this.transferPipelines = {}, this.flipYPipelines = {}, this.mipmapVertexShaderModule = e.createShaderModule({
      label: "mipmapVertex",
      code: t
    }), this.mipmapFragmentShaderModule = e.createShaderModule({
      label: "mipmapFragment",
      code: n
    }), this.flipYFragmentShaderModule = e.createShaderModule({
      label: "flipYFragment",
      code: i
    });
  }
  /**
   * Returns a render pipeline for the internal copy render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getTransferPipeline(e) {
    let t = this.transferPipelines[e];
    return t === void 0 && (t = this.device.createRenderPipeline({
      label: `mipmap-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.mipmapFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Ab.TriangleStrip,
        stripIndexFormat: Kb.Uint32
      },
      layout: "auto"
    }), this.transferPipelines[e] = t), t;
  }
  /**
   * Returns a render pipeline for the flipY render pass. The pass
   * requires a unique render pipeline for each texture format.
   *
   * @param {string} format - The GPU texture format
   * @return {GPURenderPipeline} The GPU render pipeline.
   */
  getFlipYPipeline(e) {
    let t = this.flipYPipelines[e];
    return t === void 0 && (t = this.device.createRenderPipeline({
      label: `flipY-${e}`,
      vertex: {
        module: this.mipmapVertexShaderModule,
        entryPoint: "main"
      },
      fragment: {
        module: this.flipYFragmentShaderModule,
        entryPoint: "main",
        targets: [{ format: e }]
      },
      primitive: {
        topology: Ab.TriangleStrip,
        stripIndexFormat: Kb.Uint32
      },
      layout: "auto"
    }), this.flipYPipelines[e] = t), t;
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  flipY(e, t, n = 0) {
    const i = t.format, { width: o, height: l } = t.size, p = this.getTransferPipeline(i), f = this.getFlipYPipeline(i), v = this.device.createTexture({
      size: { width: o, height: l, depthOrArrayLayers: 1 },
      format: i,
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
    }), _ = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: us.TwoD,
      baseArrayLayer: n
    }), E = v.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: us.TwoD,
      baseArrayLayer: 0
    }), A = this.device.createCommandEncoder({}), I = (j, q, L) => {
      const V = j.getBindGroupLayout(0), re = this.device.createBindGroup({
        layout: V,
        entries: [{
          binding: 0,
          resource: this.flipYSampler
        }, {
          binding: 1,
          resource: q
        }]
      }), R = A.beginRenderPass({
        colorAttachments: [{
          view: L,
          loadOp: tr.Clear,
          storeOp: po.Store,
          clearValue: [0, 0, 0, 0]
        }]
      });
      R.setPipeline(j), R.setBindGroup(0, re), R.draw(4, 1, 0, 0), R.end();
    };
    I(p, _, E), I(f, E, _), this.device.queue.submit([A.finish()]), v.destroy();
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  generateMipmaps(e, t, n = 0) {
    const i = this.get(e);
    i.useCount === void 0 && (i.useCount = 0, i.layers = []);
    const o = i.layers[n] || this._mipmapCreateBundles(e, t, n), l = this.device.createCommandEncoder({});
    this._mipmapRunBundles(l, o), this.device.queue.submit([l.finish()]), i.useCount !== 0 && (i.layers[n] = o), i.useCount++;
  }
  /**
   * Since multiple copy render passes are required to generate mipmaps, the passes
   * are managed as render bundles to improve performance.
   *
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureGPUDescriptor - The texture descriptor.
   * @param {number} baseArrayLayer - The index of the first array layer accessible to the texture view.
   * @return {Array<Object>} An array of render bundles.
   */
  _mipmapCreateBundles(e, t, n) {
    const i = this.getTransferPipeline(t.format), o = i.getBindGroupLayout(0);
    let l = e.createView({
      baseMipLevel: 0,
      mipLevelCount: 1,
      dimension: us.TwoD,
      baseArrayLayer: n
    });
    const p = [];
    for (let f = 1; f < t.mipLevelCount; f++) {
      const v = this.device.createBindGroup({
        layout: o,
        entries: [{
          binding: 0,
          resource: this.mipmapSampler
        }, {
          binding: 1,
          resource: l
        }]
      }), _ = e.createView({
        baseMipLevel: f,
        mipLevelCount: 1,
        dimension: us.TwoD,
        baseArrayLayer: n
      }), E = {
        colorAttachments: [{
          view: _,
          loadOp: tr.Clear,
          storeOp: po.Store,
          clearValue: [0, 0, 0, 0]
        }]
      }, A = this.device.createRenderBundleEncoder({
        colorFormats: [t.format]
      });
      A.setPipeline(i), A.setBindGroup(0, v), A.draw(4, 1, 0, 0), p.push({
        renderBundles: [A.finish()],
        passDescriptor: E
      }), l = _;
    }
    return p;
  }
  /**
   * Executes the render bundles.
   *
   * @param {GPUCommandEncoder} commandEncoder - The GPU command encoder.
   * @param {Array<Object>} passes - An array of render bundles.
   */
  _mipmapRunBundles(e, t) {
    const n = t.length;
    for (let i = 0; i < n; i++) {
      const o = t[i], l = e.beginRenderPass(o.passDescriptor);
      l.executeBundles(o.renderBundles), l.end();
    }
  }
}
const p3e = {
  [mye]: "never",
  [D6]: "less",
  [gye]: "equal",
  [yye]: "less-equal",
  [vye]: "greater",
  [xye]: "greater-equal",
  [_ye]: "always",
  [bye]: "not-equal"
}, f3e = [0, 1, 3, 2, 4, 5];
class m3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this._passUtils = null, this.defaultTexture = {}, this.defaultCubeTexture = {}, this.defaultVideoFrame = null, this.colorBuffer = null, this.depthTexture = new _c(), this.depthTexture.name = "depthBuffer";
  }
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(e) {
    const t = this.backend, n = t.device, i = t.get(e), o = {
      addressModeU: this._convertAddressMode(e.wrapS),
      addressModeV: this._convertAddressMode(e.wrapT),
      addressModeW: this._convertAddressMode(e.wrapR),
      magFilter: this._convertFilterMode(e.magFilter),
      minFilter: this._convertFilterMode(e.minFilter),
      mipmapFilter: this._convertFilterMode(e.minFilter),
      maxAnisotropy: 1
    };
    o.magFilter === xg.Linear && o.minFilter === xg.Linear && o.mipmapFilter === xg.Linear && (o.maxAnisotropy = e.anisotropy), e.isDepthTexture && e.compareFunction !== null && (o.compare = p3e[e.compareFunction]), i.sampler = n.createSampler(o);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    let t;
    const n = y6(e);
    e.isCubeTexture ? t = this._getDefaultCubeTextureGPU(n) : e.isVideoTexture ? this.backend.get(e).externalTexture = this._getDefaultVideoFrame() : t = this._getDefaultTextureGPU(n), this.backend.get(e).texture = t;
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t = {}) {
    const n = this.backend, i = n.get(e);
    if (i.initialized)
      throw new Error("WebGPUTextureUtils: Texture already initialized.");
    t.needsMipmaps === void 0 && (t.needsMipmaps = !1), t.levels === void 0 && (t.levels = 1), t.depth === void 0 && (t.depth = 1);
    const { width: o, height: l, depth: p, levels: f } = t;
    e.isFramebufferTexture && (t.renderTarget ? t.format = this.backend.utils.getCurrentColorFormat(t.renderTarget) : t.format = this.backend.utils.getPreferredCanvasFormat());
    const v = this._getDimension(e), _ = e.internalFormat || t.format || y6(e, n.device);
    i.format = _;
    const { samples: E, primarySamples: A, isMSAA: I } = n.utils.getTextureSampleData(e);
    let j = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
    e.isStorageTexture === !0 && (j |= GPUTextureUsage.STORAGE_BINDING), e.isCompressedTexture !== !0 && e.isCompressedArrayTexture !== !0 && (j |= GPUTextureUsage.RENDER_ATTACHMENT);
    const q = {
      label: e.name,
      size: {
        width: o,
        height: l,
        depthOrArrayLayers: p
      },
      mipLevelCount: f,
      sampleCount: A,
      dimension: v,
      format: _,
      usage: j
    };
    if (e.isVideoTexture) {
      const L = e.source.data, V = new VideoFrame(L);
      q.size.width = V.displayWidth, q.size.height = V.displayHeight, V.close(), i.externalTexture = L;
    } else {
      if (_ === void 0) {
        console.warn("WebGPURenderer: Texture format not supported."), this.createDefaultTexture(e);
        return;
      }
      e.isCubeTexture && (q.textureBindingViewDimension = us.Cube), i.texture = n.device.createTexture(q);
    }
    if (I) {
      const L = Object.assign({}, q);
      L.label = L.label + "-msaa", L.sampleCount = E, i.msaaTexture = n.device.createTexture(L);
    }
    i.initialized = !0, i.textureDescriptorGPU = q;
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(e) {
    const t = this.backend, n = t.get(e);
    n.texture !== void 0 && n.texture.destroy(), n.msaaTexture !== void 0 && n.msaaTexture.destroy(), t.delete(e);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(e) {
    const n = this.backend.get(e);
    delete n.sampler;
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    const t = this.backend.get(e);
    if (e.isCubeTexture)
      for (let n = 0; n < 6; n++)
        this._generateMipmaps(t.texture, t.textureDescriptorGPU, n);
    else {
      const n = e.image.depth || 1;
      for (let i = 0; i < n; i++)
        this._generateMipmaps(t.texture, t.textureDescriptorGPU, i);
    }
  }
  /**
   * Returns the color buffer representing the color
   * attachment of the default framebuffer.
   *
   * @return {GPUTexture} The color buffer.
   */
  getColorBuffer() {
    this.colorBuffer && this.colorBuffer.destroy();
    const e = this.backend, { width: t, height: n } = e.getDrawingBufferSize();
    return this.colorBuffer = e.device.createTexture({
      label: "colorBuffer",
      size: {
        width: t,
        height: n,
        depthOrArrayLayers: 1
      },
      sampleCount: e.utils.getSampleCount(e.renderer.samples),
      format: e.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
    }), this.colorBuffer;
  }
  /**
   * Returns the depth buffer representing the depth
   * attachment of the default framebuffer.
   *
   * @param {boolean} [depth=true] - Whether depth is enabled or not.
   * @param {boolean} [stencil=false] -  Whether stencil is enabled or not.
   * @return {GPUTexture} The depth buffer.
   */
  getDepthBuffer(e = !0, t = !1) {
    const n = this.backend, { width: i, height: o } = n.getDrawingBufferSize(), l = this.depthTexture, p = n.get(l).texture;
    let f, v;
    if (t ? (f = zd, v = Xp) : e && (f = xc, v = xi), p !== void 0) {
      if (l.image.width === i && l.image.height === o && l.format === f && l.type === v)
        return p;
      this.destroyTexture(l);
    }
    return l.name = "depthBuffer", l.format = f, l.type = v, l.image.width = i, l.image.height = o, this.createTexture(l, { width: i, height: o }), n.get(l).texture;
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    const n = this.backend.get(e), { textureDescriptorGPU: i } = n;
    if (!(e.isRenderTargetTexture || i === void 0)) {
      if (e.isDataTexture)
        this._copyBufferToTexture(t.image, n.texture, i, 0, e.flipY);
      else if (e.isArrayTexture || e.isDataArrayTexture || e.isData3DTexture)
        for (let o = 0; o < t.image.depth; o++)
          this._copyBufferToTexture(t.image, n.texture, i, o, e.flipY, o);
      else if (e.isCompressedTexture || e.isCompressedArrayTexture)
        this._copyCompressedBufferToTexture(e.mipmaps, n.texture, i);
      else if (e.isCubeTexture)
        this._copyCubeMapToTexture(t.images, n.texture, i, e.flipY, e.premultiplyAlpha);
      else if (e.isVideoTexture) {
        const o = e.source.data;
        n.externalTexture = o;
      } else
        this._copyImageToTexture(t.image, n.texture, i, 0, e.flipY, e.premultiplyAlpha);
      n.version = e.version, e.onUpdate && e.onUpdate(e);
    }
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, i, o, l) {
    const p = this.backend.device, f = this.backend.get(e), v = f.texture, _ = f.textureDescriptorGPU.format, E = this._getBytesPerTexel(_);
    let A = i * E;
    A = Math.ceil(A / 256) * 256;
    const I = p.createBuffer(
      {
        size: i * o * E,
        usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
      }
    ), j = p.createCommandEncoder();
    j.copyTextureToBuffer(
      {
        texture: v,
        origin: { x: t, y: n, z: l }
      },
      {
        buffer: I,
        bytesPerRow: A
      },
      {
        width: i,
        height: o
      }
    );
    const q = this._getTypedArrayType(_);
    p.queue.submit([j.finish()]), await I.mapAsync(GPUMapMode.READ);
    const L = I.getMappedRange();
    return new q(L);
  }
  /**
   * Returns the default GPU texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultTextureGPU(e) {
    let t = this.defaultTexture[e];
    if (t === void 0) {
      const n = new Js();
      n.minFilter = $i, n.magFilter = $i, this.createTexture(n, { width: 1, height: 1, format: e }), this.defaultTexture[e] = t = n;
    }
    return this.backend.get(t).texture;
  }
  /**
   * Returns the default GPU cube texture for the given format.
   *
   * @private
   * @param {string} format - The GPU format.
   * @return {GPUTexture} The GPU texture.
   */
  _getDefaultCubeTextureGPU(e) {
    let t = this.defaultTexture[e];
    if (t === void 0) {
      const n = new c2();
      n.minFilter = $i, n.magFilter = $i, this.createTexture(n, { width: 1, height: 1, depth: 6 }), this.defaultCubeTexture[e] = t = n;
    }
    return this.backend.get(t).texture;
  }
  /**
   * Returns the default video frame used as default data in context of video textures.
   *
   * @private
   * @return {VideoFrame} The video frame.
   */
  _getDefaultVideoFrame() {
    let e = this.defaultVideoFrame;
    if (e === null) {
      const t = {
        timestamp: 0,
        codedWidth: 1,
        codedHeight: 1,
        format: "RGBA"
      };
      this.defaultVideoFrame = e = new VideoFrame(new Uint8Array([0, 0, 0, 255]), t);
    }
    return e;
  }
  /**
   * Uploads cube texture image data to the GPU memory.
   *
   * @private
   * @param {Array} images - The cube image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   */
  _copyCubeMapToTexture(e, t, n, i, o) {
    for (let l = 0; l < 6; l++) {
      const p = e[l], f = i === !0 ? f3e[l] : l;
      p.isDataTexture ? this._copyBufferToTexture(p.image, t, n, f, i) : this._copyImageToTexture(p, t, n, f, i, o);
    }
  }
  /**
   * Uploads texture image data to the GPU memory.
   *
   * @private
   * @param {HTMLImageElement|ImageBitmap|HTMLCanvasElement} image - The image data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {boolean} premultiplyAlpha - Whether the texture should have its RGB channels premultiplied by the alpha channel or not.
   */
  _copyImageToTexture(e, t, n, i, o, l) {
    this.backend.device.queue.copyExternalImageToTexture(
      {
        source: e,
        flipY: o
      },
      {
        texture: t,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: i },
        premultipliedAlpha: l
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    );
  }
  /**
   * Returns the pass utils singleton.
   *
   * @private
   * @return {WebGPUTexturePassUtils} The utils instance.
   */
  _getPassUtils() {
    let e = this._passUtils;
    return e === null && (this._passUtils = e = new h3e(this.backend.device)), e;
  }
  /**
   * Generates mipmaps for the given GPU texture.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [baseArrayLayer=0] - The index of the first array layer accessible to the texture view.
   */
  _generateMipmaps(e, t, n = 0) {
    this._getPassUtils().generateMipmaps(e, t, n);
  }
  /**
   * Flip the contents of the given GPU texture along its vertical axis.
   *
   * @private
   * @param {GPUTexture} textureGPU - The GPU texture object.
   * @param {Object} textureDescriptorGPU - The texture descriptor.
   * @param {number} [originDepth=0] - The origin depth.
   */
  _flipY(e, t, n = 0) {
    this._getPassUtils().flipY(e, t, n);
  }
  /**
   * Uploads texture buffer data to the GPU memory.
   *
   * @private
   * @param {Object} image - An object defining the image buffer data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   * @param {number} originDepth - The origin depth.
   * @param {boolean} flipY - Whether to flip texture data along their vertical axis or not.
   * @param {number} [depth=0] - TODO.
   */
  _copyBufferToTexture(e, t, n, i, o, l = 0) {
    const p = this.backend.device, f = e.data, v = this._getBytesPerTexel(n.format), _ = e.width * v;
    p.queue.writeTexture(
      {
        texture: t,
        mipLevel: 0,
        origin: { x: 0, y: 0, z: i }
      },
      f,
      {
        offset: e.width * e.height * v * l,
        bytesPerRow: _
      },
      {
        width: e.width,
        height: e.height,
        depthOrArrayLayers: 1
      }
    ), o === !0 && this._flipY(t, n, i);
  }
  /**
   * Uploads compressed texture data to the GPU memory.
   *
   * @private
   * @param {Array<Object>} mipmaps - An array with mipmap data.
   * @param {GPUTexture} textureGPU - The GPU texture.
   * @param {Object} textureDescriptorGPU - The GPU texture descriptor.
   */
  _copyCompressedBufferToTexture(e, t, n) {
    const i = this.backend.device, o = this._getBlockData(n.format), l = n.size.depthOrArrayLayers > 1;
    for (let p = 0; p < e.length; p++) {
      const f = e[p], v = f.width, _ = f.height, E = l ? n.size.depthOrArrayLayers : 1, A = Math.ceil(v / o.width) * o.byteLength, I = A * Math.ceil(_ / o.height);
      for (let j = 0; j < E; j++)
        i.queue.writeTexture(
          {
            texture: t,
            mipLevel: p,
            origin: { x: 0, y: 0, z: j }
          },
          f.data,
          {
            offset: j * I,
            bytesPerRow: A,
            rowsPerImage: Math.ceil(_ / o.height)
          },
          {
            width: Math.ceil(v / o.width) * o.width,
            height: Math.ceil(_ / o.height) * o.height,
            depthOrArrayLayers: 1
          }
        );
    }
  }
  /**
   * This method is only relevant for compressed texture formats. It returns a block
   * data descriptor for the given GPU compressed texture format.
   *
   * @private
   * @param {string} format - The GPU compressed texture format.
   * @return {Object} The block data descriptor.
   */
  _getBlockData(e) {
    if (e === we.BC1RGBAUnorm || e === we.BC1RGBAUnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.BC2RGBAUnorm || e === we.BC2RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.BC3RGBAUnorm || e === we.BC3RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.BC4RUnorm || e === we.BC4RSnorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.BC5RGUnorm || e === we.BC5RGSnorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.BC6HRGBUFloat || e === we.BC6HRGBFloat) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.BC7RGBAUnorm || e === we.BC7RGBAUnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.ETC2RGB8Unorm || e === we.ETC2RGB8UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.ETC2RGB8A1Unorm || e === we.ETC2RGB8A1UnormSRGB) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.ETC2RGBA8Unorm || e === we.ETC2RGBA8UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.EACR11Unorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.EACR11Snorm) return { byteLength: 8, width: 4, height: 4 };
    if (e === we.EACRG11Unorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.EACRG11Snorm) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.ASTC4x4Unorm || e === we.ASTC4x4UnormSRGB) return { byteLength: 16, width: 4, height: 4 };
    if (e === we.ASTC5x4Unorm || e === we.ASTC5x4UnormSRGB) return { byteLength: 16, width: 5, height: 4 };
    if (e === we.ASTC5x5Unorm || e === we.ASTC5x5UnormSRGB) return { byteLength: 16, width: 5, height: 5 };
    if (e === we.ASTC6x5Unorm || e === we.ASTC6x5UnormSRGB) return { byteLength: 16, width: 6, height: 5 };
    if (e === we.ASTC6x6Unorm || e === we.ASTC6x6UnormSRGB) return { byteLength: 16, width: 6, height: 6 };
    if (e === we.ASTC8x5Unorm || e === we.ASTC8x5UnormSRGB) return { byteLength: 16, width: 8, height: 5 };
    if (e === we.ASTC8x6Unorm || e === we.ASTC8x6UnormSRGB) return { byteLength: 16, width: 8, height: 6 };
    if (e === we.ASTC8x8Unorm || e === we.ASTC8x8UnormSRGB) return { byteLength: 16, width: 8, height: 8 };
    if (e === we.ASTC10x5Unorm || e === we.ASTC10x5UnormSRGB) return { byteLength: 16, width: 10, height: 5 };
    if (e === we.ASTC10x6Unorm || e === we.ASTC10x6UnormSRGB) return { byteLength: 16, width: 10, height: 6 };
    if (e === we.ASTC10x8Unorm || e === we.ASTC10x8UnormSRGB) return { byteLength: 16, width: 10, height: 8 };
    if (e === we.ASTC10x10Unorm || e === we.ASTC10x10UnormSRGB) return { byteLength: 16, width: 10, height: 10 };
    if (e === we.ASTC12x10Unorm || e === we.ASTC12x10UnormSRGB) return { byteLength: 16, width: 12, height: 10 };
    if (e === we.ASTC12x12Unorm || e === we.ASTC12x12UnormSRGB) return { byteLength: 16, width: 12, height: 12 };
  }
  /**
   * Converts the three.js uv wrapping constants to GPU address mode constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a uv wrapping mode.
   * @return {string} The GPU address mode.
   */
  _convertAddressMode(e) {
    let t = pV.ClampToEdge;
    return e === Vb ? t = pV.Repeat : e === Gb && (t = pV.MirrorRepeat), t;
  }
  /**
   * Converts the three.js filter constants to GPU filter constants.
   *
   * @private
   * @param {number} value - The three.js constant defining a filter mode.
   * @return {string} The GPU filter mode.
   */
  _convertFilterMode(e) {
    let t = xg.Linear;
    return (e === $i || e === pye || e === EE) && (t = xg.Nearest), t;
  }
  /**
   * Returns the bytes-per-texel value for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {number} The bytes-per-texel.
   */
  _getBytesPerTexel(e) {
    if (e === we.R8Unorm || e === we.R8Snorm || e === we.R8Uint || e === we.R8Sint) return 1;
    if (e === we.R16Uint || e === we.R16Sint || e === we.R16Float || e === we.RG8Unorm || e === we.RG8Snorm || e === we.RG8Uint || e === we.RG8Sint) return 2;
    if (e === we.R32Uint || e === we.R32Sint || e === we.R32Float || e === we.RG16Uint || e === we.RG16Sint || e === we.RG16Float || e === we.RGBA8Unorm || e === we.RGBA8UnormSRGB || e === we.RGBA8Snorm || e === we.RGBA8Uint || e === we.RGBA8Sint || e === we.BGRA8Unorm || e === we.BGRA8UnormSRGB || // Packed 32-bit formats
    e === we.RGB9E5UFloat || e === we.RGB10A2Unorm || e === we.RG11B10UFloat || e === we.Depth32Float || e === we.Depth24Plus || e === we.Depth24PlusStencil8 || e === we.Depth32FloatStencil8) return 4;
    if (e === we.RG32Uint || e === we.RG32Sint || e === we.RG32Float || e === we.RGBA16Uint || e === we.RGBA16Sint || e === we.RGBA16Float) return 8;
    if (e === we.RGBA32Uint || e === we.RGBA32Sint || e === we.RGBA32Float) return 16;
  }
  /**
   * Returns the corresponding typed array type for the given GPU texture format.
   *
   * @private
   * @param {string} format - The GPU texture format.
   * @return {TypedArray.constructor} The typed array type.
   */
  _getTypedArrayType(e) {
    if (e === we.R8Uint) return Uint8Array;
    if (e === we.R8Sint) return Int8Array;
    if (e === we.R8Unorm) return Uint8Array;
    if (e === we.R8Snorm) return Int8Array;
    if (e === we.RG8Uint) return Uint8Array;
    if (e === we.RG8Sint) return Int8Array;
    if (e === we.RG8Unorm) return Uint8Array;
    if (e === we.RG8Snorm) return Int8Array;
    if (e === we.RGBA8Uint) return Uint8Array;
    if (e === we.RGBA8Sint) return Int8Array;
    if (e === we.RGBA8Unorm) return Uint8Array;
    if (e === we.RGBA8Snorm) return Int8Array;
    if (e === we.R16Uint) return Uint16Array;
    if (e === we.R16Sint) return Int16Array;
    if (e === we.RG16Uint) return Uint16Array;
    if (e === we.RG16Sint) return Int16Array;
    if (e === we.RGBA16Uint) return Uint16Array;
    if (e === we.RGBA16Sint) return Int16Array;
    if (e === we.R16Float || e === we.RG16Float || e === we.RGBA16Float) return Uint16Array;
    if (e === we.R32Uint) return Uint32Array;
    if (e === we.R32Sint) return Int32Array;
    if (e === we.R32Float) return Float32Array;
    if (e === we.RG32Uint) return Uint32Array;
    if (e === we.RG32Sint) return Int32Array;
    if (e === we.RG32Float) return Float32Array;
    if (e === we.RGBA32Uint) return Uint32Array;
    if (e === we.RGBA32Sint) return Int32Array;
    if (e === we.RGBA32Float) return Float32Array;
    if (e === we.BGRA8Unorm || e === we.BGRA8UnormSRGB) return Uint8Array;
    if (e === we.RGB10A2Unorm || e === we.RGB9E5UFloat || e === we.RG11B10UFloat) return Uint32Array;
    if (e === we.Depth32Float) return Float32Array;
    if (e === we.Depth24Plus || e === we.Depth24PlusStencil8) return Uint32Array;
    if (e === we.Depth32FloatStencil8) return Float32Array;
  }
  /**
   * Returns the GPU dimensions for the given texture.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @return {string} The GPU dimension.
   */
  _getDimension(e) {
    let t;
    return e.isData3DTexture ? t = $me.ThreeD : t = $me.TwoD, t;
  }
}
function y6(c, e = null) {
  const t = c.format, n = c.type, i = c.colorSpace, o = Ir.getTransfer(i);
  let l;
  if (c.isCompressedTexture === !0 || c.isCompressedArrayTexture === !0)
    switch (t) {
      case hO:
        l = o === hn ? we.BC1RGBAUnormSRGB : we.BC1RGBAUnorm;
        break;
      case pO:
        l = o === hn ? we.BC2RGBAUnormSRGB : we.BC2RGBAUnorm;
        break;
      case fO:
        l = o === hn ? we.BC3RGBAUnormSRGB : we.BC3RGBAUnorm;
        break;
      case zV:
        l = o === hn ? we.ETC2RGB8UnormSRGB : we.ETC2RGB8Unorm;
        break;
      case VV:
        l = o === hn ? we.ETC2RGBA8UnormSRGB : we.ETC2RGBA8Unorm;
        break;
      case GV:
        l = o === hn ? we.ASTC4x4UnormSRGB : we.ASTC4x4Unorm;
        break;
      case qV:
        l = o === hn ? we.ASTC5x4UnormSRGB : we.ASTC5x4Unorm;
        break;
      case HV:
        l = o === hn ? we.ASTC5x5UnormSRGB : we.ASTC5x5Unorm;
        break;
      case $V:
        l = o === hn ? we.ASTC6x5UnormSRGB : we.ASTC6x5Unorm;
        break;
      case WV:
        l = o === hn ? we.ASTC6x6UnormSRGB : we.ASTC6x6Unorm;
        break;
      case KV:
        l = o === hn ? we.ASTC8x5UnormSRGB : we.ASTC8x5Unorm;
        break;
      case YV:
        l = o === hn ? we.ASTC8x6UnormSRGB : we.ASTC8x6Unorm;
        break;
      case XV:
        l = o === hn ? we.ASTC8x8UnormSRGB : we.ASTC8x8Unorm;
        break;
      case QV:
        l = o === hn ? we.ASTC10x5UnormSRGB : we.ASTC10x5Unorm;
        break;
      case ZV:
        l = o === hn ? we.ASTC10x6UnormSRGB : we.ASTC10x6Unorm;
        break;
      case JV:
        l = o === hn ? we.ASTC10x8UnormSRGB : we.ASTC10x8Unorm;
        break;
      case e6:
        l = o === hn ? we.ASTC10x10UnormSRGB : we.ASTC10x10Unorm;
        break;
      case t6:
        l = o === hn ? we.ASTC12x10UnormSRGB : we.ASTC12x10Unorm;
        break;
      case n6:
        l = o === hn ? we.ASTC12x12UnormSRGB : we.ASTC12x12Unorm;
        break;
      case al:
        l = o === hn ? we.RGBA8UnormSRGB : we.RGBA8Unorm;
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", t);
    }
  else
    switch (t) {
      case al:
        switch (n) {
          case fE:
            l = we.RGBA8Snorm;
            break;
          case mE:
            l = we.RGBA16Sint;
            break;
          case wb:
            l = we.RGBA16Uint;
            break;
          case xi:
            l = we.RGBA32Uint;
            break;
          case fo:
            l = we.RGBA32Sint;
            break;
          case yo:
            l = o === hn ? we.RGBA8UnormSRGB : we.RGBA8Unorm;
            break;
          case ol:
            l = we.RGBA16Float;
            break;
          case wa:
            l = we.RGBA32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAFormat.", n);
        }
        break;
      case M6:
        switch (n) {
          case fye:
            l = we.RGB9E5UFloat;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBFormat.", n);
        }
        break;
      case R6:
        switch (n) {
          case fE:
            l = we.R8Snorm;
            break;
          case mE:
            l = we.R16Sint;
            break;
          case wb:
            l = we.R16Uint;
            break;
          case xi:
            l = we.R32Uint;
            break;
          case fo:
            l = we.R32Sint;
            break;
          case yo:
            l = we.R8Unorm;
            break;
          case ol:
            l = we.R16Float;
            break;
          case wa:
            l = we.R32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedFormat.", n);
        }
        break;
      case _g:
        switch (n) {
          case fE:
            l = we.RG8Snorm;
            break;
          case mE:
            l = we.RG16Sint;
            break;
          case wb:
            l = we.RG16Uint;
            break;
          case xi:
            l = we.RG32Uint;
            break;
          case fo:
            l = we.RG32Sint;
            break;
          case yo:
            l = we.RG8Unorm;
            break;
          case ol:
            l = we.RG16Float;
            break;
          case wa:
            l = we.RG32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGFormat.", n);
        }
        break;
      case xc:
        switch (n) {
          case wb:
            l = we.Depth16Unorm;
            break;
          case xi:
            l = we.Depth24Plus;
            break;
          case wa:
            l = we.Depth32Float;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthFormat.", n);
        }
        break;
      case zd:
        switch (n) {
          case Xp:
            l = we.Depth24PlusStencil8;
            break;
          case wa:
            e && e.features.has(g6.Depth32FloatStencil8) === !1 && console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'), l = we.Depth32FloatStencil8;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.", n);
        }
        break;
      case I6:
        switch (n) {
          case fo:
            l = we.R32Sint;
            break;
          case xi:
            l = we.R32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.", n);
        }
        break;
      case N6:
        switch (n) {
          case fo:
            l = we.RG32Sint;
            break;
          case xi:
            l = we.RG32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.", n);
        }
        break;
      case O6:
        switch (n) {
          case fo:
            l = we.RGBA32Sint;
            break;
          case xi:
            l = we.RGBA32Uint;
            break;
          default:
            console.error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.", n);
        }
        break;
      default:
        console.error("WebGPURenderer: Unsupported texture format.", t);
    }
  return l;
}
const g3e = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i, y3e = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig, Wme = {
  f32: "float",
  i32: "int",
  u32: "uint",
  bool: "bool",
  "vec2<f32>": "vec2",
  "vec2<i32>": "ivec2",
  "vec2<u32>": "uvec2",
  "vec2<bool>": "bvec2",
  vec2f: "vec2",
  vec2i: "ivec2",
  vec2u: "uvec2",
  vec2b: "bvec2",
  "vec3<f32>": "vec3",
  "vec3<i32>": "ivec3",
  "vec3<u32>": "uvec3",
  "vec3<bool>": "bvec3",
  vec3f: "vec3",
  vec3i: "ivec3",
  vec3u: "uvec3",
  vec3b: "bvec3",
  "vec4<f32>": "vec4",
  "vec4<i32>": "ivec4",
  "vec4<u32>": "uvec4",
  "vec4<bool>": "bvec4",
  vec4f: "vec4",
  vec4i: "ivec4",
  vec4u: "uvec4",
  vec4b: "bvec4",
  "mat2x2<f32>": "mat2",
  mat2x2f: "mat2",
  "mat3x3<f32>": "mat3",
  mat3x3f: "mat3",
  "mat4x4<f32>": "mat4",
  mat4x4f: "mat4",
  sampler: "sampler",
  texture_1d: "texture",
  texture_2d: "texture",
  texture_2d_array: "texture",
  texture_multisampled_2d: "cubeTexture",
  texture_depth_2d: "depthTexture",
  texture_depth_2d_array: "depthTexture",
  texture_depth_multisampled_2d: "depthTexture",
  texture_depth_cube: "depthTexture",
  texture_depth_cube_array: "depthTexture",
  texture_3d: "texture3D",
  texture_cube: "cubeTexture",
  texture_cube_array: "cubeTexture",
  texture_storage_1d: "storageTexture",
  texture_storage_2d: "storageTexture",
  texture_storage_2d_array: "storageTexture",
  texture_storage_3d: "storageTexture"
}, v3e = (c) => {
  c = c.trim();
  const e = c.match(g3e);
  if (e !== null && e.length === 4) {
    const t = e[2], n = [];
    let i = null;
    for (; (i = y3e.exec(t)) !== null; )
      n.push({ name: i[1], type: i[2] });
    const o = [];
    for (let _ = 0; _ < n.length; _++) {
      const { name: E, type: A } = n[_];
      let I = A;
      I.startsWith("ptr") ? I = "pointer" : (I.startsWith("texture") && (I = A.split("<")[0]), I = Wme[I]), o.push(new gG(I, E));
    }
    const l = c.substring(e[0].length), p = e[3] || "void", f = e[1] !== void 0 ? e[1] : "";
    return {
      type: Wme[p] || p,
      inputs: o,
      name: f,
      inputsCode: t,
      blockCode: l,
      outputType: p
    };
  } else
    throw new Error("FunctionNode: Function is not a WGSL code.");
};
class b3e extends bG {
  /**
   * Constructs a new WGSL node function.
   *
   * @param {string} source - The WGSL source.
   */
  constructor(e) {
    const { type: t, inputs: n, name: i, inputsCode: o, blockCode: l, outputType: p } = v3e(e);
    super(t, n, i), this.inputsCode = o, this.blockCode = l, this.outputType = p;
  }
  /**
   * This method returns the WGSL code of the node function.
   *
   * @param {string} [name=this.name] - The function's name.
   * @return {string} The shader code.
   */
  getCode(e = this.name) {
    const t = this.outputType !== "void" ? "-> " + this.outputType : "";
    return `fn ${e} ( ${this.inputsCode.trim()} ) ${t}` + this.blockCode;
  }
}
class x3e extends nve {
  /**
   * The method parses the given WGSL code an returns a node function.
   *
   * @param {string} source - The WGSL code.
   * @return {WGSLNodeFunction} A node function.
   */
  parseFunction(e) {
    return new b3e(e);
  }
}
const mb = typeof self < "u" ? self.GPUShaderStage : { VERTEX: 1, FRAGMENT: 2, COMPUTE: 4 }, _3e = {
  [Fd.READ_ONLY]: "read",
  [Fd.WRITE_ONLY]: "write",
  [Fd.READ_WRITE]: "read_write"
}, Kme = {
  [Vb]: "repeat",
  [Kp]: "clamp",
  [Gb]: "mirror"
}, JN = {
  vertex: mb ? mb.VERTEX : 1,
  fragment: mb ? mb.FRAGMENT : 2,
  compute: mb ? mb.COMPUTE : 4
}, Yme = {
  instance: !0,
  swizzleAssign: !1,
  storageBuffer: !0
}, S3e = {
  "^^": "tsl_xor"
}, w3e = {
  float: "f32",
  int: "i32",
  uint: "u32",
  bool: "bool",
  color: "vec3<f32>",
  vec2: "vec2<f32>",
  ivec2: "vec2<i32>",
  uvec2: "vec2<u32>",
  bvec2: "vec2<bool>",
  vec3: "vec3<f32>",
  ivec3: "vec3<i32>",
  uvec3: "vec3<u32>",
  bvec3: "vec3<bool>",
  vec4: "vec4<f32>",
  ivec4: "vec4<i32>",
  uvec4: "vec4<u32>",
  bvec4: "vec4<bool>",
  mat2: "mat2x2<f32>",
  mat3: "mat3x3<f32>",
  mat4: "mat4x4<f32>"
}, Xme = {}, il = {
  tsl_xor: new qi("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),
  mod_float: new qi("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),
  mod_vec2: new qi("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),
  mod_vec3: new qi("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),
  mod_vec4: new qi("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),
  equals_bool: new qi("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),
  equals_bvec2: new qi("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),
  equals_bvec3: new qi("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),
  equals_bvec4: new qi("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),
  repeatWrapping_float: new qi("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),
  mirrorWrapping_float: new qi("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),
  clampWrapping_float: new qi("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),
  biquadraticTexture: new qi(
    /* wgsl */
    `
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`
  )
}, oE = {
  dFdx: "dpdx",
  dFdy: "- dpdy",
  mod_float: "tsl_mod_float",
  mod_vec2: "tsl_mod_vec2",
  mod_vec3: "tsl_mod_vec3",
  mod_vec4: "tsl_mod_vec4",
  equals_bool: "tsl_equals_bool",
  equals_bvec2: "tsl_equals_bvec2",
  equals_bvec3: "tsl_equals_bvec3",
  equals_bvec4: "tsl_equals_bvec4",
  inversesqrt: "inverseSqrt",
  bitcast: "bitcast<f32>"
};
typeof navigator < "u" && /Windows/g.test(navigator.userAgent) && (il.pow_float = new qi("fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }"), il.pow_vec2 = new qi("fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }", [il.pow_float]), il.pow_vec3 = new qi("fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }", [il.pow_float]), il.pow_vec4 = new qi("fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }", [il.pow_float]), oE.pow_float = "tsl_pow_float", oE.pow_vec2 = "tsl_pow_vec2", oE.pow_vec3 = "tsl_pow_vec3", oE.pow_vec4 = "tsl_pow_vec4");
let gve = "";
(typeof navigator < "u" && /Firefox|Deno/g.test(navigator.userAgent)) !== !0 && (gve += `diagnostic( off, derivative_uniformity );
`);
class E3e extends tve {
  /**
   * Constructs a new WGSL node builder renderer.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Renderer} renderer - The renderer.
   */
  constructor(e, t) {
    super(e, t, new x3e()), this.uniformGroups = {}, this.builtins = {}, this.directives = {}, this.scopedArrays = /* @__PURE__ */ new Map();
  }
  /**
   * Checks if the given texture requires a manual conversion to the working color space.
   *
   * @param {Texture} texture - The texture to check.
   * @return {boolean} Whether the given texture requires a conversion to working color space or not.
   */
  needsToWorkingColorSpace(e) {
    return e.isVideoTexture === !0 && e.colorSpace !== $d;
  }
  /**
   * Generates the WGSL snippet for sampled textures.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSample(e, t, n, i, o = this.shaderStage) {
    return o === "fragment" ? i ? `textureSample( ${t}, ${t}_sampler, ${n}, ${i} )` : `textureSample( ${t}, ${t}_sampler, ${n} )` : this._generateTextureSampleLevel(e, t, n, "0", i);
  }
  /**
   * Generates the WGSL snippet when sampling video textures.
   *
   * @private
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  _generateVideoSample(e, t, n = this.shaderStage) {
    if (n === "fragment")
      return `textureSampleBaseClampToEdge( ${e}, ${e}_sampler, vec2<f32>( ${t}.x, 1.0 - ${t}.y ) )`;
    console.error(`WebGPURenderer: THREE.VideoTexture does not support ${n} shader.`);
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @private
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @return {string} The WGSL snippet.
   */
  _generateTextureSampleLevel(e, t, n, i, o) {
    return this.isUnfilterable(e) === !1 ? `textureSampleLevel( ${t}, ${t}_sampler, ${n}, ${i} )` : this.isFilteredTexture(e) ? this.generateFilteredTexture(e, t, n, i) : this.generateTextureLod(e, t, n, o, i);
  }
  /**
   * Generates a wrap function used in context of textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @return {string} The name of the generated function.
   */
  generateWrapFunction(e) {
    const t = `tsl_coord_${Kme[e.wrapS]}S_${Kme[e.wrapT]}_${e.isData3DTexture ? "3d" : "2d"}T`;
    let n = Xme[t];
    if (n === void 0) {
      const i = [], o = e.isData3DTexture ? "vec3f" : "vec2f";
      let l = `fn ${t}( coord : ${o} ) -> ${o} {

	return ${o}(
`;
      const p = (f, v) => {
        f === Vb ? (i.push(il.repeatWrapping_float), l += `		tsl_repeatWrapping_float( coord.${v} )`) : f === Kp ? (i.push(il.clampWrapping_float), l += `		tsl_clampWrapping_float( coord.${v} )`) : f === Gb ? (i.push(il.mirrorWrapping_float), l += `		tsl_mirrorWrapping_float( coord.${v} )`) : (l += `		coord.${v}`, console.warn(`WebGPURenderer: Unsupported texture wrap type "${f}" for vertex shader.`));
      };
      p(e.wrapS, "x"), l += `,
`, p(e.wrapT, "y"), e.isData3DTexture && (l += `,
`, p(e.wrapR, "z")), l += `
	);

}
`, Xme[t] = n = new qi(l, i);
    }
    return n.build(this), t;
  }
  /**
   * Generates the array declaration string.
   *
   * @param {string} type - The type.
   * @param {?number} [count] - The count.
   * @return {string} The generated value as a shader string.
   */
  generateArrayDeclaration(e, t) {
    return `array< ${this.getType(e)}, ${t} >`;
  }
  /**
   * Generates a WGSL variable that holds the texture dimension of the given texture.
   * It also returns information about the number of layers (elements) of an arrayed
   * texture as well as the cube face count of cube textures.
   *
   * @param {Texture} texture - The texture to generate the function for.
   * @param {string} textureProperty - The name of the video texture uniform in the shader.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The name of the dimension variable.
   */
  generateTextureDimension(e, t, n) {
    const i = this.getDataFromNode(e, this.shaderStage, this.globalCache);
    i.dimensionsSnippet === void 0 && (i.dimensionsSnippet = {});
    let o = i.dimensionsSnippet[n];
    if (i.dimensionsSnippet[n] === void 0) {
      let l, p;
      const { primarySamples: f } = this.renderer.backend.utils.getTextureSampleData(e), v = f > 1;
      e.isData3DTexture ? p = "vec3<u32>" : p = "vec2<u32>", v || e.isVideoTexture || e.isStorageTexture ? l = t : l = `${t}${n ? `, u32( ${n} )` : ""}`, o = new yO(new bO(`textureDimensions( ${l} )`, p)), i.dimensionsSnippet[n] = o, (e.isArrayTexture || e.isDataArrayTexture || e.isData3DTexture) && (i.arrayLayerCount = new yO(
        new bO(
          `textureNumLayers(${t})`,
          "u32"
        )
      )), e.isTextureCube && (i.cubeFaceCount = new yO(
        new bO("6u", "u32")
      ));
    }
    return o.build(this);
  }
  /**
   * Generates the WGSL snippet for a manual filtered texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateFilteredTexture(e, t, n, i = "0u") {
    this._include("biquadraticTexture");
    const o = this.generateWrapFunction(e), l = this.generateTextureDimension(e, t, i);
    return `tsl_biquadraticTexture( ${t}, ${o}( ${n} ), ${l}, u32( ${i} ) )`;
  }
  /**
   * Generates the WGSL snippet for a texture lookup with explicit level-of-detail.
   * Since it's a lookup, no sampling or filtering is applied.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLod(e, t, n, i, o = "0u") {
    const l = this.generateWrapFunction(e), p = this.generateTextureDimension(e, t, o), f = e.isData3DTexture ? "vec3" : "vec2", v = `${f}<u32>( ${l}( ${n} ) * ${f}<f32>( ${p} ) )`;
    return this.generateTextureLoad(e, t, v, i, o);
  }
  /**
   * Generates the WGSL snippet that reads a single texel from a texture without sampling or filtering.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [levelSnippet='0u'] - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @return {string} The WGSL snippet.
   */
  generateTextureLoad(e, t, n, i, o = "0u") {
    let l;
    return e.isVideoTexture === !0 ? l = `textureLoad( ${t}, ${n} )` : i ? l = `textureLoad( ${t}, ${n}, ${i}, u32( ${o} ) )` : (l = `textureLoad( ${t}, ${n}, u32( ${o} ) )`, this.renderer.backend.compatibilityMode && e.isDepthTexture && (l += ".x")), l;
  }
  /**
   * Generates the WGSL snippet that writes a single texel to a texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvIndexSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} valueSnippet - A WGSL snippet that represent the new texel value.
   * @return {string} The WGSL snippet.
   */
  generateTextureStore(e, t, n, i, o) {
    let l;
    return i ? l = `textureStore( ${t}, ${n}, ${i}, ${o} )` : l = `textureStore( ${t}, ${n}, ${o} )`, l;
  }
  /**
   * Returns `true` if the sampled values of the given texture should be compared against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the sampled values of the given texture should be compared against a reference value or not.
   */
  isSampleCompare(e) {
    return e.isDepthTexture === !0 && e.compareFunction !== null;
  }
  /**
   * Returns `true` if the given texture is unfilterable.
   *
   * @param {Texture} texture - The texture.
   * @return {boolean} Whether the given texture is unfilterable or not.
   */
  isUnfilterable(e) {
    return this.getComponentTypeFromTexture(e) !== "float" || !this.isAvailable("float32Filterable") && e.isDataTexture === !0 && e.type === wa || this.isSampleCompare(e) === !1 && e.minFilter === $i && e.magFilter === $i || this.renderer.backend.utils.getTextureSampleData(e).primarySamples > 1;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTexture(e, t, n, i, o = this.shaderStage) {
    let l = null;
    return e.isVideoTexture === !0 ? l = this._generateVideoSample(t, n, o) : this.isUnfilterable(e) ? l = this.generateTextureLod(e, t, n, i, "0", o) : l = this._generateTextureSample(e, t, n, i, o), l;
  }
  /**
   * Generates the WGSL snippet for sampling/loading the given texture using explicit gradients.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {Array<string>} gradSnippet - An array holding both gradient WGSL snippets.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureGrad(e, t, n, i, o, l = this.shaderStage) {
    if (l === "fragment")
      return `textureSampleGrad( ${t}, ${t}_sampler, ${n},  ${i[0]}, ${i[1]} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${l} shader.`);
  }
  /**
   * Generates the WGSL snippet for sampling a depth texture and comparing the sampled depth values
   * against a reference value.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} compareSnippet -  A WGSL snippet that represents the reference value.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureCompare(e, t, n, i, o, l = this.shaderStage) {
    if (l === "fragment")
      return e.isDepthTexture === !0 && e.isArrayTexture === !0 ? `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${o}, ${i} )` : `textureSampleCompare( ${t}, ${t}_sampler, ${n}, ${i} )`;
    console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${l} shader.`);
  }
  /**
   * Generates the WGSL snippet when sampling textures with explicit mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} levelSnippet - A WGSL snippet that represents the mip level, with level 0 containing a full size version of the texture.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureLevel(e, t, n, i, o, l = this.shaderStage) {
    let p = null;
    return e.isVideoTexture === !0 ? p = this._generateVideoSample(t, n, l) : p = this._generateTextureSampleLevel(e, t, n, i, o), p;
  }
  /**
   * Generates the WGSL snippet when sampling textures with a bias to the mip level.
   *
   * @param {Texture} texture - The texture.
   * @param {string} textureProperty - The name of the texture uniform in the shader.
   * @param {string} uvSnippet - A WGSL snippet that represents texture coordinates used for sampling.
   * @param {string} biasSnippet - A WGSL snippet that represents the bias to apply to the mip level before sampling.
   * @param {?string} depthSnippet - A WGSL snippet that represents 0-based texture array index to sample.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The WGSL snippet.
   */
  generateTextureBias(e, t, n, i, o, l = this.shaderStage) {
    if (l === "fragment")
      return `textureSampleBias( ${t}, ${t}_sampler, ${n}, ${i} )`;
    console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${l} shader.`);
  }
  /**
   * Returns a WGSL snippet that represents the property name of the given node.
   *
   * @param {Node} node - The node.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getPropertyName(e, t = this.shaderStage) {
    if (e.isNodeVarying === !0 && e.needsInterpolation === !0) {
      if (t === "vertex")
        return `varyings.${e.name}`;
    } else if (e.isNodeUniform === !0) {
      const n = e.name, i = e.type;
      return i === "texture" || i === "cubeTexture" || i === "storageTexture" || i === "texture3D" ? n : i === "buffer" || i === "storageBuffer" || i === "indirectStorageBuffer" ? this.isCustomStruct(e) ? n : n + ".value" : e.groupNode.name + "." + n;
    }
    return super.getPropertyName(e);
  }
  /**
   * Returns the output struct name.
   *
   * @return {string} The name of the output struct.
   */
  getOutputStructName() {
    return "output";
  }
  /**
   * Returns the native shader operator name for a given generic name.
   *
   * @param {string} op - The operator name to resolve.
   * @return {?string} The resolved operator name.
   */
  getFunctionOperator(e) {
    const t = S3e[e];
    return t !== void 0 ? (this._include(t), t) : null;
  }
  /**
   * Returns the node access for the given node and shader stage.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The node access.
   */
  getNodeAccess(e, t) {
    return t !== "compute" ? Fd.READ_ONLY : e.access;
  }
  /**
   * Returns A WGSL snippet representing the storage access.
   *
   * @param {StorageTextureNode|StorageBufferNode} node - The storage node.
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet representing the storage access.
   */
  getStorageAccess(e, t) {
    return _3e[this.getNodeAccess(e, t)];
  }
  /**
   * This method is one of the more important ones since it's responsible
   * for generating a matching binding instance for the given uniform node.
   *
   * These bindings are later used in the renderer to create bind groups
   * and layouts.
   *
   * @param {UniformNode} node - The uniform node.
   * @param {string} type - The node data type.
   * @param {string} shaderStage - The shader stage.
   * @param {?string} [name=null] - An optional uniform name.
   * @return {NodeUniform} The node uniform object.
   */
  getUniformFromNode(e, t, n, i = null) {
    const o = super.getUniformFromNode(e, t, n, i), l = this.getDataFromNode(e, n, this.globalCache);
    if (l.uniformGPU === void 0) {
      let p;
      const f = e.groupNode, v = f.name, _ = this.getBindGroupArray(v, n);
      if (t === "texture" || t === "cubeTexture" || t === "storageTexture" || t === "texture3D") {
        let E = null;
        const A = this.getNodeAccess(e, n);
        if (t === "texture" || t === "storageTexture" ? E = new m2(o.name, o.node, f, A) : t === "cubeTexture" ? E = new hve(o.name, o.node, f, A) : t === "texture3D" && (E = new pve(o.name, o.node, f, A)), E.store = e.isStorageTextureNode === !0, E.setVisibility(JN[n]), this.isUnfilterable(e.value) === !1 && E.store === !1) {
          const I = new l3e(`${o.name}_sampler`, o.node, f);
          I.setVisibility(JN[n]), _.push(I, E), p = [I, E];
        } else
          _.push(E), p = [E];
      } else if (t === "buffer" || t === "storageBuffer" || t === "indirectStorageBuffer") {
        const E = t === "buffer" ? cve : d3e, A = new E(e, f);
        A.setVisibility(JN[n]), _.push(A), p = A, o.name = i || "NodeBuffer_" + o.id;
      } else {
        const E = this.uniformGroups[n] || (this.uniformGroups[n] = {});
        let A = E[v];
        A === void 0 && (A = new dve(v, f), A.setVisibility(JN[n]), E[v] = A, _.push(A)), p = this.getNodeUniform(o, t), A.addUniform(p);
      }
      l.uniformGPU = p;
    }
    return o;
  }
  /**
   * This method should be used whenever builtins are required in nodes.
   * The internal builtins data structure will make sure builtins are
   * defined in the WGSL source.
   *
   * @param {string} name - The builtin name.
   * @param {string} property - The property name.
   * @param {string} type - The node data type.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {string} The property name.
   */
  getBuiltin(e, t, n, i = this.shaderStage) {
    const o = this.builtins[i] || (this.builtins[i] = /* @__PURE__ */ new Map());
    return o.has(e) === !1 && o.set(e, {
      name: e,
      property: t,
      type: n
    }), t;
  }
  /**
   * Returns `true` if the given builtin is defined in the given shader stage.
   *
   * @param {string} name - The builtin name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage this code snippet is generated for.
   * @return {boolean} Whether the given builtin is defined in the given shader stage or not.
   */
  hasBuiltin(e, t = this.shaderStage) {
    return this.builtins[t] !== void 0 && this.builtins[t].has(e);
  }
  /**
   * Returns the vertex index builtin.
   *
   * @return {string} The vertex index.
   */
  getVertexIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("vertex_index", "vertexIndex", "u32", "attribute") : "vertexIndex";
  }
  /**
   * Builds the given shader node.
   *
   * @param {ShaderNodeInternal} shaderNode - The shader node.
   * @return {string} The WGSL function code.
   */
  buildFunctionCode(e) {
    const t = e.layout, n = this.flowShaderNode(e), i = [];
    for (const l of t.inputs)
      i.push(l.name + " : " + this.getType(l.type));
    let o = `fn ${t.name}( ${i.join(", ")} ) -> ${this.getType(t.type)} {
${n.vars}
${n.code}
`;
    return n.result && (o += `	return ${n.result};
`), o += `
}
`, o;
  }
  /**
   * Returns the instance index builtin.
   *
   * @return {string} The instance index.
   */
  getInstanceIndex() {
    return this.shaderStage === "vertex" ? this.getBuiltin("instance_index", "instanceIndex", "u32", "attribute") : "instanceIndex";
  }
  /**
   * Returns the invocation local index builtin.
   *
   * @return {string} The invocation local index.
   */
  getInvocationLocalIndex() {
    return this.getBuiltin("local_invocation_index", "invocationLocalIndex", "u32", "attribute");
  }
  /**
   * Returns the subgroup size builtin.
   *
   * @return {string} The subgroup size.
   */
  getSubgroupSize() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute");
  }
  /**
   * Returns the invocation subgroup index builtin.
   *
   * @return {string} The invocation subgroup index.
   */
  getInvocationSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_invocation_id", "invocationSubgroupIndex", "u32", "attribute");
  }
  /**
   * Returns the subgroup index builtin.
   *
   * @return {string} The subgroup index.
   */
  getSubgroupIndex() {
    return this.enableSubGroups(), this.getBuiltin("subgroup_id", "subgroupIndex", "u32", "attribute");
  }
  /**
   * Overwritten as a NOP since this method is intended for the WebGL 2 backend.
   *
   * @return {null} Null.
   */
  getDrawIndex() {
    return null;
  }
  /**
   * Returns the front facing builtin.
   *
   * @return {string} The front facing builtin.
   */
  getFrontFacing() {
    return this.getBuiltin("front_facing", "isFront", "bool");
  }
  /**
   * Returns the frag coord builtin.
   *
   * @return {string} The frag coord builtin.
   */
  getFragCoord() {
    return this.getBuiltin("position", "fragCoord", "vec4<f32>") + ".xy";
  }
  /**
   * Returns the frag depth builtin.
   *
   * @return {string} The frag depth builtin.
   */
  getFragDepth() {
    return "output." + this.getBuiltin("frag_depth", "depth", "f32", "output");
  }
  /**
   * Returns the clip distances builtin.
   *
   * @return {string} The clip distances builtin.
   */
  getClipDistance() {
    return "varyings.hw_clip_distances";
  }
  /**
   * Whether to flip texture data along its vertical axis or not.
   *
   * @return {boolean} Returns always `false` in context of WGSL.
   */
  isFlipY() {
    return !1;
  }
  /**
   * Enables the given directive for the given shader stage.
   *
   * @param {string} name - The directive name.
   * @param {string} [shaderStage=this.shaderStage] - The shader stage to enable the directive for.
   */
  enableDirective(e, t = this.shaderStage) {
    (this.directives[t] || (this.directives[t] = /* @__PURE__ */ new Set())).add(e);
  }
  /**
   * Returns the directives of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that enables the directives of the given stage.
   */
  getDirectives(e) {
    const t = [], n = this.directives[e];
    if (n !== void 0)
      for (const i of n)
        t.push(`enable ${i};`);
    return t.join(`
`);
  }
  /**
   * Enables the 'subgroups' directive.
   */
  enableSubGroups() {
    this.enableDirective("subgroups");
  }
  /**
   * Enables the 'subgroups-f16' directive.
   */
  enableSubgroupsF16() {
    this.enableDirective("subgroups-f16");
  }
  /**
   * Enables the 'clip_distances' directive.
   */
  enableClipDistances() {
    this.enableDirective("clip_distances");
  }
  /**
   * Enables the 'f16' directive.
   */
  enableShaderF16() {
    this.enableDirective("f16");
  }
  /**
   * Enables the 'dual_source_blending' directive.
   */
  enableDualSourceBlending() {
    this.enableDirective("dual_source_blending");
  }
  /**
   * Enables hardware clipping.
   *
   * @param {string} planeCount - The clipping plane count.
   */
  enableHardwareClipping(e) {
    this.enableClipDistances(), this.getBuiltin("clip_distances", "hw_clip_distances", `array<f32, ${e} >`, "vertex");
  }
  /**
   * Returns the builtins of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} A WGSL snippet that represents the builtins of the given stage.
   */
  getBuiltins(e) {
    const t = [], n = this.builtins[e];
    if (n !== void 0)
      for (const { name: i, property: o, type: l } of n.values())
        t.push(`@builtin( ${i} ) ${o} : ${l}`);
    return t.join(`,
	`);
  }
  /**
   * This method should be used when a new scoped buffer is used in context of
   * compute shaders. It adds the array to the internal data structure which is
   * later used to generate the respective WGSL.
   *
   * @param {string} name - The array name.
   * @param {string} scope - The scope.
   * @param {string} bufferType - The buffer type.
   * @param {string} bufferCount - The buffer count.
   * @return {string} The array name.
   */
  getScopedArray(e, t, n, i) {
    return this.scopedArrays.has(e) === !1 && this.scopedArrays.set(e, {
      name: e,
      scope: t,
      bufferType: n,
      bufferCount: i
    }), e;
  }
  /**
   * Returns the scoped arrays of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string|undefined} The WGSL snippet that defines the scoped arrays.
   * Returns `undefined` when used in the vertex or fragment stage.
   */
  getScopedArrays(e) {
    if (e !== "compute")
      return;
    const t = [];
    for (const { name: n, scope: i, bufferType: o, bufferCount: l } of this.scopedArrays.values()) {
      const p = this.getType(o);
      t.push(`var<${i}> ${n}: array< ${p}, ${l} >;`);
    }
    return t.join(`
`);
  }
  /**
   * Returns the shader attributes of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the shader attributes.
   */
  getAttributes(e) {
    const t = [];
    if (e === "compute" && (this.getBuiltin("global_invocation_id", "globalId", "vec3<u32>", "attribute"), this.getBuiltin("workgroup_id", "workgroupId", "vec3<u32>", "attribute"), this.getBuiltin("local_invocation_id", "localId", "vec3<u32>", "attribute"), this.getBuiltin("num_workgroups", "numWorkgroups", "vec3<u32>", "attribute"), this.renderer.hasFeature("subgroups") && (this.enableDirective("subgroups", e), this.getBuiltin("subgroup_size", "subgroupSize", "u32", "attribute"))), e === "vertex" || e === "compute") {
      const n = this.getBuiltins("attribute");
      n && t.push(n);
      const i = this.getAttributesArray();
      for (let o = 0, l = i.length; o < l; o++) {
        const p = i[o], f = p.name, v = this.getType(p.type);
        t.push(`@location( ${o} ) ${f} : ${v}`);
      }
    }
    return t.join(`,
	`);
  }
  /**
   * Returns the members of the given struct type node as a WGSL string.
   *
   * @param {StructTypeNode} struct - The struct type node.
   * @return {string} The WGSL snippet that defines the struct members.
   */
  getStructMembers(e) {
    const t = [];
    for (const n of e.members) {
      const i = e.output ? "@location( " + n.index + " ) " : "";
      let o = this.getType(n.type);
      n.atomic && (o = "atomic< " + o + " >"), t.push(`	${i + n.name} : ${o}`);
    }
    return e.output && t.push(`	${this.getBuiltins("output")}`), t.join(`,
`);
  }
  /**
   * Returns the structs of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the structs.
   */
  getStructs(e) {
    let t = "";
    const n = this.structs[e];
    if (n.length > 0) {
      const i = [];
      for (const o of n) {
        let l = `struct ${o.name} {
`;
        l += this.getStructMembers(o), l += `
};`, i.push(l);
      }
      t = `
` + i.join(`

`) + `
`;
    }
    return t;
  }
  /**
   * Returns a WGSL string representing a variable.
   *
   * @param {string} type - The variable's type.
   * @param {string} name - The variable's name.
   * @param {?number} [count=null] - The array length.
   * @return {string} The WGSL snippet that defines a variable.
   */
  getVar(e, t, n = null) {
    let i = `var ${t} : `;
    return n !== null ? i += this.generateArrayDeclaration(e, n) : i += this.getType(e), i;
  }
  /**
   * Returns the variables of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the variables.
   */
  getVars(e) {
    const t = [], n = this.vars[e];
    if (n !== void 0)
      for (const i of n)
        t.push(`	${this.getVar(i.type, i.name, i.count)};`);
    return `
${t.join(`
`)}
`;
  }
  /**
   * Returns the varyings of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the varyings.
   */
  getVaryings(e) {
    const t = [];
    if (e === "vertex" && this.getBuiltin("position", "Vertex", "vec4<f32>", "vertex"), e === "vertex" || e === "fragment") {
      const o = this.varyings, l = this.vars[e];
      for (let p = 0; p < o.length; p++) {
        const f = o[p];
        if (f.needsInterpolation) {
          let v = `@location( ${p} )`;
          if (f.interpolationType) {
            const _ = f.interpolationSampling !== null ? `, ${f.interpolationSampling} )` : " )";
            v += ` @interpolate( ${f.interpolationType}${_}`;
          } else /^(int|uint|ivec|uvec)/.test(f.type) && (v += ` @interpolate( ${this.renderer.backend.compatibilityMode ? "flat, either" : "flat"} )`);
          t.push(`${v} ${f.name} : ${this.getType(f.type)}`);
        } else e === "vertex" && l.includes(f) === !1 && l.push(f);
      }
    }
    const n = this.getBuiltins(e);
    n && t.push(n);
    const i = t.join(`,
	`);
    return e === "vertex" ? this._getWGSLStruct("VaryingsStruct", "	" + i) : i;
  }
  isCustomStruct(e) {
    const t = e.value, n = e.node, i = (t.isBufferAttribute || t.isInstancedBufferAttribute) && n.structTypeNode !== null, o = n.value && n.value.array && typeof n.value.itemSize == "number" && n.value.array.length > n.value.itemSize;
    return i && !o;
  }
  /**
   * Returns the uniforms of the given shader stage as a WGSL string.
   *
   * @param {string} shaderStage - The shader stage.
   * @return {string} The WGSL snippet that defines the uniforms.
   */
  getUniforms(e) {
    const t = this.uniforms[e], n = [], i = [], o = [], l = {};
    for (const f of t) {
      const v = f.groupNode.name, _ = this.bindingsIndexes[v];
      if (f.type === "texture" || f.type === "cubeTexture" || f.type === "storageTexture" || f.type === "texture3D") {
        const E = f.node.value;
        this.isUnfilterable(E) === !1 && f.node.isStorageTextureNode !== !0 && (this.isSampleCompare(E) ? n.push(`@binding( ${_.binding++} ) @group( ${_.group} ) var ${f.name}_sampler : sampler_comparison;`) : n.push(`@binding( ${_.binding++} ) @group( ${_.group} ) var ${f.name}_sampler : sampler;`));
        let A, I = "";
        const { primarySamples: j } = this.renderer.backend.utils.getTextureSampleData(E);
        if (j > 1 && (I = "_multisampled"), E.isCubeTexture === !0)
          A = "texture_cube<f32>";
        else if (E.isDepthTexture === !0)
          this.renderer.backend.compatibilityMode && E.compareFunction === null ? A = `texture${I}_2d<f32>` : A = `texture_depth${I}_2d${E.isArrayTexture === !0 ? "_array" : ""}`;
        else if (E.isArrayTexture === !0 || E.isDataArrayTexture === !0 || E.isCompressedArrayTexture === !0)
          A = "texture_2d_array<f32>";
        else if (E.isVideoTexture === !0)
          A = "texture_external";
        else if (E.isData3DTexture === !0)
          A = "texture_3d<f32>";
        else if (f.node.isStorageTextureNode === !0) {
          const q = y6(E), L = this.getStorageAccess(f.node, e);
          A = `texture_storage_2d<${q}, ${L}>`;
        } else {
          const q = this.getComponentTypeFromTexture(E).charAt(0);
          A = `texture${I}_2d<${q}32>`;
        }
        n.push(`@binding( ${_.binding++} ) @group( ${_.group} ) var ${f.name} : ${A};`);
      } else if (f.type === "buffer" || f.type === "storageBuffer" || f.type === "indirectStorageBuffer") {
        const E = f.node, A = this.getType(E.getNodeType(this)), I = E.bufferCount, j = I > 0 && f.type === "buffer" ? ", " + I : "", q = E.isStorageBufferNode ? `storage, ${this.getStorageAccess(E, e)}` : "uniform";
        if (this.isCustomStruct(f))
          i.push(`@binding( ${_.binding++} ) @group( ${_.group} ) var<${q}> ${f.name} : ${A};`);
        else {
          const V = `	value : array< ${E.isAtomic ? `atomic<${A}>` : `${A}`}${j} >`;
          i.push(this._getWGSLStructBinding(f.name, V, q, _.binding++, _.group));
        }
      } else {
        const E = this.getType(this.getVectorType(f.type)), A = f.groupNode.name;
        (l[A] || (l[A] = {
          index: _.binding++,
          id: _.group,
          snippets: []
        })).snippets.push(`	${f.name} : ${E}`);
      }
    }
    for (const f in l) {
      const v = l[f];
      o.push(this._getWGSLStructBinding(f, v.snippets.join(`,
`), "uniform", v.index, v.id));
    }
    let p = n.join(`
`);
    return p += i.join(`
`), p += o.join(`
`), p;
  }
  /**
   * Controls the code build of the shader stages.
   */
  buildCode() {
    const e = this.material !== null ? { fragment: {}, vertex: {} } : { compute: {} };
    this.sortBindingGroups();
    for (const t in e) {
      this.shaderStage = t;
      const n = e[t];
      n.uniforms = this.getUniforms(t), n.attributes = this.getAttributes(t), n.varyings = this.getVaryings(t), n.structs = this.getStructs(t), n.vars = this.getVars(t), n.codes = this.getCodes(t), n.directives = this.getDirectives(t), n.scopedArrays = this.getScopedArrays(t);
      let i = `// code

`;
      i += this.flowCode[t];
      const o = this.flowNodes[t], l = o[o.length - 1], p = l.outputNode, f = p !== void 0 && p.isOutputStructNode === !0;
      for (const v of o) {
        const _ = this.getFlowData(
          v
          /*, shaderStage*/
        ), E = v.name;
        if (E && (i.length > 0 && (i += `
`), i += `	// flow -> ${E}
`), i += `${_.code}
	`, v === l && t !== "compute") {
          if (i += `// result

	`, t === "vertex")
            i += `varyings.Vertex = ${_.result};`;
          else if (t === "fragment")
            if (f)
              n.returnType = p.getNodeType(this), n.structs += "var<private> output : " + n.returnType + ";", i += `return ${_.result};`;
            else {
              let A = "	@location(0) color: vec4<f32>";
              const I = this.getBuiltins("output");
              I && (A += `,
	` + I), n.returnType = "OutputStruct", n.structs += this._getWGSLStruct("OutputStruct", A), n.structs += `
var<private> output : OutputStruct;`, i += `output.color = ${_.result};

	return output;`;
            }
        }
      }
      n.flow = i;
    }
    this.shaderStage = null, this.material !== null ? (this.vertexShader = this._getWGSLVertexCode(e.vertex), this.fragmentShader = this._getWGSLFragmentCode(e.fragment)) : this.computeShader = this._getWGSLComputeCode(e.compute, (this.object.workgroupSize || [64]).join(", "));
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @param {string} method - The method name to resolve.
   * @param {?string} [output=null] - An optional output.
   * @return {string} The resolved WGSL method name.
   */
  getMethod(e, t = null) {
    let n;
    return t !== null && (n = this._getWGSLMethod(e + "_" + t)), n === void 0 && (n = this._getWGSLMethod(e)), n || e;
  }
  /**
   * Returns the WGSL type of the given node data type.
   *
   * @param {string} type - The node data type.
   * @return {string} The WGSL type.
   */
  getType(e) {
    return w3e[e] || e;
  }
  /**
   * Whether the requested feature is available or not.
   *
   * @param {string} name - The requested feature.
   * @return {boolean} Whether the requested feature is supported or not.
   */
  isAvailable(e) {
    let t = Yme[e];
    return t === void 0 && (e === "float32Filterable" ? t = this.renderer.hasFeature("float32-filterable") : e === "clipDistance" && (t = this.renderer.hasFeature("clip-distances")), Yme[e] = t), t;
  }
  /**
   * Returns the native shader method name for a given generic name.
   *
   * @private
   * @param {string} method - The method name to resolve.
   * @return {string} The resolved WGSL method name.
   */
  _getWGSLMethod(e) {
    return il[e] !== void 0 && this._include(e), oE[e];
  }
  /**
   * Includes the given method name into the current
   * function node.
   *
   * @private
   * @param {string} name - The method name to include.
   * @return {CodeNode} The respective code node.
   */
  _include(e) {
    const t = il[e];
    return t.build(this), this.currentFunctionNode !== null && this.currentFunctionNode.includes.push(t), t;
  }
  /**
   * Returns a WGSL vertex shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLVertexCode(e) {
    return `${this.getSignature()}
// directives
${e.directives}

// structs
${e.structs}

// uniforms
${e.uniforms}

// varyings
${e.varyings}
var<private> varyings : VaryingsStruct;

// codes
${e.codes}

@vertex
fn main( ${e.attributes} ) -> VaryingsStruct {

	// vars
	${e.vars}

	// flow
	${e.flow}

	return varyings;

}
`;
  }
  /**
   * Returns a WGSL fragment shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @return {string} The vertex shader.
   */
  _getWGSLFragmentCode(e) {
    return `${this.getSignature()}
// global
${gve}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@fragment
fn main( ${e.varyings} ) -> ${e.returnType} {

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Returns a WGSL compute shader based on the given shader data.
   *
   * @private
   * @param {Object} shaderData - The shader data.
   * @param {string} workgroupSize - The workgroup size.
   * @return {string} The vertex shader.
   */
  _getWGSLComputeCode(e, t) {
    return `${this.getSignature()}
// directives
${e.directives}

// system
var<private> instanceIndex : u32;

// locals
${e.scopedArrays}

// structs
${e.structs}

// uniforms
${e.uniforms}

// codes
${e.codes}

@compute @workgroup_size( ${t} )
fn main( ${e.attributes} ) {

	// system
	instanceIndex = globalId.x + globalId.y * numWorkgroups.x * u32(${t}) + globalId.z * numWorkgroups.x * numWorkgroups.y * u32(${t});

	// vars
	${e.vars}

	// flow
	${e.flow}

}
`;
  }
  /**
   * Returns a WGSL struct based on the given name and variables.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @return {string} The WGSL snippet representing a struct.
   */
  _getWGSLStruct(e, t) {
    return `
struct ${e} {
${t}
};`;
  }
  /**
   * Returns a WGSL struct binding.
   *
   * @private
   * @param {string} name - The struct name.
   * @param {string} vars - The struct variables.
   * @param {string} access - The access.
   * @param {number} [binding=0] - The binding index.
   * @param {number} [group=0] - The group index.
   * @return {string} The WGSL snippet representing a struct binding.
   */
  _getWGSLStructBinding(e, t, n, i = 0, o = 0) {
    const l = e + "Struct";
    return `${this._getWGSLStruct(l, t)}
@binding( ${i} ) @group( ${o} )
var<${n}> ${e} : ${l};`;
  }
}
class T3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Returns the depth/stencil GPU format for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The depth/stencil GPU texture format.
   */
  getCurrentDepthStencilFormat(e) {
    let t;
    return e.depthTexture !== null ? t = this.getTextureFormatGPU(e.depthTexture) : e.depth && e.stencil ? t = we.Depth24PlusStencil8 : e.depth && (t = we.Depth24Plus), t;
  }
  /**
   * Returns the GPU format for the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {string} The GPU texture format.
   */
  getTextureFormatGPU(e) {
    return this.backend.get(e).format;
  }
  /**
   * Returns an object that defines the multi-sampling state of the given texture.
   *
   * @param {Texture} texture - The texture.
   * @return {Object} The multi-sampling state.
   */
  getTextureSampleData(e) {
    let t;
    if (e.isFramebufferTexture)
      t = 1;
    else if (e.isDepthTexture && !e.renderTarget) {
      const o = this.backend.renderer, l = o.getRenderTarget();
      t = l ? l.samples : o.samples;
    } else e.renderTarget && (t = e.renderTarget.samples);
    t = t || 1;
    const n = t > 1 && e.renderTarget !== null && e.isDepthTexture !== !0 && e.isFramebufferTexture !== !0;
    return { samples: t, primarySamples: n ? 1 : t, isMSAA: n };
  }
  /**
   * Returns the default color attachment's GPU format of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The GPU texture format of the default color attachment.
   */
  getCurrentColorFormat(e) {
    let t;
    return e.textures !== null ? t = this.getTextureFormatGPU(e.textures[0]) : t = this.getPreferredCanvasFormat(), t;
  }
  /**
   * Returns the output color space of the current render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {string} The output color space.
   */
  getCurrentColorSpace(e) {
    return e.textures !== null ? e.textures[0].colorSpace : this.backend.renderer.outputColorSpace;
  }
  /**
   * Returns GPU primitive topology for the given object and material.
   *
   * @param {Object3D} object - The 3D object.
   * @param {Material} material - The material.
   * @return {string} The GPU primitive topology.
   */
  getPrimitiveTopology(e, t) {
    if (e.isPoints) return Ab.PointList;
    if (e.isLineSegments || e.isMesh && t.wireframe === !0) return Ab.LineList;
    if (e.isLine) return Ab.LineStrip;
    if (e.isMesh) return Ab.TriangleList;
  }
  /**
   * Returns a modified sample count from the given sample count value.
   *
   * That is required since WebGPU does not support arbitrary sample counts.
   *
   * @param {number} sampleCount - The input sample count.
   * @return {number} The (potentially updated) output sample count.
   */
  getSampleCount(e) {
    let t = 1;
    return e > 1 && (t = Math.pow(2, Math.floor(Math.log2(e))), t === 2 && (t = 4)), t;
  }
  /**
   * Returns the sample count of the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  getSampleCountRenderContext(e) {
    return e.textures !== null ? this.getSampleCount(e.sampleCount) : this.getSampleCount(this.backend.renderer.samples);
  }
  /**
   * Returns the preferred canvas format.
   *
   * There is a separate method for this so it's possible to
   * honor edge cases for specific devices.
   *
   * @return {string} The GPU texture format of the canvas.
   */
  getPreferredCanvasFormat() {
    const e = this.backend.parameters.outputType;
    if (e === void 0)
      return navigator.gpu.getPreferredCanvasFormat();
    if (e === yo)
      return we.BGRA8Unorm;
    if (e === ol)
      return we.RGBA16Float;
    throw new Error("Unsupported outputType");
  }
}
const C3e = /* @__PURE__ */ new Map([
  [Int8Array, ["sint8", "snorm8"]],
  [Uint8Array, ["uint8", "unorm8"]],
  [Int16Array, ["sint16", "snorm16"]],
  [Uint16Array, ["uint16", "unorm16"]],
  [Int32Array, ["sint32", "snorm32"]],
  [Uint32Array, ["uint32", "unorm32"]],
  [Float32Array, ["float32"]]
]), P3e = /* @__PURE__ */ new Map([
  [kye, ["float16"]]
]), A3e = /* @__PURE__ */ new Map([
  [Int32Array, "sint32"],
  [Int16Array, "sint32"],
  // patch for INT16
  [Uint32Array, "uint32"],
  [Uint16Array, "uint32"],
  // patch for UINT16
  [Float32Array, "float32"]
]);
class k3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e;
  }
  /**
   * Creates the GPU buffer for the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   * @param {GPUBufferUsage} usage - A flag that indicates how the buffer may be used after its creation.
   */
  createAttribute(e, t) {
    const n = this._getBufferAttribute(e), i = this.backend, o = i.get(n);
    let l = o.buffer;
    if (l === void 0) {
      const p = i.device;
      let f = n.array;
      if (e.normalized === !1) {
        if (f.constructor === Int16Array || f.constructor === Int8Array)
          f = new Int32Array(f);
        else if ((f.constructor === Uint16Array || f.constructor === Uint8Array) && (f = new Uint32Array(f), t & GPUBufferUsage.INDEX))
          for (let E = 0; E < f.length; E++)
            f[E] === 65535 && (f[E] = 4294967295);
      }
      if (n.array = f, (n.isStorageBufferAttribute || n.isStorageInstancedBufferAttribute) && n.itemSize === 3) {
        f = new f.constructor(n.count * 4);
        for (let E = 0; E < n.count; E++)
          f.set(n.array.subarray(E * 3, E * 3 + 3), E * 4);
        n.itemSize = 4, n.array = f, o._force3to4BytesAlignment = !0;
      }
      const v = f.byteLength, _ = v + (4 - v % 4) % 4;
      l = p.createBuffer({
        label: n.name,
        size: _,
        usage: t,
        mappedAtCreation: !0
      }), new f.constructor(l.getMappedRange()).set(f), l.unmap(), o.buffer = l;
    }
  }
  /**
   * Updates the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  updateAttribute(e) {
    const t = this._getBufferAttribute(e), n = this.backend, i = n.device, o = n.get(t), l = n.get(t).buffer;
    let p = t.array;
    if (o._force3to4BytesAlignment === !0) {
      p = new p.constructor(t.count * 4);
      for (let _ = 0; _ < t.count; _++)
        p.set(t.array.subarray(_ * 3, _ * 3 + 3), _ * 4);
      t.array = p;
    }
    const f = this._isTypedArray(p), v = t.updateRanges;
    if (v.length === 0)
      i.queue.writeBuffer(
        l,
        0,
        p,
        0
      );
    else {
      const _ = f ? 1 : p.BYTES_PER_ELEMENT;
      for (let E = 0, A = v.length; E < A; E++) {
        const I = v[E];
        let j, q;
        if (o._force3to4BytesAlignment === !0) {
          const V = Math.floor(I.start / 3), re = Math.ceil(I.count / 3);
          j = V * 4 * _, q = re * 4 * _;
        } else
          j = I.start * _, q = I.count * _;
        const L = j * (f ? p.BYTES_PER_ELEMENT : 1);
        i.queue.writeBuffer(
          l,
          L,
          p,
          j,
          q
        );
      }
      t.clearUpdateRanges();
    }
  }
  /**
   * This method creates the vertex buffer layout data which are
   * require when creating a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {Array<Object>} An array holding objects which describe the vertex buffer layout.
   */
  createShaderVertexBuffers(e) {
    const t = e.getAttributes(), n = /* @__PURE__ */ new Map();
    for (let i = 0; i < t.length; i++) {
      const o = t[i], l = o.array.BYTES_PER_ELEMENT, p = this._getBufferAttribute(o);
      let f = n.get(p);
      if (f === void 0) {
        let E, A;
        o.isInterleavedBufferAttribute === !0 ? (E = o.data.stride * l, A = o.data.isInstancedInterleavedBuffer ? ZN.Instance : ZN.Vertex) : (E = o.itemSize * l, A = o.isInstancedBufferAttribute ? ZN.Instance : ZN.Vertex), o.normalized === !1 && (o.array.constructor === Int16Array || o.array.constructor === Uint16Array) && (E = 4), f = {
          arrayStride: E,
          attributes: [],
          stepMode: A
        }, n.set(p, f);
      }
      const v = this._getVertexFormat(o), _ = o.isInterleavedBufferAttribute === !0 ? o.offset * l : 0;
      f.attributes.push({
        shaderLocation: i,
        offset: _,
        format: v
      });
    }
    return Array.from(n.values());
  }
  /**
   * Destroys the GPU buffer of the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  destroyAttribute(e) {
    const t = this.backend;
    t.get(this._getBufferAttribute(e)).buffer.destroy(), t.delete(e);
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    const t = this.backend, n = t.device, o = t.get(this._getBufferAttribute(e)).buffer, l = o.size, p = n.createBuffer({
      label: `${e.name}_readback`,
      size: l,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    }), f = n.createCommandEncoder({
      label: `readback_encoder_${e.name}`
    });
    f.copyBufferToBuffer(
      o,
      0,
      p,
      0,
      l
    );
    const v = f.finish();
    n.queue.submit([v]), await p.mapAsync(GPUMapMode.READ);
    const _ = p.getMappedRange(), E = new e.array.constructor(_.slice(0));
    return p.unmap(), E.buffer;
  }
  /**
   * Returns the vertex format of the given buffer attribute.
   *
   * @private
   * @param {BufferAttribute} geometryAttribute - The buffer attribute.
   * @return {string|undefined} The vertex format (e.g. 'float32x3').
   */
  _getVertexFormat(e) {
    const { itemSize: t, normalized: n } = e, i = e.array.constructor, o = e.constructor;
    let l;
    if (t === 1)
      l = A3e.get(i);
    else {
      const f = (P3e.get(o) || C3e.get(i))[n ? 1 : 0];
      if (f) {
        const v = i.BYTES_PER_ELEMENT * t, E = Math.floor((v + 3) / 4) * 4 / i.BYTES_PER_ELEMENT;
        if (E % 1)
          throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");
        l = `${f}x${E}`;
      }
    }
    return l || console.error("THREE.WebGPUAttributeUtils: Vertex format not supported yet."), l;
  }
  /**
   * Returns `true` if the given array is a typed array.
   *
   * @private
   * @param {any} array - The array.
   * @return {boolean} Whether the given array is a typed array or not.
   */
  _isTypedArray(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  /**
   * Utility method for handling interleaved buffer attributes correctly.
   * To process them, their `InterleavedBuffer` is returned.
   *
   * @private
   * @param {BufferAttribute} attribute - The attribute.
   * @return {BufferAttribute|InterleavedBuffer}
   */
  _getBufferAttribute(e) {
    return e.isInterleavedBufferAttribute && (e = e.data), e;
  }
}
class M3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this.bindGroupLayoutCache = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Creates a GPU bind group layout for the given bind group.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @return {GPUBindGroupLayout} The GPU bind group layout.
   */
  createBindingsLayout(e) {
    const t = this.backend, n = t.device, i = [];
    let o = 0;
    for (const l of e.bindings) {
      const p = {
        binding: o++,
        visibility: l.visibility
      };
      if (l.isUniformBuffer || l.isStorageBuffer) {
        const f = {};
        l.isStorageBuffer && (l.visibility & 4 && (l.access === Fd.READ_WRITE || l.access === Fd.WRITE_ONLY) ? f.type = fV.Storage : f.type = fV.ReadOnlyStorage), p.buffer = f;
      } else if (l.isSampler) {
        const f = {};
        l.texture.isDepthTexture && (l.texture.compareFunction !== null ? f.type = Hme.Comparison : t.compatibilityMode && (f.type = Hme.NonFiltering)), p.sampler = f;
      } else if (l.isSampledTexture && l.texture.isVideoTexture)
        p.externalTexture = {};
      else if (l.isSampledTexture && l.store) {
        const f = {};
        f.format = this.backend.get(l.texture).texture.format;
        const v = l.access;
        v === Fd.READ_WRITE ? f.access = mV.ReadWrite : v === Fd.WRITE_ONLY ? f.access = mV.WriteOnly : f.access = mV.ReadOnly, p.storageTexture = f;
      } else if (l.isSampledTexture) {
        const f = {}, { primarySamples: v } = t.utils.getTextureSampleData(l.texture);
        if (v > 1 && (f.multisampled = !0, l.texture.isDepthTexture || (f.sampleType = og.UnfilterableFloat)), l.texture.isDepthTexture)
          t.compatibilityMode && l.texture.compareFunction === null ? f.sampleType = og.UnfilterableFloat : f.sampleType = og.Depth;
        else if (l.texture.isDataTexture || l.texture.isDataArrayTexture || l.texture.isData3DTexture) {
          const _ = l.texture.type;
          _ === fo ? f.sampleType = og.SInt : _ === xi ? f.sampleType = og.UInt : _ === wa && (this.backend.hasFeature("float32-filterable") ? f.sampleType = og.Float : f.sampleType = og.UnfilterableFloat);
        }
        l.isSampledCubeTexture ? f.viewDimension = us.Cube : l.texture.isArrayTexture || l.texture.isDataArrayTexture || l.texture.isCompressedArrayTexture ? f.viewDimension = us.TwoDArray : l.isSampledTexture3D && (f.viewDimension = us.ThreeD), p.texture = f;
      } else
        console.error(`WebGPUBindingUtils: Unsupported binding "${l}".`);
      i.push(p);
    }
    return n.createBindGroupLayout({ entries: i });
  }
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t, n, i = 0) {
    const { backend: o, bindGroupLayoutCache: l } = this, p = o.get(e);
    let f = l.get(e.bindingsReference);
    f === void 0 && (f = this.createBindingsLayout(e), l.set(e.bindingsReference, f));
    let v;
    n > 0 && (p.groups === void 0 && (p.groups = [], p.versions = []), p.versions[n] === i && (v = p.groups[n])), v === void 0 && (v = this.createBindGroup(e, f), n > 0 && (p.groups[n] = v, p.versions[n] = i)), p.group = v, p.layout = f;
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    const t = this.backend, n = t.device, i = e.buffer, o = t.get(e).buffer;
    n.queue.writeBuffer(o, 0, i, 0);
  }
  /**
   * Creates a GPU bind group for the camera index.
   *
   * @param {Uint32Array} data - The index data.
   * @param {GPUBindGroupLayout} layout - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroupIndex(e, t) {
    const i = this.backend.device, o = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, l = e[0], p = i.createBuffer({
      label: "bindingCameraIndex_" + l,
      size: 16,
      // uint(4) * 4
      usage: o
    });
    i.queue.writeBuffer(p, 0, e, 0);
    const f = [{ binding: 0, resource: { buffer: p } }];
    return i.createBindGroup({
      label: "bindGroupCameraIndex_" + l,
      layout: t,
      entries: f
    });
  }
  /**
   * Creates a GPU bind group for the given bind group and GPU layout.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {GPUBindGroupLayout} layoutGPU - The GPU bind group layout.
   * @return {GPUBindGroup} The GPU bind group.
   */
  createBindGroup(e, t) {
    const n = this.backend, i = n.device;
    let o = 0;
    const l = [];
    for (const p of e.bindings) {
      if (p.isUniformBuffer) {
        const f = n.get(p);
        if (f.buffer === void 0) {
          const v = p.byteLength, _ = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST, E = i.createBuffer({
            label: "bindingBuffer_" + p.name,
            size: v,
            usage: _
          });
          f.buffer = E;
        }
        l.push({ binding: o, resource: { buffer: f.buffer } });
      } else if (p.isStorageBuffer) {
        const f = n.get(p);
        if (f.buffer === void 0) {
          const v = p.attribute;
          f.buffer = n.get(v).buffer;
        }
        l.push({ binding: o, resource: { buffer: f.buffer } });
      } else if (p.isSampler) {
        const f = n.get(p.texture);
        l.push({ binding: o, resource: f.sampler });
      } else if (p.isSampledTexture) {
        const f = n.get(p.texture);
        let v;
        if (f.externalTexture !== void 0)
          v = i.importExternalTexture({ source: f.externalTexture });
        else {
          const _ = p.store ? 1 : f.texture.mipLevelCount, E = `view-${f.texture.width}-${f.texture.height}-${_}`;
          if (v = f[E], v === void 0) {
            const A = o3e.All;
            let I;
            p.isSampledCubeTexture ? I = us.Cube : p.isSampledTexture3D ? I = us.ThreeD : p.texture.isArrayTexture || p.texture.isDataArrayTexture || p.texture.isCompressedArrayTexture ? I = us.TwoDArray : I = us.TwoD, v = f[E] = f.texture.createView({ aspect: A, dimension: I, mipLevelCount: _ });
          }
        }
        l.push({ binding: o, resource: v });
      }
      o++;
    }
    return i.createBindGroup({
      label: "bindGroup_" + e.name,
      layout: t,
      entries: l
    });
  }
}
class R3e {
  /**
   * Constructs a new utility object.
   *
   * @param {WebGPUBackend} backend - The WebGPU backend.
   */
  constructor(e) {
    this.backend = e, this._activePipelines = /* @__PURE__ */ new WeakMap();
  }
  /**
   * Sets the given pipeline for the given pass. The method makes sure to only set the
   * pipeline when necessary.
   *
   * @param {(GPURenderPassEncoder|GPUComputePassEncoder)} pass - The pass encoder.
   * @param {(GPURenderPipeline|GPUComputePipeline)} pipeline - The pipeline.
   */
  setPipeline(e, t) {
    this._activePipelines.get(e) !== t && (e.setPipeline(t), this._activePipelines.set(e, t));
  }
  /**
   * Returns the sample count derived from the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @return {number} The sample count.
   */
  _getSampleCount(e) {
    return this.backend.utils.getSampleCountRenderContext(e);
  }
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    const { object: n, material: i, geometry: o, pipeline: l } = e, { vertexProgram: p, fragmentProgram: f } = l, v = this.backend, _ = v.device, E = v.utils, A = v.get(l), I = [];
    for (const St of e.getBindings()) {
      const Ct = v.get(St);
      I.push(Ct.layout);
    }
    const j = v.attributeUtils.createShaderVertexBuffers(e);
    let q;
    i.blending !== zb && (i.blending !== jd || i.transparent !== !1) && (q = this._getBlending(i));
    let L = {};
    i.stencilWrite === !0 && (L = {
      compare: this._getStencilCompare(i),
      failOp: this._getStencilOperation(i.stencilFail),
      depthFailOp: this._getStencilOperation(i.stencilZFail),
      passOp: this._getStencilOperation(i.stencilZPass)
    });
    const V = this._getColorWriteMask(i), re = [];
    if (e.context.textures !== null) {
      const St = e.context.textures;
      for (let Ct = 0; Ct < St.length; Ct++) {
        const pe = E.getTextureFormatGPU(St[Ct]);
        re.push({
          format: pe,
          blend: q,
          writeMask: V
        });
      }
    } else {
      const St = E.getCurrentColorFormat(e.context);
      re.push({
        format: St,
        blend: q,
        writeMask: V
      });
    }
    const R = v.get(p).module, J = v.get(f).module, ge = this._getPrimitiveState(n, o, i), _e = this._getDepthCompare(i), Y = E.getCurrentDepthStencilFormat(e.context), Fe = this._getSampleCount(e.context), Me = {
      label: `renderPipeline_${i.name || i.type}_${i.id}`,
      vertex: Object.assign({}, R, { buffers: j }),
      fragment: Object.assign({}, J, { targets: re }),
      primitive: ge,
      multisample: {
        count: Fe,
        alphaToCoverageEnabled: i.alphaToCoverage && Fe > 1
      },
      layout: _.createPipelineLayout({
        bindGroupLayouts: I
      })
    }, $ = {}, dt = e.context.depth, wt = e.context.stencil;
    if ((dt === !0 || wt === !0) && (dt === !0 && ($.format = Y, $.depthWriteEnabled = i.depthWrite, $.depthCompare = _e), wt === !0 && ($.stencilFront = L, $.stencilBack = {}, $.stencilReadMask = i.stencilFuncMask, $.stencilWriteMask = i.stencilWriteMask), i.polygonOffset === !0 && ($.depthBias = i.polygonOffsetUnits, $.depthBiasSlopeScale = i.polygonOffsetFactor, $.depthBiasClamp = 0), Me.depthStencil = $), t === null)
      A.pipeline = _.createRenderPipeline(Me);
    else {
      const St = new Promise((Ct) => {
        _.createRenderPipelineAsync(Me).then((pe) => {
          A.pipeline = pe, Ct();
        });
      });
      t.push(St);
    }
  }
  /**
   * Creates GPU render bundle encoder for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {?string} [label='renderBundleEncoder'] - The label.
   * @return {GPURenderBundleEncoder} The GPU render bundle encoder.
   */
  createBundleEncoder(e, t = "renderBundleEncoder") {
    const n = this.backend, { utils: i, device: o } = n, l = i.getCurrentDepthStencilFormat(e), p = i.getCurrentColorFormat(e), f = this._getSampleCount(e), v = {
      label: t,
      colorFormats: [p],
      depthStencilFormat: l,
      sampleCount: f
    };
    return o.createRenderBundleEncoder(v);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} pipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    const n = this.backend, i = n.device, o = n.get(e.computeProgram).module, l = n.get(e), p = [];
    for (const f of t) {
      const v = n.get(f);
      p.push(v.layout);
    }
    l.pipeline = i.createComputePipeline({
      compute: o,
      layout: i.createPipelineLayout({
        bindGroupLayouts: p
      })
    });
  }
  /**
   * Returns the blending state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {Object} The blending state.
   */
  _getBlending(e) {
    let t, n;
    const i = e.blending, o = e.blendSrc, l = e.blendDst, p = e.blendEquation;
    if (i === pE) {
      const f = e.blendSrcAlpha !== null ? e.blendSrcAlpha : o, v = e.blendDstAlpha !== null ? e.blendDstAlpha : l, _ = e.blendEquationAlpha !== null ? e.blendEquationAlpha : p;
      t = {
        srcFactor: this._getBlendFactor(o),
        dstFactor: this._getBlendFactor(l),
        operation: this._getBlendOperation(p)
      }, n = {
        srcFactor: this._getBlendFactor(f),
        dstFactor: this._getBlendFactor(v),
        operation: this._getBlendOperation(_)
      };
    } else {
      const f = e.premultipliedAlpha, v = (_, E, A, I) => {
        t = {
          srcFactor: _,
          dstFactor: E,
          operation: sg.Add
        }, n = {
          srcFactor: A,
          dstFactor: I,
          operation: sg.Add
        };
      };
      if (f)
        switch (i) {
          case jd:
            v(pn.One, pn.OneMinusSrcAlpha, pn.One, pn.OneMinusSrcAlpha);
            break;
          case CO:
            v(pn.One, pn.One, pn.One, pn.One);
            break;
          case PO:
            v(pn.Zero, pn.OneMinusSrc, pn.Zero, pn.One);
            break;
          case AO:
            v(pn.Zero, pn.Src, pn.Zero, pn.SrcAlpha);
            break;
        }
      else
        switch (i) {
          case jd:
            v(pn.SrcAlpha, pn.OneMinusSrcAlpha, pn.One, pn.OneMinusSrcAlpha);
            break;
          case CO:
            v(pn.SrcAlpha, pn.One, pn.SrcAlpha, pn.One);
            break;
          case PO:
            v(pn.Zero, pn.OneMinusSrc, pn.Zero, pn.One);
            break;
          case AO:
            v(pn.Zero, pn.Src, pn.Zero, pn.Src);
            break;
        }
    }
    if (t !== void 0 && n !== void 0)
      return { color: t, alpha: n };
    console.error("THREE.WebGPURenderer: Invalid blending: ", i);
  }
  /**
   * Returns the GPU blend factor which is required for the pipeline creation.
   *
   * @private
   * @param {number} blend - The blend factor as a three.js constant.
   * @return {string} The GPU blend factor.
   */
  _getBlendFactor(e) {
    let t;
    switch (e) {
      case Vp:
        t = pn.Zero;
        break;
      case Zge:
        t = pn.One;
        break;
      case Jge:
        t = pn.Src;
        break;
      case eye:
        t = pn.OneMinusSrc;
        break;
      case kO:
        t = pn.SrcAlpha;
        break;
      case MO:
        t = pn.OneMinusSrcAlpha;
        break;
      case rye:
        t = pn.Dst;
        break;
      case iye:
        t = pn.OneMinusDst;
        break;
      case tye:
        t = pn.DstAlpha;
        break;
      case nye:
        t = pn.OneMinusDstAlpha;
        break;
      case sye:
        t = pn.SrcAlphaSaturated;
        break;
      case ORe:
        t = pn.Constant;
        break;
      case DRe:
        t = pn.OneMinusConstant;
        break;
      default:
        console.error("THREE.WebGPURenderer: Blend factor not supported.", e);
    }
    return t;
  }
  /**
   * Returns the GPU stencil compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU stencil compare function.
   */
  _getStencilCompare(e) {
    let t;
    const n = e.stencilFunc;
    switch (n) {
      case fRe:
        t = Ps.Never;
        break;
      case r6:
        t = Ps.Always;
        break;
      case mRe:
        t = Ps.Less;
        break;
      case yRe:
        t = Ps.LessEqual;
        break;
      case gRe:
        t = Ps.Equal;
        break;
      case xRe:
        t = Ps.GreaterEqual;
        break;
      case vRe:
        t = Ps.Greater;
        break;
      case bRe:
        t = Ps.NotEqual;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil function.", n);
    }
    return t;
  }
  /**
   * Returns the GPU stencil operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} op - A three.js constant defining the stencil operation.
   * @return {string} The GPU stencil operation.
   */
  _getStencilOperation(e) {
    let t;
    switch (e) {
      case pg:
        t = Lp.Keep;
        break;
      case aRe:
        t = Lp.Zero;
        break;
      case lRe:
        t = Lp.Replace;
        break;
      case pRe:
        t = Lp.Invert;
        break;
      case uRe:
        t = Lp.IncrementClamp;
        break;
      case cRe:
        t = Lp.DecrementClamp;
        break;
      case dRe:
        t = Lp.IncrementWrap;
        break;
      case hRe:
        t = Lp.DecrementWrap;
        break;
      default:
        console.error("THREE.WebGPURenderer: Invalid stencil operation.", t);
    }
    return t;
  }
  /**
   * Returns the GPU blend operation which is required for the pipeline creation.
   *
   * @private
   * @param {number} blendEquation - A three.js constant defining the blend equation.
   * @return {string} The GPU blend operation.
   */
  _getBlendOperation(e) {
    let t;
    switch (e) {
      case uu:
        t = sg.Add;
        break;
      case Xge:
        t = sg.Subtract;
        break;
      case Qge:
        t = sg.ReverseSubtract;
        break;
      case HMe:
        t = sg.Min;
        break;
      case $Me:
        t = sg.Max;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Blend equation not supported.", e);
    }
    return t;
  }
  /**
   * Returns the primitive state as a descriptor object required
   * for the pipeline creation.
   *
   * @private
   * @param {Object3D} object - The 3D object.
   * @param {BufferGeometry} geometry - The geometry.
   * @param {Material} material - The material.
   * @return {Object} The primitive state.
   */
  _getPrimitiveState(e, t, n) {
    const i = {}, o = this.backend.utils;
    switch (i.topology = o.getPrimitiveTopology(e, n), t.index !== null && e.isLine === !0 && e.isLineSegments !== !0 && (i.stripIndexFormat = t.index.array instanceof Uint16Array ? Kb.Uint16 : Kb.Uint32), n.side) {
      case Ld:
        i.frontFace = dV.CCW, i.cullMode = hV.Back;
        break;
      case Ko:
        i.frontFace = dV.CCW, i.cullMode = hV.Front;
        break;
      case Mb:
        i.frontFace = dV.CCW, i.cullMode = hV.None;
        break;
      default:
        console.error("THREE.WebGPUPipelineUtils: Unknown material.side value.", n.side);
        break;
    }
    return i;
  }
  /**
   * Returns the GPU color write mask which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU color write mask.
   */
  _getColorWriteMask(e) {
    return e.colorWrite === !0 ? qme.All : qme.None;
  }
  /**
   * Returns the GPU depth compare function which is required for the pipeline creation.
   *
   * @private
   * @param {Material} material - The material.
   * @return {string} The GPU depth compare function.
   */
  _getDepthCompare(e) {
    let t;
    if (e.depthTest === !1)
      t = Ps.Always;
    else {
      const n = e.depthFunc;
      switch (n) {
        case oye:
          t = Ps.Never;
          break;
        case aye:
          t = Ps.Always;
          break;
        case lye:
          t = Ps.Less;
          break;
        case RO:
          t = Ps.LessEqual;
          break;
        case uye:
          t = Ps.Equal;
          break;
        case cye:
          t = Ps.GreaterEqual;
          break;
        case dye:
          t = Ps.Greater;
          break;
        case hye:
          t = Ps.NotEqual;
          break;
        default:
          console.error("THREE.WebGPUPipelineUtils: Invalid depth function.", n);
      }
    }
    return t;
  }
}
class I3e extends mve {
  /**
   * Creates a new WebGPU timestamp query pool.
   *
   * @param {GPUDevice} device - The WebGPU device to create queries on.
   * @param {string} type - The type identifier for this query pool.
   * @param {number} [maxQueries=2048] - Maximum number of queries this pool can hold.
   */
  constructor(e, t, n = 2048) {
    super(n), this.device = e, this.type = t, this.querySet = this.device.createQuerySet({
      type: "timestamp",
      count: this.maxQueries,
      label: `queryset_global_timestamp_${t}`
    });
    const i = this.maxQueries * 8;
    this.resolveBuffer = this.device.createBuffer({
      label: `buffer_timestamp_resolve_${t}`,
      size: i,
      usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
    }), this.resultBuffer = this.device.createBuffer({
      label: `buffer_timestamp_result_${t}`,
      size: i,
      usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
    });
  }
  /**
   * Allocates a pair of queries for a given render context.
   *
   * @param {Object} renderContext - The render context to allocate queries for.
   * @returns {?number} The base offset for the allocated queries, or null if allocation failed.
   */
  allocateQueriesForContext(e) {
    if (!this.trackTimestamp || this.isDisposed) return null;
    if (this.currentQueryIndex + 2 > this.maxQueries)
      return Wd(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`), null;
    const t = this.currentQueryIndex;
    return this.currentQueryIndex += 2, this.queryOffsets.set(e.id, t), t;
  }
  /**
   * Asynchronously resolves all pending queries and returns the total duration.
   * If there's already a pending resolve operation, returns that promise instead.
   *
   * @async
   * @returns {Promise<number>} The total duration in milliseconds, or the last valid value if resolution fails.
   */
  async resolveQueriesAsync() {
    if (!this.trackTimestamp || this.currentQueryIndex === 0 || this.isDisposed)
      return this.lastValue;
    if (this.pendingResolve)
      return this.pendingResolve;
    this.pendingResolve = this._resolveQueries();
    try {
      return await this.pendingResolve;
    } finally {
      this.pendingResolve = null;
    }
  }
  /**
   * Internal method to resolve queries and calculate total duration.
   *
   * @async
   * @private
   * @returns {Promise<number>} The total duration in milliseconds.
   */
  async _resolveQueries() {
    if (this.isDisposed)
      return this.lastValue;
    try {
      if (this.resultBuffer.mapState !== "unmapped")
        return this.lastValue;
      const e = new Map(this.queryOffsets), t = this.currentQueryIndex, n = t * 8;
      this.currentQueryIndex = 0, this.queryOffsets.clear();
      const i = this.device.createCommandEncoder();
      i.resolveQuerySet(
        this.querySet,
        0,
        t,
        this.resolveBuffer,
        0
      ), i.copyBufferToBuffer(
        this.resolveBuffer,
        0,
        this.resultBuffer,
        0,
        n
      );
      const o = i.finish();
      if (this.device.queue.submit([o]), this.resultBuffer.mapState !== "unmapped")
        return this.lastValue;
      if (await this.resultBuffer.mapAsync(GPUMapMode.READ, 0, n), this.isDisposed)
        return this.resultBuffer.mapState === "mapped" && this.resultBuffer.unmap(), this.lastValue;
      const l = new BigUint64Array(this.resultBuffer.getMappedRange(0, n));
      let p = 0;
      for (const [, f] of e) {
        const v = l[f], _ = l[f + 1], E = Number(_ - v) / 1e6;
        p += E;
      }
      return this.resultBuffer.unmap(), this.lastValue = p, p;
    } catch (e) {
      return console.error("Error resolving queries:", e), this.resultBuffer.mapState === "mapped" && this.resultBuffer.unmap(), this.lastValue;
    }
  }
  /**
   * Dispose of the query pool.
   *
   * @async
   * @returns {Promise} A Promise that resolves when the dispose has been executed.
   */
  async dispose() {
    if (!this.isDisposed) {
      if (this.isDisposed = !0, this.pendingResolve)
        try {
          await this.pendingResolve;
        } catch (e) {
          console.error("Error waiting for pending resolve:", e);
        }
      if (this.resultBuffer && this.resultBuffer.mapState === "mapped")
        try {
          this.resultBuffer.unmap();
        } catch (e) {
          console.error("Error unmapping buffer:", e);
        }
      this.querySet && (this.querySet.destroy(), this.querySet = null), this.resolveBuffer && (this.resolveBuffer.destroy(), this.resolveBuffer = null), this.resultBuffer && (this.resultBuffer.destroy(), this.resultBuffer = null), this.queryOffsets.clear(), this.pendingResolve = null;
    }
  }
}
class N3e extends fve {
  /**
   * WebGPUBackend options.
   *
   * @typedef {Object} WebGPUBackend~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [compatibilityMode=false] - Whether the backend should be in compatibility mode or not.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
   * @property {string} [powerPreference=undefined] - The power preference.
   * @property {Object} [requiredLimits=undefined] - Specifies the limits that are required by the device request. The request will fail if the adapter cannot provide these limits.
   * @property {GPUDevice} [device=undefined] - If there is an existing GPU device on app level, it can be passed to the renderer as a parameter.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   */
  /**
   * Constructs a new WebGPU backend.
   *
   * @param {WebGPUBackend~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    super(e), this.isWebGPUBackend = !0, this.parameters.alpha = e.alpha === void 0 ? !0 : e.alpha, this.parameters.compatibilityMode = e.compatibilityMode === void 0 ? !1 : e.compatibilityMode, this.parameters.requiredLimits = e.requiredLimits === void 0 ? {} : e.requiredLimits, this.compatibilityMode = this.parameters.compatibilityMode, this.device = null, this.context = null, this.colorBuffer = null, this.defaultRenderPassdescriptor = null, this.utils = new T3e(this), this.attributeUtils = new k3e(this), this.bindingUtils = new M3e(this), this.pipelineUtils = new R3e(this), this.textureUtils = new m3e(this), this.occludedResolveCache = /* @__PURE__ */ new Map();
  }
  /**
   * Initializes the backend so it is ready for usage.
   *
   * @async
   * @param {Renderer} renderer - The renderer.
   * @return {Promise} A Promise that resolves when the backend has been initialized.
   */
  async init(e) {
    await super.init(e);
    const t = this.parameters;
    let n;
    if (t.device === void 0) {
      const l = {
        powerPreference: t.powerPreference,
        featureLevel: t.compatibilityMode ? "compatibility" : void 0
      }, p = typeof navigator < "u" ? await navigator.gpu.requestAdapter(l) : null;
      if (p === null)
        throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");
      const f = Object.values(g6), v = [];
      for (const E of f)
        p.features.has(E) && v.push(E);
      const _ = {
        requiredFeatures: v,
        requiredLimits: t.requiredLimits
      };
      n = await p.requestDevice(_);
    } else
      n = t.device;
    n.lost.then((l) => {
      const p = {
        api: "WebGPU",
        message: l.message || "Unknown reason",
        reason: l.reason || null,
        originalEvent: l
      };
      e.onDeviceLost(p);
    });
    const i = t.context !== void 0 ? t.context : e.domElement.getContext("webgpu");
    this.device = n, this.context = i;
    const o = t.alpha ? "premultiplied" : "opaque";
    this.trackTimestamp = this.trackTimestamp && this.hasFeature(g6.TimestampQuery), this.context.configure({
      device: this.device,
      format: this.utils.getPreferredCanvasFormat(),
      usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
      alphaMode: o
    }), this.updateSize();
  }
  /**
   * The coordinate system of the backend.
   *
   * @type {number}
   * @readonly
   */
  get coordinateSystem() {
    return Jp;
  }
  /**
   * This method performs a readback operation by moving buffer data from
   * a storage buffer attribute from the GPU to the CPU.
   *
   * @async
   * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
   * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
   */
  async getArrayBufferAsync(e) {
    return await this.attributeUtils.getArrayBufferAsync(e);
  }
  /**
   * Returns the backend's rendering context.
   *
   * @return {GPUCanvasContext} The rendering context.
   */
  getContext() {
    return this.context;
  }
  /**
   * Returns the default render pass descriptor.
   *
   * In WebGPU, the default framebuffer must be configured
   * like custom framebuffers so the backend needs a render
   * pass descriptor even when rendering directly to screen.
   *
   * @private
   * @return {Object} The render pass descriptor.
   */
  _getDefaultRenderPassDescriptor() {
    let e = this.defaultRenderPassdescriptor;
    if (e === null) {
      const n = this.renderer;
      e = {
        colorAttachments: [{
          view: null
        }]
      }, (this.renderer.depth === !0 || this.renderer.stencil === !0) && (e.depthStencilAttachment = {
        view: this.textureUtils.getDepthBuffer(n.depth, n.stencil).createView()
      });
      const i = e.colorAttachments[0];
      this.renderer.samples > 0 ? i.view = this.colorBuffer.createView() : i.resolveTarget = void 0, this.defaultRenderPassdescriptor = e;
    }
    const t = e.colorAttachments[0];
    return this.renderer.samples > 0 ? t.resolveTarget = this.context.getCurrentTexture().createView() : t.view = this.context.getCurrentTexture().createView(), e;
  }
  /**
   * Internal to determine if the current render target is a render target array with depth 2D array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {boolean} Whether the render target is a render target array with depth 2D array texture.
   *
   * @private
   */
  _isRenderCameraDepthArray(e) {
    return e.depthTexture && e.depthTexture.image.depth > 1 && e.camera.isArrayCamera;
  }
  /**
   * Returns the render pass descriptor for the given render context.
   *
   * @private
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
   * @return {Object} The render pass descriptor.
   */
  _getRenderPassDescriptor(e, t = {}) {
    const n = e.renderTarget, i = this.get(n);
    let o = i.descriptors;
    if (o === void 0 || i.width !== n.width || i.height !== n.height || i.dimensions !== n.dimensions || i.activeMipmapLevel !== e.activeMipmapLevel || i.activeCubeFace !== e.activeCubeFace || i.samples !== n.samples) {
      o = {}, i.descriptors = o;
      const v = () => {
        n.removeEventListener("dispose", v), this.delete(n);
      };
      n.hasEventListener("dispose", v) === !1 && n.addEventListener("dispose", v);
    }
    const l = e.getCacheKey();
    let p = o[l];
    if (p === void 0) {
      const v = e.textures, _ = [];
      let E;
      const A = this._isRenderCameraDepthArray(e);
      for (let I = 0; I < v.length; I++) {
        const j = this.get(v[I]), q = {
          label: `colorAttachment_${I}`,
          baseMipLevel: e.activeMipmapLevel,
          mipLevelCount: 1,
          baseArrayLayer: e.activeCubeFace,
          arrayLayerCount: 1,
          dimension: us.TwoD
        };
        if (n.isRenderTarget3D)
          E = e.activeCubeFace, q.baseArrayLayer = 0, q.dimension = us.ThreeD, q.depthOrArrayLayers = v[I].image.depth;
        else if (n.isRenderTarget && v[I].image.depth > 1)
          if (A === !0) {
            const L = e.camera.cameras;
            for (let V = 0; V < L.length; V++) {
              const re = {
                ...q,
                baseArrayLayer: V,
                arrayLayerCount: 1,
                dimension: us.TwoD
              }, R = j.texture.createView(re);
              _.push({
                view: R,
                resolveTarget: void 0,
                depthSlice: void 0
              });
            }
          } else
            q.dimension = us.TwoDArray, q.depthOrArrayLayers = v[I].image.depth;
        if (A !== !0) {
          const L = j.texture.createView(q);
          let V, re;
          j.msaaTexture !== void 0 ? (V = j.msaaTexture.createView(), re = L) : (V = L, re = void 0), _.push({
            view: V,
            resolveTarget: re,
            depthSlice: E
          });
        }
      }
      if (p = { textureViews: _ }, e.depth) {
        const I = this.get(e.depthTexture), j = {};
        e.depthTexture.isArrayTexture && (j.dimension = us.TwoD, j.arrayLayerCount = 1, j.baseArrayLayer = e.activeCubeFace), p.depthStencilView = I.texture.createView(j);
      }
      o[l] = p, i.width = n.width, i.height = n.height, i.samples = n.samples, i.activeMipmapLevel = e.activeMipmapLevel, i.activeCubeFace = e.activeCubeFace, i.dimensions = n.dimensions;
    }
    const f = {
      colorAttachments: []
    };
    for (let v = 0; v < p.textureViews.length; v++) {
      const _ = p.textureViews[v];
      let E = { r: 0, g: 0, b: 0, a: 1 };
      v === 0 && t.clearValue && (E = t.clearValue), f.colorAttachments.push({
        view: _.view,
        depthSlice: _.depthSlice,
        resolveTarget: _.resolveTarget,
        loadOp: t.loadOp || tr.Load,
        storeOp: t.storeOp || po.Store,
        clearValue: E
      });
    }
    return p.depthStencilView && (f.depthStencilAttachment = {
      view: p.depthStencilView
    }), f;
  }
  /**
   * This method is executed at the beginning of a render call and prepares
   * the WebGPU state for upcoming render calls
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginRender(e) {
    const t = this.get(e), n = this.device, i = e.occlusionQueryCount;
    let o;
    i > 0 && (t.currentOcclusionQuerySet && t.currentOcclusionQuerySet.destroy(), t.currentOcclusionQueryBuffer && t.currentOcclusionQueryBuffer.destroy(), t.currentOcclusionQuerySet = t.occlusionQuerySet, t.currentOcclusionQueryBuffer = t.occlusionQueryBuffer, t.currentOcclusionQueryObjects = t.occlusionQueryObjects, o = n.createQuerySet({ type: "occlusion", count: i, label: `occlusionQuerySet_${e.id}` }), t.occlusionQuerySet = o, t.occlusionQueryIndex = 0, t.occlusionQueryObjects = new Array(i), t.lastOcclusionObject = null);
    let l;
    e.textures === null ? l = this._getDefaultRenderPassDescriptor() : l = this._getRenderPassDescriptor(e, { loadOp: tr.Load }), this.initTimestampQuery(e, l), l.occlusionQuerySet = o;
    const p = l.depthStencilAttachment;
    if (e.textures !== null) {
      const v = l.colorAttachments;
      for (let _ = 0; _ < v.length; _++) {
        const E = v[_];
        e.clearColor ? (E.clearValue = _ === 0 ? e.clearColorValue : { r: 0, g: 0, b: 0, a: 1 }, E.loadOp = tr.Clear) : E.loadOp = tr.Load, E.storeOp = po.Store;
      }
    } else {
      const v = l.colorAttachments[0];
      e.clearColor ? (v.clearValue = e.clearColorValue, v.loadOp = tr.Clear) : v.loadOp = tr.Load, v.storeOp = po.Store;
    }
    e.depth && (e.clearDepth ? (p.depthClearValue = e.clearDepthValue, p.depthLoadOp = tr.Clear) : p.depthLoadOp = tr.Load, p.depthStoreOp = po.Store), e.stencil && (e.clearStencil ? (p.stencilClearValue = e.clearStencilValue, p.stencilLoadOp = tr.Clear) : p.stencilLoadOp = tr.Load, p.stencilStoreOp = po.Store);
    const f = n.createCommandEncoder({ label: "renderContext_" + e.id });
    if (this._isRenderCameraDepthArray(e) === !0) {
      const v = e.camera.cameras;
      !t.layerDescriptors || t.layerDescriptors.length !== v.length ? this._createDepthLayerDescriptors(e, t, l, v) : this._updateDepthLayerDescriptors(e, t, v), t.bundleEncoders = [], t.bundleSets = [];
      for (let _ = 0; _ < v.length; _++) {
        const E = this.pipelineUtils.createBundleEncoder(
          e,
          "renderBundleArrayCamera_" + _
        ), A = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        t.bundleEncoders.push(E), t.bundleSets.push(A);
      }
      t.currentPass = null;
    } else {
      const v = f.beginRenderPass(l);
      if (t.currentPass = v, e.viewport && this.updateViewport(e), e.scissor) {
        const { x: _, y: E, width: A, height: I } = e.scissorValue;
        v.setScissorRect(_, E, A, I);
      }
    }
    t.descriptor = l, t.encoder = f, t.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.renderBundles = [];
  }
  /**
   * This method creates layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {Object} descriptor  - The render pass descriptor.
   * @param {ArrayCamera} cameras - The array camera.
   *
   * @private
   */
  _createDepthLayerDescriptors(e, t, n, i) {
    const o = n.depthStencilAttachment;
    t.layerDescriptors = [];
    const l = this.get(e.depthTexture);
    l.viewCache || (l.viewCache = []);
    for (let p = 0; p < i.length; p++) {
      const f = {
        ...n,
        colorAttachments: [{
          ...n.colorAttachments[0],
          view: n.colorAttachments[p].view
        }]
      };
      if (n.depthStencilAttachment) {
        const v = p;
        l.viewCache[v] || (l.viewCache[v] = l.texture.createView({
          dimension: us.TwoD,
          baseArrayLayer: p,
          arrayLayerCount: 1
        })), f.depthStencilAttachment = {
          view: l.viewCache[v],
          depthLoadOp: o.depthLoadOp || tr.Clear,
          depthStoreOp: o.depthStoreOp || po.Store,
          depthClearValue: o.depthClearValue || 1
        }, e.stencil && (f.depthStencilAttachment.stencilLoadOp = o.stencilLoadOp, f.depthStencilAttachment.stencilStoreOp = o.stencilStoreOp, f.depthStencilAttachment.stencilClearValue = o.stencilClearValue);
      } else
        f.depthStencilAttachment = { ...o };
      t.layerDescriptors.push(f);
    }
  }
  /**
   * This method updates the layer descriptors for each camera in an array camera
   * to prepare for rendering to a depth array texture.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} renderContextData - The render context data.
   * @param {ArrayCamera} cameras - The array camera.
   *
   */
  _updateDepthLayerDescriptors(e, t, n) {
    for (let i = 0; i < n.length; i++) {
      const o = t.layerDescriptors[i];
      if (o.depthStencilAttachment) {
        const l = o.depthStencilAttachment;
        e.depth && (e.clearDepth ? (l.depthClearValue = e.clearDepthValue, l.depthLoadOp = tr.Clear) : l.depthLoadOp = tr.Load), e.stencil && (e.clearStencil ? (l.stencilClearValue = e.clearStencilValue, l.stencilLoadOp = tr.Clear) : l.stencilLoadOp = tr.Load);
      }
    }
  }
  /**
   * This method is executed at the end of a render call and finalizes work
   * after draw calls.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  finishRender(e) {
    const t = this.get(e), n = e.occlusionQueryCount;
    t.renderBundles.length > 0 && t.currentPass.executeBundles(t.renderBundles), n > t.occlusionQueryIndex && t.currentPass.endOcclusionQuery();
    const i = t.encoder;
    if (this._isRenderCameraDepthArray(e) === !0) {
      const o = [];
      for (let l = 0; l < t.bundleEncoders.length; l++) {
        const p = t.bundleEncoders[l];
        o.push(p.finish());
      }
      for (let l = 0; l < t.layerDescriptors.length; l++)
        if (l < o.length) {
          const p = t.layerDescriptors[l], f = i.beginRenderPass(p);
          if (e.viewport) {
            const { x: v, y: _, width: E, height: A, minDepth: I, maxDepth: j } = e.viewportValue;
            f.setViewport(v, _, E, A, I, j);
          }
          if (e.scissor) {
            const { x: v, y: _, width: E, height: A } = e.scissorValue;
            f.setScissorRect(v, _, E, A);
          }
          f.executeBundles([o[l]]), f.end();
        }
    } else t.currentPass && t.currentPass.end();
    if (n > 0) {
      const o = n * 8;
      let l = this.occludedResolveCache.get(o);
      l === void 0 && (l = this.device.createBuffer(
        {
          size: o,
          usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
        }
      ), this.occludedResolveCache.set(o, l));
      const p = this.device.createBuffer(
        {
          size: o,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
        }
      );
      t.encoder.resolveQuerySet(t.occlusionQuerySet, 0, n, l, 0), t.encoder.copyBufferToBuffer(l, 0, p, 0, o), t.occlusionQueryBuffer = p, this.resolveOccludedAsync(e);
    }
    if (this.device.queue.submit([t.encoder.finish()]), e.textures !== null) {
      const o = e.textures;
      for (let l = 0; l < o.length; l++) {
        const p = o[l];
        p.generateMipmaps === !0 && this.textureUtils.generateMipmaps(p);
      }
    }
  }
  /**
   * Returns `true` if the given 3D object is fully occluded by other
   * 3D objects in the scene.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object is fully occluded or not.
   */
  isOccluded(e, t) {
    const n = this.get(e);
    return n.occluded && n.occluded.has(t);
  }
  /**
   * This method processes the result of occlusion queries and writes it
   * into render context data.
   *
   * @async
   * @param {RenderContext} renderContext - The render context.
   * @return {Promise} A Promise that resolves when the occlusion query results have been processed.
   */
  async resolveOccludedAsync(e) {
    const t = this.get(e), { currentOcclusionQueryBuffer: n, currentOcclusionQueryObjects: i } = t;
    if (n && i) {
      const o = /* @__PURE__ */ new WeakSet();
      t.currentOcclusionQueryObjects = null, t.currentOcclusionQueryBuffer = null, await n.mapAsync(GPUMapMode.READ);
      const l = n.getMappedRange(), p = new BigUint64Array(l);
      for (let f = 0; f < i.length; f++)
        p[f] === BigInt(0) && o.add(i[f]);
      n.destroy(), t.occluded = o;
    }
  }
  /**
   * Updates the viewport with the values from the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  updateViewport(e) {
    const { currentPass: t } = this.get(e), { x: n, y: i, width: o, height: l, minDepth: p, maxDepth: f } = e.viewportValue;
    t.setViewport(n, i, o, l, p, f);
  }
  /**
   * Returns the clear color and alpha into a single
   * color object.
   *
   * @return {Color4} The clear color.
   */
  getClearColor() {
    const e = super.getClearColor();
    return this.renderer.alpha === !0 && (e.r *= e.a, e.g *= e.a, e.b *= e.a), e;
  }
  /**
   * Performs a clear operation.
   *
   * @param {boolean} color - Whether the color buffer should be cleared or not.
   * @param {boolean} depth - Whether the depth buffer should be cleared or not.
   * @param {boolean} stencil - Whether the stencil buffer should be cleared or not.
   * @param {?RenderContext} [renderTargetContext=null] - The render context of the current set render target.
   */
  clear(e, t, n, i = null) {
    const o = this.device, l = this.renderer;
    let p = [], f, v, _, E;
    if (e) {
      const j = this.getClearColor();
      v = { r: j.r, g: j.g, b: j.b, a: j.a };
    }
    if (i === null) {
      _ = l.depth, E = l.stencil;
      const j = this._getDefaultRenderPassDescriptor();
      if (e) {
        p = j.colorAttachments;
        const q = p[0];
        q.clearValue = v, q.loadOp = tr.Clear, q.storeOp = po.Store;
      }
      (_ || E) && (f = j.depthStencilAttachment);
    } else {
      _ = i.depth, E = i.stencil;
      const j = {
        loadOp: e ? tr.Clear : tr.Load,
        clearValue: e ? v : void 0
      };
      _ && (j.depthLoadOp = t ? tr.Clear : tr.Load, j.depthClearValue = t ? l.getClearDepth() : void 0, j.depthStoreOp = po.Store), E && (j.stencilLoadOp = n ? tr.Clear : tr.Load, j.stencilClearValue = n ? l.getClearStencil() : void 0, j.stencilStoreOp = po.Store);
      const q = this._getRenderPassDescriptor(i, j);
      p = q.colorAttachments, f = q.depthStencilAttachment;
    }
    _ && f && f.depthLoadOp === void 0 && (t ? (f.depthLoadOp = tr.Clear, f.depthClearValue = l.getClearDepth(), f.depthStoreOp = po.Store) : (f.depthLoadOp = tr.Load, f.depthStoreOp = po.Store)), E && f && f.stencilLoadOp === void 0 && (n ? (f.stencilLoadOp = tr.Clear, f.stencilClearValue = l.getClearStencil(), f.stencilStoreOp = po.Store) : (f.stencilLoadOp = tr.Load, f.stencilStoreOp = po.Store));
    const A = o.createCommandEncoder({ label: "clear" });
    A.beginRenderPass({
      colorAttachments: p,
      depthStencilAttachment: f
    }).end(), o.queue.submit([A.finish()]);
  }
  // compute
  /**
   * This method is executed at the beginning of a compute call and
   * prepares the state for upcoming compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  beginCompute(e) {
    const t = this.get(e), n = {
      label: "computeGroup_" + e.id
    };
    this.initTimestampQuery(e, n), t.cmdEncoderGPU = this.device.createCommandEncoder({ label: "computeGroup_" + e.id }), t.passEncoderGPU = t.cmdEncoderGPU.beginComputePass(n);
  }
  /**
   * Executes a compute command for the given compute node.
   *
   * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
   * @param {Node} computeNode - The compute node.
   * @param {Array<BindGroup>} bindings - The bindings.
   * @param {ComputePipeline} pipeline - The compute pipeline.
   */
  compute(e, t, n, i) {
    const { passEncoderGPU: o } = this.get(e), l = this.get(i).pipeline;
    this.pipelineUtils.setPipeline(o, l);
    for (let _ = 0, E = n.length; _ < E; _++) {
      const A = n[_], I = this.get(A);
      o.setBindGroup(_, I.group);
    }
    const p = this.device.limits.maxComputeWorkgroupsPerDimension, f = this.get(t);
    f.dispatchSize === void 0 && (f.dispatchSize = { x: 0, y: 1, z: 1 });
    const { dispatchSize: v } = f;
    t.dispatchCount > p ? (v.x = Math.min(t.dispatchCount, p), v.y = Math.ceil(t.dispatchCount / p)) : v.x = t.dispatchCount, o.dispatchWorkgroups(
      v.x,
      v.y,
      v.z
    );
  }
  /**
   * This method is executed at the end of a compute call and
   * finalizes work after compute tasks.
   *
   * @param {Node|Array<Node>} computeGroup - The compute node(s).
   */
  finishCompute(e) {
    const t = this.get(e);
    t.passEncoderGPU.end(), this.device.queue.submit([t.cmdEncoderGPU.finish()]);
  }
  /**
   * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
   * the CPU waits for the GPU to complete its operation (e.g. a compute task).
   *
   * @async
   * @return {Promise} A Promise that resolves when synchronization has been finished.
   */
  async waitForGPU() {
    await this.device.queue.onSubmittedWorkDone();
  }
  // render object
  /**
   * Executes a draw command for the given render object.
   *
   * @param {RenderObject} renderObject - The render object to draw.
   * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
   */
  draw(e, t) {
    const { object: n, material: i, context: o, pipeline: l } = e, p = e.getBindings(), f = this.get(o), v = this.get(l).pipeline, _ = e.getIndex(), E = _ !== null, A = e.getDrawParameters();
    if (A === null) return;
    const I = (q, L) => {
      this.pipelineUtils.setPipeline(q, v), L.pipeline = v;
      const V = L.bindingGroups;
      for (let R = 0, J = p.length; R < J; R++) {
        const ge = p[R], _e = this.get(ge);
        V[ge.index] !== ge.id && (q.setBindGroup(ge.index, _e.group), V[ge.index] = ge.id);
      }
      if (E === !0 && L.index !== _) {
        const R = this.get(_).buffer, J = _.array instanceof Uint16Array ? Kb.Uint16 : Kb.Uint32;
        q.setIndexBuffer(R, J), L.index = _;
      }
      const re = e.getVertexBuffers();
      for (let R = 0, J = re.length; R < J; R++) {
        const ge = re[R];
        if (L.attributes[R] !== ge) {
          const _e = this.get(ge).buffer;
          q.setVertexBuffer(R, _e), L.attributes[R] = ge;
        }
      }
      o.stencil === !0 && i.stencilWrite === !0 && f.currentStencilRef !== i.stencilRef && (q.setStencilReference(i.stencilRef), f.currentStencilRef = i.stencilRef);
    }, j = (q, L) => {
      if (I(q, L), n.isBatchedMesh === !0) {
        const V = n._multiDrawStarts, re = n._multiDrawCounts, R = n._multiDrawCount, J = n._multiDrawInstances;
        J !== null && Wd("THREE.WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
        for (let ge = 0; ge < R; ge++) {
          const _e = J ? J[ge] : 1, Y = _e > 1 ? 0 : ge;
          E === !0 ? q.drawIndexed(re[ge], _e, V[ge] / _.array.BYTES_PER_ELEMENT, 0, Y) : q.draw(re[ge], _e, V[ge], Y), t.update(n, re[ge], _e);
        }
      } else if (E === !0) {
        const { vertexCount: V, instanceCount: re, firstVertex: R } = A, J = e.getIndirect();
        if (J !== null) {
          const ge = this.get(J).buffer;
          q.drawIndexedIndirect(ge, 0);
        } else
          q.drawIndexed(V, re, R, 0, 0);
        t.update(n, V, re);
      } else {
        const { vertexCount: V, instanceCount: re, firstVertex: R } = A, J = e.getIndirect();
        if (J !== null) {
          const ge = this.get(J).buffer;
          q.drawIndirect(ge, 0);
        } else
          q.draw(V, re, R, 0);
        t.update(n, V, re);
      }
    };
    if (e.camera.isArrayCamera && e.camera.cameras.length > 0) {
      const q = this.get(e.camera), L = e.camera.cameras, V = e.getBindingGroup("cameraIndex");
      if (q.indexesGPU === void 0 || q.indexesGPU.length !== L.length) {
        const R = this.get(V), J = [], ge = new Uint32Array([0, 0, 0, 0]);
        for (let _e = 0, Y = L.length; _e < Y; _e++) {
          ge[0] = _e;
          const Fe = this.bindingUtils.createBindGroupIndex(ge, R.layout);
          J.push(Fe);
        }
        q.indexesGPU = J;
      }
      const re = this.renderer.getPixelRatio();
      for (let R = 0, J = L.length; R < J; R++) {
        const ge = L[R];
        if (n.layers.test(ge.layers)) {
          const _e = ge.viewport;
          let Y = f.currentPass, Fe = f.currentSets;
          if (f.bundleEncoders) {
            const Me = f.bundleEncoders[R], $ = f.bundleSets[R];
            Y = Me, Fe = $;
          }
          _e && Y.setViewport(
            Math.floor(_e.x * re),
            Math.floor(_e.y * re),
            Math.floor(_e.width * re),
            Math.floor(_e.height * re),
            o.viewportValue.minDepth,
            o.viewportValue.maxDepth
          ), V && q.indexesGPU && (Y.setBindGroup(V.index, q.indexesGPU[R]), Fe.bindingGroups[V.index] = V.id), j(Y, Fe);
        }
      }
    } else if (f.currentPass) {
      if (f.occlusionQuerySet !== void 0) {
        const q = f.lastOcclusionObject;
        q !== n && (q !== null && q.occlusionTest === !0 && (f.currentPass.endOcclusionQuery(), f.occlusionQueryIndex++), n.occlusionTest === !0 && (f.currentPass.beginOcclusionQuery(f.occlusionQueryIndex), f.occlusionQueryObjects[f.occlusionQueryIndex] = n), f.lastOcclusionObject = n);
      }
      j(f.currentPass, f.currentSets);
    }
  }
  // cache key
  /**
   * Returns `true` if the render pipeline requires an update.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {boolean} Whether the render pipeline requires an update or not.
   */
  needsRenderUpdate(e) {
    const t = this.get(e), { object: n, material: i } = e, o = this.utils, l = o.getSampleCountRenderContext(e.context), p = o.getCurrentColorSpace(e.context), f = o.getCurrentColorFormat(e.context), v = o.getCurrentDepthStencilFormat(e.context), _ = o.getPrimitiveTopology(n, i);
    let E = !1;
    return (t.material !== i || t.materialVersion !== i.version || t.transparent !== i.transparent || t.blending !== i.blending || t.premultipliedAlpha !== i.premultipliedAlpha || t.blendSrc !== i.blendSrc || t.blendDst !== i.blendDst || t.blendEquation !== i.blendEquation || t.blendSrcAlpha !== i.blendSrcAlpha || t.blendDstAlpha !== i.blendDstAlpha || t.blendEquationAlpha !== i.blendEquationAlpha || t.colorWrite !== i.colorWrite || t.depthWrite !== i.depthWrite || t.depthTest !== i.depthTest || t.depthFunc !== i.depthFunc || t.stencilWrite !== i.stencilWrite || t.stencilFunc !== i.stencilFunc || t.stencilFail !== i.stencilFail || t.stencilZFail !== i.stencilZFail || t.stencilZPass !== i.stencilZPass || t.stencilFuncMask !== i.stencilFuncMask || t.stencilWriteMask !== i.stencilWriteMask || t.side !== i.side || t.alphaToCoverage !== i.alphaToCoverage || t.sampleCount !== l || t.colorSpace !== p || t.colorFormat !== f || t.depthStencilFormat !== v || t.primitiveTopology !== _ || t.clippingContextCacheKey !== e.clippingContextCacheKey) && (t.material = i, t.materialVersion = i.version, t.transparent = i.transparent, t.blending = i.blending, t.premultipliedAlpha = i.premultipliedAlpha, t.blendSrc = i.blendSrc, t.blendDst = i.blendDst, t.blendEquation = i.blendEquation, t.blendSrcAlpha = i.blendSrcAlpha, t.blendDstAlpha = i.blendDstAlpha, t.blendEquationAlpha = i.blendEquationAlpha, t.colorWrite = i.colorWrite, t.depthWrite = i.depthWrite, t.depthTest = i.depthTest, t.depthFunc = i.depthFunc, t.stencilWrite = i.stencilWrite, t.stencilFunc = i.stencilFunc, t.stencilFail = i.stencilFail, t.stencilZFail = i.stencilZFail, t.stencilZPass = i.stencilZPass, t.stencilFuncMask = i.stencilFuncMask, t.stencilWriteMask = i.stencilWriteMask, t.side = i.side, t.alphaToCoverage = i.alphaToCoverage, t.sampleCount = l, t.colorSpace = p, t.colorFormat = f, t.depthStencilFormat = v, t.primitiveTopology = _, t.clippingContextCacheKey = e.clippingContextCacheKey, E = !0), E;
  }
  /**
   * Returns a cache key that is used to identify render pipelines.
   *
   * @param {RenderObject} renderObject - The render object.
   * @return {string} The cache key.
   */
  getRenderCacheKey(e) {
    const { object: t, material: n } = e, i = this.utils, o = e.context;
    return [
      n.transparent,
      n.blending,
      n.premultipliedAlpha,
      n.blendSrc,
      n.blendDst,
      n.blendEquation,
      n.blendSrcAlpha,
      n.blendDstAlpha,
      n.blendEquationAlpha,
      n.colorWrite,
      n.depthWrite,
      n.depthTest,
      n.depthFunc,
      n.stencilWrite,
      n.stencilFunc,
      n.stencilFail,
      n.stencilZFail,
      n.stencilZPass,
      n.stencilFuncMask,
      n.stencilWriteMask,
      n.side,
      i.getSampleCountRenderContext(o),
      i.getCurrentColorSpace(o),
      i.getCurrentColorFormat(o),
      i.getCurrentDepthStencilFormat(o),
      i.getPrimitiveTopology(t, n),
      e.getGeometryCacheKey(),
      e.clippingContextCacheKey
    ].join();
  }
  // textures
  /**
   * Creates a GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to create the sampler for.
   */
  createSampler(e) {
    this.textureUtils.createSampler(e);
  }
  /**
   * Destroys the GPU sampler for the given texture.
   *
   * @param {Texture} texture - The texture to destroy the sampler for.
   */
  destroySampler(e) {
    this.textureUtils.destroySampler(e);
  }
  /**
   * Creates a default texture for the given texture that can be used
   * as a placeholder until the actual texture is ready for usage.
   *
   * @param {Texture} texture - The texture to create a default texture for.
   */
  createDefaultTexture(e) {
    this.textureUtils.createDefaultTexture(e);
  }
  /**
   * Defines a texture on the GPU for the given texture object.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  createTexture(e, t) {
    this.textureUtils.createTexture(e, t);
  }
  /**
   * Uploads the updated texture data to the GPU.
   *
   * @param {Texture} texture - The texture.
   * @param {Object} [options={}] - Optional configuration parameter.
   */
  updateTexture(e, t) {
    this.textureUtils.updateTexture(e, t);
  }
  /**
   * Generates mipmaps for the given texture.
   *
   * @param {Texture} texture - The texture.
   */
  generateMipmaps(e) {
    this.textureUtils.generateMipmaps(e);
  }
  /**
   * Destroys the GPU data for the given texture object.
   *
   * @param {Texture} texture - The texture.
   */
  destroyTexture(e) {
    this.textureUtils.destroyTexture(e);
  }
  /**
   * Returns texture data as a typed array.
   *
   * @async
   * @param {Texture} texture - The texture to copy.
   * @param {number} x - The x coordinate of the copy origin.
   * @param {number} y - The y coordinate of the copy origin.
   * @param {number} width - The width of the copy.
   * @param {number} height - The height of the copy.
   * @param {number} faceIndex - The face index.
   * @return {Promise<TypedArray>} A Promise that resolves with a typed array when the copy operation has finished.
   */
  async copyTextureToBuffer(e, t, n, i, o, l) {
    return this.textureUtils.copyTextureToBuffer(e, t, n, i, o, l);
  }
  /**
   * Inits a time stamp query for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {Object} descriptor - The query descriptor.
   */
  initTimestampQuery(e, t) {
    if (!this.trackTimestamp) return;
    const n = e.isComputeNode ? "compute" : "render";
    this.timestampQueryPool[n] || (this.timestampQueryPool[n] = new I3e(this.device, n, 2048));
    const i = this.timestampQueryPool[n], o = i.allocateQueriesForContext(e);
    t.timestampWrites = {
      querySet: i.querySet,
      beginningOfPassWriteIndex: o,
      endOfPassWriteIndex: o + 1
    };
  }
  // node builder
  /**
   * Returns a node builder for the given render object.
   *
   * @param {RenderObject} object - The render object.
   * @param {Renderer} renderer - The renderer.
   * @return {WGSLNodeBuilder} The node builder.
   */
  createNodeBuilder(e, t) {
    return new E3e(e, t);
  }
  // program
  /**
   * Creates a shader program from the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  createProgram(e) {
    const t = this.get(e);
    t.module = {
      module: this.device.createShaderModule({ code: e.code, label: e.stage + (e.name !== "" ? `_${e.name}` : "") }),
      entryPoint: "main"
    };
  }
  /**
   * Destroys the shader program of the given programmable stage.
   *
   * @param {ProgrammableStage} program - The programmable stage.
   */
  destroyProgram(e) {
    this.delete(e);
  }
  // pipelines
  /**
   * Creates a render pipeline for the given render object.
   *
   * @param {RenderObject} renderObject - The render object.
   * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
   */
  createRenderPipeline(e, t) {
    this.pipelineUtils.createRenderPipeline(e, t);
  }
  /**
   * Creates a compute pipeline for the given compute node.
   *
   * @param {ComputePipeline} computePipeline - The compute pipeline.
   * @param {Array<BindGroup>} bindings - The bindings.
   */
  createComputePipeline(e, t) {
    this.pipelineUtils.createComputePipeline(e, t);
  }
  /**
   * Prepares the state for encoding render bundles.
   *
   * @param {RenderContext} renderContext - The render context.
   */
  beginBundle(e) {
    const t = this.get(e);
    t._currentPass = t.currentPass, t._currentSets = t.currentSets, t.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.currentPass = this.pipelineUtils.createBundleEncoder(e);
  }
  /**
   * After processing render bundles this method finalizes related work.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle.
   */
  finishBundle(e, t) {
    const n = this.get(e), o = n.currentPass.finish();
    this.get(t).bundleGPU = o, n.currentSets = n._currentSets, n.currentPass = n._currentPass;
  }
  /**
   * Adds a render bundle to the render context data.
   *
   * @param {RenderContext} renderContext - The render context.
   * @param {RenderBundle} bundle - The render bundle to add.
   */
  addBundle(e, t) {
    this.get(e).renderBundles.push(this.get(t).bundleGPU);
  }
  // bindings
  /**
   * Creates bindings from the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  createBindings(e, t, n, i) {
    this.bindingUtils.createBindings(e, t, n, i);
  }
  /**
   * Updates the given bind group definition.
   *
   * @param {BindGroup} bindGroup - The bind group.
   * @param {Array<BindGroup>} bindings - Array of bind groups.
   * @param {number} cacheIndex - The cache index.
   * @param {number} version - The version.
   */
  updateBindings(e, t, n, i) {
    this.bindingUtils.createBindings(e, t, n, i);
  }
  /**
   * Updates a buffer binding.
   *
   *  @param {Buffer} binding - The buffer binding to update.
   */
  updateBinding(e) {
    this.bindingUtils.updateBinding(e);
  }
  // attributes
  /**
   * Creates the buffer of an indexed shader attribute.
   *
   * @param {BufferAttribute} attribute - The indexed buffer attribute.
   */
  createIndexAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of a storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Creates the GPU buffer of an indirect storage attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute.
   */
  createIndirectStorageAttribute(e) {
    this.attributeUtils.createAttribute(e, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
  }
  /**
   * Updates the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to update.
   */
  updateAttribute(e) {
    this.attributeUtils.updateAttribute(e);
  }
  /**
   * Destroys the GPU buffer of a shader attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute to destroy.
   */
  destroyAttribute(e) {
    this.attributeUtils.destroyAttribute(e);
  }
  // canvas
  /**
   * Triggers an update of the default render pass descriptor.
   */
  updateSize() {
    this.colorBuffer = this.textureUtils.getColorBuffer(), this.defaultRenderPassdescriptor = null;
  }
  // utils public
  /**
   * Returns the maximum anisotropy texture filtering value.
   *
   * @return {number} The maximum anisotropy texture filtering value.
   */
  getMaxAnisotropy() {
    return 16;
  }
  /**
   * Checks if the given feature is supported  by the backend.
   *
   * @param {string} name - The feature's name.
   * @return {boolean} Whether the feature is supported or not.
   */
  hasFeature(e) {
    return this.device.features.has(e);
  }
  /**
   * Copies data of the given source texture to the given destination texture.
   *
   * @param {Texture} srcTexture - The source texture.
   * @param {Texture} dstTexture - The destination texture.
   * @param {?(Box3|Box2)} [srcRegion=null] - The region of the source texture to copy.
   * @param {?(Vector2|Vector3)} [dstPosition=null] - The destination position of the copy.
   * @param {number} [srcLevel=0] - The mipmap level to copy.
   * @param {number} [dstLevel=0] - The destination mip level to copy to.
   */
  copyTextureToTexture(e, t, n = null, i = null, o = 0, l = 0) {
    let p = 0, f = 0, v = 0, _ = 0, E = 0, A = 0, I = e.image.width, j = e.image.height, q = 1;
    n !== null && (n.isBox3 === !0 ? (_ = n.min.x, E = n.min.y, A = n.min.z, I = n.max.x - n.min.x, j = n.max.y - n.min.y, q = n.max.z - n.min.z) : (_ = n.min.x, E = n.min.y, I = n.max.x - n.min.x, j = n.max.y - n.min.y, q = 1)), i !== null && (p = i.x, f = i.y, v = i.z || 0);
    const L = this.device.createCommandEncoder({ label: "copyTextureToTexture_" + e.id + "_" + t.id }), V = this.get(e).texture, re = this.get(t).texture;
    L.copyTextureToTexture(
      {
        texture: V,
        mipLevel: o,
        origin: { x: _, y: E, z: A }
      },
      {
        texture: re,
        mipLevel: l,
        origin: { x: p, y: f, z: v }
      },
      [
        I,
        j,
        q
      ]
    ), this.device.queue.submit([L.finish()]), l === 0 && t.generateMipmaps && this.textureUtils.generateMipmaps(t);
  }
  /**
   * Copies the current bound framebuffer to the given texture.
   *
   * @param {Texture} texture - The destination texture.
   * @param {RenderContext} renderContext - The render context.
   * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
   */
  copyFramebufferToTexture(e, t, n) {
    const i = this.get(t);
    let o = null;
    t.renderTarget ? e.isDepthTexture ? o = this.get(t.depthTexture).texture : o = this.get(t.textures[0]).texture : e.isDepthTexture ? o = this.textureUtils.getDepthBuffer(t.depth, t.stencil) : o = this.context.getCurrentTexture();
    const l = this.get(e).texture;
    if (o.format !== l.format) {
      console.error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.", o.format, l.format);
      return;
    }
    let p;
    if (i.currentPass ? (i.currentPass.end(), p = i.encoder) : p = this.device.createCommandEncoder({ label: "copyFramebufferToTexture_" + e.id }), p.copyTextureToTexture(
      {
        texture: o,
        origin: [n.x, n.y, 0]
      },
      {
        texture: l
      },
      [
        n.z,
        n.w
      ]
    ), i.currentPass) {
      const { descriptor: f } = i;
      for (let v = 0; v < f.colorAttachments.length; v++)
        f.colorAttachments[v].loadOp = tr.Load;
      if (t.depth && (f.depthStencilAttachment.depthLoadOp = tr.Load), t.stencil && (f.depthStencilAttachment.stencilLoadOp = tr.Load), i.currentPass = p.beginRenderPass(f), i.currentSets = { attributes: {}, bindingGroups: [], pipeline: null, index: null }, t.viewport && this.updateViewport(t), t.scissor) {
        const { x: v, y: _, width: E, height: A } = t.scissorValue;
        i.currentPass.setScissorRect(v, _, E, A);
      }
    } else
      this.device.queue.submit([p.finish()]);
    e.generateMipmaps && this.textureUtils.generateMipmaps(e);
  }
}
class O3e extends Yo {
  /**
   * Constructs a new mesh phong material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new er(16777215), this.specular = new er(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new er(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new hl(), this.combine = QO, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
const D3e = /* @__PURE__ */ new O3e();
class F3e extends Ni {
  static get type() {
    return "MeshPhongNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshPhongNodeMaterial = !0, this.lights = !0, this.shininessNode = null, this.specularNode = null, this.setDefaultValues(D3e), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new vG(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ive();
  }
  /**
   * Setups the phong specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = (this.shininessNode ? et(this.shininessNode) : M2e).max(1e-4);
    l6.assign(e);
    const t = this.specularNode || I2e;
    ba.assign(t);
  }
  copy(e) {
    return this.shininessNode = e.shininessNode, this.specularNode = e.specularNode, super.copy(e);
  }
}
class yve extends Yo {
  /**
   * Constructs a new mesh standard material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = { STANDARD: "" }, this.color = new er(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new er(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new hl(), this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { STANDARD: "" }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
const B3e = /* @__PURE__ */ new yve();
class vve extends Ni {
  static get type() {
    return "MeshStandardNodeMaterial";
  }
  /**
   * Constructs a new mesh standard node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshStandardNodeMaterial = !0, this.lights = !0, this.emissiveNode = null, this.metalnessNode = null, this.roughnessNode = null, this.setDefaultValues(B3e), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link EnvironmentNode}
   * to implement the PBR (PMREM based) environment mapping. Besides, the
   * method honors `Scene.environment`.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?EnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    let t = super.setupEnvironment(e);
    return t === null && e.environmentNode && (t = e.environmentNode), t ? new QBe(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ove();
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const e = Vr(tt(0.04), Jn.rgb, UO);
    ba.assign(e), VO.assign(1);
  }
  /**
   * Setups the standard specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = this.metalnessNode ? et(this.metalnessNode) : D2e;
    UO.assign(e);
    let t = this.roughnessNode ? et(this.roughnessNode) : O2e;
    t = K0e({ roughness: t }), Dd.assign(t), this.setupSpecular(), Jn.assign(gn(Jn.rgb.mul(e.oneMinus()), Jn.a));
  }
  copy(e) {
    return this.emissiveNode = e.emissiveNode, this.metalnessNode = e.metalnessNode, this.roughnessNode = e.roughnessNode, super.copy(e);
  }
}
class L3e extends yve {
  /**
   * Constructs a new mesh physical material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshPhysicalMaterial = !0, this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Pn(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
      get: function() {
        return Nn(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(t) {
        this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
      }
    }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new er(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new er(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new er(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e);
  }
  /**
   * The anisotropy strength.
   *
   * @type {number}
   * @default 0
   */
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e;
  }
  /**
   * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
   * clear coat related properties to enable multilayer materials that have a
   * thin translucent layer over the base layer.
   *
   * @type {number}
   * @default 0
   */
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e;
  }
  /**
   * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
   * the surface and the viewer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e;
  }
  /**
   * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
   * through a relatively clear volume. Any value zero or larger is valid, the typical range of
   * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
   *
   * @type {number}
   * @default 0
   */
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(e) {
    this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e;
  }
  /**
   * The intensity of the sheen layer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, this._sheen = e;
  }
  /**
   * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
   *
   * Thin, transparent or semitransparent, plastic or glass materials remain
   * largely reflective even if they are fully transmissive. The transmission
   * property can be used to model these materials.
   *
   * When transmission is non-zero, `opacity` should be  set to `1`.
   *
   * @type {number}
   * @default 0
   */
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, this._transmission = e;
  }
  copy(e) {
    return super.copy(e), this.defines = {
      STANDARD: "",
      PHYSICAL: ""
    }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this;
  }
}
const j3e = /* @__PURE__ */ new L3e();
class U3e extends vve {
  static get type() {
    return "MeshPhysicalNodeMaterial";
  }
  /**
   * Constructs a new mesh physical node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshPhysicalNodeMaterial = !0, this.clearcoatNode = null, this.clearcoatRoughnessNode = null, this.clearcoatNormalNode = null, this.sheenNode = null, this.sheenRoughnessNode = null, this.iridescenceNode = null, this.iridescenceIORNode = null, this.iridescenceThicknessNode = null, this.specularIntensityNode = null, this.specularColorNode = null, this.iorNode = null, this.transmissionNode = null, this.thicknessNode = null, this.attenuationDistanceNode = null, this.attenuationColorNode = null, this.dispersionNode = null, this.anisotropyNode = null, this.setDefaultValues(j3e), this.setValues(e);
  }
  /**
   * Whether the lighting model should use clearcoat or not.
   *
   * @type {boolean}
   * @default true
   */
  get useClearcoat() {
    return this.clearcoat > 0 || this.clearcoatNode !== null;
  }
  /**
   * Whether the lighting model should use iridescence or not.
   *
   * @type {boolean}
   * @default true
   */
  get useIridescence() {
    return this.iridescence > 0 || this.iridescenceNode !== null;
  }
  /**
   * Whether the lighting model should use sheen or not.
   *
   * @type {boolean}
   * @default true
   */
  get useSheen() {
    return this.sheen > 0 || this.sheenNode !== null;
  }
  /**
   * Whether the lighting model should use anisotropy or not.
   *
   * @type {boolean}
   * @default true
   */
  get useAnisotropy() {
    return this.anisotropy > 0 || this.anisotropyNode !== null;
  }
  /**
   * Whether the lighting model should use transmission or not.
   *
   * @type {boolean}
   * @default true
   */
  get useTransmission() {
    return this.transmission > 0 || this.transmissionNode !== null;
  }
  /**
   * Whether the lighting model should use dispersion or not.
   *
   * @type {boolean}
   * @default true
   */
  get useDispersion() {
    return this.dispersion > 0 || this.dispersionNode !== null;
  }
  /**
   * Setups the specular related node variables.
   */
  setupSpecular() {
    const e = this.iorNode ? et(this.iorNode) : Y2e;
    gO.assign(e), ba.assign(Vr(Hb(r0e(gO.sub(1).div(gO.add(1))).mul(N2e), tt(1)).mul(Lfe), Jn.rgb, UO)), VO.assign(Vr(Lfe, 1, UO));
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhysicalLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ove(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
  }
  /**
   * Setups the physical specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(e) {
    if (super.setupVariants(e), this.useClearcoat) {
      const t = this.clearcoatNode ? et(this.clearcoatNode) : B2e, n = this.clearcoatRoughnessNode ? et(this.clearcoatRoughnessNode) : L2e;
      o6.assign(t), zO.assign(K0e({ roughness: n }));
    }
    if (this.useSheen) {
      const t = this.sheenNode ? tt(this.sheenNode) : z2e, n = this.sheenRoughnessNode ? et(this.sheenRoughnessNode) : V2e;
      Cb.assign(t), K6.assign(n);
    }
    if (this.useIridescence) {
      const t = this.iridescenceNode ? et(this.iridescenceNode) : q2e, n = this.iridescenceIORNode ? et(this.iridescenceIORNode) : H2e, i = this.iridescenceThicknessNode ? et(this.iridescenceThicknessNode) : $2e;
      Y6.assign(t), Vye.assign(n), Gye.assign(i);
    }
    if (this.useAnisotropy) {
      const t = (this.anisotropyNode ? xt(this.anisotropyNode) : G2e).toVar();
      fg.assign(t.length()), _i(fg.equal(0), () => {
        t.assign(xt(1, 0));
      }).Else(() => {
        t.divAssign(xt(fg)), fg.assign(fg.saturate());
      }), a6.assign(fg.pow2().mix(Dd.pow2(), 1)), mO.assign(iE[0].mul(t.x).add(iE[1].mul(t.y))), Fb.assign(iE[1].mul(t.x).sub(iE[0].mul(t.y)));
    }
    if (this.useTransmission) {
      const t = this.transmissionNode ? et(this.transmissionNode) : W2e, n = this.thicknessNode ? et(this.thicknessNode) : K2e, i = this.attenuationDistanceNode ? et(this.attenuationDistanceNode) : X2e, o = this.attenuationColorNode ? tt(this.attenuationColorNode) : Q2e;
      if (u6.assign(t), qye.assign(n), Hye.assign(i), $ye.assign(o), this.useDispersion) {
        const l = this.dispersionNode ? et(this.dispersionNode) : rDe;
        Wye.assign(l);
      }
    }
  }
  /**
   * Setups the clearcoat normal node.
   *
   * @return {Node<vec3>} The clearcoat normal.
   */
  setupClearcoatNormal() {
    return this.clearcoatNormalNode ? tt(this.clearcoatNormalNode) : j2e;
  }
  setup(e) {
    e.context.setupClearcoatNormal = () => this.setupClearcoatNormal(e), super.setup(e);
  }
  copy(e) {
    return this.clearcoatNode = e.clearcoatNode, this.clearcoatRoughnessNode = e.clearcoatRoughnessNode, this.clearcoatNormalNode = e.clearcoatNormalNode, this.sheenNode = e.sheenNode, this.sheenRoughnessNode = e.sheenRoughnessNode, this.iridescenceNode = e.iridescenceNode, this.iridescenceIORNode = e.iridescenceIORNode, this.iridescenceThicknessNode = e.iridescenceThicknessNode, this.specularIntensityNode = e.specularIntensityNode, this.specularColorNode = e.specularColorNode, this.transmissionNode = e.transmissionNode, this.thicknessNode = e.thicknessNode, this.attenuationDistanceNode = e.attenuationDistanceNode, this.attenuationColorNode = e.attenuationColorNode, this.dispersionNode = e.dispersionNode, this.anisotropyNode = e.anisotropyNode, super.copy(e);
  }
}
const z3e = /* @__PURE__ */ at(({ normal: c, lightDirection: e, builder: t }) => {
  const n = c.dot(e), i = xt(n.mul(0.5).add(0.5), 0);
  if (t.material.gradientMap) {
    const o = $p("gradientMap", "texture").context({ getUV: () => i });
    return tt(o.r);
  } else {
    const o = i.fwidth().mul(0.5);
    return Vr(tt(0.7), tt(1), ef(et(0.7).sub(o.x), et(0.7).add(o.x), i.x));
  }
});
class V3e extends f2 {
  /**
   * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
   * reduced to a small number of discrete shades to create a comic-like, flat look.
   *
   * @param {Object} lightData - The light data.
   * @param {NodeBuilder} builder - The current node builder.
   */
  direct({ lightDirection: e, lightColor: t, reflectedLight: n }, i) {
    const o = z3e({ normal: v0e, lightDirection: e, builder: i }).mul(t);
    n.directDiffuse.addAssign(o.mul(Wb({ diffuseColor: Jn.rgb })));
  }
  /**
   * Implements the indirect lighting.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  indirect(e) {
    const { ambientOcclusion: t, irradiance: n, reflectedLight: i } = e.context;
    i.indirectDiffuse.addAssign(n.mul(Wb({ diffuseColor: Jn }))), i.indirectDiffuse.mulAssign(t);
  }
}
class G3e extends Yo {
  /**
   * Constructs a new mesh toon material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshToonMaterial = !0, this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.color = new er(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new er(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this;
  }
}
const q3e = /* @__PURE__ */ new G3e();
class H3e extends Ni {
  static get type() {
    return "MeshToonNodeMaterial";
  }
  /**
   * Constructs a new mesh toon node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshToonNodeMaterial = !0, this.lights = !0, this.setDefaultValues(q3e), this.setValues(e);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ToonLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new V3e();
  }
}
class $3e extends Zb {
  static get type() {
    return "BasicLightMapNode";
  }
  /**
   * Constructs a new basic light map node.
   *
   * @param {?Node<vec3>} [lightMapNode=null] - The light map node.
   */
  constructor(e = null) {
    super(), this.lightMapNode = e;
  }
  setup(e) {
    const t = et(1 / Math.PI);
    e.context.irradianceLightMap = this.lightMapNode.mul(t);
  }
}
const W3e = /* @__PURE__ */ new Wp();
class K3e extends Ni {
  static get type() {
    return "MeshBasicNodeMaterial";
  }
  /**
   * Constructs a new mesh basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshBasicNodeMaterial = !0, this.lights = !0, this.setDefaultValues(W3e), this.setValues(e);
  }
  /**
   * Basic materials are not affected by normal and bump maps so we
   * return by default {@link normalView}.
   *
   * @return {Node<vec3>} The normal node.
   */
  setupNormal() {
    return Ec;
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new vG(t) : null;
  }
  /**
   * This method must be overwritten since light maps are evaluated
   * with a special scaling factor for basic materials.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicLightMapNode<vec3>} The light map node.
   */
  setupLightMap(e) {
    let t = null;
    return e.material.lightMap && (t = new $3e(I0e)), t;
  }
  /**
   * The material overwrites this method because `lights` is set to `true` but
   * we still want to return the diffuse color as the outgoing light.
   *
   * @return {Node<vec3>} The outgoing light node.
   */
  setupOutgoingLight() {
    return Jn.rgb;
  }
  /**
   * Setups the lighting model.
   *
   * @return {BasicLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new rve();
  }
}
class Y3e extends Yo {
  /**
   * Constructs a new mesh lambert material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new er(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new er(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new hl(), this.combine = QO, this.reflectivity = 1, this.refractionRatio = 0.98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
const X3e = /* @__PURE__ */ new Y3e();
class Q3e extends Ni {
  static get type() {
    return "MeshLambertNodeMaterial";
  }
  /**
   * Constructs a new mesh lambert node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshLambertNodeMaterial = !0, this.lights = !0, this.setDefaultValues(X3e), this.setValues(e);
  }
  /**
   * Overwritten since this type of material uses {@link BasicEnvironmentNode}
   * to implement the default environment mapping.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {?BasicEnvironmentNode<vec3>} The environment node.
   */
  setupEnvironment(e) {
    const t = super.setupEnvironment(e);
    return t ? new vG(t) : null;
  }
  /**
   * Setups the lighting model.
   *
   * @return {PhongLightingModel} The lighting model.
   */
  setupLightingModel() {
    return new ive(!1);
  }
}
class Z3e extends Yo {
  /**
   * Constructs a new mesh normal material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this;
  }
}
const J3e = /* @__PURE__ */ new Z3e();
class eje extends Ni {
  static get type() {
    return "MeshNormalNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshNormalNodeMaterial = !0, this.setDefaultValues(J3e), this.setValues(e);
  }
  /**
   * Overwrites the default implementation by computing the diffuse color
   * based on the normal data.
   */
  setupDiffuseColor() {
    const e = this.opacityNode ? et(this.opacityNode) : R0e;
    Jn.assign(nG(gn(XOe(Ri), e), _a));
  }
}
class tje extends Yo {
  /**
   * Constructs a new mesh matcap material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isMeshMatcapMaterial = !0, this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new er(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Zp, this.normalScale = new Pn(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.defines = { MATCAP: "" }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this;
  }
}
const nje = /* @__PURE__ */ new tje();
class rje extends Ni {
  static get type() {
    return "MeshMatcapNodeMaterial";
  }
  /**
   * Constructs a new mesh normal node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isMeshMatcapNodeMaterial = !0, this.setDefaultValues(nje), this.setValues(e);
  }
  /**
   * Setups the matcap specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants(e) {
    const t = WOe;
    let n;
    e.material.matcap ? n = $p("matcap", "texture").context({ getUV: () => t }) : n = tt(Vr(0.2, 0.8, t.y)), Jn.rgb.mulAssign(n.rgb);
  }
}
class bve extends Yo {
  /**
   * Constructs a new line basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new er(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this;
  }
}
const ije = /* @__PURE__ */ new bve();
class sje extends Ni {
  static get type() {
    return "LineBasicNodeMaterial";
  }
  /**
   * Constructs a new line basic node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isLineBasicNodeMaterial = !0, this.setDefaultValues(ije), this.setValues(e);
  }
}
class oje extends bve {
  /**
   * Constructs a new line dashed material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this;
  }
}
const aje = /* @__PURE__ */ new oje();
class lje extends Ni {
  static get type() {
    return "LineDashedNodeMaterial";
  }
  /**
   * Constructs a new line dashed node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isLineDashedNodeMaterial = !0, this.setDefaultValues(aje), this.dashOffset = 0, this.offsetNode = null, this.dashScaleNode = null, this.dashSizeNode = null, this.gapSizeNode = null, this.setValues(e);
  }
  /**
   * Setups the dash specific node variables.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  setupVariants() {
    const e = this.offsetNode ? et(this.offsetNode) : tDe, t = this.dashScaleNode ? et(this.dashScaleNode) : Z2e, n = this.dashSizeNode ? et(this.dashSizeNode) : J2e, i = this.gapSizeNode ? et(this.gapSizeNode) : eDe;
    b5.assign(n), Pfe.assign(i);
    const o = pu(tf("lineDistance").mul(t));
    (e ? o.add(e) : o).mod(b5.add(Pfe)).greaterThan(b5).discard();
  }
}
class uje extends Yo {
  /**
   * Constructs a new sprite material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new er(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const cje = /* @__PURE__ */ new uje();
class xve extends Ni {
  static get type() {
    return "SpriteNodeMaterial";
  }
  /**
   * Constructs a new sprite node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isSpriteNodeMaterial = !0, this._useSizeAttenuation = !0, this.positionNode = null, this.rotationNode = null, this.scaleNode = null, this.transparent = !0, this.setDefaultValues(cje), this.setValues(e);
  }
  /**
   * Setups the position node in view space. This method implements
   * the sprite specific vertex shader.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The position in view space.
   */
  setupPositionView(e) {
    const { object: t, camera: n } = e, i = this.sizeAttenuation, { positionNode: o, rotationNode: l, scaleNode: p } = this, f = o2.mul(tt(o || 0));
    let v = xt(Cg[0].xyz.length(), Cg[1].xyz.length());
    if (p !== null && (v = v.mul(xt(p))), i === !1)
      if (n.isPerspectiveCamera)
        v = v.mul(f.z.negate());
      else {
        const I = et(2).div(oG.element(1).element(1));
        v = v.mul(I.mul(2));
      }
    let _ = a2.xy;
    if (t.center && t.center.isVector2 === !0) {
      const I = oOe("center", "vec2", t);
      _ = _.sub(I.sub(0.5));
    }
    _ = _.mul(v);
    const E = et(l || U2e), A = x0e(_, E);
    return gn(f.xy.add(A), f.zw);
  }
  copy(e) {
    return this.positionNode = e.positionNode, this.rotationNode = e.rotationNode, this.scaleNode = e.scaleNode, super.copy(e);
  }
  /**
   * Whether to use size attenuation or not.
   *
   * @type {boolean}
   * @default true
   */
  get sizeAttenuation() {
    return this._useSizeAttenuation;
  }
  set sizeAttenuation(e) {
    this._useSizeAttenuation !== e && (this._useSizeAttenuation = e, this.needsUpdate = !0);
  }
}
class dje extends Yo {
  /**
   * Constructs a new points material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new er(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this;
  }
}
const hje = /* @__PURE__ */ new dje();
class pje extends xve {
  static get type() {
    return "PointsNodeMaterial";
  }
  /**
   * Constructs a new points node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.sizeNode = null, this.isPointsNodeMaterial = !0, this.setDefaultValues(hje), this.setValues(e);
  }
  setupPositionView() {
    const { positionNode: e } = this;
    return o2.mul(tt(e || Qs)).xyz;
  }
  setupVertex(e) {
    const t = super.setupVertex(e);
    if (e.material.isNodeMaterial !== !0)
      return t;
    const { rotationNode: n, scaleNode: i, sizeNode: o } = this, l = a2.xy.toVar(), p = yE.z.div(yE.w);
    if (n && n.isNode) {
      const v = et(n);
      l.assign(x0e(l, v));
    }
    let f = o !== null ? xt(o) : nDe;
    return this.sizeAttenuation === !0 && (f = f.mul(f.div(Ii.z.negate()))), i && i.isNode && (f = f.mul(xt(i))), l.mulAssign(f.mul(2)), l.assign(l.div(yE.z)), l.y.assign(l.y.mul(p)), l.assign(l.mul(t.w)), t.addAssign(gn(l, 0, 0)), t;
  }
  /**
   * Whether alpha to coverage should be used or not.
   *
   * @type {boolean}
   * @default true
   */
  get alphaToCoverage() {
    return this._useAlphaToCoverage;
  }
  set alphaToCoverage(e) {
    this._useAlphaToCoverage !== e && (this._useAlphaToCoverage = e, this.needsUpdate = !0);
  }
}
class fje extends f2 {
  /**
   * Constructs a new shadow mask model.
   */
  constructor() {
    super(), this.shadowNode = et(1).toVar("shadowMask");
  }
  /**
   * Only used to save the shadow mask.
   *
   * @param {Object} input - The input data.
   */
  direct({ lightNode: e }) {
    e.shadowNode !== null && this.shadowNode.mulAssign(e.shadowNode);
  }
  /**
   * Uses the shadow mask to produce the final color.
   *
   * @param {NodeBuilder} builder - The current node builder.
   */
  finish({ context: e }) {
    Jn.a.mulAssign(this.shadowNode.oneMinus()), e.outgoingLight.rgb.assign(Jn.rgb);
  }
}
class mje extends Yo {
  /**
   * Constructs a new shadow material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(e) {
    super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new er(0), this.transparent = !0, this.fog = !0, this.setValues(e);
  }
  copy(e) {
    return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this;
  }
}
const gje = /* @__PURE__ */ new mje();
class yje extends Ni {
  static get type() {
    return "ShadowNodeMaterial";
  }
  /**
   * Constructs a new shadow node material.
   *
   * @param {Object} [parameters] - The configuration parameter.
   */
  constructor(e) {
    super(), this.isShadowNodeMaterial = !0, this.lights = !0, this.transparent = !0, this.setDefaultValues(gje), this.setValues(e);
  }
  /**
   * Setups the lighting model.
   *
   * @return {ShadowMaskModel} The lighting model.
   */
  setupLightingModel() {
    return new fje();
  }
}
class Ig extends Wi {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t = 1) {
    super(), this.isLight = !0, this.type = "Light", this.color = new er(e), this.intensity = t;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
  }
  copy(e, t) {
    return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t;
  }
}
const gV = /* @__PURE__ */ new Pr(), Qme = /* @__PURE__ */ new Ue(), Zme = /* @__PURE__ */ new Ue();
class TG {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(e) {
    this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Pn(512, 512), this.mapType = yo, this.map = null, this.mapPass = null, this.matrix = new Pr(), this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new SG(), this._frameExtents = new Pn(1, 1), this._viewportCount = 1, this._viewports = [
      new Bn(0, 0, 1, 1)
    ];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(e) {
    const t = this.camera, n = this.matrix;
    Qme.setFromMatrixPosition(e.matrixWorld), t.position.copy(Qme), Zme.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(Zme), t.updateMatrixWorld(), gV.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(gV), n.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ), n.multiply(gV);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(e) {
    return this._viewports[e];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(e) {
    return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.autoUpdate = e.autoUpdate, this.needsUpdate = e.needsUpdate, this.normalBias = e.normalBias, this.blurSamples = e.blurSamples, this.mapSize.copy(e.mapSize), this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const e = {};
    return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e;
  }
}
const Jme = /* @__PURE__ */ new Pr(), qw = /* @__PURE__ */ new Ue(), yV = /* @__PURE__ */ new Ue();
class vje extends TG {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new Sa(90, 1, 0.5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Pn(4, 2), this._viewportCount = 6, this._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction
      // positive X
      new Bn(2, 1, 1, 1),
      // negative X
      new Bn(0, 1, 1, 1),
      // positive Z
      new Bn(3, 1, 1, 1),
      // negative Z
      new Bn(1, 1, 1, 1),
      // positive Y
      new Bn(3, 0, 1, 1),
      // negative Y
      new Bn(1, 0, 1, 1)
    ], this._cubeDirections = [
      new Ue(1, 0, 0),
      new Ue(-1, 0, 0),
      new Ue(0, 0, 1),
      new Ue(0, 0, -1),
      new Ue(0, 1, 0),
      new Ue(0, -1, 0)
    ], this._cubeUps = [
      new Ue(0, 1, 0),
      new Ue(0, 1, 0),
      new Ue(0, 1, 0),
      new Ue(0, 1, 0),
      new Ue(0, 0, 1),
      new Ue(0, 0, -1)
    ];
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   * @param {number} [viewportIndex=0] - The viewport index.
   */
  updateMatrices(e, t = 0) {
    const n = this.camera, i = this.matrix, o = e.distance || n.far;
    o !== n.far && (n.far = o, n.updateProjectionMatrix()), qw.setFromMatrixPosition(e.matrixWorld), n.position.copy(qw), yV.copy(n.position), yV.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(yV), n.updateMatrixWorld(), i.makeTranslation(-qw.x, -qw.y, -qw.z), Jme.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Jme);
  }
}
class bje extends Ig {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n = 0, i = 2) {
    super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new vje();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this;
  }
}
class xje extends TG {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new dG(-5, 5, 5, -5, 0.5, 500)), this.isDirectionalLightShadow = !0;
  }
}
class _je extends Ig {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Wi.DEFAULT_UP), this.updateMatrix(), this.target = new Wi(), this.shadow = new xje();
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Sje extends Ig {
  /**
   * Constructs a new area light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   * @param {number} [width=10] - The width of the light.
   * @param {number} [height=10] - The height of the light.
   */
  constructor(e, t, n = 10, i = 10) {
    super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i;
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * this.width * this.height * Math.PI;
  }
  set power(e) {
    this.intensity = e / (this.width * this.height * Math.PI);
  }
  copy(e) {
    return super.copy(e), this.width = e.width, this.height = e.height, this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.width = this.width, t.object.height = this.height, t;
  }
}
class wje extends TG {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new Sa(50, 1, 0.5, 500)), this.isSpotLightShadow = !0, this.focus = 1, this.aspect = 1;
  }
  updateMatrices(e) {
    const t = this.camera, n = Ub * 2 * e.angle * this.focus, i = this.mapSize.width / this.mapSize.height * this.aspect, o = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || o !== t.far) && (t.fov = n, t.aspect = i, t.far = o, t.updateProjectionMatrix()), super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), this.focus = e.focus, this;
  }
}
class CG extends Ig {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n = 0, i = Math.PI / 3, o = 0, l = 2) {
    super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Wi.DEFAULT_UP), this.updateMatrix(), this.target = new Wi(), this.distance = n, this.angle = i, this.penumbra = o, this.decay = l, this.map = null, this.shadow = new wje();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this;
  }
}
class Eje extends Ig {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t) {
    super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight";
  }
}
class Tje extends Ig {
  /**
   * Constructs a new hemisphere light.
   *
   * @param {(number|Color|string)} [skyColor=0xffffff] - The light's sky color.
   * @param {(number|Color|string)} [groundColor=0xffffff] - The light's ground color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e, t, n) {
    super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Wi.DEFAULT_UP), this.updateMatrix(), this.groundColor = new er(t);
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
class Cje {
  /**
   * Constructs a new spherical harmonics.
   */
  constructor() {
    this.isSphericalHarmonics3 = !0, this.coefficients = [];
    for (let e = 0; e < 9; e++)
      this.coefficients.push(new Ue());
  }
  /**
   * Sets the given SH coefficients to this instance by copying
   * the values.
   *
   * @param {Array<Vector3>} coefficients - The SH coefficients.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  set(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].copy(e[t]);
    return this;
  }
  /**
   * Sets all SH coefficients to `0`.
   *
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  zero() {
    for (let e = 0; e < 9; e++)
      this.coefficients[e].set(0, 0, 0);
    return this;
  }
  /**
   * Returns the radiance in the direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The radiance.
   */
  getAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.282095), t.addScaledVector(l[1], 0.488603 * i), t.addScaledVector(l[2], 0.488603 * o), t.addScaledVector(l[3], 0.488603 * n), t.addScaledVector(l[4], 1.092548 * (n * i)), t.addScaledVector(l[5], 1.092548 * (i * o)), t.addScaledVector(l[6], 0.315392 * (3 * o * o - 1)), t.addScaledVector(l[7], 1.092548 * (n * o)), t.addScaledVector(l[8], 0.546274 * (n * n - i * i)), t;
  }
  /**
   * Returns the irradiance (radiance convolved with cosine lobe) in the
   * direction of the given normal.
   *
   * @param {Vector3} normal - The normal vector (assumed to be unit length)
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The irradiance.
   */
  getIrradianceAt(e, t) {
    const n = e.x, i = e.y, o = e.z, l = this.coefficients;
    return t.copy(l[0]).multiplyScalar(0.886227), t.addScaledVector(l[1], 2 * 0.511664 * i), t.addScaledVector(l[2], 2 * 0.511664 * o), t.addScaledVector(l[3], 2 * 0.511664 * n), t.addScaledVector(l[4], 2 * 0.429043 * n * i), t.addScaledVector(l[5], 2 * 0.429043 * i * o), t.addScaledVector(l[6], 0.743125 * o * o - 0.247708), t.addScaledVector(l[7], 2 * 0.429043 * n * o), t.addScaledVector(l[8], 0.429043 * (n * n - i * i)), t;
  }
  /**
   * Adds the given SH to this instance.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  add(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].add(e.coefficients[t]);
    return this;
  }
  /**
   * A convenience method for performing {@link SphericalHarmonics3#add} and
   * {@link SphericalHarmonics3#scale} at once.
   *
   * @param {SphericalHarmonics3} sh - The SH to add.
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  addScaledSH(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].addScaledVector(e.coefficients[n], t);
    return this;
  }
  /**
   * Scales this SH by the given scale factor.
   *
   * @param {number} s - The scale factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  scale(e) {
    for (let t = 0; t < 9; t++)
      this.coefficients[t].multiplyScalar(e);
    return this;
  }
  /**
   * Linear interpolates between the given SH and this instance by the given
   * alpha factor.
   *
   * @param {SphericalHarmonics3} sh - The SH to interpolate with.
   * @param {number} alpha - The alpha factor.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  lerp(e, t) {
    for (let n = 0; n < 9; n++)
      this.coefficients[n].lerp(e.coefficients[n], t);
    return this;
  }
  /**
   * Returns `true` if this spherical harmonics is equal with the given one.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to test for equality.
   * @return {boolean} Whether this spherical harmonics is equal with the given one.
   */
  equals(e) {
    for (let t = 0; t < 9; t++)
      if (!this.coefficients[t].equals(e.coefficients[t]))
        return !1;
    return !0;
  }
  /**
   * Copies the values of the given spherical harmonics to this instance.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics to copy.
   * @return {SphericalHarmonics3} A reference to this spherical harmonics.
   */
  copy(e) {
    return this.set(e.coefficients);
  }
  /**
   * Returns a new spherical harmonics with copied values from this instance.
   *
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Sets the SH coefficients of this instance from the given array.
   *
   * @param {Array<number>} array - An array holding the SH coefficients.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {SphericalHarmonics3} A clone of this instance.
   */
  fromArray(e, t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].fromArray(e, t + i * 3);
    return this;
  }
  /**
   * Returns an array with the SH coefficients, or copies them into the provided
   * array. The coefficients are represented as numbers.
   *
   * @param {Array<number>} [array=[]] - The target array.
   * @param {number} [offset=0] - The array offset where to start copying.
   * @return {Array<number>} An array with flat SH coefficients.
   */
  toArray(e = [], t = 0) {
    const n = this.coefficients;
    for (let i = 0; i < 9; i++)
      n[i].toArray(e, t + i * 3);
    return e;
  }
  /**
   * Computes the SH basis for the given normal vector.
   *
   * @param {Vector3} normal - The normal.
   * @param {Array<number>} shBasis - The target array holding the SH basis.
   */
  static getBasisAt(e, t) {
    const n = e.x, i = e.y, o = e.z;
    t[0] = 0.282095, t[1] = 0.488603 * i, t[2] = 0.488603 * o, t[3] = 0.488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * o, t[6] = 0.315392 * (3 * o * o - 1), t[7] = 1.092548 * n * o, t[8] = 0.546274 * (n * n - i * i);
  }
}
class Pje extends Ig {
  /**
   * Constructs a new light probe.
   *
   * @param {SphericalHarmonics3} sh - The spherical harmonics which represents encoded lighting information.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(e = new Cje(), t = 1) {
    super(void 0, t), this.isLightProbe = !0, this.sh = e;
  }
  copy(e) {
    return super.copy(e), this.sh.copy(e.sh), this;
  }
  /**
   * Deserializes the light prove from the given JSON.
   *
   * @param {Object} json - The JSON holding the serialized light probe.
   * @return {LightProbe} A reference to this light probe.
   */
  fromJSON(e) {
    return this.intensity = e.intensity, this.sh.fromArray(e.sh), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return t.object.sh = this.sh.toArray(), t;
  }
}
class Aje extends CG {
  /**
   * Constructs a new IES spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n, i, o, l) {
    super(e, t, n, i, o, l), this.iesMap = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.iesMap = e.iesMap, this;
  }
}
class kje extends CG {
  /**
   * Constructs a new projector light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(e, t, n, i, o, l) {
    super(e, t, n, i, o, l), this.aspect = null;
  }
  copy(e, t) {
    return super.copy(e, t), this.aspect = e.aspect, this;
  }
}
class Mje extends ave {
  /**
   * Constructs a new standard node library.
   */
  constructor() {
    super(), this.addMaterial(F3e, "MeshPhongMaterial"), this.addMaterial(vve, "MeshStandardMaterial"), this.addMaterial(U3e, "MeshPhysicalMaterial"), this.addMaterial(H3e, "MeshToonMaterial"), this.addMaterial(K3e, "MeshBasicMaterial"), this.addMaterial(Q3e, "MeshLambertMaterial"), this.addMaterial(eje, "MeshNormalMaterial"), this.addMaterial(rje, "MeshMatcapMaterial"), this.addMaterial(sje, "LineBasicMaterial"), this.addMaterial(lje, "LineDashedMaterial"), this.addMaterial(pje, "PointsMaterial"), this.addMaterial(xve, "SpriteMaterial"), this.addMaterial(yje, "ShadowMaterial"), this.addLight(DFe, bje), this.addLight(GBe, _je), this.addLight(qBe, Sje), this.addLight(yG, CG), this.addLight(KBe, Eje), this.addLight(YBe, Tje), this.addLight(XBe, Pje), this.addLight(HBe, Aje), this.addLight(WBe, kje), this.addToneMapping(GDe, YMe), this.addToneMapping(qDe, XMe), this.addToneMapping(HDe, QMe), this.addToneMapping(WDe, ZMe), this.addToneMapping(QDe, JMe), this.addToneMapping(ZDe, eRe);
  }
}
class eO extends BLe {
  /**
   * WebGPURenderer options.
   *
   * @typedef {Object} WebGPURenderer~Options
   * @property {boolean} [logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
   * @property {boolean} [alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
   * @property {boolean} [depth=true] - Whether the default framebuffer should have a depth buffer or not.
   * @property {boolean} [stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
   * @property {boolean} [antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
   * @property {number} [samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
   * @property {boolean} [forceWebGL=false] - If set to `true`, the renderer uses a WebGL 2 backend no matter if WebGPU is supported or not.
   * @property {boolean} [multiview=false] - If set to `true`, the renderer will use multiview during WebXR rendering if supported.
   * @property {number} [outputType=undefined] - Texture type for output to canvas. By default, device's preferred format is used; other formats may incur overhead.
   * @property {number} [colorBufferType=HalfFloatType] - Defines the type of color buffers. The default `HalfFloatType` is recommend for best
   * quality. To save memory and bandwidth, `UnsignedByteType` might be used. This will reduce rendering quality though.
   */
  /**
   * Constructs a new WebGPU renderer.
   *
   * @param {WebGPURenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(e = {}) {
    let t;
    e.forceWebGL ? t = Gme : (t = N3e, e.getFallback = () => (console.warn("THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend."), new Gme(e)));
    const n = new t(e);
    super(n, e), this.library = new Mje(), this.isWebGPURenderer = !0, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
  }
}
class Rje extends mc {
  /**
   * Constructs a new rect area light helper.
   *
   * @param {RectAreaLight} light - The light to visualize.
   * @param {number|Color|string} [color] - The helper's color.
   * If this is not the set, the helper will take the color of the light.
   */
  constructor(e, t) {
    const n = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], i = new Qp();
    i.setAttribute("position", new bc(n, 3)), i.computeBoundingSphere();
    const o = new w6({ fog: !1 });
    super(i, o), this.light = e, this.color = t, this.type = "RectAreaLightHelper";
    const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], p = new Qp();
    p.setAttribute("position", new bc(l, 3)), p.computeBoundingSphere(), this.add(new Dt(p, new Tg({ side: Tge, fog: !1 })));
  }
  updateMatrixWorld() {
    if (this.scale.set(0.5 * this.light.width, 0.5 * this.light.height, 1), this.color !== void 0)
      this.material.color.set(this.color), this.children[0].material.color.set(this.color);
    else {
      this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
      const e = this.material.color, t = Math.max(e.r, e.g, e.b);
      t > 1 && e.multiplyScalar(1 / t), this.children[0].material.color.copy(this.material.color);
    }
    this.matrixWorld.extractRotation(this.light.matrixWorld).scale(this.scale).copyPosition(this.light.matrixWorld), this.children[0].matrixWorld.copy(this.matrixWorld);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose();
  }
}
const ege = { type: "change" }, PG = { type: "start" }, _ve = { type: "end" }, tO = new UAe(), tge = new zAe(), Ije = Math.cos(70 * VAe.DEG2RAD), Gi = new Vt(), Go = 2 * Math.PI, xr = {
  NONE: -1,
  ROTATE: 0,
  DOLLY: 1,
  PAN: 2,
  TOUCH_ROTATE: 3,
  TOUCH_PAN: 4,
  TOUCH_DOLLY_PAN: 5,
  TOUCH_DOLLY_ROTATE: 6
}, vV = 1e-6;
class Nje extends Dge {
  /**
   * Constructs a new controls instance.
   *
   * @param {Object3D} object - The object that is managed by the controls.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(e, t), this.state = xr.NONE, this.target = new Vt(), this.cursor = new Vt(), this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.minTargetRadius = 0, this.maxTargetRadius = 1 / 0, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.enableDamping = !1, this.dampingFactor = 0.05, this.enableZoom = !0, this.zoomSpeed = 1, this.enableRotate = !0, this.rotateSpeed = 1, this.keyRotateSpeed = 1, this.enablePan = !0, this.panSpeed = 1, this.screenSpacePanning = !0, this.keyPanSpeed = 7, this.zoomToCursor = !1, this.autoRotate = !1, this.autoRotateSpeed = 2, this.keys = { LEFT: "ArrowLeft", UP: "ArrowUp", RIGHT: "ArrowRight", BOTTOM: "ArrowDown" }, this.mouseButtons = { LEFT: kb.ROTATE, MIDDLE: kb.DOLLY, RIGHT: kb.PAN }, this.touches = { ONE: Sb.ROTATE, TWO: Sb.DOLLY_PAN }, this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this._domElementKeyEvents = null, this._lastPosition = new Vt(), this._lastQuaternion = new xa(), this._lastTargetPosition = new Vt(), this._quat = new xa().setFromUnitVectors(e.up, new Vt(0, 1, 0)), this._quatInverse = this._quat.clone().invert(), this._spherical = new NV(), this._sphericalDelta = new NV(), this._scale = 1, this._panOffset = new Vt(), this._rotateStart = new As(), this._rotateEnd = new As(), this._rotateDelta = new As(), this._panStart = new As(), this._panEnd = new As(), this._panDelta = new As(), this._dollyStart = new As(), this._dollyEnd = new As(), this._dollyDelta = new As(), this._dollyDirection = new Vt(), this._mouse = new As(), this._performCursorZoom = !1, this._pointers = [], this._pointerPositions = {}, this._controlActive = !1, this._onPointerMove = Dje.bind(this), this._onPointerDown = Oje.bind(this), this._onPointerUp = Fje.bind(this), this._onContextMenu = Gje.bind(this), this._onMouseWheel = jje.bind(this), this._onKeyDown = Uje.bind(this), this._onTouchStart = zje.bind(this), this._onTouchMove = Vje.bind(this), this._onMouseDown = Bje.bind(this), this._onMouseMove = Lje.bind(this), this._interceptControlDown = qje.bind(this), this._interceptControlUp = Hje.bind(this), this.domElement !== null && this.connect(this.domElement), this.update();
  }
  connect(e) {
    super.connect(e), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointercancel", this._onPointerUp), this.domElement.addEventListener("contextmenu", this._onContextMenu), this.domElement.addEventListener("wheel", this._onMouseWheel, { passive: !1 }), this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, { passive: !0, capture: !0 }), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.removeEventListener("pointercancel", this._onPointerUp), this.domElement.removeEventListener("wheel", this._onMouseWheel), this.domElement.removeEventListener("contextmenu", this._onContextMenu), this.stopListenToKeyEvents(), this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, { capture: !0 }), this.domElement.style.touchAction = "auto";
  }
  dispose() {
    this.disconnect();
  }
  /**
   * Get the current vertical rotation, in radians.
   *
   * @return {number} The current vertical rotation, in radians.
   */
  getPolarAngle() {
    return this._spherical.phi;
  }
  /**
   * Get the current horizontal rotation, in radians.
   *
   * @return {number} The current horizontal rotation, in radians.
   */
  getAzimuthalAngle() {
    return this._spherical.theta;
  }
  /**
   * Returns the distance from the camera to the target.
   *
   * @return {number} The distance from the camera to the target.
   */
  getDistance() {
    return this.object.position.distanceTo(this.target);
  }
  /**
   * Adds key event listeners to the given DOM element.
   * `window` is a recommended argument for using this method.
   *
   * @param {HTMLDOMElement} domElement - The DOM element
   */
  listenToKeyEvents(e) {
    e.addEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = e;
  }
  /**
   * Removes the key event listener previously defined with `listenToKeyEvents()`.
   */
  stopListenToKeyEvents() {
    this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown), this._domElementKeyEvents = null);
  }
  /**
   * Save the current state of the controls. This can later be recovered with `reset()`.
   */
  saveState() {
    this.target0.copy(this.target), this.position0.copy(this.object.position), this.zoom0 = this.object.zoom;
  }
  /**
   * Reset the controls to their state from either the last time the `saveState()`
   * was called, or the initial state.
   */
  reset() {
    this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(ege), this.update(), this.state = xr.NONE;
  }
  update(e = null) {
    const t = this.object.position;
    Gi.copy(t).sub(this.target), Gi.applyQuaternion(this._quat), this._spherical.setFromVector3(Gi), this.autoRotate && this.state === xr.NONE && this._rotateLeft(this._getAutoRotationAngle(e)), this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor, this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta, this._spherical.phi += this._sphericalDelta.phi);
    let n = this.minAzimuthAngle, i = this.maxAzimuthAngle;
    isFinite(n) && isFinite(i) && (n < -Math.PI ? n += Go : n > Math.PI && (n -= Go), i < -Math.PI ? i += Go : i > Math.PI && (i -= Go), n <= i ? this._spherical.theta = Math.max(n, Math.min(i, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + i) / 2 ? Math.max(n, this._spherical.theta) : Math.min(i, this._spherical.theta)), this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)), this._spherical.makeSafe(), this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset), this.target.sub(this.cursor), this.target.clampLength(this.minTargetRadius, this.maxTargetRadius), this.target.add(this.cursor);
    let o = !1;
    if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
      this._spherical.radius = this._clampDistance(this._spherical.radius);
    else {
      const l = this._spherical.radius;
      this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale), o = l != this._spherical.radius;
    }
    if (Gi.setFromSpherical(this._spherical), Gi.applyQuaternion(this._quatInverse), t.copy(this.target).add(Gi), this.object.lookAt(this.target), this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor, this._sphericalDelta.phi *= 1 - this.dampingFactor, this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0), this._panOffset.set(0, 0, 0)), this.zoomToCursor && this._performCursorZoom) {
      let l = null;
      if (this.object.isPerspectiveCamera) {
        const p = Gi.length();
        l = this._clampDistance(p * this._scale);
        const f = p - l;
        this.object.position.addScaledVector(this._dollyDirection, f), this.object.updateMatrixWorld(), o = !!f;
      } else if (this.object.isOrthographicCamera) {
        const p = new Vt(this._mouse.x, this._mouse.y, 0);
        p.unproject(this.object);
        const f = this.object.zoom;
        this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), this.object.updateProjectionMatrix(), o = f !== this.object.zoom;
        const v = new Vt(this._mouse.x, this._mouse.y, 0);
        v.unproject(this.object), this.object.position.sub(v).add(p), this.object.updateMatrixWorld(), l = Gi.length();
      } else
        console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."), this.zoomToCursor = !1;
      l !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(l).add(this.object.position) : (tO.origin.copy(this.object.position), tO.direction.set(0, 0, -1).transformDirection(this.object.matrix), Math.abs(this.object.up.dot(tO.direction)) < Ije ? this.object.lookAt(this.target) : (tge.setFromNormalAndCoplanarPoint(this.object.up, this.target), tO.intersectPlane(tge, this.target))));
    } else if (this.object.isOrthographicCamera) {
      const l = this.object.zoom;
      this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)), l !== this.object.zoom && (this.object.updateProjectionMatrix(), o = !0);
    }
    return this._scale = 1, this._performCursorZoom = !1, o || this._lastPosition.distanceToSquared(this.object.position) > vV || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > vV || this._lastTargetPosition.distanceToSquared(this.target) > vV ? (this.dispatchEvent(ege), this._lastPosition.copy(this.object.position), this._lastQuaternion.copy(this.object.quaternion), this._lastTargetPosition.copy(this.target), !0) : !1;
  }
  _getAutoRotationAngle(e) {
    return e !== null ? Go / 60 * this.autoRotateSpeed * e : Go / 60 / 60 * this.autoRotateSpeed;
  }
  _getZoomScale(e) {
    const t = Math.abs(e * 0.01);
    return Math.pow(0.95, this.zoomSpeed * t);
  }
  _rotateLeft(e) {
    this._sphericalDelta.theta -= e;
  }
  _rotateUp(e) {
    this._sphericalDelta.phi -= e;
  }
  _panLeft(e, t) {
    Gi.setFromMatrixColumn(t, 0), Gi.multiplyScalar(-e), this._panOffset.add(Gi);
  }
  _panUp(e, t) {
    this.screenSpacePanning === !0 ? Gi.setFromMatrixColumn(t, 1) : (Gi.setFromMatrixColumn(t, 0), Gi.crossVectors(this.object.up, Gi)), Gi.multiplyScalar(e), this._panOffset.add(Gi);
  }
  // deltaX and deltaY are in pixels; right and down are positive
  _pan(e, t) {
    const n = this.domElement;
    if (this.object.isPerspectiveCamera) {
      const i = this.object.position;
      Gi.copy(i).sub(this.target);
      let o = Gi.length();
      o *= Math.tan(this.object.fov / 2 * Math.PI / 180), this._panLeft(2 * e * o / n.clientHeight, this.object.matrix), this._panUp(2 * t * o / n.clientHeight, this.object.matrix);
    } else this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix), this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."), this.enablePan = !1);
  }
  _dollyOut(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _dollyIn(e) {
    this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."), this.enableZoom = !1);
  }
  _updateZoomParameters(e, t) {
    if (!this.zoomToCursor)
      return;
    this._performCursorZoom = !0;
    const n = this.domElement.getBoundingClientRect(), i = e - n.left, o = t - n.top, l = n.width, p = n.height;
    this._mouse.x = i / l * 2 - 1, this._mouse.y = -(o / p) * 2 + 1, this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize();
  }
  _clampDistance(e) {
    return Math.max(this.minDistance, Math.min(this.maxDistance, e));
  }
  //
  // event callbacks - update the object state
  //
  _handleMouseDownRotate(e) {
    this._rotateStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownDolly(e) {
    this._updateZoomParameters(e.clientX, e.clientX), this._dollyStart.set(e.clientX, e.clientY);
  }
  _handleMouseDownPan(e) {
    this._panStart.set(e.clientX, e.clientY);
  }
  _handleMouseMoveRotate(e) {
    this._rotateEnd.set(e.clientX, e.clientY), this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Go * this._rotateDelta.x / t.clientHeight), this._rotateUp(Go * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd), this.update();
  }
  _handleMouseMoveDolly(e) {
    this._dollyEnd.set(e.clientX, e.clientY), this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart), this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)), this._dollyStart.copy(this._dollyEnd), this.update();
  }
  _handleMouseMovePan(e) {
    this._panEnd.set(e.clientX, e.clientY), this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd), this.update();
  }
  _handleMouseWheel(e) {
    this._updateZoomParameters(e.clientX, e.clientY), e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)), this.update();
  }
  _handleKeyDown(e) {
    let t = !1;
    switch (e.code) {
      case this.keys.UP:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(Go * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, this.keyPanSpeed), t = !0;
        break;
      case this.keys.BOTTOM:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateUp(-Go * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(0, -this.keyPanSpeed), t = !0;
        break;
      case this.keys.LEFT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(Go * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(this.keyPanSpeed, 0), t = !0;
        break;
      case this.keys.RIGHT:
        e.ctrlKey || e.metaKey || e.shiftKey ? this.enableRotate && this._rotateLeft(-Go * this.keyRotateSpeed / this.domElement.clientHeight) : this.enablePan && this._pan(-this.keyPanSpeed, 0), t = !0;
        break;
    }
    t && (e.preventDefault(), this.update());
  }
  _handleTouchStartRotate(e) {
    if (this._pointers.length === 1)
      this._rotateStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), i = 0.5 * (e.pageY + t.y);
      this._rotateStart.set(n, i);
    }
  }
  _handleTouchStartPan(e) {
    if (this._pointers.length === 1)
      this._panStart.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), i = 0.5 * (e.pageY + t.y);
      this._panStart.set(n, i);
    }
  }
  _handleTouchStartDolly(e) {
    const t = this._getSecondPointerPosition(e), n = e.pageX - t.x, i = e.pageY - t.y, o = Math.sqrt(n * n + i * i);
    this._dollyStart.set(0, o);
  }
  _handleTouchStartDollyPan(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enablePan && this._handleTouchStartPan(e);
  }
  _handleTouchStartDollyRotate(e) {
    this.enableZoom && this._handleTouchStartDolly(e), this.enableRotate && this._handleTouchStartRotate(e);
  }
  _handleTouchMoveRotate(e) {
    if (this._pointers.length == 1)
      this._rotateEnd.set(e.pageX, e.pageY);
    else {
      const n = this._getSecondPointerPosition(e), i = 0.5 * (e.pageX + n.x), o = 0.5 * (e.pageY + n.y);
      this._rotateEnd.set(i, o);
    }
    this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
    const t = this.domElement;
    this._rotateLeft(Go * this._rotateDelta.x / t.clientHeight), this._rotateUp(Go * this._rotateDelta.y / t.clientHeight), this._rotateStart.copy(this._rotateEnd);
  }
  _handleTouchMovePan(e) {
    if (this._pointers.length === 1)
      this._panEnd.set(e.pageX, e.pageY);
    else {
      const t = this._getSecondPointerPosition(e), n = 0.5 * (e.pageX + t.x), i = 0.5 * (e.pageY + t.y);
      this._panEnd.set(n, i);
    }
    this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed), this._pan(this._panDelta.x, this._panDelta.y), this._panStart.copy(this._panEnd);
  }
  _handleTouchMoveDolly(e) {
    const t = this._getSecondPointerPosition(e), n = e.pageX - t.x, i = e.pageY - t.y, o = Math.sqrt(n * n + i * i);
    this._dollyEnd.set(0, o), this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)), this._dollyOut(this._dollyDelta.y), this._dollyStart.copy(this._dollyEnd);
    const l = (e.pageX + t.x) * 0.5, p = (e.pageY + t.y) * 0.5;
    this._updateZoomParameters(l, p);
  }
  _handleTouchMoveDollyPan(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enablePan && this._handleTouchMovePan(e);
  }
  _handleTouchMoveDollyRotate(e) {
    this.enableZoom && this._handleTouchMoveDolly(e), this.enableRotate && this._handleTouchMoveRotate(e);
  }
  // pointers
  _addPointer(e) {
    this._pointers.push(e.pointerId);
  }
  _removePointer(e) {
    delete this._pointerPositions[e.pointerId];
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) {
        this._pointers.splice(t, 1);
        return;
      }
  }
  _isTrackingPointer(e) {
    for (let t = 0; t < this._pointers.length; t++)
      if (this._pointers[t] == e.pointerId) return !0;
    return !1;
  }
  _trackPointer(e) {
    let t = this._pointerPositions[e.pointerId];
    t === void 0 && (t = new As(), this._pointerPositions[e.pointerId] = t), t.set(e.pageX, e.pageY);
  }
  _getSecondPointerPosition(e) {
    const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
    return this._pointerPositions[t];
  }
  //
  _customWheelEvent(e) {
    const t = e.deltaMode, n = {
      clientX: e.clientX,
      clientY: e.clientY,
      deltaY: e.deltaY
    };
    switch (t) {
      case 1:
        n.deltaY *= 16;
        break;
      case 2:
        n.deltaY *= 100;
        break;
    }
    return e.ctrlKey && !this._controlActive && (n.deltaY *= 10), n;
  }
}
function Oje(c) {
  this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(c.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.domElement.addEventListener("pointerup", this._onPointerUp)), !this._isTrackingPointer(c) && (this._addPointer(c), c.pointerType === "touch" ? this._onTouchStart(c) : this._onMouseDown(c)));
}
function Dje(c) {
  this.enabled !== !1 && (c.pointerType === "touch" ? this._onTouchMove(c) : this._onMouseMove(c));
}
function Fje(c) {
  switch (this._removePointer(c), this._pointers.length) {
    case 0:
      this.domElement.releasePointerCapture(c.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.dispatchEvent(_ve), this.state = xr.NONE;
      break;
    case 1:
      const e = this._pointers[0], t = this._pointerPositions[e];
      this._onTouchStart({ pointerId: e, pageX: t.x, pageY: t.y });
      break;
  }
}
function Bje(c) {
  let e;
  switch (c.button) {
    case 0:
      e = this.mouseButtons.LEFT;
      break;
    case 1:
      e = this.mouseButtons.MIDDLE;
      break;
    case 2:
      e = this.mouseButtons.RIGHT;
      break;
    default:
      e = -1;
  }
  switch (e) {
    case kb.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseDownDolly(c), this.state = xr.DOLLY;
      break;
    case kb.ROTATE:
      if (c.ctrlKey || c.metaKey || c.shiftKey) {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(c), this.state = xr.PAN;
      } else {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(c), this.state = xr.ROTATE;
      }
      break;
    case kb.PAN:
      if (c.ctrlKey || c.metaKey || c.shiftKey) {
        if (this.enableRotate === !1) return;
        this._handleMouseDownRotate(c), this.state = xr.ROTATE;
      } else {
        if (this.enablePan === !1) return;
        this._handleMouseDownPan(c), this.state = xr.PAN;
      }
      break;
    default:
      this.state = xr.NONE;
  }
  this.state !== xr.NONE && this.dispatchEvent(PG);
}
function Lje(c) {
  switch (this.state) {
    case xr.ROTATE:
      if (this.enableRotate === !1) return;
      this._handleMouseMoveRotate(c);
      break;
    case xr.DOLLY:
      if (this.enableZoom === !1) return;
      this._handleMouseMoveDolly(c);
      break;
    case xr.PAN:
      if (this.enablePan === !1) return;
      this._handleMouseMovePan(c);
      break;
  }
}
function jje(c) {
  this.enabled === !1 || this.enableZoom === !1 || this.state !== xr.NONE || (c.preventDefault(), this.dispatchEvent(PG), this._handleMouseWheel(this._customWheelEvent(c)), this.dispatchEvent(_ve));
}
function Uje(c) {
  this.enabled !== !1 && this._handleKeyDown(c);
}
function zje(c) {
  switch (this._trackPointer(c), this._pointers.length) {
    case 1:
      switch (this.touches.ONE) {
        case Sb.ROTATE:
          if (this.enableRotate === !1) return;
          this._handleTouchStartRotate(c), this.state = xr.TOUCH_ROTATE;
          break;
        case Sb.PAN:
          if (this.enablePan === !1) return;
          this._handleTouchStartPan(c), this.state = xr.TOUCH_PAN;
          break;
        default:
          this.state = xr.NONE;
      }
      break;
    case 2:
      switch (this.touches.TWO) {
        case Sb.DOLLY_PAN:
          if (this.enableZoom === !1 && this.enablePan === !1) return;
          this._handleTouchStartDollyPan(c), this.state = xr.TOUCH_DOLLY_PAN;
          break;
        case Sb.DOLLY_ROTATE:
          if (this.enableZoom === !1 && this.enableRotate === !1) return;
          this._handleTouchStartDollyRotate(c), this.state = xr.TOUCH_DOLLY_ROTATE;
          break;
        default:
          this.state = xr.NONE;
      }
      break;
    default:
      this.state = xr.NONE;
  }
  this.state !== xr.NONE && this.dispatchEvent(PG);
}
function Vje(c) {
  switch (this._trackPointer(c), this.state) {
    case xr.TOUCH_ROTATE:
      if (this.enableRotate === !1) return;
      this._handleTouchMoveRotate(c), this.update();
      break;
    case xr.TOUCH_PAN:
      if (this.enablePan === !1) return;
      this._handleTouchMovePan(c), this.update();
      break;
    case xr.TOUCH_DOLLY_PAN:
      if (this.enableZoom === !1 && this.enablePan === !1) return;
      this._handleTouchMoveDollyPan(c), this.update();
      break;
    case xr.TOUCH_DOLLY_ROTATE:
      if (this.enableZoom === !1 && this.enableRotate === !1) return;
      this._handleTouchMoveDollyRotate(c), this.update();
      break;
    default:
      this.state = xr.NONE;
  }
}
function Gje(c) {
  this.enabled !== !1 && c.preventDefault();
}
function qje(c) {
  c.key === "Control" && (this._controlActive = !0, this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
function Hje(c) {
  c.key === "Control" && (this._controlActive = !1, this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, { passive: !0, capture: !0 }));
}
/*!
 * camera-controls
 * https://github.com/yomotsu/camera-controls
 * (c) 2017 @yomotsu
 * Released under the MIT License.
 */
const ri = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
}, He = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  SCREEN_PAN: 4,
  OFFSET: 8,
  DOLLY: 16,
  ZOOM: 32,
  TOUCH_ROTATE: 64,
  TOUCH_TRUCK: 128,
  TOUCH_SCREEN_PAN: 256,
  TOUCH_OFFSET: 512,
  TOUCH_DOLLY: 1024,
  TOUCH_ZOOM: 2048,
  TOUCH_DOLLY_TRUCK: 4096,
  TOUCH_DOLLY_SCREEN_PAN: 8192,
  TOUCH_DOLLY_OFFSET: 16384,
  TOUCH_DOLLY_ROTATE: 32768,
  TOUCH_ZOOM_TRUCK: 65536,
  TOUCH_ZOOM_OFFSET: 131072,
  TOUCH_ZOOM_SCREEN_PAN: 262144,
  TOUCH_ZOOM_ROTATE: 524288
}), gb = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function ag(c) {
  return c.isPerspectiveCamera;
}
function Up(c) {
  return c.isOrthographicCamera;
}
const yb = Math.PI * 2, nge = Math.PI / 2, Sve = 1e-5, Hw = Math.PI / 180;
function su(c, e, t) {
  return Math.max(e, Math.min(t, c));
}
function Rr(c, e = Sve) {
  return Math.abs(c) < e;
}
function lr(c, e, t = Sve) {
  return Rr(c - e, t);
}
function rge(c, e) {
  return Math.round(c / e) * e;
}
function $w(c) {
  return isFinite(c) ? c : c < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;
}
function Ww(c) {
  return Math.abs(c) < Number.MAX_VALUE ? c : c * (1 / 0);
}
function nO(c, e, t, n, i = 1 / 0, o) {
  n = Math.max(1e-4, n);
  const l = 2 / n, p = l * o, f = 1 / (1 + p + 0.48 * p * p + 0.235 * p * p * p);
  let v = c - e;
  const _ = e, E = i * n;
  v = su(v, -E, E), e = c - v;
  const A = (t.value + l * v) * o;
  t.value = (t.value - l * A) * f;
  let I = e + (v + A) * f;
  return _ - c > 0 == I > _ && (I = _, t.value = (I - _) / o), I;
}
function ige(c, e, t, n, i = 1 / 0, o, l) {
  n = Math.max(1e-4, n);
  const p = 2 / n, f = p * o, v = 1 / (1 + f + 0.48 * f * f + 0.235 * f * f * f);
  let _ = e.x, E = e.y, A = e.z, I = c.x - _, j = c.y - E, q = c.z - A;
  const L = _, V = E, re = A, R = i * n, J = R * R, ge = I * I + j * j + q * q;
  if (ge > J) {
    const pe = Math.sqrt(ge);
    I = I / pe * R, j = j / pe * R, q = q / pe * R;
  }
  _ = c.x - I, E = c.y - j, A = c.z - q;
  const _e = (t.x + p * I) * o, Y = (t.y + p * j) * o, Fe = (t.z + p * q) * o;
  t.x = (t.x - p * _e) * v, t.y = (t.y - p * Y) * v, t.z = (t.z - p * Fe) * v, l.x = _ + (I + _e) * v, l.y = E + (j + Y) * v, l.z = A + (q + Fe) * v;
  const Me = L - c.x, $ = V - c.y, dt = re - c.z, wt = l.x - L, St = l.y - V, Ct = l.z - re;
  return Me * wt + $ * St + dt * Ct > 0 && (l.x = L, l.y = V, l.z = re, t.x = (l.x - L) / o, t.y = (l.y - V) / o, t.z = (l.z - re) / o), l;
}
function bV(c, e) {
  e.set(0, 0), c.forEach((t) => {
    e.x += t.clientX, e.y += t.clientY;
  }), e.x /= c.length, e.y /= c.length;
}
function xV(c, e) {
  return Up(c) ? (console.warn(`${e} is not supported in OrthographicCamera`), !0) : !1;
}
class $je {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(e, t) {
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    const i = this._listeners[e];
    if (i !== void 0) {
      const o = i.indexOf(t);
      o !== -1 && i.splice(o, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(e) {
    if (!e) {
      this._listeners = {};
      return;
    }
    Array.isArray(this._listeners[e]) && (this._listeners[e].length = 0);
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(e) {
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let o = 0, l = i.length; o < l; o++)
        i[o].call(this, e);
    }
  }
}
var _V;
const Wje = "2.10.1", rO = 1 / 8, Kje = /Mac/.test((_V = globalThis?.navigator) === null || _V === void 0 ? void 0 : _V.platform);
let cn, sge, iO, SV, qo, wn, Zn, vb, Kw, dc, hc, lg, oge, age, rl, Yw, bb, lge, wV, uge, EV, TV, sO;
class yc extends $je {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(e) {
    cn = e.THREE, sge = Object.freeze(new cn.Vector3(0, 0, 0)), iO = Object.freeze(new cn.Vector3(0, 1, 0)), SV = Object.freeze(new cn.Vector3(0, 0, 1)), qo = new cn.Vector2(), wn = new cn.Vector3(), Zn = new cn.Vector3(), vb = new cn.Vector3(), Kw = new cn.Vector3(), dc = new cn.Vector3(), hc = new cn.Vector3(), lg = new cn.Vector3(), oge = new cn.Vector3(), age = new cn.Vector3(), rl = new cn.Spherical(), Yw = new cn.Spherical(), bb = new cn.Box3(), lge = new cn.Box3(), wV = new cn.Sphere(), uge = new cn.Quaternion(), EV = new cn.Quaternion(), TV = new cn.Matrix4(), sO = new cn.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return He;
  }
  /**
   * @deprecated Use `cameraControls.mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.
   */
  set verticalDragToForward(e) {
    console.warn("camera-controls: `verticalDragToForward` was removed. Use `mouseButtons.left = CameraControls.ACTION.SCREEN_PAN` instead.");
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(e, t) {
    super(), this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.minDistance = Number.EPSILON, this.maxDistance = 1 / 0, this.infinityDolly = !1, this.minZoom = 0.01, this.maxZoom = 1 / 0, this.smoothTime = 0.25, this.draggingSmoothTime = 0.125, this.maxSpeed = 1 / 0, this.azimuthRotateSpeed = 1, this.polarRotateSpeed = 1, this.dollySpeed = 1, this.dollyDragInverted = !1, this.truckSpeed = 2, this.dollyToCursor = !1, this.dragToOffset = !1, this.boundaryFriction = 0, this.restThreshold = 0.01, this.colliderMeshes = [], this.cancel = () => {
    }, this._enabled = !0, this._state = He.NONE, this._viewport = null, this._changedDolly = 0, this._changedZoom = 0, this._hasRested = !0, this._boundaryEnclosesCamera = !1, this._needsUpdate = !0, this._updatedLastTime = !1, this._elementRect = new DOMRect(), this._isDragging = !1, this._dragNeedsUpdate = !0, this._activePointers = [], this._lockedPointer = null, this._interactiveArea = new DOMRect(0, 0, 1, 1), this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._isUserControllingOffset = !1, this._isUserControllingZoom = !1, this._lastDollyDirection = gb.NONE, this._thetaVelocity = { value: 0 }, this._phiVelocity = { value: 0 }, this._radiusVelocity = { value: 0 }, this._targetVelocity = new cn.Vector3(), this._focalOffsetVelocity = new cn.Vector3(), this._zoomVelocity = { value: 0 }, this._truckInternal = (V, re, R, J) => {
      let ge, _e;
      if (ag(this._camera)) {
        const Y = wn.copy(this._camera.position).sub(this._target), Fe = this._camera.getEffectiveFOV() * Hw, Me = Y.length() * Math.tan(Fe * 0.5);
        ge = this.truckSpeed * V * Me / this._elementRect.height, _e = this.truckSpeed * re * Me / this._elementRect.height;
      } else if (Up(this._camera)) {
        const Y = this._camera;
        ge = this.truckSpeed * V * (Y.right - Y.left) / Y.zoom / this._elementRect.width, _e = this.truckSpeed * re * (Y.top - Y.bottom) / Y.zoom / this._elementRect.height;
      } else
        return;
      J ? (R ? this.setFocalOffset(this._focalOffsetEnd.x + ge, this._focalOffsetEnd.y, this._focalOffsetEnd.z, !0) : this.truck(ge, 0, !0), this.forward(-_e, !0)) : R ? this.setFocalOffset(this._focalOffsetEnd.x + ge, this._focalOffsetEnd.y + _e, this._focalOffsetEnd.z, !0) : this.truck(ge, _e, !0);
    }, this._rotateInternal = (V, re) => {
      const R = yb * this.azimuthRotateSpeed * V / this._elementRect.height, J = yb * this.polarRotateSpeed * re / this._elementRect.height;
      this.rotate(R, J, !0);
    }, this._dollyInternal = (V, re, R) => {
      const J = Math.pow(0.95, -V * this.dollySpeed), ge = this._sphericalEnd.radius, _e = this._sphericalEnd.radius * J, Y = su(_e, this.minDistance, this.maxDistance), Fe = Y - _e;
      this.infinityDolly && this.dollyToCursor ? this._dollyToNoClamp(_e, !0) : this.infinityDolly && !this.dollyToCursor ? (this.dollyInFixed(Fe, !0), this._dollyToNoClamp(Y, !0)) : this._dollyToNoClamp(Y, !0), this.dollyToCursor && (this._changedDolly += (this.infinityDolly ? _e : Y) - ge, this._dollyControlCoord.set(re, R)), this._lastDollyDirection = Math.sign(-V);
    }, this._zoomInternal = (V, re, R) => {
      const J = Math.pow(0.95, V * this.dollySpeed), ge = this._zoom, _e = this._zoom * J;
      this.zoomTo(_e, !0), this.dollyToCursor && (this._changedZoom += _e - ge, this._dollyControlCoord.set(re, R));
    }, typeof cn > "u" && console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information."), this._camera = e, this._yAxisUpSpace = new cn.Quaternion().setFromUnitVectors(this._camera.up, iO), this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert(), this._state = He.NONE, this._target = new cn.Vector3(), this._targetEnd = this._target.clone(), this._focalOffset = new cn.Vector3(), this._focalOffsetEnd = this._focalOffset.clone(), this._spherical = new cn.Spherical().setFromVector3(wn.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace)), this._sphericalEnd = this._spherical.clone(), this._lastDistance = this._spherical.radius, this._zoom = this._camera.zoom, this._zoomEnd = this._zoom, this._lastZoom = this._zoom, this._nearPlaneCorners = [
      new cn.Vector3(),
      new cn.Vector3(),
      new cn.Vector3(),
      new cn.Vector3()
    ], this._updateNearPlaneCorners(), this._boundary = new cn.Box3(new cn.Vector3(-1 / 0, -1 / 0, -1 / 0), new cn.Vector3(1 / 0, 1 / 0, 1 / 0)), this._cameraUp0 = this._camera.up.clone(), this._target0 = this._target.clone(), this._position0 = this._camera.position.clone(), this._zoom0 = this._zoom, this._focalOffset0 = this._focalOffset.clone(), this._dollyControlCoord = new cn.Vector2(), this.mouseButtons = {
      left: He.ROTATE,
      middle: He.DOLLY,
      right: He.TRUCK,
      wheel: ag(this._camera) ? He.DOLLY : Up(this._camera) ? He.ZOOM : He.NONE
    }, this.touches = {
      one: He.TOUCH_ROTATE,
      two: ag(this._camera) ? He.TOUCH_DOLLY_TRUCK : Up(this._camera) ? He.TOUCH_ZOOM_TRUCK : He.NONE,
      three: He.TOUCH_TRUCK
    };
    const n = new cn.Vector2(), i = new cn.Vector2(), o = new cn.Vector2(), l = (V) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const J = this._domElement.getBoundingClientRect(), ge = V.clientX / J.width, _e = V.clientY / J.height;
        if (ge < this._interactiveArea.left || ge > this._interactiveArea.right || _e < this._interactiveArea.top || _e > this._interactiveArea.bottom)
          return;
      }
      const re = V.pointerType !== "mouse" ? null : (V.buttons & ri.LEFT) === ri.LEFT ? ri.LEFT : (V.buttons & ri.MIDDLE) === ri.MIDDLE ? ri.MIDDLE : (V.buttons & ri.RIGHT) === ri.RIGHT ? ri.RIGHT : null;
      if (re !== null) {
        const J = this._findPointerByMouseButton(re);
        J && this._disposePointer(J);
      }
      if ((V.buttons & ri.LEFT) === ri.LEFT && this._lockedPointer)
        return;
      const R = {
        pointerId: V.pointerId,
        clientX: V.clientX,
        clientY: V.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: re
      };
      this._activePointers.push(R), this._domElement.ownerDocument.removeEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", f), this._domElement.ownerDocument.addEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", f), this._isDragging = !0, A(V);
    }, p = (V) => {
      V.cancelable && V.preventDefault();
      const re = V.pointerId, R = this._lockedPointer || this._findPointerById(re);
      if (R) {
        if (R.clientX = V.clientX, R.clientY = V.clientY, R.deltaX = V.movementX, R.deltaY = V.movementY, this._state = 0, V.pointerType === "touch")
          switch (this._activePointers.length) {
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          (!this._isDragging && this._lockedPointer || this._isDragging && (V.buttons & ri.LEFT) === ri.LEFT) && (this._state = this._state | this.mouseButtons.left), this._isDragging && (V.buttons & ri.MIDDLE) === ri.MIDDLE && (this._state = this._state | this.mouseButtons.middle), this._isDragging && (V.buttons & ri.RIGHT) === ri.RIGHT && (this._state = this._state | this.mouseButtons.right);
        I();
      }
    }, f = (V) => {
      const re = this._findPointerById(V.pointerId);
      if (!(re && re === this._lockedPointer)) {
        if (re && this._disposePointer(re), V.pointerType === "touch")
          switch (this._activePointers.length) {
            case 0:
              this._state = He.NONE;
              break;
            case 1:
              this._state = this.touches.one;
              break;
            case 2:
              this._state = this.touches.two;
              break;
            case 3:
              this._state = this.touches.three;
              break;
          }
        else
          this._state = He.NONE;
        j();
      }
    };
    let v = -1;
    const _ = (V) => {
      if (!this._domElement || !this._enabled || this.mouseButtons.wheel === He.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const _e = this._domElement.getBoundingClientRect(), Y = V.clientX / _e.width, Fe = V.clientY / _e.height;
        if (Y < this._interactiveArea.left || Y > this._interactiveArea.right || Fe < this._interactiveArea.top || Fe > this._interactiveArea.bottom)
          return;
      }
      if (V.preventDefault(), this.dollyToCursor || this.mouseButtons.wheel === He.ROTATE || this.mouseButtons.wheel === He.TRUCK) {
        const _e = performance.now();
        v - _e < 1e3 && this._getClientRect(this._elementRect), v = _e;
      }
      const re = Kje ? -1 : -3, R = V.deltaMode === 1 || V.ctrlKey ? V.deltaY / re : V.deltaY / (re * 10), J = this.dollyToCursor ? (V.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, ge = this.dollyToCursor ? (V.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case He.ROTATE: {
          this._rotateInternal(V.deltaX, V.deltaY), this._isUserControllingRotate = !0;
          break;
        }
        case He.TRUCK: {
          this._truckInternal(V.deltaX, V.deltaY, !1, !1), this._isUserControllingTruck = !0;
          break;
        }
        case He.SCREEN_PAN: {
          this._truckInternal(V.deltaX, V.deltaY, !1, !0), this._isUserControllingTruck = !0;
          break;
        }
        case He.OFFSET: {
          this._truckInternal(V.deltaX, V.deltaY, !0, !1), this._isUserControllingOffset = !0;
          break;
        }
        case He.DOLLY: {
          this._dollyInternal(-R, J, ge), this._isUserControllingDolly = !0;
          break;
        }
        case He.ZOOM: {
          this._zoomInternal(-R, J, ge), this._isUserControllingZoom = !0;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    }, E = (V) => {
      if (!(!this._domElement || !this._enabled)) {
        if (this.mouseButtons.right === yc.ACTION.NONE) {
          const re = V instanceof PointerEvent ? V.pointerId : 0, R = this._findPointerById(re);
          R && this._disposePointer(R), this._domElement.ownerDocument.removeEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", f);
          return;
        }
        V.preventDefault();
      }
    }, A = (V) => {
      if (!this._enabled)
        return;
      if (bV(this._activePointers, qo), this._getClientRect(this._elementRect), n.copy(qo), i.copy(qo), this._activePointers.length >= 2) {
        const R = qo.x - this._activePointers[1].clientX, J = qo.y - this._activePointers[1].clientY, ge = Math.sqrt(R * R + J * J);
        o.set(0, ge);
        const _e = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5, Y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        i.set(_e, Y);
      }
      if (this._state = 0, !V)
        this._lockedPointer && (this._state = this._state | this.mouseButtons.left);
      else if ("pointerType" in V && V.pointerType === "touch")
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      else
        !this._lockedPointer && (V.buttons & ri.LEFT) === ri.LEFT && (this._state = this._state | this.mouseButtons.left), (V.buttons & ri.MIDDLE) === ri.MIDDLE && (this._state = this._state | this.mouseButtons.middle), (V.buttons & ri.RIGHT) === ri.RIGHT && (this._state = this._state | this.mouseButtons.right);
      ((this._state & He.ROTATE) === He.ROTATE || (this._state & He.TOUCH_ROTATE) === He.TOUCH_ROTATE || (this._state & He.TOUCH_DOLLY_ROTATE) === He.TOUCH_DOLLY_ROTATE || (this._state & He.TOUCH_ZOOM_ROTATE) === He.TOUCH_ZOOM_ROTATE) && (this._sphericalEnd.theta = this._spherical.theta, this._sphericalEnd.phi = this._spherical.phi, this._thetaVelocity.value = 0, this._phiVelocity.value = 0), ((this._state & He.TRUCK) === He.TRUCK || (this._state & He.SCREEN_PAN) === He.SCREEN_PAN || (this._state & He.TOUCH_TRUCK) === He.TOUCH_TRUCK || (this._state & He.TOUCH_SCREEN_PAN) === He.TOUCH_SCREEN_PAN || (this._state & He.TOUCH_DOLLY_TRUCK) === He.TOUCH_DOLLY_TRUCK || (this._state & He.TOUCH_DOLLY_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN || (this._state & He.TOUCH_ZOOM_TRUCK) === He.TOUCH_ZOOM_TRUCK || (this._state & He.TOUCH_ZOOM_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN) && (this._targetEnd.copy(this._target), this._targetVelocity.set(0, 0, 0)), ((this._state & He.DOLLY) === He.DOLLY || (this._state & He.TOUCH_DOLLY) === He.TOUCH_DOLLY || (this._state & He.TOUCH_DOLLY_TRUCK) === He.TOUCH_DOLLY_TRUCK || (this._state & He.TOUCH_DOLLY_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN || (this._state & He.TOUCH_DOLLY_OFFSET) === He.TOUCH_DOLLY_OFFSET || (this._state & He.TOUCH_DOLLY_ROTATE) === He.TOUCH_DOLLY_ROTATE) && (this._sphericalEnd.radius = this._spherical.radius, this._radiusVelocity.value = 0), ((this._state & He.ZOOM) === He.ZOOM || (this._state & He.TOUCH_ZOOM) === He.TOUCH_ZOOM || (this._state & He.TOUCH_ZOOM_TRUCK) === He.TOUCH_ZOOM_TRUCK || (this._state & He.TOUCH_ZOOM_SCREEN_PAN) === He.TOUCH_ZOOM_SCREEN_PAN || (this._state & He.TOUCH_ZOOM_OFFSET) === He.TOUCH_ZOOM_OFFSET || (this._state & He.TOUCH_ZOOM_ROTATE) === He.TOUCH_ZOOM_ROTATE) && (this._zoomEnd = this._zoom, this._zoomVelocity.value = 0), ((this._state & He.OFFSET) === He.OFFSET || (this._state & He.TOUCH_OFFSET) === He.TOUCH_OFFSET || (this._state & He.TOUCH_DOLLY_OFFSET) === He.TOUCH_DOLLY_OFFSET || (this._state & He.TOUCH_ZOOM_OFFSET) === He.TOUCH_ZOOM_OFFSET) && (this._focalOffsetEnd.copy(this._focalOffset), this._focalOffsetVelocity.set(0, 0, 0)), this.dispatchEvent({ type: "controlstart" });
    }, I = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = !1, bV(this._activePointers, qo);
      const re = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement ? this._lockedPointer || this._activePointers[0] : null, R = re ? -re.deltaX : i.x - qo.x, J = re ? -re.deltaY : i.y - qo.y;
      if (i.copy(qo), ((this._state & He.ROTATE) === He.ROTATE || (this._state & He.TOUCH_ROTATE) === He.TOUCH_ROTATE || (this._state & He.TOUCH_DOLLY_ROTATE) === He.TOUCH_DOLLY_ROTATE || (this._state & He.TOUCH_ZOOM_ROTATE) === He.TOUCH_ZOOM_ROTATE) && (this._rotateInternal(R, J), this._isUserControllingRotate = !0), (this._state & He.DOLLY) === He.DOLLY || (this._state & He.ZOOM) === He.ZOOM) {
        const ge = this.dollyToCursor ? (n.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, _e = this.dollyToCursor ? (n.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0, Y = this.dollyDragInverted ? -1 : 1;
        (this._state & He.DOLLY) === He.DOLLY ? (this._dollyInternal(Y * J * rO, ge, _e), this._isUserControllingDolly = !0) : (this._zoomInternal(Y * J * rO, ge, _e), this._isUserControllingZoom = !0);
      }
      if ((this._state & He.TOUCH_DOLLY) === He.TOUCH_DOLLY || (this._state & He.TOUCH_ZOOM) === He.TOUCH_ZOOM || (this._state & He.TOUCH_DOLLY_TRUCK) === He.TOUCH_DOLLY_TRUCK || (this._state & He.TOUCH_ZOOM_TRUCK) === He.TOUCH_ZOOM_TRUCK || (this._state & He.TOUCH_DOLLY_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN || (this._state & He.TOUCH_ZOOM_SCREEN_PAN) === He.TOUCH_ZOOM_SCREEN_PAN || (this._state & He.TOUCH_DOLLY_OFFSET) === He.TOUCH_DOLLY_OFFSET || (this._state & He.TOUCH_ZOOM_OFFSET) === He.TOUCH_ZOOM_OFFSET || (this._state & He.TOUCH_DOLLY_ROTATE) === He.TOUCH_DOLLY_ROTATE || (this._state & He.TOUCH_ZOOM_ROTATE) === He.TOUCH_ZOOM_ROTATE) {
        const ge = qo.x - this._activePointers[1].clientX, _e = qo.y - this._activePointers[1].clientY, Y = Math.sqrt(ge * ge + _e * _e), Fe = o.y - Y;
        o.set(0, Y);
        const Me = this.dollyToCursor ? (i.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0, $ = this.dollyToCursor ? (i.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        (this._state & He.TOUCH_DOLLY) === He.TOUCH_DOLLY || (this._state & He.TOUCH_DOLLY_ROTATE) === He.TOUCH_DOLLY_ROTATE || (this._state & He.TOUCH_DOLLY_TRUCK) === He.TOUCH_DOLLY_TRUCK || (this._state & He.TOUCH_DOLLY_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN || (this._state & He.TOUCH_DOLLY_OFFSET) === He.TOUCH_DOLLY_OFFSET ? (this._dollyInternal(Fe * rO, Me, $), this._isUserControllingDolly = !0) : (this._zoomInternal(Fe * rO, Me, $), this._isUserControllingZoom = !0);
      }
      ((this._state & He.TRUCK) === He.TRUCK || (this._state & He.TOUCH_TRUCK) === He.TOUCH_TRUCK || (this._state & He.TOUCH_DOLLY_TRUCK) === He.TOUCH_DOLLY_TRUCK || (this._state & He.TOUCH_ZOOM_TRUCK) === He.TOUCH_ZOOM_TRUCK) && (this._truckInternal(R, J, !1, !1), this._isUserControllingTruck = !0), ((this._state & He.SCREEN_PAN) === He.SCREEN_PAN || (this._state & He.TOUCH_SCREEN_PAN) === He.TOUCH_SCREEN_PAN || (this._state & He.TOUCH_DOLLY_SCREEN_PAN) === He.TOUCH_DOLLY_SCREEN_PAN || (this._state & He.TOUCH_ZOOM_SCREEN_PAN) === He.TOUCH_ZOOM_SCREEN_PAN) && (this._truckInternal(R, J, !1, !0), this._isUserControllingTruck = !0), ((this._state & He.OFFSET) === He.OFFSET || (this._state & He.TOUCH_OFFSET) === He.TOUCH_OFFSET || (this._state & He.TOUCH_DOLLY_OFFSET) === He.TOUCH_DOLLY_OFFSET || (this._state & He.TOUCH_ZOOM_OFFSET) === He.TOUCH_ZOOM_OFFSET) && (this._truckInternal(R, J, !0, !1), this._isUserControllingOffset = !0), this.dispatchEvent({ type: "control" });
    }, j = () => {
      bV(this._activePointers, qo), i.copy(qo), this._dragNeedsUpdate = !1, (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) && (this._isDragging = !1), this._activePointers.length === 0 && this._domElement && (this._domElement.ownerDocument.removeEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", f), this.dispatchEvent({ type: "controlend" }));
    };
    this.lockPointer = () => {
      !this._enabled || !this._domElement || (this.cancel(), this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      }, this._activePointers.push(this._lockedPointer), this._domElement.ownerDocument.removeEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", f), this._domElement.requestPointerLock(), this._domElement.ownerDocument.addEventListener("pointerlockchange", q), this._domElement.ownerDocument.addEventListener("pointerlockerror", L), this._domElement.ownerDocument.addEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.addEventListener("pointerup", f), A());
    }, this.unlockPointer = () => {
      var V, re, R;
      this._lockedPointer !== null && (this._disposePointer(this._lockedPointer), this._lockedPointer = null), (V = this._domElement) === null || V === void 0 || V.ownerDocument.exitPointerLock(), (re = this._domElement) === null || re === void 0 || re.ownerDocument.removeEventListener("pointerlockchange", q), (R = this._domElement) === null || R === void 0 || R.ownerDocument.removeEventListener("pointerlockerror", L), this.cancel();
    };
    const q = () => {
      this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement || this.unlockPointer();
    }, L = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (V) => {
      this._domElement = V, this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none", this._domElement.addEventListener("pointerdown", l), this._domElement.addEventListener("pointercancel", f), this._domElement.addEventListener("wheel", _, { passive: !1 }), this._domElement.addEventListener("contextmenu", E);
    }, this._removeAllEventListeners = () => {
      this._domElement && (this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = "", this._domElement.removeEventListener("pointerdown", l), this._domElement.removeEventListener("pointercancel", f), this._domElement.removeEventListener("wheel", _, { passive: !1 }), this._domElement.removeEventListener("contextmenu", E), this._domElement.ownerDocument.removeEventListener("pointermove", p, { passive: !1 }), this._domElement.ownerDocument.removeEventListener("pointerup", f), this._domElement.ownerDocument.removeEventListener("pointerlockchange", q), this._domElement.ownerDocument.removeEventListener("pointerlockerror", L));
    }, this.cancel = () => {
      this._state !== He.NONE && (this._state = He.NONE, this._activePointers.length = 0, j());
    }, t && this.connect(t), this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.updateCameraUp(), this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this._domElement && (e ? (this._domElement.style.touchAction = "none", this._domElement.style.userSelect = "none", this._domElement.style.webkitUserSelect = "none") : (this.cancel(), this._domElement.style.touchAction = "", this._domElement.style.userSelect = "", this._domElement.style.webkitUserSelect = ""));
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(e) {
    this._spherical.radius === e && this._sphericalEnd.radius === e || (this._spherical.radius = e, this._sphericalEnd.radius = e, this._needsUpdate = !0);
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(e) {
    this._spherical.theta === e && this._sphericalEnd.theta === e || (this._spherical.theta = e, this._sphericalEnd.theta = e, this._needsUpdate = !0);
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(e) {
    this._spherical.phi === e && this._sphericalEnd.phi === e || (this._spherical.phi = e, this._sphericalEnd.phi = e, this._needsUpdate = !0);
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(e) {
    this._boundaryEnclosesCamera = e, this._needsUpdate = !0;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(e) {
    this._interactiveArea.width = su(e.width, 0, 1), this._interactiveArea.height = su(e.height, 0, 1), this._interactiveArea.x = su(e.x, 0, 1 - this._interactiveArea.width), this._interactiveArea.y = su(e.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(e, t) {
    super.addEventListener(e, t);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(e, t) {
    super.removeEventListener(e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(e, t, n = !1) {
    return this.rotateTo(this._sphericalEnd.theta + e, this._sphericalEnd.phi + t, n);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(e, t = !1) {
    return this.rotateTo(e, this._sphericalEnd.phi, t);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(e, t = !1) {
    return this.rotateTo(this._sphericalEnd.theta, e, t);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(e, t, n = !1) {
    this._isUserControllingRotate = !1;
    const i = su(e, this.minAzimuthAngle, this.maxAzimuthAngle), o = su(t, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = i, this._sphericalEnd.phi = o, this._sphericalEnd.makeSafe(), this._needsUpdate = !0, n || (this._spherical.theta = this._sphericalEnd.theta, this._spherical.phi = this._sphericalEnd.phi);
    const l = !n || lr(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lr(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(l);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(e, t = !1) {
    return this.dollyTo(this._sphericalEnd.radius - e, t);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(e, t = !1) {
    return this._isUserControllingDolly = !1, this._lastDollyDirection = gb.NONE, this._changedDolly = 0, this._dollyToNoClamp(su(e, this.minDistance, this.maxDistance), t);
  }
  _dollyToNoClamp(e, t = !1) {
    const n = this._sphericalEnd.radius;
    if (this.colliderMeshes.length >= 1) {
      const l = this._collisionTest(), p = lr(l, this._spherical.radius);
      if (!(n > e) && p)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(e, l);
    } else
      this._sphericalEnd.radius = e;
    this._needsUpdate = !0, t || (this._spherical.radius = this._sphericalEnd.radius);
    const o = !t || lr(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(e, t = !1) {
    this._targetEnd.add(this._getCameraDirection(Kw).multiplyScalar(e)), t || this._target.copy(this._targetEnd);
    const n = !t || lr(this._target.x, this._targetEnd.x, this.restThreshold) && lr(this._target.y, this._targetEnd.y, this.restThreshold) && lr(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(n);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(e, t = !1) {
    return this.zoomTo(this._zoomEnd + e, t);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(e, t = !1) {
    this._isUserControllingZoom = !1, this._zoomEnd = su(e, this.minZoom, this.maxZoom), this._needsUpdate = !0, t || (this._zoom = this._zoomEnd);
    const n = !t || lr(this._zoom, this._zoomEnd, this.restThreshold);
    return this._changedZoom = 0, this._createOnRestPromise(n);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(e, t, n = !1) {
    return console.warn("`pan` has been renamed to `truck`"), this.truck(e, t, n);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(e, t, n = !1) {
    this._camera.updateMatrix(), dc.setFromMatrixColumn(this._camera.matrix, 0), hc.setFromMatrixColumn(this._camera.matrix, 1), dc.multiplyScalar(e), hc.multiplyScalar(-t);
    const i = wn.copy(dc).add(hc), o = Zn.copy(this._targetEnd).add(i);
    return this.moveTo(o.x, o.y, o.z, n);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(e, t = !1) {
    wn.setFromMatrixColumn(this._camera.matrix, 0), wn.crossVectors(this._camera.up, wn), wn.multiplyScalar(e);
    const n = Zn.copy(this._targetEnd).add(wn);
    return this.moveTo(n.x, n.y, n.z, t);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(e, t = !1) {
    return wn.copy(this._camera.up).multiplyScalar(e), this.moveTo(this._targetEnd.x + wn.x, this._targetEnd.y + wn.y, this._targetEnd.z + wn.z, t);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(e, t, n, i = !1) {
    this._isUserControllingTruck = !1;
    const o = wn.set(e, t, n).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, o, this.boundaryFriction), this._needsUpdate = !0, i || this._target.copy(this._targetEnd);
    const l = !i || lr(this._target.x, this._targetEnd.x, this.restThreshold) && lr(this._target.y, this._targetEnd.y, this.restThreshold) && lr(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(l);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(e, t, n, i = !1) {
    const p = wn.set(e, t, n).sub(this._targetEnd).normalize().multiplyScalar(-this._sphericalEnd.radius).add(this._targetEnd);
    return this.setPosition(p.x, p.y, p.z, i);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(e, t, { cover: n = !1, paddingLeft: i = 0, paddingRight: o = 0, paddingBottom: l = 0, paddingTop: p = 0 } = {}) {
    const f = [], v = e.isBox3 ? bb.copy(e) : bb.setFromObject(e);
    v.isEmpty() && (console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting"), Promise.resolve());
    const _ = rge(this._sphericalEnd.theta, nge), E = rge(this._sphericalEnd.phi, nge);
    f.push(this.rotateTo(_, E, t));
    const A = wn.setFromSpherical(this._sphericalEnd).normalize(), I = uge.setFromUnitVectors(A, SV), j = lr(Math.abs(A.y), 1);
    j && I.multiply(EV.setFromAxisAngle(iO, _)), I.multiply(this._yAxisUpSpaceInverse);
    const q = lge.makeEmpty();
    Zn.copy(v.min).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.min).setX(v.max.x).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.min).setY(v.max.y).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.max).setZ(v.min.z).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.min).setZ(v.max.z).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.max).setY(v.min.y).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.max).setX(v.min.x).applyQuaternion(I), q.expandByPoint(Zn), Zn.copy(v.max).applyQuaternion(I), q.expandByPoint(Zn), q.min.x -= i, q.min.y -= l, q.max.x += o, q.max.y += p, I.setFromUnitVectors(SV, A), j && I.premultiply(EV.invert()), I.premultiply(this._yAxisUpSpace);
    const L = q.getSize(wn), V = q.getCenter(Zn).applyQuaternion(I);
    if (ag(this._camera)) {
      const re = this.getDistanceToFitBox(L.x, L.y, L.z, n);
      f.push(this.moveTo(V.x, V.y, V.z, t)), f.push(this.dollyTo(re, t)), f.push(this.setFocalOffset(0, 0, 0, t));
    } else if (Up(this._camera)) {
      const re = this._camera, R = re.right - re.left, J = re.top - re.bottom, ge = n ? Math.max(R / L.x, J / L.y) : Math.min(R / L.x, J / L.y);
      f.push(this.moveTo(V.x, V.y, V.z, t)), f.push(this.zoomTo(ge, t)), f.push(this.setFocalOffset(0, 0, 0, t));
    }
    return Promise.all(f);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(e, t) {
    const n = [], o = "isObject3D" in e ? yc.createBoundingSphere(e, wV) : wV.copy(e);
    if (n.push(this.moveTo(o.center.x, o.center.y, o.center.z, t)), ag(this._camera)) {
      const l = this.getDistanceToFitSphere(o.radius);
      n.push(this.dollyTo(l, t));
    } else if (Up(this._camera)) {
      const l = this._camera.right - this._camera.left, p = this._camera.top - this._camera.bottom, f = 2 * o.radius, v = Math.min(l / f, p / f);
      n.push(this.zoomTo(v, t));
    }
    return n.push(this.setFocalOffset(0, 0, 0, t)), Promise.all(n);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(e, t, n, i, o, l, p = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = gb.NONE, this._changedDolly = 0;
    const f = Zn.set(i, o, l), v = wn.set(e, t, n);
    this._targetEnd.copy(f), this._sphericalEnd.setFromVector3(v.sub(f).applyQuaternion(this._yAxisUpSpace)), this.normalizeRotations(), this._needsUpdate = !0, p || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const _ = !p || lr(this._target.x, this._targetEnd.x, this.restThreshold) && lr(this._target.y, this._targetEnd.y, this.restThreshold) && lr(this._target.z, this._targetEnd.z, this.restThreshold) && lr(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lr(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && lr(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(_);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(e, t, n, i, o, l, p, f, v, _, E, A, I, j = !1) {
    this._isUserControllingRotate = !1, this._isUserControllingDolly = !1, this._isUserControllingTruck = !1, this._lastDollyDirection = gb.NONE, this._changedDolly = 0;
    const q = wn.set(i, o, l), L = Zn.set(e, t, n);
    rl.setFromVector3(L.sub(q).applyQuaternion(this._yAxisUpSpace));
    const V = vb.set(_, E, A), re = Zn.set(p, f, v);
    Yw.setFromVector3(re.sub(V).applyQuaternion(this._yAxisUpSpace)), this._targetEnd.copy(q.lerp(V, I));
    const R = Yw.theta - rl.theta, J = Yw.phi - rl.phi, ge = Yw.radius - rl.radius;
    this._sphericalEnd.set(rl.radius + ge * I, rl.phi + J * I, rl.theta + R * I), this.normalizeRotations(), this._needsUpdate = !0, j || (this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd));
    const _e = !j || lr(this._target.x, this._targetEnd.x, this.restThreshold) && lr(this._target.y, this._targetEnd.y, this.restThreshold) && lr(this._target.z, this._targetEnd.z, this.restThreshold) && lr(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && lr(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && lr(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(_e);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(e, t, n, i = !1) {
    return this.setLookAt(e, t, n, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, i);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(e, t, n, i = !1) {
    const o = this.getPosition(wn), l = this.setLookAt(o.x, o.y, o.z, e, t, n, i);
    return this._sphericalEnd.phi = su(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle), l;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(e, t, n, i = !1) {
    this._isUserControllingOffset = !1, this._focalOffsetEnd.set(e, t, n), this._needsUpdate = !0, i || this._focalOffset.copy(this._focalOffsetEnd);
    const o = !i || lr(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && lr(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && lr(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(o);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(e, t, n) {
    this._camera.updateMatrixWorld(), dc.setFromMatrixColumn(this._camera.matrixWorldInverse, 0), hc.setFromMatrixColumn(this._camera.matrixWorldInverse, 1), lg.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const i = wn.set(e, t, n), o = i.distanceTo(this._camera.position), l = i.sub(this._camera.position);
    dc.multiplyScalar(l.x), hc.multiplyScalar(l.y), lg.multiplyScalar(l.z), wn.copy(dc).add(hc).add(lg), wn.z = wn.z + o, this.dollyTo(o, !1), this.setFocalOffset(-wn.x, wn.y, -wn.z, !1), this.moveTo(e, t, n, !1);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(e) {
    if (!e) {
      this._boundary.min.set(-1 / 0, -1 / 0, -1 / 0), this._boundary.max.set(1 / 0, 1 / 0, 1 / 0), this._needsUpdate = !0;
      return;
    }
    this._boundary.copy(e), this._boundary.clampPoint(this._targetEnd, this._targetEnd), this._needsUpdate = !0;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(e, t, n, i) {
    if (e === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new cn.Vector4(), typeof e == "number" ? this._viewport.set(e, t, n, i) : this._viewport.copy(e);
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(e, t, n, i = !1) {
    if (xV(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const o = e / t, l = this._camera.getEffectiveFOV() * Hw, p = this._camera.aspect;
    return ((i ? o > p : o < p) ? t : e / p) * 0.5 / Math.tan(l * 0.5) + n * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(e) {
    if (xV(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const t = this._camera.getEffectiveFOV() * Hw, n = Math.atan(Math.tan(t * 0.5) * this._camera.aspect) * 2, i = 1 < this._camera.aspect ? t : n;
    return e / Math.sin(i * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(e, t = !0) {
    return (e && e.isVector3 ? e : new cn.Vector3()).copy(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(e, t = !0) {
    return (e && e.isVector3 ? e : new cn.Vector3()).setFromSpherical(t ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(t ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(e, t = !0) {
    return (e || new cn.Spherical()).copy(t ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(e, t = !0) {
    return (e && e.isVector3 ? e : new cn.Vector3()).copy(t ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % yb, this._sphericalEnd.theta < 0 && (this._sphericalEnd.theta += yb), this._spherical.theta += yb * Math.round((this._sphericalEnd.theta - this._spherical.theta) / yb);
  }
  /**
   * stop all transitions.
   */
  stop() {
    this._focalOffset.copy(this._focalOffsetEnd), this._target.copy(this._targetEnd), this._spherical.copy(this._sphericalEnd), this._zoom = this._zoomEnd;
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(e = !1) {
    if (!lr(this._camera.up.x, this._cameraUp0.x) || !lr(this._camera.up.y, this._cameraUp0.y) || !lr(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const n = this.getPosition(wn);
      this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
    }
    const t = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, e),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, e),
      this.zoomTo(this._zoom0, e)
    ];
    return Promise.all(t);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up), this.getTarget(this._target0), this.getPosition(this._position0), this._zoom0 = this._zoom, this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, iO), this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const e = wn.subVectors(this._target, this._camera.position).normalize(), t = Zn.crossVectors(e, this._camera.up);
    this._camera.up.crossVectors(t, e).normalize(), this._camera.updateMatrixWorld();
    const n = this.getPosition(wn);
    this.updateCameraUp(), this.setPosition(n.x, n.y, n.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(e) {
    const t = this._sphericalEnd.theta - this._spherical.theta, n = this._sphericalEnd.phi - this._spherical.phi, i = this._sphericalEnd.radius - this._spherical.radius, o = oge.subVectors(this._targetEnd, this._target), l = age.subVectors(this._focalOffsetEnd, this._focalOffset), p = this._zoomEnd - this._zoom;
    if (Rr(t))
      this._thetaVelocity.value = 0, this._spherical.theta = this._sphericalEnd.theta;
    else {
      const E = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = nO(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, E, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Rr(n))
      this._phiVelocity.value = 0, this._spherical.phi = this._sphericalEnd.phi;
    else {
      const E = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = nO(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, E, 1 / 0, e), this._needsUpdate = !0;
    }
    if (Rr(i))
      this._radiusVelocity.value = 0, this._spherical.radius = this._sphericalEnd.radius;
    else {
      const E = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = nO(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, E, this.maxSpeed, e), this._needsUpdate = !0;
    }
    if (Rr(o.x) && Rr(o.y) && Rr(o.z))
      this._targetVelocity.set(0, 0, 0), this._target.copy(this._targetEnd);
    else {
      const E = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      ige(this._target, this._targetEnd, this._targetVelocity, E, this.maxSpeed, e, this._target), this._needsUpdate = !0;
    }
    if (Rr(l.x) && Rr(l.y) && Rr(l.z))
      this._focalOffsetVelocity.set(0, 0, 0), this._focalOffset.copy(this._focalOffsetEnd);
    else {
      const E = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      ige(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, E, this.maxSpeed, e, this._focalOffset), this._needsUpdate = !0;
    }
    if (Rr(p))
      this._zoomVelocity.value = 0, this._zoom = this._zoomEnd;
    else {
      const E = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = nO(this._zoom, this._zoomEnd, this._zoomVelocity, E, 1 / 0, e);
    }
    if (this.dollyToCursor) {
      if (ag(this._camera) && this._changedDolly !== 0) {
        const E = this._spherical.radius - this._lastDistance, A = this._camera, I = this._getCameraDirection(Kw), j = wn.copy(I).cross(A.up).normalize();
        j.lengthSq() === 0 && (j.x = 1);
        const q = Zn.crossVectors(j, I), L = this._sphericalEnd.radius * Math.tan(A.getEffectiveFOV() * Hw * 0.5), re = (this._sphericalEnd.radius - E - this._sphericalEnd.radius) / this._sphericalEnd.radius, R = vb.copy(this._targetEnd).add(j.multiplyScalar(this._dollyControlCoord.x * L * A.aspect)).add(q.multiplyScalar(this._dollyControlCoord.y * L)), J = wn.copy(this._targetEnd).lerp(R, re), ge = this._lastDollyDirection === gb.IN && this._spherical.radius <= this.minDistance, _e = this._lastDollyDirection === gb.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (ge || _e)) {
          this._sphericalEnd.radius -= E, this._spherical.radius -= E;
          const Fe = Zn.copy(I).multiplyScalar(-E);
          J.add(Fe);
        }
        this._boundary.clampPoint(J, J);
        const Y = Zn.subVectors(J, this._targetEnd);
        this._targetEnd.copy(J), this._target.add(Y), this._changedDolly -= E, Rr(this._changedDolly) && (this._changedDolly = 0);
      } else if (Up(this._camera) && this._changedZoom !== 0) {
        const E = this._zoom - this._lastZoom, A = this._camera, I = wn.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (A.near + A.far) / (A.near - A.far)).unproject(A), j = Zn.set(0, 0, -1).applyQuaternion(A.quaternion), q = vb.copy(I).add(j.multiplyScalar(-I.dot(A.up))), V = -(this._zoom - E - this._zoom) / this._zoom, re = this._getCameraDirection(Kw), R = this._targetEnd.dot(re), J = wn.copy(this._targetEnd).lerp(q, V), ge = J.dot(re), _e = re.multiplyScalar(ge - R);
        J.sub(_e), this._boundary.clampPoint(J, J);
        const Y = Zn.subVectors(J, this._targetEnd);
        this._targetEnd.copy(J), this._target.add(Y), this._changedZoom -= E, Rr(this._changedZoom) && (this._changedZoom = 0);
      }
    }
    this._camera.zoom !== this._zoom && (this._camera.zoom = this._zoom, this._camera.updateProjectionMatrix(), this._updateNearPlaneCorners(), this._needsUpdate = !0), this._dragNeedsUpdate = !0;
    const f = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, f), this._spherical.makeSafe(), this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target), this._camera.lookAt(this._target), (!Rr(this._focalOffset.x) || !Rr(this._focalOffset.y) || !Rr(this._focalOffset.z)) && (dc.setFromMatrixColumn(this._camera.matrix, 0), hc.setFromMatrixColumn(this._camera.matrix, 1), lg.setFromMatrixColumn(this._camera.matrix, 2), dc.multiplyScalar(this._focalOffset.x), hc.multiplyScalar(-this._focalOffset.y), lg.multiplyScalar(this._focalOffset.z), wn.copy(dc).add(hc).add(lg), this._camera.position.add(wn), this._camera.updateMatrixWorld()), this._boundaryEnclosesCamera && this._encloseToBoundary(this._camera.position.copy(this._target), wn.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    const _ = this._needsUpdate;
    return _ && !this._updatedLastTime ? (this._hasRested = !1, this.dispatchEvent({ type: "wake" }), this.dispatchEvent({ type: "update" })) : _ ? (this.dispatchEvent({ type: "update" }), Rr(t, this.restThreshold) && Rr(n, this.restThreshold) && Rr(i, this.restThreshold) && Rr(o.x, this.restThreshold) && Rr(o.y, this.restThreshold) && Rr(o.z, this.restThreshold) && Rr(l.x, this.restThreshold) && Rr(l.y, this.restThreshold) && Rr(l.z, this.restThreshold) && Rr(p, this.restThreshold) && !this._hasRested && (this._hasRested = !0, this.dispatchEvent({ type: "rest" }))) : !_ && this._updatedLastTime && this.dispatchEvent({ type: "sleep" }), this._lastDistance = this._spherical.radius, this._lastZoom = this._zoom, this._updatedLastTime = _, this._needsUpdate = !1, _;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: $w(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: $w(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: $w(this.maxPolarAngle),
      minAzimuthAngle: $w(this.minAzimuthAngle),
      maxAzimuthAngle: $w(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      target: this._targetEnd.toArray(),
      position: wn.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(e, t = !1) {
    const n = JSON.parse(e);
    this.enabled = n.enabled, this.minDistance = n.minDistance, this.maxDistance = Ww(n.maxDistance), this.minZoom = n.minZoom, this.maxZoom = Ww(n.maxZoom), this.minPolarAngle = n.minPolarAngle, this.maxPolarAngle = Ww(n.maxPolarAngle), this.minAzimuthAngle = Ww(n.minAzimuthAngle), this.maxAzimuthAngle = Ww(n.maxAzimuthAngle), this.smoothTime = n.smoothTime, this.draggingSmoothTime = n.draggingSmoothTime, this.dollySpeed = n.dollySpeed, this.truckSpeed = n.truckSpeed, this.dollyToCursor = n.dollyToCursor, this._target0.fromArray(n.target0), this._position0.fromArray(n.position0), this._zoom0 = n.zoom0, this._focalOffset0.fromArray(n.focalOffset0), this.moveTo(n.target[0], n.target[1], n.target[2], t), rl.setFromVector3(wn.fromArray(n.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace)), this.rotateTo(rl.theta, rl.phi, t), this.dollyTo(rl.radius, t), this.zoomTo(n.zoom, t), this.setFocalOffset(n.focalOffset[0], n.focalOffset[1], n.focalOffset[2], t), this._needsUpdate = !0;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(e) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    e.setAttribute("data-camera-controls-version", Wje), this._addAllEventListeners(e), this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel(), this._removeAllEventListeners(), this._domElement && (this._domElement.removeAttribute("data-camera-controls-version"), this._domElement = void 0);
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners(), this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(e) {
    return e.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(e) {
    return this._getTargetDirection(e).negate();
  }
  _findPointerById(e) {
    return this._activePointers.find((t) => t.pointerId === e);
  }
  _findPointerByMouseButton(e) {
    return this._activePointers.find((t) => t.mouseButton === e);
  }
  _disposePointer(e) {
    this._activePointers.splice(this._activePointers.indexOf(e), 1);
  }
  _encloseToBoundary(e, t, n) {
    const i = t.lengthSq();
    if (i === 0)
      return e;
    const o = Zn.copy(t).add(e), p = this._boundary.clampPoint(o, vb).sub(o), f = p.lengthSq();
    if (f === 0)
      return e.add(t);
    if (f === i)
      return e;
    if (n === 0)
      return e.add(t).add(p);
    {
      const v = 1 + n * f / t.dot(p);
      return e.add(Zn.copy(t).multiplyScalar(v)).add(p.multiplyScalar(1 - n));
    }
  }
  _updateNearPlaneCorners() {
    if (ag(this._camera)) {
      const e = this._camera, t = e.near, n = e.getEffectiveFOV() * Hw, i = Math.tan(n * 0.5) * t, o = i * e.aspect;
      this._nearPlaneCorners[0].set(-o, -i, 0), this._nearPlaneCorners[1].set(o, -i, 0), this._nearPlaneCorners[2].set(o, i, 0), this._nearPlaneCorners[3].set(-o, i, 0);
    } else if (Up(this._camera)) {
      const e = this._camera, t = 1 / e.zoom, n = e.left * t, i = e.right * t, o = e.top * t, l = e.bottom * t;
      this._nearPlaneCorners[0].set(n, o, 0), this._nearPlaneCorners[1].set(i, o, 0), this._nearPlaneCorners[2].set(i, l, 0), this._nearPlaneCorners[3].set(n, l, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let e = 1 / 0;
    if (!(this.colliderMeshes.length >= 1) || xV(this._camera, "_collisionTest"))
      return e;
    const n = this._getTargetDirection(Kw);
    TV.lookAt(sge, n, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const o = Zn.copy(this._nearPlaneCorners[i]);
      o.applyMatrix4(TV);
      const l = vb.addVectors(this._target, o);
      sO.set(l, n), sO.far = this._spherical.radius + 1;
      const p = sO.intersectObjects(this.colliderMeshes);
      p.length !== 0 && p[0].distance < e && (e = p[0].distance);
    }
    return e;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(e) {
    if (!this._domElement)
      return;
    const t = this._domElement.getBoundingClientRect();
    return e.x = t.left, e.y = t.top, this._viewport ? (e.x += this._viewport.x, e.y += t.height - this._viewport.w - this._viewport.y, e.width = this._viewport.z, e.height = this._viewport.w) : (e.width = t.width, e.height = t.height), e;
  }
  _createOnRestPromise(e) {
    return e ? Promise.resolve() : (this._hasRested = !1, this.dispatchEvent({ type: "transitionstart" }), new Promise((t) => {
      const n = () => {
        this.removeEventListener("rest", n), t();
      };
      this.addEventListener("rest", n);
    }));
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(e) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    return console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(e) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    return console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead."), 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(e) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(e, t = new cn.Sphere()) {
    const n = t, i = n.center;
    bb.makeEmpty(), e.traverseVisible((l) => {
      l.isMesh && bb.expandByObject(l);
    }), bb.getCenter(i);
    let o = 0;
    return e.traverseVisible((l) => {
      if (!l.isMesh)
        return;
      const p = l;
      if (!p.geometry)
        return;
      const f = p.geometry.clone();
      f.applyMatrix4(p.matrixWorld);
      const _ = f.attributes.position;
      for (let E = 0, A = _.count; E < A; E++)
        wn.fromBufferAttribute(_, E), o = Math.max(o, i.distanceToSquared(wn));
    }), n.radius = Math.sqrt(o), n;
  }
}
const HO = (c) => {
  const [e, t] = nr(c.options[c.index]), n = () => {
    c.onToggle(!c.open);
  }, i = (l) => {
    l !== e && (c.onSelect(l), t(l)), c.onToggle(!1);
  }, o = c.open ? `${c.options.length * 31 - 1}px` : "0px";
  return /* @__PURE__ */ ke.jsxs("div", { className: `dropdown ${c.up === !0 ? "up" : ""}`, children: [
    /* @__PURE__ */ ke.jsx("div", { className: "dropdown-toggle", onClick: n, children: `${c.title}: ${e}` }),
    /* @__PURE__ */ ke.jsx("ul", { className: "dropdown-menu", style: { height: o }, children: c.options.map((l) => /* @__PURE__ */ ke.jsx("li", { onClick: () => i(l), children: l }, l)) })
  ] });
}, ug = TAe(function(e, t) {
  const n = [
    "Renderer",
    "Depth",
    "Normals",
    "UVs",
    "Wireframe"
  ], [i, o] = nr("Renderer"), [l, p] = nr(!1), [f, v] = nr(!1), [_, E] = nr(!1);
  return /* @__PURE__ */ ke.jsxs("div", { className: `CameraWindow ${e.name}`, children: [
    /* @__PURE__ */ ke.jsx("div", { ref: t, className: "clickable", onClick: () => {
      _ && E(!1);
    } }),
    /* @__PURE__ */ ke.jsxs("div", { className: "options", children: [
      e.camera !== null && /* @__PURE__ */ ke.jsx(
        HO,
        {
          title: "Camera",
          index: e.options.indexOf(e.camera.name),
          open: _,
          options: e.options,
          onSelect: e.onSelectCamera,
          onToggle: (A) => {
            A && f && v(!1), E(A);
          },
          up: !0
        }
      ),
      /* @__PURE__ */ ke.jsx(
        HO,
        {
          title: "Mode",
          index: n.indexOf(i),
          open: f,
          options: n,
          onSelect: (A) => {
            if (A === i) return;
            const I = A;
            e.onSelectRenderMode(I), o(I);
          },
          onToggle: (A) => {
            A && _ && E(!1), l && p(!1), v(A);
          },
          up: !0
        }
      )
    ] })
  ] });
}), Yje = `out vec3 worldPosition;
uniform float uDistance;

void main() {
  // Scale the plane by the drawing distance
  worldPosition = position.xzy * uDistance;
  worldPosition.xz += cameraPosition.xz;

  gl_Position = projectionMatrix * modelViewMatrix * vec4(worldPosition, 1.0);
}`, Xje = `out vec4 fragColor;
in vec3 worldPosition;
uniform float uDivisions;
uniform float uScale;
uniform vec3 uColor;
uniform float uDistance;
uniform float uGridOpacity;
uniform float uSubgridOpacity;

#define minAlpha 0.00784313725490196

float getGrid(float gapSize) {
  vec2 worldPositionByDivision = worldPosition.xz / gapSize;

  // Inverted, 0 where line, >1 where there's no line
  // We use the worldPosition (which in this case we use similarly to UVs) differential to control the anti-aliasing
  // We need to do the -0.5)-0.5 trick because the result fades out from 0 to 1, and we want both
  // worldPositionByDivision == 0.3 and worldPositionByDivision == 0.7 to result in the same fade, i.e. 0.3,
  // otherwise only one side of the line will be anti-aliased
  vec2 grid = abs(fract(worldPositionByDivision-0.5)-0.5) / fwidth(worldPositionByDivision) / 2.0;
  float gridLine = min(grid.x, grid.y);

  // Uninvert and clamp
  return 1.0 - min(gridLine, 1.0);
}

void main() {
  float cameraDistanceToGridPlane = max(200.0, distance(cameraPosition.y, worldPosition.y));
  float cameraDistanceToFragmentOnGridPlane = distance(cameraPosition.xyz, worldPosition.xyz);

  // The size of the grid and subgrid are powers of each other and they are determined based on camera distance.
  // The current grid will become the next subgrid when it becomes too small, and its next power becomes the new grid.
  float subGridPower = pow(uDivisions, floor(log(cameraDistanceToGridPlane) / log(uDivisions)));
  float gridPower = subGridPower * uDivisions;

  // If we want to fade both the grid and its subgrid, we need to displays 3 different opacities, with the next grid being the third
  float nextGridPower = gridPower * uDivisions;

  // 1 where grid, 0 where no grid
  float subgrid = getGrid(subGridPower * uScale);
  float grid = getGrid(gridPower * uScale);
  float nextGrid = getGrid(nextGridPower * uScale);

  // Where we are between the introduction of the current grid power and when we switch to the next grid power
  float stepPercentage = (cameraDistanceToGridPlane - subGridPower)/(gridPower - subGridPower);

  // The last x percentage of the current step over which we want to fade
  float fadeRange = 0.3;

  // We calculate the fade percentage from the step percentage and the fade range
  float fadePercentage = max(stepPercentage - 1.0 + fadeRange, 0.0) / fadeRange;

  // Set base opacity based on how close we are to the drawing distance, with a cubic falloff
  float baseOpacity = subgrid * pow(1.0 - min(cameraDistanceToFragmentOnGridPlane / uDistance, 1.0), 3.0);

  // Shade the subgrid
  fragColor = vec4(uColor.rgb, (baseOpacity - fadePercentage) * uSubgridOpacity);

  // Somewhat arbitrary additional fade coefficient to counter anti-aliasing popping when switching between grid powers
  float fadeCoefficient = 0.5;

  // Shade the grid
  fragColor.a = mix(fragColor.a, baseOpacity * uGridOpacity - fadePercentage * (uGridOpacity - uSubgridOpacity) * fadeCoefficient, grid);

  // Shade the next grid
  fragColor.a = mix(fragColor.a, baseOpacity * uGridOpacity, nextGrid);

  if (fragColor.a <= minAlpha) discard;
}`;
class Qje extends Fge {
  constructor(e) {
    super({
      extensions: {
        // @ts-ignore
        derivatives: !0
      },
      uniforms: {
        uScale: {
          value: e?.scale !== void 0 ? e?.scale : 0.1
        },
        uDivisions: {
          value: e?.divisions !== void 0 ? e?.divisions : 10
        },
        uColor: {
          value: e?.color !== void 0 ? e?.color : new Ag(16777215)
        },
        uDistance: {
          value: e?.distance !== void 0 ? e?.distance : 1e4
        },
        uSubgridOpacity: {
          value: e?.subgridOpacity !== void 0 ? e?.subgridOpacity : 0.15
        },
        uGridOpacity: {
          value: e?.gridOpacity !== void 0 ? e?.gridOpacity : 0.25
        }
      },
      glslVersion: GAe,
      side: S6,
      transparent: !0,
      name: "InfiniteGrid",
      vertexShader: Yje,
      fragmentShader: Xje,
      depthTest: !1
    });
  }
}
class Zje extends Dt {
  gridMaterial;
  constructor(e) {
    const t = new Qje(e);
    super(new Bge(), t), this.gridMaterial = t, this.frustumCulled = !1, this.name = "InfiniteGridHelper";
  }
  update() {
    this.gridMaterial.needsUpdate = !0;
  }
}
function CV(c) {
  const [e, t] = nr(c.selected), n = "toggle" + (e ? " selected" : "");
  return /* @__PURE__ */ ke.jsx(
    "button",
    {
      className: n,
      onClick: () => {
        const i = !e;
        t(i), c.onClick(i);
      },
      style: {
        backgroundImage: `url(${c.icon})`,
        backgroundPositionX: "center",
        backgroundPositionY: c.top !== void 0 ? `${c.top}px` : "center",
        backgroundSize: `${c.width !== void 0 ? `${c.width}px` : "26px"} ${c.height}px`
      }
    },
    c.name
  );
}
const Jje = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {
  #include <uv_vertex>
  #include <color_vertex>
  #include <morphcolor_vertex>
  #include <batching_vertex>

  #if defined ( USE_SKINNING )
    #include <beginnormal_vertex>
    #include <morphnormal_vertex>
    #include <skinbase_vertex>
    #include <skinnormal_vertex>
    #include <defaultnormal_vertex>
  #endif

  #include <begin_vertex>
  #include <morphtarget_vertex>
  #include <skinning_vertex>
  #include <project_vertex>
  #include <logdepthbuf_vertex>
  #include <clipping_planes_vertex>
  #include <worldpos_vertex>
}`, eUe = `
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <clipping_planes_pars_fragment>

void main() {
  #include <clipping_planes_fragment>
  if (opacity < 0.015) discard;
  gl_FragColor = vec4(vec3(vUv, 0.0), opacity);
}`;
class tUe extends Fge {
  constructor() {
    super({
      defines: {
        USE_UV: ""
      },
      uniforms: {
        opacity: { value: 1 }
      },
      vertexShader: Jje,
      fragmentShader: eUe,
      transparent: !0
    });
  }
}
const cg = new _E(), Xs = new Vt(), jp = new Vt(), Kr = new xa(), cge = {
  X: new Vt(1, 0, 0),
  Y: new Vt(0, 1, 0),
  Z: new Vt(0, 0, 1)
}, PV = { type: "change" }, dge = { type: "mouseDown", mode: null }, hge = { type: "mouseUp", mode: null }, pge = { type: "objectChange" };
class nUe extends Dge {
  /**
   * Constructs a new controls instance.
   *
   * @param {Camera} camera - The camera of the rendered scene.
   * @param {?HTMLDOMElement} domElement - The HTML element used for event listeners.
   */
  constructor(e, t = null) {
    super(void 0, t);
    const n = new lUe(this);
    this._root = n;
    const i = new uUe();
    this._gizmo = i, n.add(i);
    const o = new cUe();
    this._plane = o, n.add(o);
    const l = this;
    function p(R, J) {
      let ge = J;
      Object.defineProperty(l, R, {
        get: function() {
          return ge !== void 0 ? ge : J;
        },
        set: function(_e) {
          ge !== _e && (ge = _e, o[R] = _e, i[R] = _e, l.dispatchEvent({ type: R + "-changed", value: _e }), l.dispatchEvent(PV));
        }
      }), l[R] = J, o[R] = J, i[R] = J;
    }
    p("camera", e), p("object", void 0), p("enabled", !0), p("axis", null), p("mode", "translate"), p("translationSnap", null), p("rotationSnap", null), p("scaleSnap", null), p("space", "world"), p("size", 1), p("dragging", !1), p("showX", !0), p("showY", !0), p("showZ", !0), p("minX", -1 / 0), p("maxX", 1 / 0), p("minY", -1 / 0), p("maxY", 1 / 0), p("minZ", -1 / 0), p("maxZ", 1 / 0);
    const f = new Vt(), v = new Vt(), _ = new xa(), E = new xa(), A = new Vt(), I = new xa(), j = new Vt(), q = new Vt(), L = new Vt(), V = 0, re = new Vt();
    p("worldPosition", f), p("worldPositionStart", v), p("worldQuaternion", _), p("worldQuaternionStart", E), p("cameraPosition", A), p("cameraQuaternion", I), p("pointStart", j), p("pointEnd", q), p("rotationAxis", L), p("rotationAngle", V), p("eye", re), this._offset = new Vt(), this._startNorm = new Vt(), this._endNorm = new Vt(), this._cameraScale = new Vt(), this._parentPosition = new Vt(), this._parentQuaternion = new xa(), this._parentQuaternionInv = new xa(), this._parentScale = new Vt(), this._worldScaleStart = new Vt(), this._worldQuaternionInv = new xa(), this._worldScale = new Vt(), this._positionStart = new Vt(), this._quaternionStart = new xa(), this._scaleStart = new Vt(), this._getPointer = rUe.bind(this), this._onPointerDown = sUe.bind(this), this._onPointerHover = iUe.bind(this), this._onPointerMove = oUe.bind(this), this._onPointerUp = aUe.bind(this), t !== null && this.connect(t);
  }
  connect(e) {
    super.connect(e), this.domElement.addEventListener("pointerdown", this._onPointerDown), this.domElement.addEventListener("pointermove", this._onPointerHover), this.domElement.addEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "none";
  }
  disconnect() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown), this.domElement.removeEventListener("pointermove", this._onPointerHover), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.domElement.removeEventListener("pointerup", this._onPointerUp), this.domElement.style.touchAction = "auto";
  }
  /**
   * Returns the visual representation of the controls. Add the helper to your scene to
   * visually transform the attached  3D object.
   *
   * @return {TransformControlsRoot} The helper.
   */
  getHelper() {
    return this._root;
  }
  pointerHover(e) {
    if (this.object === void 0 || this.dragging === !0) return;
    e !== null && cg.setFromCamera(e, this.camera);
    const t = AV(this._gizmo.picker[this.mode], cg);
    t ? this.axis = t.object.name : this.axis = null;
  }
  pointerDown(e) {
    if (!(this.object === void 0 || this.dragging === !0 || e != null && e.button !== 0) && this.axis !== null) {
      e !== null && cg.setFromCamera(e, this.camera);
      const t = AV(this._plane, cg, !0);
      t && (this.object.updateMatrixWorld(), this.object.parent.updateMatrixWorld(), this._positionStart.copy(this.object.position), this._quaternionStart.copy(this.object.quaternion), this._scaleStart.copy(this.object.scale), this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart), this.pointStart.copy(t.point).sub(this.worldPositionStart)), this.dragging = !0, dge.mode = this.mode, this.dispatchEvent(dge);
    }
  }
  pointerMove(e) {
    const t = this.axis, n = this.mode, i = this.object;
    let o = this.space;
    if (n === "scale" ? o = "local" : (t === "E" || t === "XYZE" || t === "XYZ") && (o = "world"), i === void 0 || t === null || this.dragging === !1 || e !== null && e.button !== -1) return;
    e !== null && cg.setFromCamera(e, this.camera);
    const l = AV(this._plane, cg, !0);
    if (l) {
      if (this.pointEnd.copy(l.point).sub(this.worldPositionStart), n === "translate")
        this._offset.copy(this.pointEnd).sub(this.pointStart), o === "local" && t !== "XYZ" && this._offset.applyQuaternion(this._worldQuaternionInv), t.indexOf("X") === -1 && (this._offset.x = 0), t.indexOf("Y") === -1 && (this._offset.y = 0), t.indexOf("Z") === -1 && (this._offset.z = 0), o === "local" && t !== "XYZ" ? this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale) : this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale), i.position.copy(this._offset).add(this._positionStart), this.translationSnap && (o === "local" && (i.position.applyQuaternion(Kr.copy(this._quaternionStart).invert()), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.position.applyQuaternion(this._quaternionStart)), o === "world" && (i.parent && i.position.add(Xs.setFromMatrixPosition(i.parent.matrixWorld)), t.search("X") !== -1 && (i.position.x = Math.round(i.position.x / this.translationSnap) * this.translationSnap), t.search("Y") !== -1 && (i.position.y = Math.round(i.position.y / this.translationSnap) * this.translationSnap), t.search("Z") !== -1 && (i.position.z = Math.round(i.position.z / this.translationSnap) * this.translationSnap), i.parent && i.position.sub(Xs.setFromMatrixPosition(i.parent.matrixWorld)))), i.position.x = Math.max(this.minX, Math.min(this.maxX, i.position.x)), i.position.y = Math.max(this.minY, Math.min(this.maxY, i.position.y)), i.position.z = Math.max(this.minZ, Math.min(this.maxZ, i.position.z));
      else if (n === "scale") {
        if (t.search("XYZ") !== -1) {
          let p = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (p *= -1), jp.set(p, p, p);
        } else
          Xs.copy(this.pointStart), jp.copy(this.pointEnd), Xs.applyQuaternion(this._worldQuaternionInv), jp.applyQuaternion(this._worldQuaternionInv), jp.divide(Xs), t.search("X") === -1 && (jp.x = 1), t.search("Y") === -1 && (jp.y = 1), t.search("Z") === -1 && (jp.z = 1);
        i.scale.copy(this._scaleStart).multiply(jp), this.scaleSnap && (t.search("X") !== -1 && (i.scale.x = Math.round(i.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Y") !== -1 && (i.scale.y = Math.round(i.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap), t.search("Z") !== -1 && (i.scale.z = Math.round(i.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap));
      } else if (n === "rotate") {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const p = 20 / this.worldPosition.distanceTo(Xs.setFromMatrixPosition(this.camera.matrixWorld));
        let f = !1;
        t === "XYZE" ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(), this.rotationAngle = this._offset.dot(Xs.copy(this.rotationAxis).cross(this.eye)) * p) : (t === "X" || t === "Y" || t === "Z") && (this.rotationAxis.copy(cge[t]), Xs.copy(cge[t]), o === "local" && Xs.applyQuaternion(this.worldQuaternion), Xs.cross(this.eye), Xs.length() === 0 ? f = !0 : this.rotationAngle = this._offset.dot(Xs.normalize()) * p), (t === "E" || f) && (this.rotationAxis.copy(this.eye), this.rotationAngle = this.pointEnd.angleTo(this.pointStart), this._startNorm.copy(this.pointStart).normalize(), this._endNorm.copy(this.pointEnd).normalize(), this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1), this.rotationSnap && (this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap), o === "local" && t !== "E" && t !== "XYZE" ? (i.quaternion.copy(this._quaternionStart), i.quaternion.multiply(Kr.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize()) : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv), i.quaternion.copy(Kr.setFromAxisAngle(this.rotationAxis, this.rotationAngle)), i.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(PV), this.dispatchEvent(pge);
    }
  }
  pointerUp(e) {
    e !== null && e.button !== 0 || (this.dragging && this.axis !== null && (hge.mode = this.mode, this.dispatchEvent(hge)), this.dragging = !1, this.axis = null);
  }
  dispose() {
    this.disconnect(), this._root.dispose();
  }
  /**
   * Sets the 3D object that should be transformed and ensures the controls UI is visible.
   *
   * @param {Object3D} object -  The 3D object that should be transformed.
   * @return {TransformControls} A reference to this controls.
   */
  attach(e) {
    return this.object = e, this._root.visible = !0, this;
  }
  /**
   * Removes the current 3D object from the controls and makes the helper UI invisible.
   *
   * @return {TransformControls} A reference to this controls.
   */
  detach() {
    return this.object = void 0, this.axis = null, this._root.visible = !1, this;
  }
  /**
   * Resets the object's position, rotation and scale to when the current transform began.
   */
  reset() {
    this.enabled && this.dragging && (this.object.position.copy(this._positionStart), this.object.quaternion.copy(this._quaternionStart), this.object.scale.copy(this._scaleStart), this.dispatchEvent(PV), this.dispatchEvent(pge), this.pointStart.copy(this.pointEnd));
  }
  /**
   * Returns the raycaster that is used for user interaction. This object is shared between all
   * instances of `TransformControls`.
   *
   * @returns {Raycaster} The internal raycaster.
   */
  getRaycaster() {
    return cg;
  }
  /**
   * Returns the transformation mode.
   *
   * @returns {'translate'|'rotate'|'scale'} The transformation mode.
   */
  getMode() {
    return this.mode;
  }
  /**
   * Sets the given transformation mode.
   *
   * @param {'translate'|'rotate'|'scale'} mode - The transformation mode to set.
   */
  setMode(e) {
    this.mode = e;
  }
  /**
   * Sets the translation snap.
   *
   * @param {?number} translationSnap - The translation snap to set.
   */
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  /**
   * Sets the rotation snap.
   *
   * @param {?number} rotationSnap - The rotation snap to set.
   */
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  /**
   * Sets the scale snap.
   *
   * @param {?number} scaleSnap - The scale snap to set.
   */
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  /**
   * Sets the size of the helper UI.
   *
   * @param {number} size - The size to set.
   */
  setSize(e) {
    this.size = e;
  }
  /**
   * Sets the coordinate space in which transformations are applied.
   *
   * @param {'world'|'local'} space - The space to set.
   */
  setSpace(e) {
    this.space = e;
  }
}
function rUe(c) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return {
      x: 0,
      y: 0,
      button: c.button
    };
  {
    const e = this.domElement.getBoundingClientRect();
    return {
      x: (c.clientX - e.left) / e.width * 2 - 1,
      y: -(c.clientY - e.top) / e.height * 2 + 1,
      button: c.button
    };
  }
}
function iUe(c) {
  if (this.enabled)
    switch (c.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(c));
        break;
    }
}
function sUe(c) {
  this.enabled && (document.pointerLockElement || this.domElement.setPointerCapture(c.pointerId), this.domElement.addEventListener("pointermove", this._onPointerMove), this.pointerHover(this._getPointer(c)), this.pointerDown(this._getPointer(c)));
}
function oUe(c) {
  this.enabled && this.pointerMove(this._getPointer(c));
}
function aUe(c) {
  this.enabled && (this.domElement.releasePointerCapture(c.pointerId), this.domElement.removeEventListener("pointermove", this._onPointerMove), this.pointerUp(this._getPointer(c)));
}
function AV(c, e, t) {
  const n = e.intersectObject(c, !0);
  for (let i = 0; i < n.length; i++)
    if (n[i].object.visible || t)
      return n[i];
  return !1;
}
const oO = new jge(), Tr = new Vt(0, 1, 0), fge = new Vt(0, 0, 0), mge = new IE(), aO = new xa(), _O = new xa(), pc = new Vt(), gge = new IE(), aE = new Vt(1, 0, 0), gg = new Vt(0, 1, 0), lE = new Vt(0, 0, 1), lO = new Vt(), Xw = new Vt(), Qw = new Vt();
class lUe extends jb {
  constructor(e) {
    super(), this.isTransformControlsRoot = !0, this.controls = e, this.visible = !1;
  }
  // updateMatrixWorld updates key transformation variables
  updateMatrixWorld(e) {
    const t = this.controls;
    t.object !== void 0 && (t.object.updateMatrixWorld(), t.object.parent === null ? console.error("TransformControls: The attached 3D object must be a part of the scene graph.") : t.object.parent.matrixWorld.decompose(t._parentPosition, t._parentQuaternion, t._parentScale), t.object.matrixWorld.decompose(t.worldPosition, t.worldQuaternion, t._worldScale), t._parentQuaternionInv.copy(t._parentQuaternion).invert(), t._worldQuaternionInv.copy(t.worldQuaternion).invert()), t.camera.updateMatrixWorld(), t.camera.matrixWorld.decompose(t.cameraPosition, t.cameraQuaternion, t._cameraScale), t.camera.isOrthographicCamera ? t.camera.getWorldDirection(t.eye).negate() : t.eye.copy(t.cameraPosition).sub(t.worldPosition).normalize(), super.updateMatrixWorld(e);
  }
  dispose() {
    this.traverse(function(e) {
      e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
    });
  }
}
class uUe extends jb {
  constructor() {
    super(), this.isTransformControlsGizmo = !0, this.type = "TransformControlsGizmo";
    const e = new Tg({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), t = new w6({
      depthTest: !1,
      depthWrite: !1,
      fog: !1,
      toneMapped: !1,
      transparent: !0
    }), n = e.clone();
    n.opacity = 0.15;
    const i = t.clone();
    i.opacity = 0.5;
    const o = e.clone();
    o.color.setHex(16711680);
    const l = e.clone();
    l.color.setHex(65280);
    const p = e.clone();
    p.color.setHex(255);
    const f = e.clone();
    f.color.setHex(16711680), f.opacity = 0.5;
    const v = e.clone();
    v.color.setHex(65280), v.opacity = 0.5;
    const _ = e.clone();
    _.color.setHex(255), _.opacity = 0.5;
    const E = e.clone();
    E.opacity = 0.25;
    const A = e.clone();
    A.color.setHex(16776960), A.opacity = 0.25, e.clone().color.setHex(16776960);
    const j = e.clone();
    j.color.setHex(7895160);
    const q = new Vo(0, 0.04, 0.1, 12);
    q.translate(0, 0.05, 0);
    const L = new Ys(0.08, 0.08, 0.08);
    L.translate(0, 0.04, 0);
    const V = new Qp();
    V.setAttribute("position", new bc([0, 0, 0, 1, 0, 0], 3));
    const re = new Vo(75e-4, 75e-4, 0.5, 3);
    re.translate(0, 0.25, 0);
    function R(pe, Tt) {
      const st = new ww(pe, 75e-4, 3, 64, Tt * Math.PI * 2);
      return st.rotateY(Math.PI / 2), st.rotateX(Math.PI / 2), st;
    }
    function J() {
      const pe = new Qp();
      return pe.setAttribute("position", new bc([0, 0, 0, 1, 1, 1], 3)), pe;
    }
    const ge = {
      X: [
        [new Dt(q, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Dt(q, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Dt(re, o), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Dt(q, l), [0, 0.5, 0]],
        [new Dt(q, l), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Dt(re, l)]
      ],
      Z: [
        [new Dt(q, p), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Dt(q, p), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Dt(re, p), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Dt(new gN(0.1, 0), E.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Dt(new Ys(0.15, 0.15, 0.01), _.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Dt(new Ys(0.15, 0.15, 0.01), f.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Dt(new Ys(0.15, 0.15, 0.01), v.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, _e = {
      X: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Dt(new gN(0.2, 0), n)]
      ],
      XY: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    }, Y = {
      START: [
        [new Dt(new gN(0.01, 2), i), null, null, null, "helper"]
      ],
      END: [
        [new Dt(new gN(0.01, 2), i), null, null, null, "helper"]
      ],
      DELTA: [
        [new mc(J(), i), null, null, null, "helper"]
      ],
      X: [
        [new mc(V, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new mc(V, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new mc(V, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    }, Fe = {
      XYZE: [
        [new Dt(R(0.5, 1), j), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Dt(R(0.5, 0.5), o)]
      ],
      Y: [
        [new Dt(R(0.5, 0.5), l), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Dt(R(0.5, 0.5), p), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Dt(R(0.75, 1), A), null, [0, Math.PI / 2, 0]]
      ]
    }, Me = {
      AXIS: [
        [new mc(V, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    }, $ = {
      XYZE: [
        [new Dt(new Lge(0.25, 10, 8), n)]
      ],
      X: [
        [new Dt(new ww(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Dt(new ww(0.5, 0.1, 4, 24), n), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Dt(new ww(0.5, 0.1, 4, 24), n), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Dt(new ww(0.75, 0.1, 2, 24), n)]
      ]
    }, dt = {
      X: [
        [new Dt(L, o), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Dt(re, o), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Dt(L, o), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Dt(L, l), [0, 0.5, 0]],
        [new Dt(re, l)],
        [new Dt(L, l), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Dt(L, p), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Dt(re, p), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Dt(L, p), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Dt(new Ys(0.15, 0.15, 0.01), _), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Dt(new Ys(0.15, 0.15, 0.01), f), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Dt(new Ys(0.15, 0.15, 0.01), v), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Dt(new Ys(0.1, 0.1, 0.1), E.clone())]
      ]
    }, wt = {
      X: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0.3, 0]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Dt(new Vo(0.2, 0, 0.6, 4), n), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Dt(new Ys(0.2, 0.2, 0.01), n), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Dt(new Ys(0.2, 0.2, 0.2), n), [0, 0, 0]]
      ]
    }, St = {
      X: [
        [new mc(V, i.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new mc(V, i.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new mc(V, i.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function Ct(pe) {
      const Tt = new jb();
      for (const st in pe)
        for (let Zt = pe[st].length; Zt--; ) {
          const $t = pe[st][Zt][0].clone(), Ht = pe[st][Zt][1], Gn = pe[st][Zt][2], an = pe[st][Zt][3], An = pe[st][Zt][4];
          $t.name = st, $t.tag = An, Ht && $t.position.set(Ht[0], Ht[1], Ht[2]), Gn && $t.rotation.set(Gn[0], Gn[1], Gn[2]), an && $t.scale.set(an[0], an[1], an[2]), $t.updateMatrix();
          const pr = $t.geometry.clone();
          pr.applyMatrix4($t.matrix), $t.geometry = pr, $t.renderOrder = 1 / 0, $t.position.set(0, 0, 0), $t.rotation.set(0, 0, 0), $t.scale.set(1, 1, 1), Tt.add($t);
        }
      return Tt;
    }
    this.gizmo = {}, this.picker = {}, this.helper = {}, this.add(this.gizmo.translate = Ct(ge)), this.add(this.gizmo.rotate = Ct(Fe)), this.add(this.gizmo.scale = Ct(dt)), this.add(this.picker.translate = Ct(_e)), this.add(this.picker.rotate = Ct($)), this.add(this.picker.scale = Ct(wt)), this.add(this.helper.translate = Ct(Y)), this.add(this.helper.rotate = Ct(Me)), this.add(this.helper.scale = Ct(St)), this.picker.translate.visible = !1, this.picker.rotate.visible = !1, this.picker.scale.visible = !1;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(e) {
    const n = (this.mode === "scale" ? "local" : this.space) === "local" ? this.worldQuaternion : _O;
    this.gizmo.translate.visible = this.mode === "translate", this.gizmo.rotate.visible = this.mode === "rotate", this.gizmo.scale.visible = this.mode === "scale", this.helper.translate.visible = this.mode === "translate", this.helper.rotate.visible = this.mode === "rotate", this.helper.scale.visible = this.mode === "scale";
    let i = [];
    i = i.concat(this.picker[this.mode].children), i = i.concat(this.gizmo[this.mode].children), i = i.concat(this.helper[this.mode].children);
    for (let o = 0; o < i.length; o++) {
      const l = i[o];
      l.visible = !0, l.rotation.set(0, 0, 0), l.position.copy(this.worldPosition);
      let p;
      if (this.camera.isOrthographicCamera ? p = (this.camera.top - this.camera.bottom) / this.camera.zoom : p = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7), l.scale.set(1, 1, 1).multiplyScalar(p * this.size / 4), l.tag === "helper") {
        l.visible = !1, l.name === "AXIS" ? (l.visible = !!this.axis, this.axis === "X" && (Kr.setFromEuler(oO.set(0, 0, 0)), l.quaternion.copy(n).multiply(Kr), Math.abs(Tr.copy(aE).applyQuaternion(n).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Y" && (Kr.setFromEuler(oO.set(0, 0, Math.PI / 2)), l.quaternion.copy(n).multiply(Kr), Math.abs(Tr.copy(gg).applyQuaternion(n).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "Z" && (Kr.setFromEuler(oO.set(0, Math.PI / 2, 0)), l.quaternion.copy(n).multiply(Kr), Math.abs(Tr.copy(lE).applyQuaternion(n).dot(this.eye)) > 0.9 && (l.visible = !1)), this.axis === "XYZE" && (Kr.setFromEuler(oO.set(0, Math.PI / 2, 0)), Tr.copy(this.rotationAxis), l.quaternion.setFromRotationMatrix(mge.lookAt(fge, Tr, gg)), l.quaternion.multiply(Kr), l.visible = this.dragging), this.axis === "E" && (l.visible = !1)) : l.name === "START" ? (l.position.copy(this.worldPositionStart), l.visible = this.dragging) : l.name === "END" ? (l.position.copy(this.worldPosition), l.visible = this.dragging) : l.name === "DELTA" ? (l.position.copy(this.worldPositionStart), l.quaternion.copy(this.worldQuaternionStart), Xs.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1), Xs.applyQuaternion(this.worldQuaternionStart.clone().invert()), l.scale.copy(Xs), l.visible = this.dragging) : (l.quaternion.copy(n), this.dragging ? l.position.copy(this.worldPositionStart) : l.position.copy(this.worldPosition), this.axis && (l.visible = this.axis.search(l.name) !== -1));
        continue;
      }
      l.quaternion.copy(n), this.mode === "translate" || this.mode === "scale" ? (l.name === "X" && Math.abs(Tr.copy(aE).applyQuaternion(n).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Y" && Math.abs(Tr.copy(gg).applyQuaternion(n).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "Z" && Math.abs(Tr.copy(lE).applyQuaternion(n).dot(this.eye)) > 0.99 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XY" && Math.abs(Tr.copy(lE).applyQuaternion(n).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "YZ" && Math.abs(Tr.copy(aE).applyQuaternion(n).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1), l.name === "XZ" && Math.abs(Tr.copy(gg).applyQuaternion(n).dot(this.eye)) < 0.2 && (l.scale.set(1e-10, 1e-10, 1e-10), l.visible = !1)) : this.mode === "rotate" && (aO.copy(n), Tr.copy(this.eye).applyQuaternion(Kr.copy(n).invert()), l.name.search("E") !== -1 && l.quaternion.setFromRotationMatrix(mge.lookAt(this.eye, fge, gg)), l.name === "X" && (Kr.setFromAxisAngle(aE, Math.atan2(-Tr.y, Tr.z)), Kr.multiplyQuaternions(aO, Kr), l.quaternion.copy(Kr)), l.name === "Y" && (Kr.setFromAxisAngle(gg, Math.atan2(Tr.x, Tr.z)), Kr.multiplyQuaternions(aO, Kr), l.quaternion.copy(Kr)), l.name === "Z" && (Kr.setFromAxisAngle(lE, Math.atan2(Tr.y, Tr.x)), Kr.multiplyQuaternions(aO, Kr), l.quaternion.copy(Kr))), l.visible = l.visible && (l.name.indexOf("X") === -1 || this.showX), l.visible = l.visible && (l.name.indexOf("Y") === -1 || this.showY), l.visible = l.visible && (l.name.indexOf("Z") === -1 || this.showZ), l.visible = l.visible && (l.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ), l.material._color = l.material._color || l.material.color.clone(), l.material._opacity = l.material._opacity || l.material.opacity, l.material.color.copy(l.material._color), l.material.opacity = l.material._opacity, this.enabled && this.axis && (l.name === this.axis || this.axis.split("").some(function(f) {
        return l.name === f;
      })) && (l.material.color.setHex(16776960), l.material.opacity = 1);
    }
    super.updateMatrixWorld(e);
  }
}
class cUe extends Dt {
  constructor() {
    super(
      new Bge(1e5, 1e5, 2, 2),
      new Tg({ visible: !1, wireframe: !0, side: S6, transparent: !0, opacity: 0.1, toneMapped: !1 })
    ), this.isTransformControlsPlane = !0, this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (this.position.copy(this.worldPosition), this.mode === "scale" && (t = "local"), lO.copy(aE).applyQuaternion(t === "local" ? this.worldQuaternion : _O), Xw.copy(gg).applyQuaternion(t === "local" ? this.worldQuaternion : _O), Qw.copy(lE).applyQuaternion(t === "local" ? this.worldQuaternion : _O), Tr.copy(Xw), this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            Tr.copy(this.eye).cross(lO), pc.copy(lO).cross(Tr);
            break;
          case "Y":
            Tr.copy(this.eye).cross(Xw), pc.copy(Xw).cross(Tr);
            break;
          case "Z":
            Tr.copy(this.eye).cross(Qw), pc.copy(Qw).cross(Tr);
            break;
          case "XY":
            pc.copy(Qw);
            break;
          case "YZ":
            pc.copy(lO);
            break;
          case "XZ":
            Tr.copy(Qw), pc.copy(Xw);
            break;
          case "XYZ":
          case "E":
            pc.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        pc.set(0, 0, 0);
    }
    pc.length() === 0 ? this.quaternion.copy(this.cameraQuaternion) : (gge.lookAt(Xs.set(0, 0, 0), pc, Tr), this.quaternion.setFromRotationMatrix(gge)), super.updateMatrixWorld(e);
  }
}
class ls extends Ege {
  static DRAG_START = "Transform::dragStart";
  static DRAG_END = "Transform::dragEnd";
  static _instance;
  three;
  activeCamera;
  controls = /* @__PURE__ */ new Map();
  visibility = /* @__PURE__ */ new Map();
  setApp(e) {
    this.three = e, this.three.addEventListener(Cn.SET_SCENE, this.setScene);
  }
  clear() {
    for (const e of this.controls.values()) {
      e.detach(), e.disconnect();
      const t = e.getHelper();
      Hd(t);
    }
    this.controls = /* @__PURE__ */ new Map(), this.visibility = /* @__PURE__ */ new Map();
  }
  add(e) {
    let t = this.controls.get(e);
    if (t === void 0) {
      const n = document.querySelector(".clickable");
      t = new nUe(this.activeCamera, n), t.getHelper().name = e, t.setSize(0.5), t.setSpace("local"), this.controls.set(e, t), this.visibility.set(e, !0), t.addEventListener("mouseDown", () => {
        this.dispatchEvent({ type: ls.DRAG_START });
      }), t.addEventListener("mouseUp", () => {
        this.dispatchEvent({ type: ls.DRAG_END });
      }), t.addEventListener("dragging-changed", (i) => {
        Hi.instance?.toggleOrbitControls(i.value);
      });
    }
    return t;
  }
  get(e) {
    return this.controls.get(e);
  }
  remove(e) {
    const t = this.get(e);
    return t === void 0 ? !1 : (t.detach(), t.disconnect(), Hd(t.getHelper()), this.controls.delete(e), !0);
  }
  enabled(e) {
    this.controls.forEach((t) => {
      t.enabled = e;
    });
  }
  updateCamera(e, t) {
    this.activeCamera = e, this.controls.forEach((n) => {
      n.camera !== e && (n.camera = e, e.getWorldPosition(n.cameraPosition), e.getWorldQuaternion(n.cameraQuaternion)), n.domElement !== t && (n.disconnect(), n.domElement = t, n.connect(t));
    });
  }
  show() {
    this.controls.forEach((e) => {
      const t = e.getHelper(), n = this.visibility.get(t.name);
      n !== void 0 && (t.visible = n);
    });
  }
  hide() {
    this.controls.forEach((e) => {
      const t = e.getHelper();
      this.visibility.set(t.name, t.visible), t.visible = !1;
    });
  }
  setScene = () => {
    this.clear();
  };
  static get instance() {
    return ls._instance || (ls._instance = new ls()), ls._instance;
  }
}
const dUe = new Ys(), kV = new As();
class MV extends jb {
  curve = new Ppe();
  line;
  draggable;
  curvePos;
  // Variables
  tension = 0.5;
  closed = !1;
  subdivide = 50;
  curveType;
  offset = 1;
  lineMaterial;
  _camera;
  _curvePercentage = 0;
  _draggableScale = 10;
  _transform;
  raycaster;
  draggedMat = new Tg();
  parentGroup;
  group;
  constructor(e, t) {
    const n = new Ag(Yp(0.5, 1, Math.random()), Yp(0.5, 1, Math.random()), Yp(0.5, 1, Math.random()));
    super(), this.name = e, this.lineMaterial = new w6({ color: n }), this.line = new mc(new Qp(), this.lineMaterial), this.line.name = "line", this.line.visible = !1, this.add(this.line), this._camera = t, this.curveType = "catmullrom", this.draggedMat.color = n, this.draggable = new jb(), this.draggable.name = "draggablePoints", this.add(this.draggable), this.curvePos = new Dt(new Lge(1.5), new Tg({ color: n })), this.curvePos.name = "curvePos", this.curvePos.scale.setScalar(this._draggableScale), this.curvePos.visible = !1, this.add(this.curvePos), this.raycaster = new _E(), this.raycaster.params.Line.threshold = 3, this.enable();
  }
  enable() {
    document.addEventListener("pointerdown", this.onMouseClick);
  }
  disable() {
    document.removeEventListener("pointerdown", this.onMouseClick);
  }
  dispose = () => {
    this._transform && (this._transform.removeEventListener("objectChange", this.updateSpline), ls.instance.remove(this.name)), this.disable(), this.parentGroup.removeGroup(this.name);
  };
  hideTransform = () => {
    this._transform?.detach();
  };
  exportSpline = () => {
    const e = [];
    this.draggable.children.forEach((t) => {
      e.push([
        au(t.position.x, 3),
        au(t.position.y, 3),
        au(t.position.z, 3)
      ]);
    }), fke({
      name: this.name,
      points: e,
      tension: this.tension,
      closed: this.closed,
      subdivide: this.subdivide,
      type: this.curveType
    }), console.log("Spline copied!");
  };
  showPoints = (e = !0) => {
    this.draggable.visible = e;
  };
  // Modifiers
  addPoints = (e = []) => {
    if (e.length > 0) {
      const t = e.length - 1;
      for (let n = 0; n < t; n++)
        this.addPoint(e[n], !1);
      this.addPoint(e[t]);
    }
  };
  addPoint = (e, t = !0) => {
    const n = this.draggable.children.length, i = new Dt(dUe, this.draggedMat);
    i.name = `point_${n}`, i.position.copy(e), i.scale.setScalar(this._draggableScale), this.draggable.add(i), this._transform?.attach(i);
    const o = this.points.length > 1;
    return o && t && this.updateSpline(), this.line.visible = o, this.updateCurrentPoint(), i;
  };
  addNextPt = () => {
    const e = this.draggable.children.length, t = e > 1 ? this.draggable.children[e - 1].position.clone() : new Vt(), n = this.addPoint(t);
    this.updateField(n.position);
  };
  removePoint = (e) => {
    if (this._transform?.object === e) {
      this._transform?.detach();
      const t = this.draggable.children[this.draggable.children.length - 1];
      this._transform?.attach(t), this.updateField(t.position);
    }
    Hd(e), this.updateSpline();
  };
  removePointAt = (e) => {
    const t = this.draggable.children[e];
    this.removePoint(t);
  };
  removeSelectedPt = () => {
    this._transform?.object !== void 0 && this.removePoint(this._transform?.object);
  };
  updateLastPoint(e) {
    const t = this.draggable.children.length;
    t > 0 && (this.draggable.children[t - 1].position.copy(e), this.updateSpline());
  }
  updateSpline = () => {
    this.points.length < 2 || (this.curve = new Ppe(this.points, this.closed, this.curveType, this.tension), this.line.geometry.dispose(), this.line.geometry = new Qp().setFromPoints(this.curve.getPoints(this.subdivide)), this.curvePos.position.copy(this.getPointAt(this._curvePercentage)));
  };
  updateField(e) {
    this.group.current?.setField("Current Point", e);
  }
  // Handlers
  onMouseClick = (e) => {
    if (!Hi.instance || !Hi.instance.currentWindow || this._transform && !this._transform.getHelper().visible) return;
    const n = Hi.instance.currentWindow.current.getBoundingClientRect();
    kV.x = (e.clientX - n.x) / n.width * 2 - 1, kV.y = -((e.clientY - n.y) / n.height) * 2 + 1, this.raycaster.setFromCamera(kV, this.camera);
    const i = this.raycaster.intersectObjects(this.draggable.children, !1);
    if (i.length > 0) {
      const o = i[0].object;
      o !== this._transform?.object && (this._transform?.attach(o), this.updateField(o.position));
    }
  };
  // Getters
  getPointAt(e) {
    return this.curve.points.length > 1 ? this.curve.getPointAt(e) : this.curve.points.length === 1 ? this.curve.points[0] : new Vt();
  }
  getTangentAt(e) {
    return this.curve.getTangentAt(e);
  }
  get points() {
    const e = [];
    return this.draggable.children.forEach((t) => {
      e.push(t.position);
    }), e;
  }
  get total() {
    return this.draggable.children.length;
  }
  get draggableScale() {
    return this._draggableScale;
  }
  set draggableScale(e) {
    this._draggableScale = e, this.draggable.children.forEach((t) => t.scale.setScalar(e)), this.curvePos.scale.setScalar(e);
  }
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this._transform !== void 0 && (this._transform.camera = e);
  }
  get curvePercentage() {
    return this._curvePercentage;
  }
  set curvePercentage(e) {
    this._curvePercentage = e, this.curvePos.position.copy(this.getPointAt(e));
  }
  // Debug
  updateCurrentPoint() {
    if (this._transform?.object && this.group) {
      const e = this._transform?.object;
      e.name.search("point") > -1 && this.updateField(e.position);
    }
  }
  onUpdateTransform = () => {
    this.updateCurrentPoint(), this.updateSpline();
  };
  initDebug(e, t) {
    const n = this.draggable.children;
    this.visible = t, this.parentGroup = e, this._transform = ls.instance.add(this.name), this._transform.camera = this._camera, this._transform.addEventListener("objectChange", this.onUpdateTransform), n.length > 0 && this._transform.attach(n[n.length - 1]), Hi.instance?.helpersContainer.add(this._transform.getHelper());
    const i = n.length > 0 ? n[n.length - 1].position : { x: 0, y: 0, z: 0 };
    this.group = e.addGroup({
      title: this.name,
      expanded: t,
      items: [
        {
          prop: "Closed",
          type: "boolean",
          value: this.closed
        },
        {
          prop: "Visible",
          type: "boolean",
          value: this.visible
        },
        {
          prop: "Show Position",
          type: "boolean",
          value: this.curvePos.visible
        },
        {
          prop: "Show Points",
          type: "boolean",
          value: this.draggable.visible
        },
        {
          prop: "Color",
          type: "color",
          value: `#${this.draggedMat.color.getHexString()}`
        },
        {
          prop: "Curve",
          type: "option",
          options: [
            {
              title: "Catmullrom",
              value: "catmullrom"
            },
            {
              title: "Centripetal",
              value: "centripetal"
            },
            {
              title: "Chordal",
              value: "chordal"
            }
          ]
        },
        {
          prop: "Draggable Scale",
          type: "range",
          min: 0.01,
          max: 100,
          step: 0.01,
          value: this._draggableScale
        },
        {
          prop: "Subdivide",
          type: "range",
          min: 1,
          max: 1e3,
          step: 1,
          value: this.subdivide
        },
        {
          prop: "Tension",
          type: "range",
          min: 0,
          max: 1,
          step: 0.01,
          value: this.tension
        },
        {
          prop: "New Pt Offset",
          type: "range",
          min: 0,
          max: 10,
          value: this.offset
        },
        {
          prop: "Curve At",
          type: "range",
          min: 0,
          max: 1,
          step: 0.01,
          value: 0
        },
        {
          prop: "Toggle Transform",
          type: "button"
        },
        {
          prop: "Add Point",
          type: "button"
        },
        {
          prop: "Remove Point",
          type: "button"
        },
        {
          prop: "Export",
          type: "button"
        },
        {
          prop: "Delete",
          type: "button"
        },
        {
          prop: "Current Point",
          type: "grid3",
          value: i
        }
      ],
      onUpdate: (o, l) => {
        switch (o) {
          case "Closed":
            this.closed = l, this.updateSpline();
            break;
          case "Visible":
            this.visible = l;
            break;
          case "Color":
            this.lineMaterial.color.setStyle(l), this.draggedMat.color.setStyle(l);
            break;
          case "Curve":
            this.curveType = l, this.updateSpline();
            break;
          case "Draggable Scale":
            this.draggableScale = l;
            break;
          case "Subdivide":
            this.subdivide = l, this.updateSpline();
            break;
          case "Tension":
            this.tension = l, this.updateSpline();
            break;
          case "New Pt Offset":
            this.offset = l;
            break;
          case "Curve At":
            this.curvePos.position.copy(this.getPointAt(l));
            break;
          case "Show Position":
            this.curvePos.visible = l;
            break;
          case "Show Points":
            this.draggable.visible = l;
            break;
          case "Toggle Transform":
            this._transform && (this._transform.getHelper().visible = !this._transform.getHelper().visible);
            break;
          case "Add Point":
            this.addNextPt();
            break;
          case "Remove Point":
            this.removeSelectedPt();
            break;
          case "Export":
            this.exportSpline();
            break;
          case "Delete":
            this.parent.currentSpline = null, Hd(this);
            break;
          case "Current Point":
            if (this.group.current && this._transform?.object) {
              const p = this._transform?.object;
              p.name.search("point") > -1 && (p.position.copy(l), this.updateSpline());
            }
            break;
        }
      }
    }), this.draggable.children.forEach((o) => {
      this.debugPoint(o);
    });
  }
  debugPoint = (e) => {
    e.name, e.visible = this.draggable.visible;
  };
}
let uO = 0;
class hUe extends jb {
  defaultScale = 10;
  currentSpline = null;
  _camera;
  group = null;
  three;
  splineDataText = "";
  constructor(e, t) {
    super(), this.name = "Spline Editor", this._camera = e, this.three = t, this.three.addEventListener(Cn.ADD_SPLINE, this.onAddSpline);
  }
  initDebug() {
    this.group = Vn.addEditorGroup({
      title: this.name,
      items: [
        {
          type: "field",
          prop: "Spline Data",
          value: "",
          disabled: !1
        },
        {
          type: "button",
          prop: "Import Spline"
        },
        {
          type: "button",
          prop: "New Spline"
        },
        {
          type: "boolean",
          prop: "Show Points",
          value: !0
        },
        {
          type: "boolean",
          prop: "Draw Mode",
          value: !1
        },
        {
          type: "boolean",
          prop: "Visible",
          value: this.visible
        },
        {
          type: "range",
          prop: "Default Scale",
          min: 0,
          max: 50,
          step: 0.01,
          value: this.defaultScale
        }
      ],
      onUpdate: (e, t) => {
        switch (e) {
          case "New Spline":
            this.createSpline();
            break;
          case "Spline Data":
            this.splineDataText = t;
            break;
          case "Import Spline":
            this.createSplineFromJSON(JSON.parse(this.splineDataText));
            break;
          case "Show Points":
            this.showPoints(t);
            break;
          case "Visible":
            this.visible = t;
            break;
          case "Default Scale":
            this.defaultScale = t;
            break;
          case "Draw Mode":
            t ? this.enableClickToDraw() : this.disableClickToDraw();
            break;
        }
      }
    });
  }
  dispose() {
    this.three.removeEventListener(Cn.ADD_SPLINE, this.onAddSpline), Vn.removeEditorGroup(this.name);
  }
  addSpline(e, t) {
    e.draggableScale = this.defaultScale, e.hideTransform(), this.group?.current !== null && e.initDebug(this.group.current, t), this.add(e), this.currentSpline = e;
  }
  createSpline = (e = []) => {
    const t = `Spline ${uO + 1}`, n = new MV(t, this._camera);
    return n.addPoints(e), this.addSpline(n, !0), uO++, n;
  };
  createSplineFromArray = (e) => {
    const t = [];
    return e.forEach((n) => {
      t.push(new Vt(n[0], n[1], n[2]));
    }), this.createSpline(t);
  };
  createSplineFromCatmullRom = (e) => this.createSpline(e.points);
  createSplineFromJSON = (e) => {
    const t = [];
    e.points.forEach((i) => {
      t.push(new Vt(i[0], i[1], i[2]));
    });
    const n = new MV(e.name, this._camera);
    return n.closed = e.closed, n.subdivide = e.subdivide, n.tension = e.tension, n.type = e.type, n.addPoints(t), n.updateSpline(), this.addSpline(n, !1), n;
  };
  showPoints = (e = !0) => {
    this.children.forEach((t) => {
      t.showPoints(e);
    });
  };
  onAddSpline = (e) => {
    const t = JSON.parse(e.value), n = t.name !== void 0 ? t.name : `Spline ${uO + 1}`, i = new MV(n, this.camera);
    t.tension !== void 0 && (i.tension = t.tension), t.closed !== void 0 && (i.closed = t.closed), t.subdivide !== void 0 && (i.subdivide = t.subdivide), t.type !== void 0 && (i.curveType = t.type);
    const o = [];
    t.points.forEach((l) => {
      o.push(new Vt(l[0], l[1], l[2]));
    }), i.addPoints(o), this.addSpline(i, !1), uO++;
  };
  isMouseDown = !1;
  enableClickToDraw() {
    document.querySelectorAll(".clickable").forEach((e) => {
      e.addEventListener("mousedown", this.onClickCanvas), e.addEventListener("mousemove", this.onMouseMove), e.addEventListener("mouseup", this.onMouseUp);
    });
  }
  disableClickToDraw() {
    document.querySelectorAll(".clickable").forEach((e) => {
      e.removeEventListener("mousedown", this.onClickCanvas), e.removeEventListener("mousemove", this.onMouseMove), e.removeEventListener("mouseup", this.onMouseUp);
    });
  }
  onClickCanvas = (e) => {
    if (e.button !== 0) return;
    if (this._camera.type !== "OrthographicCamera") {
      console.warn("Spline Editor - 3D Camera not supported in Draw Mode");
      return;
    }
    const n = e.target.getBoundingClientRect(), i = (e.clientX - n.left) / n.width * 2 - 1, o = -((e.clientY - n.top) / n.height) * 2 + 1;
    if (Hi.instance) {
      const p = new _E();
      p.setFromCamera(new As(i, o), this._camera);
      const f = p.intersectObjects(Hi.instance.helpersContainer.children, !0);
      for (let v = 0; v < f.length; v++) {
        const _ = f[v];
        if (!(_.object.isLine || _.object.isTransformControlsPlane) && _.object.isObject3D)
          return;
      }
    }
    this.currentSpline === null && (this.currentSpline = this.createSpline());
    const l = this.mouseToSplinePos(i, o, n.width, n.height);
    this.currentSpline?.addPoint(l), this.isMouseDown = !0;
  };
  onMouseMove = (e) => {
    if (!this.isMouseDown) return;
    const n = e.target.getBoundingClientRect(), i = (e.clientX - n.left) / n.width * 2 - 1, o = -((e.clientY - n.top) / n.height) * 2 + 1, l = this.mouseToSplinePos(i, o, n.width, n.height);
    this.currentSpline?.updateLastPoint(l), this.currentSpline?.updateField(l);
  };
  onMouseUp = () => {
    this.isMouseDown = !1;
  };
  mouseToSplinePos(e, t, n, i) {
    const o = new Vt(), l = Math.PI / 2, p = this._camera, f = p.zoom, v = p.rotation.x === -6123233995736766e-32 && p.rotation.y === 0 && p.rotation.z === 0, _ = p.rotation.x === -Math.PI && p.rotation.y === 12246467991473532e-32 && p.rotation.z === Math.PI, E = p.rotation.x === -6162975822039155e-48 && p.rotation.y === -l && p.rotation.z === 0, A = p.rotation.x === -6162975822039155e-48 && p.rotation.y === l && p.rotation.z === 0, I = p.rotation.x === -1.5707953264174506 && p.rotation.y === 0 && p.rotation.z === 0, j = p.rotation.x === 1.5707953264174506 && p.rotation.y === 0 && p.rotation.z === 0;
    let q = e, L = t;
    _ || A ? q *= -1 : I && (L *= -1);
    const V = n / 2 / f, re = i / 2 / f;
    if (this.currentSpline === null && (this.currentSpline = this.createSpline()), v || _) {
      const R = q * V + p.position.x, J = L * re + p.position.y;
      o.set(R, J, 0);
    } else if (E || A) {
      const R = q * V + p.position.z, J = L * re + p.position.y;
      o.set(0, J, R);
    } else if (I || j) {
      const R = q * V + p.position.x, J = L * re + p.position.z;
      o.set(R, 0, J);
    }
    return o;
  }
  get camera() {
    return this._camera;
  }
  set camera(e) {
    this._camera = e, this.children.forEach((t) => {
      const n = t;
      n.camera = e;
    });
  }
}
const yge = [
  "Single",
  "Side by Side",
  "Stacked",
  "Quad"
], pUe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC60lEQVRYhe2YT4hNcRTHP48xpmYaNAvRyEQxEhnKQljYsRm9/EmSyJiMFAsMZWNhJYoNIUVJ2VGiyb9ZzIpMpkQSahbGv9GMYWrM+1rc2zjvzvvdd+99rzdvMd+6de75nd+5387vnN/v/G5KEuWMKRNNIB8mCRaKiiL5qQb2ApuBuUAV0Ad0AJeB3sSeJRX6LJbULTf6JTUn9Z+KWMUpPyp/Avoa4CNQZ3Sj/lNpdL/xottR7AjOkHRUUpekN5I6JbVLavDH75lIfZN0UFKTpCWS0pJem/HeJBEMG6yV1ONYtgFJbZJ+GF1jDh+zJb03NuliEuwMkMo4yErS2RA/LcbuYVyCrm1mA7Dal/8Cu4FG4JD/HsTTkCy6a+SVMTPQuc1sBKb78nHghi+/A+YBxwL2lbhRY+ThuARdEVxu5JdGFvACr0otdoZ8Y4+Rn0Sn5sFFsMvI6YB9MzA1YJ8mN8k1wAHzfj4uQVdyrpI0aJL7oqTtkq4FiqPLyCOSbktqlbRL0jlJQ2b8QdwCUZ4qvhRStZL0XFK1pMd57CRvq5mfhKBriRfiFUMY6oD7eOdwPlQAN4G10dfWg+uouwXsiOssAj4AC+JMcEWwvnAuOTEr7gTXPmg34zagOwkbIIOXAo9CbDYBrcBXYN+4UUdy2sRflyS5zVNlfPX7ugpJW5V9nI7mmh+lYU0lCZ2B3TOnAVuAk0BTwC5nuhWro46KauBOQJch5OpRaoIW34GreGf+YZdRqS9NAj4Bp4ClQDvwOWxCqSM4ADQEdKE5XvbXzlITrAVe4TW+M6NMKDXBFLAMuAD0ACfIc7pMZBXXA2cY3/xmodQRHAL2A2+NLtj8ZiEKwUL/z2WMPAJcAVYALWSf8dZuDFGWeBHwKxm3sWYhiGG8Tfo6sA2vSfiSy4GrH3wGrDcfKSSKKf6v1E9yF0XK9Q1XBPuMXMw8HXTonQFwETwNzMFr64v1jzgFHIk9ybHEZYPJo65QlD3Bf2/Q/eaHPiSWAAAAAElFTkSuQmCC", fUe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoCAYAAACM/rhtAAAACXBIWXMAAAsTAAALEwEAmpwYAAAETklEQVRYhe2YXYhVVRTHf3d0/JhyUrMpFbImM+whSa3Mynww+4AeIgiKoozooQ+KyMyXIAujF6OXqHyI6iEKKYgIP/owsjSFqCkprdDUTEcjbWZ0HHV+Pex1ucfb9Z57Z9REXHA4Z++99l7/s/ZZ/7X2KaiczNLwfwPIk9MA+yunNMAG4DHgV+BvoB3YFff2TPstYEyfrajVroI6Sr1GvahsbJC63HzZq04pmztSvU5tVRuqYRiYg78JeBR4HPg5ntdmxovz9wJfA3uAxuibDLQCA+IqynnAQuBuYCnwMLC1rx48U12U8cZqdWqMDcx4cI16qTpYbVKHqa+ovWUeHKsujn7VL9ULq2HI+wY7gVeBJdGeFu3J4ZUiy/cAXeHRRuAQsC/GC0B3eG4BcH/0tUV7czUAeVsMsBF4Kha9HZgCvAncAuwPnXHA0wFuGLANuDrGuoGDwFxgTqzzQ7RX5FrP2eLsdb76vnogtme6+nE8H1YPlQXHwbi3q9eqn0e7Tb25VrsF68vFY0lb1AGcDTwItGQ8tQM4AIwGmqP/EPAu8A0wElgJfFGzxTo8mKWXu9Rd4ZF96jvqjSbauEC9Sn1O3R463epLaku99voCsFXdkAH3kNpcQW+IiT/bQne3eufxBtioPqP2mKhioXpWzpxb1T8C5Ifh4ZptVoriRmAIKdrI3Lujf3bobAPeJpF0NVkKrAFuI9HTOBIxnxFrF4OgQKKr/dnJlQA+AcwABgOHA4zAamA5cE7orQL+zAEHiWI+A2bFC7aSguheYCgpqAphZz3wSB7AecCICv2TgH8oFRib4gVqka0k0h8CXAxMBW6ooDejFoCvA9OBQUAvKWM0kDz4XUZvNKXtyZMWUl7vBbaQXq457PeEziDgx/KJlQAuIPFdMcEXv5OdYWBP9M8k8VpnDQCvB4aTSrCNJB5cSdrW3tBpIJVnR0qdUTxAfdGUOVTnmwqEanNmqltC/9OgqePKg5eom8PgdvW+oJ9Kupera0O3U50TL3lcAaI+oHaF4R3qa6Z822wq0Saq89T1lmSxOrxeW/Xm4uGkiqQDmECKuKHxHW0HdpMiewSpvGqKeR8Ay0iBsYIjg6261PE2o9Q3Yqv+MqWxO9R1Hl12qs+q49Vlppy82pSr+5xJKsko4AXgHlJ0t5NIeg3wLXAlqZhtIUV8J6nmWwX8QiLjdhL5TwMWkY4R6/rrwYKlMr1Y321QZ/vfwBijPqm+rF4Wc7PjE9QllurGVeoV5gRNHsAm9fnMom3qrKPoTjKdMXaYyrFygEWQ72XWW24qhPu8xcUc2UU6O8wFPjmK7jhgPHAuMJGUGQ6U6WwE5sfzTXGvei7KA9hFOiR9D/wOfFVFt4dS2tpfRe83Ur7/CPiJakfOGgBCypubatArl2r8VfOax/LfzABKtePAzHO/5FgC7KBEzB2kOrDfUm8mOeFySv9+OyFyGmB/5aQH+C9BVKmVCNuMZgAAAABJRU5ErkJggg==", mUe = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAQ0lEQVQ4jWP8////fwYqAxYozUhFM/8zkaKYWIWkGEq0b0ZdSjQY5i79TyWagRGaTUdzFEEw6lLqGzqwLoVVJ1StpwA9sBwbUqAh5gAAAABJRU5ErkJggg==";
class Hi extends RE {
  static instance = null;
  scene;
  renderer;
  currentScene;
  scenes = /* @__PURE__ */ new Map();
  cameras = /* @__PURE__ */ new Map();
  controls = /* @__PURE__ */ new Map();
  currentCamera;
  currentWindow;
  // RefObject to one of the "windows"
  helpersContainer = new qAe();
  grid = new Zje();
  cameraHelpers = /* @__PURE__ */ new Map();
  lightHelpers = /* @__PURE__ */ new Map();
  interactionHelper = new HAe(25);
  currentTransform;
  // Tools
  splineEditor;
  // Override Materials
  depthMaterial = new $Ae();
  normalsMaterial = new WAe();
  uvMaterial = new tUe();
  wireframeMaterial = new Tg({
    opacity: 0.33,
    transparent: !0,
    wireframe: !0
  });
  // Playback
  playing = !1;
  rafID = -1;
  cameraControlsRafID = -1;
  width = 0;
  height = 0;
  // Windows
  tlCam = null;
  trCam = null;
  blCam = null;
  brCam = null;
  tlRender = "Renderer";
  trRender = "Renderer";
  blRender = "Renderer";
  brRender = "Renderer";
  cameraVisibility = !0;
  lightVisibility = !0;
  gridVisibility = !0;
  // Interactions
  selectedItem = void 0;
  debugCamera;
  raycaster = new _E();
  pointer = new As();
  cameraControls = void 0;
  // References
  canvasRef;
  containerRef;
  tlWindow;
  trWindow;
  blWindow;
  brWindow;
  editorCameras = [
    "Top",
    "Bottom",
    "Left",
    "Right",
    "Front",
    "Back",
    "Orthographic",
    "UI",
    "Debug"
  ];
  constructor(e) {
    super(e), this.props.three.addEventListener(Cn.ADD_RENDERER, this.setupRenderer), this.scene = new _ge(), this.scene.name = this.scene.uuid = "", this.canvasRef = zp(), this.containerRef = zp(), this.tlWindow = zp(), this.trWindow = zp(), this.blWindow = zp(), this.brWindow = zp();
    const t = e.three.name, n = localStorage, i = n.getItem(`${t}_mode`);
    this.state = {
      mode: i !== null ? i : "Single",
      modeOpen: !1,
      renderModeOpen: !1,
      interactionMode: "Orbit",
      interactionModeOpen: !1,
      lastUpdate: Date.now()
    }, n.setItem(`${t}_mode`, this.state.mode), n.setItem(`${t}_tlCam`, n.getItem(`${t}_tlCam`) !== null ? n.getItem(`${t}_tlCam`) : "Debug"), n.setItem(`${t}_trCam`, n.getItem(`${t}_trCam`) !== null ? n.getItem(`${t}_trCam`) : "Orthographic"), n.setItem(`${t}_blCam`, n.getItem(`${t}_blCam`) !== null ? n.getItem(`${t}_blCam`) : "Front"), n.setItem(`${t}_brCam`, n.getItem(`${t}_brCam`) !== null ? n.getItem(`${t}_brCam`) : "Top"), n.setItem(`${t}_tlRender`, n.getItem(`${t}_tlRender`) !== null ? n.getItem(`${t}_tlRender`) : "Renderer"), n.setItem(`${t}_trRender`, n.getItem(`${t}_trRender`) !== null ? n.getItem(`${t}_trRender`) : "Renderer"), n.setItem(`${t}_blRender`, n.getItem(`${t}_blRender`) !== null ? n.getItem(`${t}_blRender`) : "Renderer"), n.setItem(`${t}_brRender`, n.getItem(`${t}_brRender`) !== null ? n.getItem(`${t}_brRender`) : "Renderer");
    const o = {
      Vector2: As,
      Vector3: Vt,
      Vector4: XAe,
      Quaternion: xa,
      Matrix4: IE,
      Spherical: NV,
      Box3: YAe,
      Sphere: KAe,
      Raycaster: _E
    };
    yc.install({ THREE: o }), this.setupScene(), this.setupTools();
    const l = localStorage.getItem(this.expandedCameraVisibility);
    l !== null && (this.cameraVisibility = l === "open"), this.saveExpandedCameraVisibility();
    const p = localStorage.getItem(this.expandedLightVisibility);
    p !== null && (this.lightVisibility = p === "open"), this.saveExpandedLightVisibility();
    const f = localStorage.getItem(this.expandedGridVisibility);
    f !== null && (this.gridVisibility = f === "open"), this.grid.visible = this.gridVisibility, this.saveExpandedGridVisibility(), Hi.instance = this;
  }
  componentDidMount() {
    this.enable(), this.assignControls(), this.resize(), this.play(), ls.instance.setApp(this.props.three), ls.instance.activeCamera = this.debugCamera;
  }
  componentDidUpdate(e, t, n) {
    t.mode !== this.state.mode && (this.assignControls(), this.resize());
  }
  componentWillUnmount() {
    this.disable(), this.clear(), Vn.removeEditorGroup("View Settings");
  }
  render() {
    const e = [];
    return this.cameras.forEach((t, n) => {
      e.push(n);
    }), /* @__PURE__ */ ke.jsxs("div", { className: "multiview", children: [
      /* @__PURE__ */ ke.jsx("canvas", { ref: this.canvasRef }),
      /* @__PURE__ */ ke.jsxs("div", { className: `cameras ${this.state.mode === "Single" || this.state.mode === "Stacked" ? "single" : ""}`, ref: this.containerRef, children: [
        this.state.mode === "Single" && /* @__PURE__ */ ke.jsx(ke.Fragment, { children: /* @__PURE__ */ ke.jsx(
          ug,
          {
            name: "tl",
            camera: this.tlCam,
            options: e,
            ref: this.tlWindow,
            onSelectCamera: (t) => {
              this.controls.get(this.tlCam.name)?.dispose();
              const n = this.cameras.get(t);
              n !== void 0 && (this.clearCamera(this.tlCam), this.tlCam = n, localStorage.setItem(`${this.appID}_tlCam`, n.name), this.createControls(n, this.tlWindow.current));
            },
            onSelectRenderMode: (t) => {
              this.tlRender = t, localStorage.setItem(`${this.appID}_tlRender`, t);
            }
          }
        ) }),
        (this.state.mode === "Side by Side" || this.state.mode === "Stacked") && /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "tl",
              camera: this.tlCam,
              options: e,
              ref: this.tlWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.tlCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.tlCam), this.tlCam = n, localStorage.setItem(`${this.appID}_tlCam`, n.name), this.createControls(n, this.tlWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.tlRender = t, localStorage.setItem(`${this.appID}_tlRender`, t);
              }
            }
          ),
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "tr",
              camera: this.trCam,
              options: e,
              ref: this.trWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.trCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.trCam), this.trCam = n, localStorage.setItem(`${this.appID}_trCam`, n.name), this.createControls(n, this.trWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.trRender = t, localStorage.setItem(`${this.appID}_trRender`, t);
              }
            }
          )
        ] }),
        this.state.mode === "Quad" && /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "tl",
              camera: this.tlCam,
              options: e,
              ref: this.tlWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.tlCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.tlCam), this.tlCam = n, localStorage.setItem(`${this.appID}_tlCam`, n.name), this.createControls(n, this.tlWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.tlRender = t, localStorage.setItem(`${this.appID}_tlRender`, t);
              }
            }
          ),
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "tr",
              camera: this.trCam,
              options: e,
              ref: this.trWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.trCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.trCam), this.trCam = n, localStorage.setItem(`${this.appID}_trCam`, n.name), this.createControls(n, this.trWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.trRender = t, localStorage.setItem(`${this.appID}_trRender`, t);
              }
            }
          ),
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "bl",
              camera: this.blCam,
              options: e,
              ref: this.blWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.blCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.blCam), this.blCam = n, localStorage.setItem(`${this.appID}_blCam`, n.name), this.createControls(n, this.blWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.blRender = t, localStorage.setItem(`${this.appID}_blRender`, t);
              }
            }
          ),
          /* @__PURE__ */ ke.jsx(
            ug,
            {
              name: "br",
              camera: this.brCam,
              options: e,
              ref: this.brWindow,
              onSelectCamera: (t) => {
                this.controls.get(this.brCam.name)?.dispose();
                const n = this.cameras.get(t);
                n !== void 0 && (this.clearCamera(this.brCam), this.brCam = n, localStorage.setItem(`${this.appID}_brCam`, n.name), this.createControls(n, this.brWindow.current));
              },
              onSelectRenderMode: (t) => {
                this.brRender = t, localStorage.setItem(`${this.appID}_brRender`, t);
              }
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ ke.jsxs("div", { className: "settings", children: [
        /* @__PURE__ */ ke.jsx(
          HO,
          {
            title: "View",
            index: yge.indexOf(this.state.mode),
            options: yge,
            onSelect: (t) => {
              t !== this.state.mode && (this.killControls(), this.setState({ mode: t }), localStorage.setItem(`${this.appID}_mode`, t));
            },
            open: this.state.modeOpen,
            onToggle: (t) => {
              this.setState({
                modeOpen: t,
                renderModeOpen: !1,
                interactionModeOpen: !1
              });
            }
          }
        ),
        /* @__PURE__ */ ke.jsx(
          HO,
          {
            title: "Interact",
            index: this.state.interactionMode === "Orbit" ? 0 : 1,
            options: [
              "Orbit Mode",
              "Selection Mode"
            ],
            onSelect: (t) => {
              this.interactionHelper.visible = t === "Selection Mode", this.setState({ interactionMode: this.interactionHelper.visible ? "Selection" : "Orbit" });
            },
            open: this.state.interactionModeOpen,
            onToggle: (t) => {
              this.setState({
                modeOpen: !1,
                renderModeOpen: !1,
                interactionModeOpen: t
              });
            }
          }
        ),
        /* @__PURE__ */ ke.jsx(
          CV,
          {
            name: "cameraHelper",
            icon: pUe,
            selected: this.cameraVisibility,
            height: 24,
            top: 2,
            onClick: (t) => {
              if (this.cameraVisibility = t, this.saveExpandedCameraVisibility(), this.cameraHelpers.forEach((n) => {
                n.visible = t;
              }), this.selectedItem !== void 0 && !t) {
                const n = this.cameraHelpers.get(this.selectedItem.name);
                n !== void 0 && (n.visible = !0);
              }
            }
          }
        ),
        /* @__PURE__ */ ke.jsx(
          CV,
          {
            name: "lightHelper",
            icon: fUe,
            selected: this.lightVisibility,
            height: 24,
            top: 4,
            onClick: (t) => {
              if (this.lightVisibility = t, this.saveExpandedLightVisibility(), this.lightHelpers.forEach((n) => {
                n.visible = t;
              }), this.selectedItem !== void 0 && !t && this.selectedItem.isLight === !0) {
                const n = this.lightHelpers.get(this.selectedItem.name);
                n !== void 0 && (n.visible = !0);
              }
            }
          }
        ),
        /* @__PURE__ */ ke.jsx(
          CV,
          {
            name: "gridHelper",
            icon: mUe,
            selected: this.gridVisibility,
            height: 21,
            width: 21,
            onClick: (t) => {
              this.setGridVisibility(t);
            }
          }
        )
      ] }, this.state.lastUpdate)
    ] });
  }
  // Setup
  setupRenderer = (e) => {
    this.renderer && this.renderer.dispose();
    const t = this.canvasRef.current;
    this.props.three.canvas = t;
    const n = e.value;
    n.type === "WebGLRenderer" ? (this.renderer = new Zw({
      canvas: t,
      stencil: !1
    }), this.grid.visible = !0) : n.type === "WebGPURenderer" && (this.renderer = new eO({
      canvas: t,
      stencil: !1
    }), this.grid.visible = !1), this.renderer && (this.renderer.autoClear = !1, this.renderer.shadowMap.enabled = !0, this.renderer.setPixelRatio(devicePixelRatio), this.renderer.setClearColor(0), this.resize(), this.props.three.renderer = this.renderer);
  };
  setupScene() {
    this.helpersContainer.name = "helpers", this.scene.add(this.helpersContainer), this.scene.add(this.grid), this.interactionHelper.name = "interactionHelper", this.interactionHelper.visible = !1, this.helpersContainer.add(this.interactionHelper);
    const e = (o, l) => {
      const p = new SO(-100, 100, 100, -100, 0, 3e3);
      return p.name = o, p.position.copy(l), p.lookAt(0, 0, 0), this.cameras.set(o, p), p;
    }, t = 1e3;
    e("Top", new Vt(0, t, 0)), e("Bottom", new Vt(0, -t, 0)), e("Left", new Vt(-t, 0, 0)), e("Right", new Vt(t, 0, 0)), e("Front", new Vt(0, 0, t)), e("Back", new Vt(0, 0, -t)), e("Orthographic", new Vt(t, t, t)), e("UI", new Vt()), this.debugCamera = new Ape(60, 1, 0.01, 3e3), this.debugCamera.name = "Debug", this.debugCamera.position.set(300, 300, 300), this.debugCamera.lookAt(0, 0, 0), this.cameras.set("Debug", this.debugCamera), this.currentCamera = this.debugCamera;
    const n = localStorage, i = this.props.three.name;
    this.tlCam = this.cameras.get(n.getItem(`${i}_tlCam`)), this.trCam = this.cameras.get(n.getItem(`${i}_trCam`)), this.blCam = this.cameras.get(n.getItem(`${i}_blCam`)), this.brCam = this.cameras.get(n.getItem(`${i}_brCam`)), this.tlCam === void 0 && (this.tlCam = this.cameras.get("Debug")), this.trCam === void 0 && (this.trCam = this.cameras.get("Orthographic")), this.blCam === void 0 && (this.blCam = this.cameras.get("Front")), this.brCam === void 0 && (this.brCam = this.cameras.get("Top")), Vn.addEditorGroup({
      title: "Editor",
      items: [
        {
          type: "button",
          prop: "Hide All Transforms"
        },
        {
          type: "button",
          prop: "Resize"
        }
      ],
      onUpdate: (o, l) => {
        switch (o) {
          case "Hide All Transforms":
            ls.instance.hide();
            break;
          case "Resize":
            this.resize();
            break;
        }
      },
      subgroups: [
        {
          title: "Debug Camera",
          items: [
            {
              type: "range",
              prop: "Near",
              step: 1e-4,
              min: 1e-3,
              max: 1e3,
              value: this.debugCamera.near
            },
            {
              type: "range",
              prop: "Far",
              step: 1e-3,
              min: 1e-3,
              max: 1e4,
              value: this.debugCamera.far
            }
          ],
          onUpdate: (o, l) => {
            switch (o) {
              case "Near":
                this.debugCamera.near = l, this.debugCamera.updateProjectionMatrix();
                break;
              case "Far":
                this.debugCamera.far = l, this.debugCamera.updateProjectionMatrix();
                break;
            }
          }
        },
        {
          title: "Grid",
          items: [
            {
              type: "number",
              prop: "Position",
              value: this.grid.position.y
            },
            {
              type: "boolean",
              prop: "Depth Test",
              value: this.grid.gridMaterial.depthTest
            }
          ],
          onUpdate: (o, l) => {
            switch (o) {
              case "Position":
                this.grid.position.y = l;
                break;
              case "Depth Test":
                this.grid.gridMaterial.depthTest = l, this.grid.gridMaterial.needsUpdate = !0;
                break;
            }
          }
        }
      ]
    });
  }
  setupTools() {
    this.splineEditor = new hUe(this.currentCamera, this.three), this.splineEditor.initDebug(), this.helpersContainer.add(this.splineEditor);
  }
  // Public
  play() {
    this.playing = !0, this.onUpdate();
  }
  pause() {
    this.playing = !1, cancelAnimationFrame(this.rafID), this.rafID = -1;
  }
  toggleOrbitControls(e) {
    this.controls.forEach((t) => {
      t.enabled = !e;
    });
  }
  clear() {
    this.three.dispatchEvent({ type: Cn.CLEAR_OBJECT }), Vn.removeAllGroups(), this.clearLightHelpers(), this.clearControls(), this.currentTransform !== void 0 && (this.currentTransform.removeEventListener("objectChange", this.onUpdateTransform), ls.instance.remove(this.currentTransform.getHelper().name)), this.currentTransform = void 0, ls.instance.clear(), this.cameras.forEach((e) => {
      this.editorCameras.indexOf(e.name) < 0 && this.three.dispatchEvent({ type: Cn.REMOVE_CAMERA, value: e });
    }), this.currentCamera = this.debugCamera, this.currentScene = void 0, this.scenes.forEach((e) => {
      this.three.dispatchEvent({ type: Cn.REMOVE_SCENE, value: e });
    }), this.scenes.clear();
  }
  setGridVisibility(e) {
    this.gridVisibility = e, this.saveExpandedGridVisibility(), this.grid.visible = e;
  }
  // Playback
  update() {
    this.renderer && (this.renderer instanceof Zw ? this.renderer?.clear() : this.renderer instanceof eO && this.renderer?.clearAsync()), this.controls.forEach((e) => e.update()), this.cameraHelpers.forEach((e) => e.update()), this.lightHelpers.forEach((e) => {
      e.update !== void 0 && e.update();
    }), this.props.onSceneUpdate !== void 0 && this.currentScene !== void 0 && this.props.onSceneUpdate(this.currentScene);
  }
  draw() {
    switch (this.renderer && (this.renderer instanceof Zw ? this.renderer?.clear() : this.renderer instanceof eO && this.renderer?.clearAsync()), this.state.mode) {
      case "Single":
        this.drawSingle();
        break;
      case "Side by Side":
      case "Stacked":
        this.drawDouble();
        break;
      case "Quad":
        this.drawQuad();
        break;
    }
  }
  onUpdate = () => {
    this.playing && (this.update(), this.draw(), this.rafID = requestAnimationFrame(this.onUpdate));
  };
  // Events
  enable() {
    const e = this.containerRef.current;
    e.addEventListener("mousemove", this.onMouseMove), e.addEventListener("click", this.onClick), window.addEventListener("keydown", this.onKey), window.addEventListener("resize", this.resize), this.three.addEventListener(Cn.ADD_SCENE, this.addScene), this.three.addEventListener(Cn.SET_SCENE, this.sceneUpdate), this.three.addEventListener(Cn.REMOVE_SCENE, this.removeScene), this.three.addEventListener(Cn.ADD_CAMERA, this.addCamera), this.three.addEventListener(Cn.REMOVE_CAMERA, this.removeCamera), this.three.addEventListener(Cn.SET_OBJECT, this.onSetSelectedItem);
  }
  disable() {
    const e = this.containerRef.current;
    e.removeEventListener("mousemove", this.onMouseMove), e.removeEventListener("click", this.onClick), window.removeEventListener("keydown", this.onKey), window.removeEventListener("resize", this.resize), this.three.removeEventListener(Cn.ADD_SCENE, this.addScene), this.three.removeEventListener(Cn.SET_SCENE, this.sceneUpdate), this.three.removeEventListener(Cn.ADD_CAMERA, this.addCamera), this.three.removeEventListener(Cn.REMOVE_CAMERA, this.removeCamera), this.three.removeEventListener(Cn.SET_OBJECT, this.onSetSelectedItem);
  }
  resize = () => {
    this.width = window.innerWidth - 300, this.height = window.innerHeight, this.renderer?.setSize(this.width, this.height);
    const e = Math.floor(this.width / 2), t = Math.floor(this.height / 2);
    this.props.three.resize(this.width, this.height), this.props.onSceneResize !== void 0 && this.currentScene !== void 0 && this.props.onSceneResize(this.currentScene, this.width, this.height);
    let n = this.width, i = this.height;
    switch (this.state.mode) {
      case "Side by Side":
        n = e, i = this.height;
        break;
      case "Stacked":
        n = this.width, i = t;
        break;
      case "Quad":
        n = e, i = t;
        break;
    }
    const o = n / i;
    this.cameras.forEach((l) => {
      l instanceof SO ? (l.left = n / -2, l.right = n / 2, l.top = i / 2, l.bottom = i / -2, l.name === "UI" && (l.position.x = this.width / 2, l.position.y = this.height / -2, l.position.z = 100), l.updateProjectionMatrix()) : l instanceof Ape && (l.aspect = o, l.updateProjectionMatrix()), this.cameraHelpers.get(l.name)?.update();
    });
  };
  addScene = (e) => {
    const t = this.props.scenes.get(e.value.name);
    if (t !== void 0) {
      const n = new t();
      n.visible = !1, this.props.onSceneAdd !== void 0 && this.props.onSceneAdd(n), this.props.three.scene = n, this.scenes.set(e.value.name, n), this.scene.add(n);
    } else
      console.log("Hermes - Scene not found:", e.value.name, this.props.scenes);
  };
  sceneUpdate = (e) => {
    this.currentScene !== void 0 && (this.currentScene.visible = !1, this.clearLightHelpers());
    const t = this.scene.getObjectByName(e.value.name);
    t !== void 0 && (this.currentScene = t, this.currentScene.visible = !0, this.addLightHelpers(this.currentScene));
  };
  removeScene = (e) => {
    const t = e.value.name;
    this.scenes.delete(t);
    const n = this.scene.getObjectByName(t);
    n && setTimeout(() => {
      Hd(n);
    }, 100), this.clearLightHelpers();
  };
  addCamera = (e) => {
    const t = e.value, n = t.uuid, i = this.props.three.scene?.getObjectByProperty("uuid", t.uuid);
    if (i !== void 0) {
      const o = i;
      this.cameras.set(n, o);
      const l = new QAe(o);
      l.visible = this.cameraVisibility, this.cameraHelpers.set(n, l), this.helpersContainer.add(l), this.setState({ lastUpdate: Date.now() });
    }
  };
  removeCamera = (e) => {
    const n = e.value.uuid, i = this.cameraHelpers.get(n);
    i !== void 0 && (this.helpersContainer.remove(i), i.dispose()), this.cameras.delete(n), this.setState({ lastUpdate: Date.now() });
  };
  onMouseMove = (e) => {
    const t = new As();
    this.renderer?.getSize(t);
    const n = Math.min(e.clientX, t.x), i = Math.min(e.clientY, t.y);
    this.pointer.x = hg(n, 0, t.x, -1, 1), this.pointer.y = hg(i, 0, t.y, 1, -1);
    const o = t.x / 2, l = t.y / 2, p = () => {
      n < o ? this.pointer.x = hg(n, 0, o, -1, 1) : this.pointer.x = hg(n, o, t.x, -1, 1);
    }, f = () => {
      i < l ? this.pointer.y = hg(i, 0, l, 1, -1) : this.pointer.y = hg(i, l, t.y, 1, -1);
    };
    switch (this.state.mode) {
      case "Quad":
        p(), f();
        break;
      case "Side by Side":
        p();
        break;
      case "Stacked":
        f(), f();
        break;
    }
    if (this.updateCamera(n, i, o, l), this.state.interactionMode === "Orbit" || this.currentScene === void 0) return;
    const v = this.raycaster.intersectObjects(this.currentScene.children);
    v.length > 0 && this.interactionHelper.position.copy(v[0].point);
  };
  onClick = (e) => {
    if (this.state.interactionMode === "Orbit" || this.currentScene === void 0) return;
    const t = new As();
    if (this.renderer.getSize(t), e.clientX >= t.x) return;
    this.onMouseMove(e);
    const n = this.raycaster.intersectObjects(this.currentScene.children);
    n.length > 0 && (this.props.three.getObject(n[0].object.uuid), this.interactionHelper.visible = !1, this.setState({ interactionMode: "Orbit", lastUpdate: Date.now() }));
  };
  onKey = (e) => {
    if (this.selectedItem !== void 0) {
      if (e.ctrlKey) {
        if (this.currentCamera.name === "UI") return;
        const t = this.controls.get(this.currentCamera.name);
        e.key === "0" ? (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.selectedItem instanceof Dt || this.selectedItem instanceof ZAe ? (this.selectedItem.geometry.computeBoundingBox(), this.cameraControls.fitToBox(this.selectedItem.geometry.boundingBox, !0)) : this.cameraControls.fitToSphere(this.selectedItem, !0), this.updateCameraControls(t, !0)) : e.key === "1" ? (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.cameraControls.rotateTo(0, Math.PI * 0.5, !0), this.cameraControls.moveTo(this.selectedItem.position.x, this.selectedItem.position.y, 0, !0), this.updateCameraControls(t)) : e.key === "2" ? (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.cameraControls.rotateTo(0, 0, !0), this.cameraControls.moveTo(this.selectedItem.position.x, 0, this.selectedItem.position.z, !0), this.updateCameraControls(t)) : e.key === "3" ? (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.cameraControls.rotateTo(Math.PI / 2, Math.PI / 2, !0), this.cameraControls.moveTo(0, this.selectedItem.position.y, this.selectedItem.position.z, !0), this.updateCameraControls(t)) : e.key === "4" ? (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.cameraControls.rotateTo(Math.PI, Math.PI / 2, !0), this.cameraControls.moveTo(this.selectedItem.position.x, this.selectedItem.position.y, 0, !0), this.updateCameraControls(t)) : e.key === "5" && (e.preventDefault(), this.clearControls(), this.cameraControls = new yc(this.currentCamera, this.currentWindow.current), this.cameraControls.rotateTo(TO(45), TO(45), !0), this.updateCameraControls(t));
      } else if (this.currentTransform !== void 0)
        switch (e.key) {
          case "r":
            this.currentTransform.setMode("rotate");
            break;
          case "s":
            this.currentTransform.setMode("scale");
            break;
          case "t":
            this.currentTransform.setMode("translate");
            break;
          case "q":
            this.currentTransform.setSpace(this.currentTransform.space === "local" ? "world" : "local");
            break;
        }
    }
  };
  onSetSelectedItem = (e) => {
    this.selectedItem !== void 0 && this.updateSelectedItemHelper(!1), this.selectedItem = void 0;
    const t = e.value.uuid;
    if (this.scenes.forEach((n) => {
      t.search(n.uuid) > -1 && (this.selectedItem = n.getObjectByProperty("uuid", t));
    }), this.selectedItem === void 0) {
      console.log(`Hermes - Can't find selected item: ${e.value.uuid}, ${e.value.name}`);
      return;
    }
    this.currentTransform !== void 0 && (this.currentTransform.removeEventListener("objectChange", this.onUpdateTransform), ls.instance.remove(this.currentTransform.getHelper().name)), this.currentTransform = ls.instance.add(e.value.name), this.currentTransform.attach(this.selectedItem), this.helpersContainer.add(this.currentTransform.getHelper()), this.currentTransform.addEventListener("objectChange", this.onUpdateTransform), this.updateSelectedItemHelper(!0);
  };
  updateSelectedItemHelper(e) {
    if (this.selectedItem !== void 0)
      if (this.cameraVisibility) {
        if (this.selectedItem.isLight === !0 && !this.lightVisibility) {
          const t = this.lightHelpers.get(this.selectedItem.name);
          t !== void 0 && (t.visible = e);
        }
      } else {
        const t = this.cameraHelpers.get(this.selectedItem.name);
        t !== void 0 && (t.visible = e);
      }
  }
  onUpdateTransform = () => {
    this.selectedItem !== void 0 && (this.props.three.updateObject(this.selectedItem.uuid, "position", this.selectedItem.position), this.props.three.updateObject(this.selectedItem.uuid, "rotation", {
      x: this.selectedItem.rotation.x,
      y: this.selectedItem.rotation.y,
      z: this.selectedItem.rotation.z
    }), this.props.three.updateObject(this.selectedItem.uuid, "scale", this.selectedItem.scale), g2.instance.update());
  };
  // Utils
  clearLightHelpers = () => {
    this.lightHelpers.forEach((e) => {
      this.helpersContainer.remove(e), e.dispose();
    }), this.lightHelpers.clear();
  };
  addLightHelpers = (e) => {
    e.traverse((t) => {
      if (t.type.search("Light") > -1) {
        let n;
        switch (t.type) {
          case "DirectionalLight":
            n = new nke(t, 100), n.name = `${t.name}Helper`, n.visible = this.lightVisibility, this.lightHelpers.set(t.name, n), this.helpersContainer.add(n);
            break;
          case "HemisphereLight":
            n = new tke(t, 250), n.name = `${t.name}Helper`, n.visible = this.lightVisibility, this.lightHelpers.set(t.name, n), this.helpersContainer.add(n);
            break;
          case "RectAreaLight":
            n = new Rje(t), n.name = `${t.name}Helper`, n.visible = this.lightVisibility, this.lightHelpers.set(t.name, n), this.helpersContainer.add(n);
            break;
          case "PointLight":
            n = new eke(t, 100), n.name = `${t.name}Helper`, n.visible = this.lightVisibility, this.lightHelpers.set(t.name, n), this.helpersContainer.add(n);
            break;
          case "SpotLight":
            n = new JAe(t), n.name = `${t.name}Helper`, n.visible = this.lightVisibility, this.lightHelpers.set(t.name, n), this.helpersContainer.add(n);
            break;
        }
      }
    });
  };
  createControls(e, t) {
    const n = this.controls.get(e.name);
    if (n !== void 0 && n.dispose(), this.controls.delete(e.name), e.name === "UI") return;
    const i = new Nje(e, t);
    switch (i.enableDamping = !0, i.dampingFactor = 0.1, e.name) {
      case "Top":
      case "Bottom":
      case "Left":
      case "Right":
      case "Front":
      case "Back":
        i.enableRotate = !1;
        break;
    }
    this.controls.set(e.name, i);
  }
  clearCamera(e) {
    const t = this.cameraHelpers.get(e.name);
    t !== void 0 && (this.helpersContainer.remove(t), t.dispose(), this.cameraHelpers.delete(e.name));
    const n = this.controls.get(e.name);
    n !== void 0 && (n.dispose(), this.controls.delete(e.name));
  }
  killControls() {
    this.controls.forEach((e, t) => {
      e.dispose();
      const n = this.cameraHelpers.get(t);
      n !== void 0 && (this.helpersContainer.remove(n), n.dispose()), this.cameraHelpers.delete(t), this.controls.delete(t);
    }), this.controls.clear(), this.cameraHelpers.clear();
  }
  assignControls() {
    switch (this.state.mode) {
      case "Single":
        this.createControls(this.tlCam, this.tlWindow.current);
        break;
      case "Side by Side":
      case "Stacked":
        this.createControls(this.tlCam, this.tlWindow.current), this.createControls(this.trCam, this.trWindow.current);
        break;
      case "Quad":
        this.createControls(this.tlCam, this.tlWindow.current), this.createControls(this.trCam, this.trWindow.current), this.createControls(this.blCam, this.blWindow.current), this.createControls(this.brCam, this.brWindow.current);
        break;
    }
  }
  updateCamera = (e, t, n, i) => {
    switch (this.state.mode) {
      case "Quad":
        t < i ? e < n ? this.currentCamera = this.tlCam : this.currentCamera = this.trCam : e < n ? this.currentCamera = this.blCam : this.currentCamera = this.brCam;
        break;
      case "Side by Side":
        e < n ? this.currentCamera = this.tlCam : this.currentCamera = this.trCam;
        break;
      case "Single":
        this.currentCamera = this.tlCam;
        break;
      case "Stacked":
        t < i ? this.currentCamera = this.tlCam : this.currentCamera = this.trCam;
        break;
    }
    this.splineEditor.camera = this.currentCamera, this.raycaster.setFromCamera(this.pointer, this.currentCamera), this.currentCamera === this.tlCam ? this.currentWindow = this.tlWindow : this.currentCamera === this.trCam ? this.currentWindow = this.trWindow : this.currentCamera === this.blCam ? this.currentWindow = this.blWindow : this.currentCamera === this.brCam && (this.currentWindow = this.brWindow), ls.instance.updateCamera(this.currentCamera, this.currentWindow.current);
  };
  updateCameraControls = (e, t = !1) => {
    if (this.selectedItem === void 0) return;
    cancelAnimationFrame(this.cameraControlsRafID), this.cameraControlsRafID = -1, this.cameraControls && (this.cameraControls.smoothTime = 0.1);
    const n = 0.15, i = new rke();
    i.start(), this.selectedItem.getWorldPosition(e.target0);
    const o = () => {
      const l = i.getDelta();
      this.cameraControls && this.cameraControls.update(l), t && (e.target.lerp(e.target0, n), e.object.position.lerp(e.position0, n), e.object.zoom = SE(e.object.zoom, e.zoom0, n), e.object.updateProjectionMatrix(), e.dispatchEvent({ type: "change" })), i.getElapsedTime() >= 0.5 ? (cancelAnimationFrame(this.cameraControlsRafID), this.cameraControlsRafID = -1, this.clearControls()) : this.cameraControlsRafID = requestAnimationFrame(o);
    };
    o();
  };
  clearControls = () => {
    this.cameraControls !== void 0 && (this.cameraControls.disconnect(), this.cameraControls.dispose(), this.cameraControls = void 0);
  };
  saveExpandedCameraVisibility() {
    localStorage.setItem(this.expandedCameraVisibility, this.cameraVisibility ? "open" : "closed");
  }
  saveExpandedLightVisibility() {
    localStorage.setItem(this.expandedLightVisibility, this.lightVisibility ? "open" : "closed");
  }
  saveExpandedGridVisibility() {
    localStorage.setItem(this.expandedGridVisibility, this.gridVisibility ? "open" : "closed");
  }
  // Drawing
  getSceneOverride(e) {
    switch (e) {
      case "Depth":
        return this.depthMaterial;
      case "Normals":
        return this.normalsMaterial;
      case "Renderer":
        return null;
      case "UVs":
        return this.uvMaterial;
      case "Wireframe":
        return this.wireframeMaterial;
    }
    return null;
  }
  drawTo(e, t, n, i, o, l) {
    switch (o.name) {
      case "Left":
      case "Right":
        this.grid.rotation.z = Math.PI / 2;
        break;
      case "Front":
      case "Back":
        this.grid.rotation.x = Math.PI / 2;
        break;
    }
    this.scene.overrideMaterial = l, this.renderer && (this.renderer?.setViewport(e, t, n, i), this.renderer?.setScissor(e, t, n, i), this.renderer instanceof Zw ? this.renderer?.render(this.scene, o) : this.renderer instanceof eO && this.renderer?.renderAsync(this.scene, o)), this.grid.rotation.set(0, 0, 0);
  }
  drawSingle() {
    const e = this.getSceneOverride(this.tlRender);
    this.drawTo(0, 0, this.width, this.height, this.tlCam, e);
  }
  drawDouble = () => {
    const e = this.getSceneOverride(this.tlRender), t = this.getSceneOverride(this.trRender), n = Math.floor(this.width / 2), i = Math.floor(this.height / 2);
    if (this.state.mode === "Side by Side")
      this.drawTo(0, 0, n, this.height, this.tlCam, e), this.drawTo(n, 0, n, this.height, this.trCam, t);
    else {
      const o = this.height - i;
      this.drawTo(0, o, this.width, i, this.tlCam, e), this.drawTo(0, 0, this.width, i, this.trCam, t);
    }
  };
  drawQuad = () => {
    const e = this.getSceneOverride(this.tlRender), t = this.getSceneOverride(this.trRender), n = this.getSceneOverride(this.blRender), i = this.getSceneOverride(this.brRender), o = Math.floor(this.width / 2), l = Math.floor(this.height / 2);
    let p = 0, f = 0;
    f = this.height - l, p = 0, this.drawTo(p, f, o, l, this.tlCam, e), p = o, this.drawTo(p, f, o, l, this.trCam, t), f = 0, p = 0, this.scene.overrideMaterial = n, this.drawTo(p, f, o, l, this.blCam, n), p = o, this.drawTo(p, f, o, l, this.brCam, i);
  };
  // Getters
  get appID() {
    return this.props.three.name;
  }
  get mode() {
    return this.state.mode;
  }
  get three() {
    return this.props.three;
  }
  get expandedCameraVisibility() {
    return `${this.appID}_multiviewCameraVisibility`;
  }
  get expandedLightVisibility() {
    return `${this.appID}_multiviewLightVisibility`;
  }
  get expandedGridVisibility() {
    return `${this.appID}_multiviewGridVisibility`;
  }
}
class g2 extends RE {
  static instance;
  matrix = new IE();
  position = new Vt();
  rotation = new jge();
  scale = new Vt();
  open = !1;
  constructor(e) {
    super(e);
    const t = localStorage.getItem(this.expandedName), n = t !== null ? t === "open" : !1;
    this.open = n, this.saveExpanded(), this.state = {
      lastUpdated: 0,
      expanded: n
    }, this.matrix.elements = e.object.matrix, e.object.uuid.length > 0 && (this.position.setFromMatrixPosition(this.matrix), this.rotation.setFromRotationMatrix(this.matrix), this.scale.setFromMatrixScale(this.matrix)), g2.instance = this;
  }
  update() {
    if (Hi.instance) {
      const e = Hi.instance.selectedItem;
      if (e === void 0) return;
      this.position.x = au(e.position.x, 3), this.position.y = au(e.position.y, 3), this.position.z = au(e.position.z, 3), this.rotation.copy(e.rotation), this.scale.x = au(e.scale.x, 3), this.scale.y = au(e.scale.y, 3), this.scale.z = au(e.scale.z, 3), this.setState({ lastUpdated: Date.now() });
    }
  }
  render() {
    return /* @__PURE__ */ ke.jsx(
      dl,
      {
        three: this.props.three,
        title: "Transform",
        expanded: this.open,
        items: [
          {
            title: "Position",
            prop: "position",
            type: "grid3",
            step: 0.1,
            value: this.position,
            onChange: this.updateTransform
          },
          {
            title: "Rotation",
            prop: "rotation",
            type: "euler",
            value: this.rotation,
            onChange: this.updateTransform
          },
          {
            title: "Scale",
            prop: "scale",
            type: "grid3",
            value: this.scale,
            onChange: this.updateTransform
          },
          {
            title: "Visible",
            prop: "visible",
            type: "boolean",
            value: this.props.object.visible,
            onChange: this.updateTransform
          }
        ],
        onToggle: (e) => {
          this.open = e, this.saveExpanded();
        }
      },
      this.state.lastUpdated
    );
  }
  updateTransform = (e, t) => {
    const n = e === "rotation" ? { x: t._x, y: t._y, z: t._z } : t;
    this.props.three.updateObject(this.props.object.uuid, e, n);
    const i = this.props.three.getScene(this.props.object.uuid);
    if (i) {
      const o = i.getObjectByProperty("uuid", this.props.object.uuid);
      bi(o, e, n);
    }
  };
  saveExpanded() {
    localStorage.setItem(this.expandedName, this.open ? "open" : "closed");
  }
  get expandedName() {
    return `${this.props.three.name}_transform`;
  }
}
function vge(c) {
  switch (c) {
    case "color":
      return "Color";
    case "intensity":
      return "Intensity";
    case "decay":
      return "Decay";
    case "distance":
      return "Distance";
    case "angle":
      return "Angle";
    case "penumbra":
      return "Penumbra";
    case "groundColor":
      return "Ground Color";
    case "width":
      return "Width";
    case "height":
      return "Height";
  }
  return c;
}
function gUe(c, e) {
  function t() {
    return `${e.name}_light`;
  }
  const n = localStorage.getItem(t()), i = n !== null ? n === "open" : !1;
  function o(p) {
    localStorage.setItem(t(), p ? "open" : "closed");
  }
  const l = [];
  if (c.lightInfo !== void 0)
    for (const p in c.lightInfo) {
      const f = c.lightInfo[p];
      f !== void 0 && (f.isColor !== void 0 ? l.push({
        title: vge(p),
        prop: p,
        type: "color",
        value: f,
        onChange: (v, _) => {
          const E = new Ag(_);
          e.updateObject(c.uuid, v, E);
          const A = e.getScene(c.uuid);
          if (A !== null) {
            const I = A.getObjectByProperty("uuid", c.uuid);
            bi(I, v, E);
          }
        }
      }) : l.push({
        title: vge(p),
        prop: p,
        type: typeof f,
        value: f,
        step: typeof f == "number" ? 0.01 : void 0,
        onChange: (v, _) => {
          e.updateObject(c.uuid, v, _);
          const E = e.getScene(c.uuid);
          if (E !== null) {
            const A = E.getObjectByProperty("uuid", c.uuid);
            bi(A, v, _);
          }
        }
      }));
    }
  return /* @__PURE__ */ ke.jsx(
    dl,
    {
      three: e,
      title: "Light",
      items: l,
      expanded: i,
      onToggle: (p) => {
        o(p);
      }
    }
  );
}
function yUe(c) {
  const e = c.object, t = c.three;
  function n() {
    return `${t.name}_animation`;
  }
  const i = localStorage.getItem(n()), o = i !== null ? i === "open" : !1;
  function l(A) {
    localStorage.setItem(n(), A ? "open" : "closed");
  }
  const p = [], f = [];
  let v = 0;
  e.animations.forEach((A) => {
    v = Math.max(v, A.duration), A.duration > 0 && f.push({
      title: A.name,
      items: [
        {
          title: "Duration",
          type: "number",
          value: A.duration,
          disabled: !0
        },
        {
          title: "Blend Mode",
          type: "option",
          disabled: !0,
          options: [
            {
              title: "Normal",
              value: 2500
            },
            {
              title: "Additive",
              value: 2501
            }
          ]
        }
      ]
    });
  }), p.push({
    title: "Animations",
    items: f
  });
  let _;
  const E = t.getScene(e.uuid);
  if (E !== null) {
    const A = E.getObjectByProperty("uuid", e.uuid);
    if (A !== void 0) {
      const I = A.mixer;
      if (I !== void 0) {
        const q = [
          {
            title: "Time Scale",
            type: "range",
            value: I.timeScale,
            step: 0.01,
            min: -1,
            max: 2,
            onChange: (L, V) => {
              I.timeScale = V, t.updateObject(e.uuid, "mixer.timeScale", V);
            }
          }
        ];
        q.push({
          title: "Stop All",
          type: "button",
          onChange: () => {
            I.stopAllAction(), t.requestMethod(e.uuid, "stopAllAction", void 0, "mixer");
          }
        }), p.push({
          title: "Mixer",
          items: q
        }), _ = new ike(A), Hi.instance?.scene.add(_);
      }
    }
  }
  return Pg(() => () => {
    _ !== void 0 && Hd(_);
  }, []), /* @__PURE__ */ ke.jsx(
    dl,
    {
      three: c.three,
      title: "Animation",
      items: p,
      expanded: o,
      onToggle: (A) => {
        l(A);
      }
    }
  );
}
const RV = {
  name: "",
  uuid: "",
  type: "",
  visible: !1,
  matrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
  animations: [],
  material: void 0,
  perspectiveCameraInfo: void 0,
  orthographicCameraInfo: void 0,
  lightInfo: void 0,
  children: []
};
function vUe(c) {
  const [e, t] = nr(RV);
  Pg(() => {
    function l(f) {
      t(f.value);
    }
    function p() {
      t(RV);
    }
    return c.three.addEventListener(Cn.CLEAR_OBJECT, p), c.three.addEventListener(Cn.SET_SCENE, p), c.three.addEventListener(Cn.SET_OBJECT, l), () => {
      c.three.removeEventListener(Cn.CLEAR_OBJECT, p), c.three.removeEventListener(Cn.SET_SCENE, p), c.three.removeEventListener(Cn.SET_OBJECT, l);
    };
  }, []);
  const n = e.type.toLowerCase(), i = e.animations.length > 0 || e.mixer !== void 0, o = n.search("mesh") > -1 || n.search("line") > -1 || n.search("points") > -1;
  return /* @__PURE__ */ ke.jsx(
    dE,
    {
      three: c.three,
      label: "Inspector",
      button: e.uuid.length > 0 ? /* @__PURE__ */ ke.jsx("button", { className: "remove", onClick: () => {
        ls.instance.remove(e.name), t(RV);
      } }) : void 0,
      children: /* @__PURE__ */ ke.jsx("div", { id: "Inspector", className: c.class, children: e.uuid.length > 0 && /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
        /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
          /* @__PURE__ */ ke.jsx(
            cO,
            {
              type: "string",
              title: "Name",
              prop: "name",
              value: e.name,
              disabled: !0
            }
          ),
          /* @__PURE__ */ ke.jsx(
            cO,
            {
              type: "string",
              title: "Type",
              prop: "type",
              value: e.type,
              disabled: !0
            }
          ),
          /* @__PURE__ */ ke.jsx(
            cO,
            {
              type: "string",
              title: "UUID",
              prop: "uuid",
              value: e.uuid,
              disabled: !0
            }
          )
        ] }),
        /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
          /* @__PURE__ */ ke.jsx(g2, { object: e, three: c.three }),
          i ? /* @__PURE__ */ ke.jsx(yUe, { object: e, three: c.three }) : null,
          n.search("camera") > -1 ? LMe(e, c.three) : null,
          n.search("light") > -1 ? gUe(e, c.three) : null,
          o ? DMe(e, c.three) : null
        ] })
      ] }) })
    },
    "Inspector"
  );
}
class bUe extends RE {
  // Renderer
  autoClear = !0;
  autoClearColor = !0;
  autoClearDepth = !0;
  autoClearStencil = !0;
  outputColorSpace = kpe;
  localClippingEnabled = !1;
  clearColor = new Ag(0);
  clearAlpha = 1;
  toneMapping = Mpe;
  toneMappingExposure = 1;
  type = "";
  constructor(e) {
    super(e);
    const t = localStorage.getItem(this.expandedName), n = t !== null ? t === "open" : !1;
    if (this.state = {
      expanded: n,
      lastUpdated: Date.now()
    }, this.saveExpanded(n), Hi.instance) {
      const i = Hi.instance.renderer;
      i && (this.autoClear = i.autoClear, this.autoClearColor = i.autoClearColor, this.autoClearDepth = i.autoClearDepth, this.autoClearStencil = i.autoClearStencil, this.clearAlpha = i.getClearAlpha(), this.toneMapping = i.toneMapping, this.toneMappingExposure = i.toneMappingExposure, i instanceof Zw && (this.localClippingEnabled = i.localClippingEnabled, i.getClearColor(this.clearColor)));
    }
    this.props.three.addEventListener(Cn.ADD_RENDERER, this.onAddRenderer);
  }
  componentwillunmount() {
    this.props.three.removeEventListener(Cn.ADD_RENDERER, this.onAddRenderer);
  }
  onAddRenderer = (e) => {
    const t = e.value;
    if (this.autoClear = t.autoClear, this.autoClearColor = t.autoClearColor, this.autoClearDepth = t.autoClearDepth, this.autoClearStencil = t.autoClearStencil, this.outputColorSpace = t.outputColorSpace, this.localClippingEnabled = t.localClippingEnabled, this.clearAlpha = t.clearAlpha, this.type = t.type, this.toneMapping = t.toneMapping, this.toneMappingExposure = t.toneMappingExposure, this.clearColor.setStyle(t.clearColor, xE), _b.enabled = t.colorManagement, Hi.instance) {
      const n = Hi.instance.renderer;
      n && (n.autoClearColor = this.autoClearColor, n.outputColorSpace = this.outputColorSpace, n.localClippingEnabled = this.localClippingEnabled, n.toneMapping = this.toneMapping, n.toneMappingExposure = this.toneMappingExposure, n.setClearColor(t.clearColor, this.clearAlpha));
    }
    this.setState({ lastUpdated: Date.now() });
  };
  render() {
    const e = () => {
      if (Hi.instance) {
        const t = Hi.instance.renderer;
        t && (t.autoClearColor = this.autoClearColor, t.outputColorSpace = this.outputColorSpace, t.localClippingEnabled = this.localClippingEnabled, t.toneMapping = this.toneMapping, t.toneMappingExposure = this.toneMappingExposure, t.setClearColor(this.clearColor.getStyle(), this.clearAlpha), this.props.three.updateRenderer({
          autoClear: this.autoClear,
          autoClearColor: this.autoClearColor,
          autoClearDepth: this.autoClearDepth,
          autoClearStencil: this.autoClearStencil,
          outputColorSpace: this.outputColorSpace,
          localClippingEnabled: this.localClippingEnabled,
          clearAlpha: this.clearAlpha,
          clearColor: this.clearColor.getStyle(),
          colorManagement: _b.enabled,
          toneMapping: this.toneMapping,
          toneMappingExposure: this.toneMappingExposure
        }));
      }
    };
    return /* @__PURE__ */ ke.jsx(
      dl,
      {
        three: this.props.three,
        title: "Renderer",
        expanded: this.state.expanded,
        items: [
          {
            type: "boolean",
            title: "Auto Clear",
            value: this.autoClear,
            onChange: (t, n) => {
              this.autoClear = n;
            }
          },
          {
            type: "boolean",
            title: "Auto Clear Color",
            value: this.autoClearColor,
            onChange: (t, n) => {
              this.autoClearColor = n, e();
            }
          },
          {
            type: "boolean",
            title: "Auto Clear Depth",
            value: this.autoClearDepth,
            onChange: (t, n) => {
              this.autoClearDepth = n, e();
            }
          },
          {
            type: "boolean",
            title: "Auto Clear Stencil",
            value: this.autoClearStencil,
            onChange: (t, n) => {
              this.autoClearStencil = n, e();
            }
          },
          {
            type: "boolean",
            title: "Local Clipping",
            value: this.localClippingEnabled,
            onChange: (t, n) => {
              this.localClippingEnabled = n, e();
            }
          },
          {
            type: "color",
            title: "Clear Color",
            value: `#${this.clearColor.getHexString()}`,
            onChange: (t, n) => {
              this.clearColor.setStyle(n), e();
            }
          },
          {
            type: "range",
            title: "Clear Alpha",
            min: 0,
            max: 1,
            step: 0.01,
            value: this.clearAlpha,
            onChange: (t, n) => {
              this.clearAlpha = n, e();
            }
          },
          {
            type: "boolean",
            title: "Color Management",
            value: _b.enabled,
            onChange: (t, n) => {
              _b.enabled = n, e();
            }
          },
          {
            type: "option",
            title: "Color Space",
            value: this.outputColorSpace,
            options: [
              {
                title: "No Color Space",
                value: ske
              },
              {
                title: "SRB Color Space",
                value: kpe
              },
              {
                title: "Linear SRB Color Space",
                value: xE
              }
            ],
            onChange: (t, n) => {
              this.outputColorSpace = n, e();
            }
          },
          {
            type: "option",
            title: "Tone Mapping",
            value: this.toneMapping,
            options: [
              {
                title: "None ",
                value: Mpe
              },
              {
                title: "Linear ",
                value: oke
              },
              {
                title: "Reinhard",
                value: ake
              },
              {
                title: "Cineon ",
                value: lke
              },
              {
                title: "ACES Filmic",
                value: uke
              },
              {
                title: "AgX",
                value: cke
              },
              {
                title: "Neutral",
                value: dke
              },
              {
                title: "Custom",
                value: hke
              }
            ],
            onChange: (t, n) => {
              this.toneMapping = n, e();
            }
          },
          {
            type: "range",
            title: "Tone Mapping Exposure",
            value: this.toneMappingExposure,
            min: 0,
            max: 2,
            step: 0.01,
            onChange: (t, n) => {
              this.toneMappingExposure = n, e();
            }
          },
          {
            type: "string",
            title: "Type",
            value: this.type,
            disabled: !0
          },
          {
            type: "button",
            title: "Resize Scenes from Source",
            onChange: () => {
              this.props.three.requestSize();
            }
          }
        ],
        onToggle: (t) => {
          this.setState({ expanded: t }), this.saveExpanded(t);
        }
      },
      Math.random()
    );
  }
  saveExpanded(e) {
    localStorage.setItem(this.expandedName, e ? "open" : "closed");
  }
  get expandedName() {
    return `${this.props.three.name}_renderer`;
  }
}
function xUe(c) {
  const [e] = nr([]), [t] = nr([]), [n, i] = nr(0), o = (v) => {
    const _ = v.value;
    e.push(_), t.push(
      /* @__PURE__ */ ke.jsx(
        dE,
        {
          three: c.three,
          label: `Scene: ${_.name}`,
          scene: _,
          open: !1,
          visible: !1,
          onRefresh: () => {
            c.three.refreshScene(_.name);
          },
          children: /* @__PURE__ */ ke.jsx(l5, { child: _, scene: _, three: c.three })
        },
        _.name
      )
    ), i(Date.now());
  }, l = (v) => {
    const _ = v.value;
    for (let E = 0; E < e.length; E++)
      if (_.uuid === e[E].uuid) {
        e[E] = _, t[E] = /* @__PURE__ */ ke.jsx(
          dE,
          {
            three: c.three,
            label: `Scene: ${_.name}`,
            scene: _,
            open: t[E].props.open,
            visible: t[E].props.visible,
            onRefresh: () => {
              c.three.refreshScene(_.name);
            },
            children: /* @__PURE__ */ ke.jsx(l5, { child: _, scene: _, three: c.three })
          },
          _.name
        ), i(Date.now());
        return;
      }
  }, p = (v) => {
    const _ = v.value;
    for (let E = 0; E < e.length; E++)
      if (_.uuid === e[E].uuid) {
        e.splice(E, 1), t.splice(E, 1), i(Date.now());
        return;
      }
  }, f = (v) => {
    const _ = v.value.name;
    for (let E = 0; E < e.length; E++) {
      const A = e[E], I = A.name === _;
      t[E] = /* @__PURE__ */ ke.jsx(
        dE,
        {
          three: c.three,
          label: `Scene: ${A.name}`,
          scene: A,
          open: I,
          visible: I,
          onRefresh: () => {
            c.three.refreshScene(A.name);
          },
          children: /* @__PURE__ */ ke.jsx(l5, { child: A, scene: A, three: c.three })
        },
        A.name
      );
    }
    i(Date.now());
  };
  return Pg(() => (c.three.addEventListener(Cn.ADD_SCENE, o), c.three.addEventListener(Cn.SET_SCENE, f), c.three.addEventListener(Cn.REFRESH_SCENE, l), c.three.addEventListener(Cn.REMOVE_SCENE, p), () => {
    c.three.removeEventListener(Cn.ADD_SCENE, o), c.three.removeEventListener(Cn.SET_SCENE, f), c.three.removeEventListener(Cn.REFRESH_SCENE, l), c.three.removeEventListener(Cn.REMOVE_SCENE, p);
  }), []), /* @__PURE__ */ ke.jsxs("div", { id: "SidePanel", children: [
    /* @__PURE__ */ ke.jsx("div", { className: "scenes", children: t }, n),
    /* @__PURE__ */ ke.jsx(vUe, { three: c.three }),
    /* @__PURE__ */ ke.jsx(bUe, { three: c.three }),
    /* @__PURE__ */ ke.jsx(Vn, { three: c.three })
  ] });
}
function _Ue(c) {
  return /* @__PURE__ */ ke.jsxs("div", { className: "editor", ref: c.ref, style: c.style, children: [
    /* @__PURE__ */ ke.jsx("div", { className: "header", children: c.header }),
    c.children,
    /* @__PURE__ */ ke.jsx("div", { className: "footer", children: c.footer })
  ] });
}
function uze(c) {
  return /* @__PURE__ */ ke.jsx(_Ue, { children: /* @__PURE__ */ ke.jsxs(ke.Fragment, { children: [
    /* @__PURE__ */ ke.jsx(
      Hi,
      {
        three: c.three,
        scenes: c.scenes,
        onSceneAdd: c.onSceneAdd,
        onSceneResize: c.onSceneResize,
        onSceneUpdate: c.onSceneUpdate
      }
    ),
    /* @__PURE__ */ ke.jsx(xUe, { three: c.three })
  ] }) });
}
var uE = { exports: {} };
uE.exports;
var bge;
function SUe() {
  return bge || (bge = 1, function(c, e) {
    var t = Object.create, n = Object.freeze, i = Object.defineProperty, o = Object.defineProperties, l = Object.getOwnPropertyDescriptor, p = Object.getOwnPropertyDescriptors, f = Object.getOwnPropertyNames, v = Object.getOwnPropertySymbols, _ = Object.getPrototypeOf, E = Object.prototype.hasOwnProperty, A = Object.prototype.propertyIsEnumerable, I = (r, s) => {
      if (s = Symbol[r]) return s;
      throw Error("Symbol." + r + " is not defined");
    }, j = Math.pow, q = (r, s, a) => s in r ? i(r, s, { enumerable: !0, configurable: !0, writable: !0, value: a }) : r[s] = a, L = (r, s) => {
      for (var a in s || (s = {})) E.call(s, a) && q(r, a, s[a]);
      if (v) for (var a of v(s)) A.call(s, a) && q(r, a, s[a]);
      return r;
    }, V = (r, s) => o(r, p(s)), re = (r, s) => {
      var a = {};
      for (var d in r) E.call(r, d) && s.indexOf(d) < 0 && (a[d] = r[d]);
      if (r != null && v) for (var d of v(r)) s.indexOf(d) < 0 && A.call(r, d) && (a[d] = r[d]);
      return a;
    }, R = (r, s) => () => (r && (s = r(r = 0)), s), J = (r, s) => () => (s || r((s = { exports: {} }).exports, s), s.exports), ge = (r, s) => {
      for (var a in s) i(r, a, { get: s[a], enumerable: !0 });
    }, _e = (r, s, a, d) => {
      if (s && typeof s == "object" || typeof s == "function") for (let m of f(s)) !E.call(r, m) && m !== a && i(r, m, { get: () => s[m], enumerable: !(d = l(s, m)) || d.enumerable });
      return r;
    }, Y = (r, s, a) => (a = r != null ? t(_(r)) : {}, _e(s || !r || !r.__esModule ? i(a, "default", { value: r, enumerable: !0 }) : a, r)), Fe = (r) => _e(i({}, "__esModule", { value: !0 }), r), Me = (r, s, a) => (q(r, typeof s != "symbol" ? s + "" : s, a), a), $ = (r, s) => n(i(r, "raw", { value: n(r.slice()) })), dt = (r, s, a) => new Promise((d, m) => {
      var y = (T) => {
        try {
          w(a.next(T));
        } catch (P) {
          m(P);
        }
      }, x = (T) => {
        try {
          w(a.throw(T));
        } catch (P) {
          m(P);
        }
      }, w = (T) => T.done ? d(T.value) : Promise.resolve(T.value).then(y, x);
      w((a = a.apply(r, s)).next());
    }), wt = function(r, s) {
      this[0] = r, this[1] = s;
    }, St = (r) => {
      var s = r[I("asyncIterator")], a = !1, d, m = {};
      return s == null ? (s = r[I("iterator")](), d = (y) => m[y] = (x) => s[y](x)) : (s = s.call(r), d = (y) => m[y] = (x) => {
        if (a) {
          if (a = !1, y === "throw") throw x;
          return x;
        }
        return a = !0, { done: !1, value: new wt(new Promise((w) => {
          var T = s[y](x);
          if (!(T instanceof Object)) throw TypeError("Object expected");
          w(T);
        }), 1) };
      }), m[I("iterator")] = () => m, d("next"), "throw" in s ? d("throw") : m.throw = (y) => {
        throw y;
      }, "return" in s && d("return"), m;
    };
    function Ct(r) {
      Tt = r;
    }
    function pe() {
      return Tt;
    }
    var Tt, st = R(() => {
    });
    function Zt(r) {
      return (s) => typeof s == "object" && !!s && s.type === r;
    }
    var $t, Ht, Gn, an, An, pr, Kn, Qo, _r = R(() => {
      $t = Zt("Theatre_Project"), Ht = Zt("Theatre_Sheet"), Gn = Zt("Theatre_SheetTemplate"), an = Zt("Theatre_SheetObject"), An = Zt("Theatre_Sequence"), pr = Zt("Theatre_SheetObjectTemplate"), Kn = Zt("Theatre_Sheet_PublicAPI"), Qo = Zt("Theatre_SheetObject_PublicAPI");
    }), Ta, fl, Ca = R(() => {
      Ta = typeof ks == "object" && ks && ks.Object === Object && ks, fl = Ta;
    }), Pa, Cc, Fi, Ki = R(() => {
      Ca(), Pa = typeof self == "object" && self && self.Object === Object && self, Cc = fl || Pa || Function("return this")(), Fi = Cc;
    }), ml, Qr, Zo = R(() => {
      Ki(), ml = Fi.Symbol, Qr = ml;
    });
    function fu(r) {
      var s = Pc.call(r, Si), a = r[Si];
      try {
        r[Si] = void 0;
        var d = !0;
      } catch {
      }
      var m = Jd.call(r);
      return d && (s ? r[Si] = a : delete r[Si]), m;
    }
    var Jo, Pc, Jd, Si, eh, to = R(() => {
      Zo(), Jo = Object.prototype, Pc = Jo.hasOwnProperty, Jd = Jo.toString, Si = Qr ? Qr.toStringTag : void 0, eh = fu;
    });
    function th(r) {
      return Aa.call(r);
    }
    var Ac, Aa, nh, rh = R(() => {
      Ac = Object.prototype, Aa = Ac.toString, nh = th;
    });
    function ih(r) {
      return r == null ? r === void 0 ? sh : mu : Bi && Bi in Object(r) ? eh(r) : nh(r);
    }
    var mu, sh, Bi, _o, ka = R(() => {
      Zo(), to(), rh(), mu = "[object Null]", sh = "[object Undefined]", Bi = Qr ? Qr.toStringTag : void 0, _o = ih;
    });
    function of(r) {
      return r != null && typeof r == "object";
    }
    var Ms, ds = R(() => {
      Ms = of;
    });
    function kc(r) {
      return typeof r == "symbol" || Ms(r) && _o(r) == hs;
    }
    var hs, ps, So = R(() => {
      ka(), ds(), hs = "[object Symbol]", ps = kc;
    });
    function oh(r, s) {
      for (var a = -1, d = r == null ? 0 : r.length, m = Array(d); ++a < d; ) m[a] = s(r[a], a, r);
      return m;
    }
    var Ma, gu = R(() => {
      Ma = oh;
    }), ah, ci, Or = R(() => {
      ah = Array.isArray, ci = ah;
    });
    function lh(r) {
      if (typeof r == "string") return r;
      if (ci(r)) return Ma(r, lh) + "";
      if (ps(r)) return vu ? vu.call(r) : "";
      var s = r + "";
      return s == "0" && 1 / r == -uh ? "-0" : s;
    }
    var uh, yu, vu, ch, af = R(() => {
      Zo(), gu(), Or(), So(), uh = 1 / 0, yu = Qr ? Qr.prototype : void 0, vu = yu ? yu.toString : void 0, ch = lh;
    });
    function lf(r) {
      for (var s = r.length; s-- && dh.test(r.charAt(s)); ) ;
      return s;
    }
    var dh, be, ht = R(() => {
      dh = /\s/, be = lf;
    });
    function Pt(r) {
      return r && r.slice(0, be(r) + 1).replace(Wt, "");
    }
    var Wt, vn, qn = R(() => {
      ht(), Wt = /^\s+/, vn = Pt;
    });
    function fn(r) {
      var s = typeof r;
      return r != null && (s == "object" || s == "function");
    }
    var Gt, rr = R(() => {
      Gt = fn;
    });
    function Sr(r) {
      if (typeof r == "number") return r;
      if (ps(r)) return fr;
      if (Gt(r)) {
        var s = typeof r.valueOf == "function" ? r.valueOf() : r;
        r = Gt(s) ? s + "" : s;
      }
      if (typeof r != "string") return r === 0 ? r : +r;
      r = vn(r);
      var a = ea.test(r);
      return a || wo.test(r) ? di(r.slice(2), a ? 2 : 8) : Li.test(r) ? fr : +r;
    }
    var fr, Li, ea, wo, di, fs, gl = R(() => {
      qn(), rr(), So(), fr = NaN, Li = /^[-+]0x[0-9a-f]+$/i, ea = /^0b[01]+$/i, wo = /^0o[0-7]+$/i, di = parseInt, fs = Sr;
    });
    function uf(r) {
      if (!r) return r === 0 ? r : 0;
      if (r = fs(r), r === Ra || r === -Ra) {
        var s = r < 0 ? -1 : 1;
        return s * Ng;
      }
      return r === r ? r : 0;
    }
    var Ra, Ng, hh, Og = R(() => {
      gl(), Ra = 1 / 0, Ng = 17976931348623157e292, hh = uf;
    });
    function Jb(r) {
      var s = hh(r), a = s % 1;
      return s === s ? a ? s - a : s : 0;
    }
    var Eo, Mc = R(() => {
      Og(), Eo = Jb;
    });
    function ex(r) {
      return r;
    }
    var Rc, yl = R(() => {
      Rc = ex;
    });
    function cf(r) {
      if (!Gt(r)) return !1;
      var s = _o(r);
      return s == Ic || s == Fg || s == Dg || s == Bg;
    }
    var Dg, Ic, Fg, Bg, df, Lg = R(() => {
      ka(), rr(), Dg = "[object AsyncFunction]", Ic = "[object Function]", Fg = "[object GeneratorFunction]", Bg = "[object Proxy]", df = cf;
    }), jg, ta, Ug = R(() => {
      Ki(), jg = Fi["__core-js_shared__"], ta = jg;
    });
    function tx(r) {
      return !!Nc && Nc in r;
    }
    var Nc, zg, bu = R(() => {
      Ug(), Nc = function() {
        var r = /[^.]+$/.exec(ta && ta.keys && ta.keys.IE_PROTO || "");
        return r ? "Symbol(src)_1." + r : "";
      }(), zg = tx;
    });
    function ph(r) {
      if (r != null) {
        try {
          return xu.call(r);
        } catch {
        }
        try {
          return r + "";
        } catch {
        }
      }
      return "";
    }
    var Vg, xu, Ia, Gg = R(() => {
      Vg = Function.prototype, xu = Vg.toString, Ia = ph;
    });
    function nx(r) {
      if (!Gt(r) || zg(r)) return !1;
      var s = df(r) ? Wg : Hg;
      return s.test(Ia(r));
    }
    var qg, Hg, _u, hf, pf, $g, Wg, Kg, rx = R(() => {
      Lg(), bu(), rr(), Gg(), qg = /[\\^$.*+?()[\]{}|]/g, Hg = /^\[object .+?Constructor\]$/, _u = Function.prototype, hf = Object.prototype, pf = _u.toString, $g = hf.hasOwnProperty, Wg = RegExp("^" + pf.call($g).replace(qg, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Kg = nx;
    });
    function ix(r, s) {
      return r?.[s];
    }
    var Yg, Su = R(() => {
      Yg = ix;
    });
    function fh(r, s) {
      var a = Yg(r, s);
      return Kg(a) ? a : void 0;
    }
    var Na, na = R(() => {
      rx(), Su(), Na = fh;
    }), Xg, mh, sx = R(() => {
      na(), Ki(), Xg = Na(Fi, "WeakMap"), mh = Xg;
    }), ff, Qg, Zg, ox = R(() => {
      rr(), ff = Object.create, Qg = /* @__PURE__ */ function() {
        function r() {
        }
        return function(s) {
          if (!Gt(s)) return {};
          if (ff) return ff(s);
          r.prototype = s;
          var a = new r();
          return r.prototype = void 0, a;
        };
      }(), Zg = Qg;
    });
    function ax(r, s, a) {
      switch (a.length) {
        case 0:
          return r.call(s);
        case 1:
          return r.call(s, a[0]);
        case 2:
          return r.call(s, a[0], a[1]);
        case 3:
          return r.call(s, a[0], a[1], a[2]);
      }
      return r.apply(s, a);
    }
    var mf, lx = R(() => {
      mf = ax;
    });
    function Jg() {
    }
    var gf, ey = R(() => {
      gf = Jg;
    });
    function ty(r, s) {
      var a = -1, d = r.length;
      for (s || (s = Array(d)); ++a < d; ) s[a] = r[a];
      return s;
    }
    var yf, Oc = R(() => {
      yf = ty;
    });
    function ny(r) {
      var s = 0, a = 0;
      return function() {
        var d = To(), m = ry - (d - a);
        if (a = d, m > 0) {
          if (++s >= wu) return arguments[0];
        } else s = 0;
        return r.apply(void 0, arguments);
      };
    }
    var wu, ry, To, Eu, gh = R(() => {
      wu = 800, ry = 16, To = Date.now, Eu = ny;
    });
    function vf(r) {
      return function() {
        return r;
      };
    }
    var Oa, iy = R(() => {
      Oa = vf;
    }), vl, Dr, Dc = R(() => {
      na(), vl = function() {
        try {
          var r = Na(Object, "defineProperty");
          return r({}, "", {}), r;
        } catch {
        }
      }(), Dr = vl;
    }), yh, sy, bl = R(() => {
      iy(), Dc(), yl(), yh = Dr ? function(r, s) {
        return Dr(r, "toString", { configurable: !0, enumerable: !1, value: Oa(s), writable: !0 });
      } : Rc, sy = yh;
    }), Tu, oy, ux = R(() => {
      bl(), gh(), Tu = Eu(sy), oy = Tu;
    });
    function bf(r, s) {
      for (var a = -1, d = r == null ? 0 : r.length; ++a < d && s(r[a], a, r) !== !1; ) ;
      return r;
    }
    var ay, ly = R(() => {
      ay = bf;
    });
    function cx(r, s, a, d) {
      for (var m = r.length, y = a + (d ? 1 : -1); d ? y-- : ++y < m; ) if (s(r[y], y, r)) return y;
      return -1;
    }
    var Cu, xf = R(() => {
      Cu = cx;
    });
    function uy(r) {
      return r !== r;
    }
    var _f, vh = R(() => {
      _f = uy;
    });
    function wi(r, s, a) {
      for (var d = a - 1, m = r.length; ++d < m; ) if (r[d] === s) return d;
      return -1;
    }
    var cy, Sf = R(() => {
      cy = wi;
    });
    function dy(r, s, a) {
      return s === s ? cy(r, s, a) : Cu(r, _f, a);
    }
    var bh, Yi = R(() => {
      xf(), vh(), Sf(), bh = dy;
    });
    function dx(r, s) {
      var a = r == null ? 0 : r.length;
      return !!a && bh(r, s, 0) > -1;
    }
    var hy, hx = R(() => {
      Yi(), hy = dx;
    });
    function py(r, s) {
      var a = typeof r;
      return s = s ?? fy, !!s && (a == "number" || a != "symbol" && si.test(r)) && r > -1 && r % 1 == 0 && r < s;
    }
    var fy, si, ra, Da = R(() => {
      fy = 9007199254740991, si = /^(?:0|[1-9]\d*)$/, ra = py;
    });
    function Fc(r, s, a) {
      s == "__proto__" && Dr ? Dr(r, s, { configurable: !0, enumerable: !0, value: a, writable: !0 }) : r[s] = a;
    }
    var Pu, Un = R(() => {
      Dc(), Pu = Fc;
    });
    function wf(r, s) {
      return r === s || r !== r && s !== s;
    }
    var Bc, Lc = R(() => {
      Bc = wf;
    });
    function my(r, s, a) {
      var d = r[s];
      (!(gy.call(r, s) && Bc(d, a)) || a === void 0 && !(s in r)) && Pu(r, s, a);
    }
    var Ef, gy, xl, jc = R(() => {
      Un(), Lc(), Ef = Object.prototype, gy = Ef.hasOwnProperty, xl = my;
    });
    function px(r, s, a, d) {
      var m = !a;
      a || (a = {});
      for (var y = -1, x = s.length; ++y < x; ) {
        var w = s[y], T = d ? d(a[w], r[w], w, a, r) : void 0;
        T === void 0 && (T = r[w]), m ? Pu(a, w, T) : xl(a, w, T);
      }
      return a;
    }
    var Uc, Au = R(() => {
      jc(), Un(), Uc = px;
    });
    function fx(r, s, a) {
      return s = Tf(s === void 0 ? r.length - 1 : s, 0), function() {
        for (var d = arguments, m = -1, y = Tf(d.length - s, 0), x = Array(y); ++m < y; ) x[m] = d[s + m];
        m = -1;
        for (var w = Array(s + 1); ++m < s; ) w[m] = d[m];
        return w[s] = a(x), mf(r, this, w);
      };
    }
    var Tf, K, ae = R(() => {
      lx(), Tf = Math.max, K = fx;
    });
    function Pe(r, s) {
      return oy(K(r, s, Rc), r + "");
    }
    var Ye, Kt = R(() => {
      yl(), ae(), ux(), Ye = Pe;
    });
    function zn(r) {
      return typeof r == "number" && r > -1 && r % 1 == 0 && r <= Ei;
    }
    var Ei, ms, xh = R(() => {
      Ei = 9007199254740991, ms = zn;
    });
    function ku(r) {
      return r != null && ms(r.length) && !df(r);
    }
    var Co, _h = R(() => {
      Lg(), xh(), Co = ku;
    });
    function y2(r, s, a) {
      if (!Gt(a)) return !1;
      var d = typeof s;
      return (d == "number" ? Co(a) && ra(s, a.length) : d == "string" && s in a) ? Bc(a[s], r) : !1;
    }
    var mx, v2 = R(() => {
      Lc(), _h(), Da(), rr(), mx = y2;
    });
    function b2(r) {
      var s = r && r.constructor, a = typeof s == "function" && s.prototype || jE;
      return r === a;
    }
    var jE, yy, gx = R(() => {
      jE = Object.prototype, yy = b2;
    });
    function vy(r, s) {
      for (var a = -1, d = Array(r); ++a < r; ) d[a] = s(a);
      return d;
    }
    var UE, x2 = R(() => {
      UE = vy;
    });
    function yx(r) {
      return Ms(r) && _o(r) == zE;
    }
    var zE, by, _2 = R(() => {
      ka(), ds(), zE = "[object Arguments]", by = yx;
    }), vx, xy, VE, GE, _y, bx = R(() => {
      _2(), ds(), vx = Object.prototype, xy = vx.hasOwnProperty, VE = vx.propertyIsEnumerable, GE = by(/* @__PURE__ */ function() {
        return arguments;
      }()) ? by : function(r) {
        return Ms(r) && xy.call(r, "callee") && !VE.call(r, "callee");
      }, _y = GE;
    });
    function qE() {
      return !1;
    }
    var xx, S2 = R(() => {
      xx = qE;
    }), _x, Sx, wx, Ex, HE, Tx, Sh, Cx = R(() => {
      Ki(), S2(), _x = e && !e.nodeType && e, Sx = _x && !0 && c && !c.nodeType && c, wx = Sx && Sx.exports === _x, Ex = wx ? Fi.Buffer : void 0, HE = Ex ? Ex.isBuffer : void 0, Tx = HE || xx, Sh = Tx;
    });
    function $E(r) {
      return Ms(r) && ms(r.length) && !!mr[_o(r)];
    }
    var WE, KE, Cf, YE, XE, QE, ZE, JE, eT, tT, nT, rT, iT, sT, oT, aT, lT, uT, cT, dT, hT, pT, fT, mT, mr, gT, w2 = R(() => {
      ka(), xh(), ds(), WE = "[object Arguments]", KE = "[object Array]", Cf = "[object Boolean]", YE = "[object Date]", XE = "[object Error]", QE = "[object Function]", ZE = "[object Map]", JE = "[object Number]", eT = "[object Object]", tT = "[object RegExp]", nT = "[object Set]", rT = "[object String]", iT = "[object WeakMap]", sT = "[object ArrayBuffer]", oT = "[object DataView]", aT = "[object Float32Array]", lT = "[object Float64Array]", uT = "[object Int8Array]", cT = "[object Int16Array]", dT = "[object Int32Array]", hT = "[object Uint8Array]", pT = "[object Uint8ClampedArray]", fT = "[object Uint16Array]", mT = "[object Uint32Array]", mr = {}, mr[aT] = mr[lT] = mr[uT] = mr[cT] = mr[dT] = mr[hT] = mr[pT] = mr[fT] = mr[mT] = !0, mr[WE] = mr[KE] = mr[sT] = mr[Cf] = mr[oT] = mr[YE] = mr[XE] = mr[QE] = mr[ZE] = mr[JE] = mr[eT] = mr[tT] = mr[nT] = mr[rT] = mr[iT] = !1, gT = $E;
    });
    function wr(r) {
      return function(s) {
        return r(s);
      };
    }
    var wh, Pf = R(() => {
      wh = wr;
    }), Px, Mu, Ax, Ru, yT, _l, kx = R(() => {
      Ca(), Px = e && !e.nodeType && e, Mu = Px && !0 && c && !c.nodeType && c, Ax = Mu && Mu.exports === Px, Ru = Ax && fl.process, yT = function() {
        try {
          var r = Mu && Mu.require && Mu.require("util").types;
          return r || Ru && Ru.binding && Ru.binding("util");
        } catch {
        }
      }(), _l = yT;
    }), Iu, Mx, Rx, Ix = R(() => {
      w2(), Pf(), kx(), Iu = _l && _l.isTypedArray, Mx = Iu ? wh(Iu) : gT, Rx = Mx;
    });
    function E2(r, s) {
      var a = ci(r), d = !a && _y(r), m = !a && !d && Sh(r), y = !a && !d && !m && Rx(r), x = a || d || m || y, w = x ? UE(r.length, String) : [], T = w.length;
      for (var P in r) (s || bT.call(r, P)) && !(x && (P == "length" || m && (P == "offset" || P == "parent") || y && (P == "buffer" || P == "byteLength" || P == "byteOffset") || ra(P, T))) && w.push(P);
      return w;
    }
    var vT, bT, Sy, xT = R(() => {
      x2(), bx(), Or(), Cx(), Da(), Ix(), vT = Object.prototype, bT = vT.hasOwnProperty, Sy = E2;
    });
    function _T(r, s) {
      return function(a) {
        return r(s(a));
      };
    }
    var Nx, ST = R(() => {
      Nx = _T;
    }), wT, ET, T2 = R(() => {
      ST(), wT = Nx(Object.keys, Object), ET = wT;
    });
    function C2(r) {
      if (!yy(r)) return ET(r);
      var s = [];
      for (var a in Object(r)) Eh.call(r, a) && a != "constructor" && s.push(a);
      return s;
    }
    var TT, Eh, CT, P2 = R(() => {
      gx(), T2(), TT = Object.prototype, Eh = TT.hasOwnProperty, CT = C2;
    });
    function A2(r) {
      return Co(r) ? Sy(r) : CT(r);
    }
    var Th, Af = R(() => {
      xT(), P2(), _h(), Th = A2;
    });
    function k2(r) {
      var s = [];
      if (r != null) for (var a in Object(r)) s.push(a);
      return s;
    }
    var PT, Ox = R(() => {
      PT = k2;
    });
    function M2(r) {
      if (!Gt(r)) return PT(r);
      var s = yy(r), a = [];
      for (var d in r) d == "constructor" && (s || !AT.call(r, d)) || a.push(d);
      return a;
    }
    var Dx, AT, wy, R2 = R(() => {
      rr(), gx(), Ox(), Dx = Object.prototype, AT = Dx.hasOwnProperty, wy = M2;
    });
    function I2(r) {
      return Co(r) ? Sy(r, !0) : wy(r);
    }
    var Ey, Ty = R(() => {
      xT(), R2(), _h(), Ey = I2;
    });
    function N2(r, s) {
      if (ci(r)) return !1;
      var a = typeof r;
      return a == "number" || a == "symbol" || a == "boolean" || r == null || ps(r) ? !0 : MT.test(r) || !kT.test(r) || s != null && r in Object(s);
    }
    var kT, MT, Cy, Fx = R(() => {
      Or(), So(), kT = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, MT = /^\w*$/, Cy = N2;
    }), Bx, Ch, Py = R(() => {
      na(), Bx = Na(Object, "create"), Ch = Bx;
    });
    function O2() {
      this.__data__ = Ch ? Ch(null) : {}, this.size = 0;
    }
    var RT, D2 = R(() => {
      Py(), RT = O2;
    });
    function F2(r) {
      var s = this.has(r) && delete this.__data__[r];
      return this.size -= s ? 1 : 0, s;
    }
    var IT, B2 = R(() => {
      IT = F2;
    });
    function L2(r) {
      var s = this.__data__;
      if (Ch) {
        var a = s[r];
        return a === NT ? void 0 : a;
      }
      return Ay.call(s, r) ? s[r] : void 0;
    }
    var NT, OT, Ay, DT, j2 = R(() => {
      Py(), NT = "__lodash_hash_undefined__", OT = Object.prototype, Ay = OT.hasOwnProperty, DT = L2;
    });
    function FT(r) {
      var s = this.__data__;
      return Ch ? s[r] !== void 0 : LT.call(s, r);
    }
    var BT, LT, jT, U2 = R(() => {
      Py(), BT = Object.prototype, LT = BT.hasOwnProperty, jT = FT;
    });
    function z2(r, s) {
      var a = this.__data__;
      return this.size += this.has(r) ? 0 : 1, a[r] = Ch && s === void 0 ? UT : s, this;
    }
    var UT, ky, Lx = R(() => {
      Py(), UT = "__lodash_hash_undefined__", ky = z2;
    });
    function Ph(r) {
      var s = -1, a = r == null ? 0 : r.length;
      for (this.clear(); ++s < a; ) {
        var d = r[s];
        this.set(d[0], d[1]);
      }
    }
    var My, zT = R(() => {
      D2(), B2(), j2(), U2(), Lx(), Ph.prototype.clear = RT, Ph.prototype.delete = IT, Ph.prototype.get = DT, Ph.prototype.has = jT, Ph.prototype.set = ky, My = Ph;
    });
    function VT() {
      this.__data__ = [], this.size = 0;
    }
    var GT, qT = R(() => {
      GT = VT;
    });
    function HT(r, s) {
      for (var a = r.length; a--; ) if (Bc(r[a][0], s)) return a;
      return -1;
    }
    var kf, Ry = R(() => {
      Lc(), kf = HT;
    });
    function V2(r) {
      var s = this.__data__, a = kf(s, r);
      if (a < 0) return !1;
      var d = s.length - 1;
      return a == d ? s.pop() : WT.call(s, a, 1), --this.size, !0;
    }
    var $T, WT, KT, G2 = R(() => {
      Ry(), $T = Array.prototype, WT = $T.splice, KT = V2;
    });
    function q2(r) {
      var s = this.__data__, a = kf(s, r);
      return a < 0 ? void 0 : s[a][1];
    }
    var YT, H2 = R(() => {
      Ry(), YT = q2;
    });
    function $2(r) {
      return kf(this.__data__, r) > -1;
    }
    var jx, W2 = R(() => {
      Ry(), jx = $2;
    });
    function K2(r, s) {
      var a = this.__data__, d = kf(a, r);
      return d < 0 ? (++this.size, a.push([r, s])) : a[d][1] = s, this;
    }
    var XT, Y2 = R(() => {
      Ry(), XT = K2;
    });
    function Ah(r) {
      var s = -1, a = r == null ? 0 : r.length;
      for (this.clear(); ++s < a; ) {
        var d = r[s];
        this.set(d[0], d[1]);
      }
    }
    var Mf, Iy = R(() => {
      qT(), G2(), H2(), W2(), Y2(), Ah.prototype.clear = GT, Ah.prototype.delete = KT, Ah.prototype.get = YT, Ah.prototype.has = jx, Ah.prototype.set = XT, Mf = Ah;
    }), QT, kh, Ux = R(() => {
      na(), Ki(), QT = Na(Fi, "Map"), kh = QT;
    });
    function X2() {
      this.size = 0, this.__data__ = { hash: new My(), map: new (kh || Mf)(), string: new My() };
    }
    var zc, Rf = R(() => {
      zT(), Iy(), Ux(), zc = X2;
    });
    function Q2(r) {
      var s = typeof r;
      return s == "string" || s == "number" || s == "symbol" || s == "boolean" ? r !== "__proto__" : r === null;
    }
    var ZT, Z2 = R(() => {
      ZT = Q2;
    });
    function J2(r, s) {
      var a = r.__data__;
      return ZT(s) ? a[typeof s == "string" ? "string" : "hash"] : a.map;
    }
    var Mh, If = R(() => {
      Z2(), Mh = J2;
    });
    function eD(r) {
      var s = Mh(this, r).delete(r);
      return this.size -= s ? 1 : 0, s;
    }
    var zx, JT = R(() => {
      If(), zx = eD;
    });
    function tD(r) {
      return Mh(this, r).get(r);
    }
    var eC, nD = R(() => {
      If(), eC = tD;
    });
    function rD(r) {
      return Mh(this, r).has(r);
    }
    var tC, nC = R(() => {
      If(), tC = rD;
    });
    function iD(r, s) {
      var a = Mh(this, r), d = a.size;
      return a.set(r, s), this.size += a.size == d ? 0 : 1, this;
    }
    var rC, iC = R(() => {
      If(), rC = iD;
    });
    function Rh(r) {
      var s = -1, a = r == null ? 0 : r.length;
      for (this.clear(); ++s < a; ) {
        var d = r[s];
        this.set(d[0], d[1]);
      }
    }
    var Vc, Vx = R(() => {
      Rf(), JT(), nD(), nC(), iC(), Rh.prototype.clear = zc, Rh.prototype.delete = zx, Rh.prototype.get = eC, Rh.prototype.has = tC, Rh.prototype.set = rC, Vc = Rh;
    });
    function Gx(r, s) {
      if (typeof r != "function" || s != null && typeof s != "function") throw new TypeError(sC);
      var a = function() {
        var d = arguments, m = s ? s.apply(this, d) : d[0], y = a.cache;
        if (y.has(m)) return y.get(m);
        var x = r.apply(this, d);
        return a.cache = y.set(m, x) || y, x;
      };
      return a.cache = new (Gx.Cache || Vc)(), a;
    }
    var sC, qx, Hx = R(() => {
      Vx(), sC = "Expected a function", Gx.Cache = Vc, qx = Gx;
    });
    function sD(r) {
      var s = qx(r, function(d) {
        return a.size === oC && a.clear(), d;
      }), a = s.cache;
      return s;
    }
    var oC, aC, lC = R(() => {
      Hx(), oC = 500, aC = sD;
    }), uC, Ny, cC, dC, oD = R(() => {
      lC(), uC = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ny = /\\(\\)?/g, cC = aC(function(r) {
        var s = [];
        return r.charCodeAt(0) === 46 && s.push(""), r.replace(uC, function(a, d, m, y) {
          s.push(m ? y.replace(Ny, "$1") : d || a);
        }), s;
      }), dC = cC;
    });
    function $x(r) {
      return r == null ? "" : ch(r);
    }
    var Oy, Dy = R(() => {
      af(), Oy = $x;
    });
    function aD(r, s) {
      return ci(r) ? r : Cy(r, s) ? [r] : dC(Oy(r));
    }
    var Ih, Fy = R(() => {
      Or(), Fx(), oD(), Dy(), Ih = aD;
    });
    function lD(r) {
      if (typeof r == "string" || ps(r)) return r;
      var s = r + "";
      return s == "0" && 1 / r == -Wx ? "-0" : s;
    }
    var Wx, Gc, Nh = R(() => {
      So(), Wx = 1 / 0, Gc = lD;
    });
    function hC(r, s) {
      s = Ih(s, r);
      for (var a = 0, d = s.length; r != null && a < d; ) r = r[Gc(s[a++])];
      return a && a == d ? r : void 0;
    }
    var By, Kx = R(() => {
      Fy(), Nh(), By = hC;
    });
    function uD(r, s, a) {
      var d = r == null ? void 0 : By(r, s);
      return d === void 0 ? a : d;
    }
    var qc, Nf = R(() => {
      Kx(), qc = uD;
    });
    function Hc(r, s) {
      for (var a = -1, d = s.length, m = r.length; ++a < d; ) r[m + a] = s[a];
      return r;
    }
    var Nu, Yx = R(() => {
      Nu = Hc;
    });
    function cD(r) {
      return ci(r) || _y(r) || !!(Xx && r && r[Xx]);
    }
    var Xx, pC, dD = R(() => {
      Zo(), bx(), Or(), Xx = Qr ? Qr.isConcatSpreadable : void 0, pC = cD;
    });
    function Of(r, s, a, d, m) {
      var y = -1, x = r.length;
      for (a || (a = pC), m || (m = []); ++y < x; ) {
        var w = r[y];
        s > 0 && a(w) ? s > 1 ? Of(w, s - 1, a, d, m) : Nu(m, w) : d || (m[m.length] = w);
      }
      return m;
    }
    var fC, Qx = R(() => {
      Yx(), dD(), fC = Of;
    }), mC, Ly, Zx = R(() => {
      ST(), mC = Nx(Object.getPrototypeOf, Object), Ly = mC;
    });
    function hD(r) {
      if (!Ms(r) || _o(r) != gC) return !1;
      var s = Ly(r);
      if (s === null) return !0;
      var a = yC.call(s, "constructor") && s.constructor;
      return typeof a == "function" && a instanceof a && t_.call(a) == vC;
    }
    var gC, Jx, e_, t_, yC, vC, jy, bC = R(() => {
      ka(), Zx(), ds(), gC = "[object Object]", Jx = Function.prototype, e_ = Object.prototype, t_ = Jx.toString, yC = e_.hasOwnProperty, vC = t_.call(Object), jy = hD;
    });
    function pD(r) {
      var s = Math[r];
      return function(a, d) {
        if (a = fs(a), d = d == null ? 0 : _C(Eo(d), 292), d && xC(a)) {
          var m = (Oy(a) + "e").split("e"), y = s(m[0] + "e" + (+m[1] + d));
          return m = (Oy(y) + "e").split("e"), +(m[0] + "e" + (+m[1] - d));
        }
        return s(a);
      };
    }
    var xC, _C, SC, fD = R(() => {
      Ki(), Mc(), gl(), Dy(), xC = Fi.isFinite, _C = Math.min, SC = pD;
    });
    function mD(r, s, a) {
      return r === r && (a !== void 0 && (r = r <= a ? r : a), s !== void 0 && (r = r >= s ? r : s)), r;
    }
    var wC, gD = R(() => {
      wC = mD;
    });
    function yD(r, s, a) {
      return a === void 0 && (a = s, s = void 0), a !== void 0 && (a = fs(a), a = a === a ? a : 0), s !== void 0 && (s = fs(s), s = s === s ? s : 0), wC(fs(r), s, a);
    }
    var ir, Df = R(() => {
      gD(), gl(), ir = yD;
    });
    function vD() {
      this.__data__ = new Mf(), this.size = 0;
    }
    var EC, bD = R(() => {
      Iy(), EC = vD;
    });
    function xD(r) {
      var s = this.__data__, a = s.delete(r);
      return this.size = s.size, a;
    }
    var TC, _D = R(() => {
      TC = xD;
    });
    function SD(r) {
      return this.__data__.get(r);
    }
    var CC, wD = R(() => {
      CC = SD;
    });
    function ED(r) {
      return this.__data__.has(r);
    }
    var PC, TD = R(() => {
      PC = ED;
    });
    function CD(r, s) {
      var a = this.__data__;
      if (a instanceof Mf) {
        var d = a.__data__;
        if (!kh || d.length < AC - 1) return d.push([r, s]), this.size = ++a.size, this;
        a = this.__data__ = new Vc(d);
      }
      return a.set(r, s), this.size = a.size, this;
    }
    var AC, n_, PD = R(() => {
      Iy(), Ux(), Vx(), AC = 200, n_ = CD;
    });
    function Oh(r) {
      var s = this.__data__ = new Mf(r);
      this.size = s.size;
    }
    var Dh, r_ = R(() => {
      Iy(), bD(), _D(), wD(), TD(), PD(), Oh.prototype.clear = EC, Oh.prototype.delete = TC, Oh.prototype.get = CC, Oh.prototype.has = PC, Oh.prototype.set = n_, Dh = Oh;
    });
    function AD(r, s) {
      return r && Uc(s, Th(s), r);
    }
    var i_, kD = R(() => {
      Au(), Af(), i_ = AD;
    });
    function MD(r, s) {
      return r && Uc(s, Ey(s), r);
    }
    var kC, RD = R(() => {
      Au(), Ty(), kC = MD;
    });
    function ID(r, s) {
      if (s) return r.slice();
      var a = r.length, d = a_ ? a_(a) : new r.constructor(a);
      return r.copy(d), d;
    }
    var Uy, s_, MC, o_, a_, l_, ND = R(() => {
      Ki(), Uy = e && !e.nodeType && e, s_ = Uy && !0 && c && !c.nodeType && c, MC = s_ && s_.exports === Uy, o_ = MC ? Fi.Buffer : void 0, a_ = o_ ? o_.allocUnsafe : void 0, l_ = ID;
    });
    function OD(r, s) {
      for (var a = -1, d = r == null ? 0 : r.length, m = 0, y = []; ++a < d; ) {
        var x = r[a];
        s(x, a, r) && (y[m++] = x);
      }
      return y;
    }
    var RC, IC = R(() => {
      RC = OD;
    });
    function DD() {
      return [];
    }
    var u_, NC = R(() => {
      u_ = DD;
    }), OC, DC, c_, FC, zy, d_ = R(() => {
      IC(), NC(), OC = Object.prototype, DC = OC.propertyIsEnumerable, c_ = Object.getOwnPropertySymbols, FC = c_ ? function(r) {
        return r == null ? [] : (r = Object(r), RC(c_(r), function(s) {
          return DC.call(r, s);
        }));
      } : u_, zy = FC;
    });
    function FD(r, s) {
      return Uc(r, zy(r), s);
    }
    var BC, BD = R(() => {
      Au(), d_(), BC = FD;
    }), LC, jC, h_, UC = R(() => {
      Yx(), Zx(), d_(), NC(), LC = Object.getOwnPropertySymbols, jC = LC ? function(r) {
        for (var s = []; r; ) Nu(s, zy(r)), r = Ly(r);
        return s;
      } : u_, h_ = jC;
    });
    function gr(r, s) {
      return Uc(r, h_(r), s);
    }
    var Ff, LD = R(() => {
      Au(), UC(), Ff = gr;
    });
    function jD(r, s, a) {
      var d = s(r);
      return ci(r) ? d : Nu(d, a(r));
    }
    var p_, zC = R(() => {
      Yx(), Or(), p_ = jD;
    });
    function UD(r) {
      return p_(r, Th, zy);
    }
    var Vy, VC = R(() => {
      zC(), d_(), Af(), Vy = UD;
    });
    function zD(r) {
      return p_(r, Ey, h_);
    }
    var GC, VD = R(() => {
      zC(), UC(), Ty(), GC = zD;
    }), Bf, Gy, GD = R(() => {
      na(), Ki(), Bf = Na(Fi, "DataView"), Gy = Bf;
    }), qC, qy, qD = R(() => {
      na(), Ki(), qC = Na(Fi, "Promise"), qy = qC;
    }), HC, $c, $C = R(() => {
      na(), Ki(), HC = Na(Fi, "Set"), $c = HC;
    }), Hy, WC, f_, m_, g_, y_, KC, YC, XC, QC, ZC, Ou, Fh, $y = R(() => {
      GD(), Ux(), qD(), $C(), sx(), ka(), Gg(), Hy = "[object Map]", WC = "[object Object]", f_ = "[object Promise]", m_ = "[object Set]", g_ = "[object WeakMap]", y_ = "[object DataView]", KC = Ia(Gy), YC = Ia(kh), XC = Ia(qy), QC = Ia($c), ZC = Ia(mh), Ou = _o, (Gy && Ou(new Gy(new ArrayBuffer(1))) != y_ || kh && Ou(new kh()) != Hy || qy && Ou(qy.resolve()) != f_ || $c && Ou(new $c()) != m_ || mh && Ou(new mh()) != g_) && (Ou = function(r) {
        var s = _o(r), a = s == WC ? r.constructor : void 0, d = a ? Ia(a) : "";
        if (d) switch (d) {
          case KC:
            return y_;
          case YC:
            return Hy;
          case XC:
            return f_;
          case QC:
            return m_;
          case ZC:
            return g_;
        }
        return s;
      }), Fh = Ou;
    });
    function HD(r) {
      var s = r.length, a = new r.constructor(s);
      return s && typeof r[0] == "string" && eP.call(r, "index") && (a.index = r.index, a.input = r.input), a;
    }
    var JC, eP, tP, nP = R(() => {
      JC = Object.prototype, eP = JC.hasOwnProperty, tP = HD;
    }), Wy, Lf, rP = R(() => {
      Ki(), Wy = Fi.Uint8Array, Lf = Wy;
    });
    function $D(r) {
      var s = new r.constructor(r.byteLength);
      return new Lf(s).set(new Lf(r)), s;
    }
    var Ky, v_ = R(() => {
      rP(), Ky = $D;
    });
    function WD(r, s) {
      var a = s ? Ky(r.buffer) : r.buffer;
      return new r.constructor(a, r.byteOffset, r.byteLength);
    }
    var iP, KD = R(() => {
      v_(), iP = WD;
    });
    function sP(r) {
      var s = new r.constructor(r.source, b_.exec(r));
      return s.lastIndex = r.lastIndex, s;
    }
    var b_, jf, YD = R(() => {
      b_ = /\w*$/, jf = sP;
    });
    function oP(r) {
      return __ ? Object(__.call(r)) : {};
    }
    var x_, __, S_, aP = R(() => {
      Zo(), x_ = Qr ? Qr.prototype : void 0, __ = x_ ? x_.valueOf : void 0, S_ = oP;
    });
    function XD(r, s) {
      var a = s ? Ky(r.buffer) : r.buffer;
      return new r.constructor(a, r.byteOffset, r.length);
    }
    var lP, QD = R(() => {
      v_(), lP = XD;
    });
    function ZD(r, s, a) {
      var d = r.constructor;
      switch (s) {
        case mP:
          return Ky(r);
        case uP:
        case w_:
          return new d(+r);
        case gP:
          return iP(r, a);
        case yP:
        case vP:
        case bP:
        case xP:
        case _P:
        case SP:
        case wP:
        case EP:
        case TP:
          return lP(r, a);
        case cP:
          return new d();
        case dP:
        case pP:
          return new d(r);
        case hP:
          return jf(r);
        case E_:
          return new d();
        case fP:
          return S_(r);
      }
    }
    var uP, w_, cP, dP, hP, E_, pP, fP, mP, gP, yP, vP, bP, xP, _P, SP, wP, EP, TP, T_, JD = R(() => {
      v_(), KD(), YD(), aP(), QD(), uP = "[object Boolean]", w_ = "[object Date]", cP = "[object Map]", dP = "[object Number]", hP = "[object RegExp]", E_ = "[object Set]", pP = "[object String]", fP = "[object Symbol]", mP = "[object ArrayBuffer]", gP = "[object DataView]", yP = "[object Float32Array]", vP = "[object Float64Array]", bP = "[object Int8Array]", xP = "[object Int16Array]", _P = "[object Int32Array]", SP = "[object Uint8Array]", wP = "[object Uint8ClampedArray]", EP = "[object Uint16Array]", TP = "[object Uint32Array]", T_ = ZD;
    });
    function eF(r) {
      return typeof r.constructor == "function" && !yy(r) ? Zg(Ly(r)) : {};
    }
    var CP, tF = R(() => {
      ox(), Zx(), gx(), CP = eF;
    });
    function nF(r) {
      return Ms(r) && Fh(r) == PP;
    }
    var PP, AP, rF = R(() => {
      $y(), ds(), PP = "[object Map]", AP = nF;
    }), C_, kP, MP, iF = R(() => {
      rF(), Pf(), kx(), C_ = _l && _l.isMap, kP = C_ ? wh(C_) : AP, MP = kP;
    });
    function sF(r) {
      return Ms(r) && Fh(r) == Yy;
    }
    var Yy, RP, oF = R(() => {
      $y(), ds(), Yy = "[object Set]", RP = sF;
    }), P_, IP, NP, aF = R(() => {
      oF(), Pf(), kx(), P_ = _l && _l.isSet, IP = P_ ? wh(P_) : RP, NP = IP;
    });
    function Xy(r, s, a, d, m, y) {
      var x, w = s & OP, T = s & DP, P = s & FP;
      if (a && (x = m ? a(r, d, m, y) : a(r)), x !== void 0) return x;
      if (!Gt(r)) return r;
      var M = ci(r);
      if (M) {
        if (x = tP(r), !w) return yf(r, x);
      } else {
        var F = Fh(r), O = F == k_ || F == zP;
        if (Sh(r)) return l_(r, w);
        if (F == R_ || F == A_ || O && !m) {
          if (x = T || O ? {} : CP(r), !w) return T ? Ff(r, kC(x, r)) : BC(r, i_(x, r));
        } else {
          if (!sr[F]) return m ? r : {};
          x = T_(r, F, w);
        }
      }
      y || (y = new Dh());
      var N = y.get(r);
      if (N) return N;
      y.set(r, x), NP(r) ? r.forEach(function(H) {
        x.add(Xy(H, s, a, H, r, y));
      }) : MP(r) && r.forEach(function(H, W) {
        x.set(W, Xy(H, s, a, W, r, y));
      });
      var B = P ? T ? GC : Vy : T ? Ey : Th, U = M ? void 0 : B(r);
      return ay(U || r, function(H, W) {
        U && (W = H, H = r[W]), xl(x, W, Xy(H, s, a, W, r, y));
      }), x;
    }
    var OP, DP, FP, A_, BP, LP, jP, UP, k_, zP, VP, M_, R_, GP, I_, qP, HP, $P, WP, KP, YP, Qy, Zy, XP, N_, O_, D_, QP, F_, sr, ZP, lF = R(() => {
      r_(), ly(), jc(), kD(), RD(), ND(), Oc(), BD(), LD(), VC(), VD(), $y(), nP(), JD(), tF(), Or(), Cx(), iF(), rr(), aF(), Af(), Ty(), OP = 1, DP = 2, FP = 4, A_ = "[object Arguments]", BP = "[object Array]", LP = "[object Boolean]", jP = "[object Date]", UP = "[object Error]", k_ = "[object Function]", zP = "[object GeneratorFunction]", VP = "[object Map]", M_ = "[object Number]", R_ = "[object Object]", GP = "[object RegExp]", I_ = "[object Set]", qP = "[object String]", HP = "[object Symbol]", $P = "[object WeakMap]", WP = "[object ArrayBuffer]", KP = "[object DataView]", YP = "[object Float32Array]", Qy = "[object Float64Array]", Zy = "[object Int8Array]", XP = "[object Int16Array]", N_ = "[object Int32Array]", O_ = "[object Uint8Array]", D_ = "[object Uint8ClampedArray]", QP = "[object Uint16Array]", F_ = "[object Uint32Array]", sr = {}, sr[A_] = sr[BP] = sr[WP] = sr[KP] = sr[LP] = sr[jP] = sr[YP] = sr[Qy] = sr[Zy] = sr[XP] = sr[N_] = sr[VP] = sr[M_] = sr[R_] = sr[GP] = sr[I_] = sr[qP] = sr[HP] = sr[O_] = sr[D_] = sr[QP] = sr[F_] = !0, sr[UP] = sr[k_] = sr[$P] = !1, ZP = Xy;
    });
    function uF(r) {
      return ZP(r, B_ | JP);
    }
    var B_, JP, eA, cF = R(() => {
      lF(), B_ = 1, JP = 4, eA = uF;
    });
    function tA(r) {
      return this.__data__.set(r, nA), this;
    }
    var nA, rA, dF = R(() => {
      nA = "__lodash_hash_undefined__", rA = tA;
    });
    function hF(r) {
      return this.__data__.has(r);
    }
    var Bh, pF = R(() => {
      Bh = hF;
    });
    function Uf(r) {
      var s = -1, a = r == null ? 0 : r.length;
      for (this.__data__ = new Vc(); ++s < a; ) this.add(r[s]);
    }
    var L_, iA = R(() => {
      Vx(), dF(), pF(), Uf.prototype.add = Uf.prototype.push = rA, Uf.prototype.has = Bh, L_ = Uf;
    });
    function fF(r, s) {
      for (var a = -1, d = r == null ? 0 : r.length; ++a < d; ) if (s(r[a], a, r)) return !0;
      return !1;
    }
    var zf, j_ = R(() => {
      zf = fF;
    });
    function mF(r, s) {
      return r.has(s);
    }
    var U_, cr = R(() => {
      U_ = mF;
    });
    function no(r, s, a, d, m, y) {
      var x = a & Rs, w = r.length, T = s.length;
      if (w != T && !(x && T > w)) return !1;
      var P = y.get(r), M = y.get(s);
      if (P && M) return P == s && M == r;
      var F = -1, O = !0, N = a & Du ? new L_() : void 0;
      for (y.set(r, s), y.set(s, r); ++F < w; ) {
        var B = r[F], U = s[F];
        if (d) var H = x ? d(U, B, F, s, r, y) : d(B, U, F, r, s, y);
        if (H !== void 0) {
          if (H) continue;
          O = !1;
          break;
        }
        if (N) {
          if (!zf(s, function(W, Q) {
            if (!U_(N, Q) && (B === W || m(B, W, a, d, y))) return N.push(Q);
          })) {
            O = !1;
            break;
          }
        } else if (!(B === U || m(B, U, a, d, y))) {
          O = !1;
          break;
        }
      }
      return y.delete(r), y.delete(s), O;
    }
    var Rs, Du, or, Fa = R(() => {
      iA(), j_(), cr(), Rs = 1, Du = 2, or = no;
    });
    function sA(r) {
      var s = -1, a = Array(r.size);
      return r.forEach(function(d, m) {
        a[++s] = [m, d];
      }), a;
    }
    var oA, gF = R(() => {
      oA = sA;
    });
    function yF(r) {
      var s = -1, a = Array(r.size);
      return r.forEach(function(d) {
        a[++s] = d;
      }), a;
    }
    var Jy, z_ = R(() => {
      Jy = yF;
    });
    function aA(r, s, a, d, m, y, x) {
      switch (a) {
        case pA:
          if (r.byteLength != s.byteLength || r.byteOffset != s.byteOffset) return !1;
          r = r.buffer, s = s.buffer;
        case hA:
          return !(r.byteLength != s.byteLength || !y(new Lf(r), new Lf(s)));
        case G_:
        case lA:
        case $_:
          return Bc(+r, +s);
        case q_:
          return r.name == s.name && r.message == s.message;
        case uA:
        case W_:
          return r == s + "";
        case H_:
          var w = oA;
        case cA:
          var T = d & V_;
          if (w || (w = Jy), r.size != s.size && !T) return !1;
          var P = x.get(r);
          if (P) return P == s;
          d |= Vf, x.set(r, s);
          var M = or(w(r), w(s), d, m, y, x);
          return x.delete(r), M;
        case dA:
          if (yr) return yr.call(r) == yr.call(s);
      }
      return !1;
    }
    var V_, Vf, G_, lA, q_, H_, $_, uA, cA, W_, dA, hA, pA, K_, yr, Y_, vF = R(() => {
      Zo(), rP(), Lc(), Fa(), gF(), z_(), V_ = 1, Vf = 2, G_ = "[object Boolean]", lA = "[object Date]", q_ = "[object Error]", H_ = "[object Map]", $_ = "[object Number]", uA = "[object RegExp]", cA = "[object Set]", W_ = "[object String]", dA = "[object Symbol]", hA = "[object ArrayBuffer]", pA = "[object DataView]", K_ = Qr ? Qr.prototype : void 0, yr = K_ ? K_.valueOf : void 0, Y_ = aA;
    });
    function bF(r, s, a, d, m, y) {
      var x = a & qr, w = Vy(r), T = w.length, P = Vy(s), M = P.length;
      if (T != M && !x) return !1;
      for (var F = T; F--; ) {
        var O = w[F];
        if (!(x ? O in s : fA.call(s, O))) return !1;
      }
      var N = y.get(r), B = y.get(s);
      if (N && B) return N == s && B == r;
      var U = !0;
      y.set(r, s), y.set(s, r);
      for (var H = x; ++F < T; ) {
        O = w[F];
        var W = r[O], Q = s[O];
        if (d) var ne = x ? d(Q, W, O, s, r, y) : d(W, Q, O, r, s, y);
        if (!(ne === void 0 ? W === Q || m(W, Q, a, d, y) : ne)) {
          U = !1;
          break;
        }
        H || (H = O == "constructor");
      }
      if (U && !H) {
        var ce = r.constructor, ue = s.constructor;
        ce != ue && "constructor" in r && "constructor" in s && !(typeof ce == "function" && ce instanceof ce && typeof ue == "function" && ue instanceof ue) && (U = !1);
      }
      return y.delete(r), y.delete(s), U;
    }
    var qr, Ba, fA, Gf, xF = R(() => {
      VC(), qr = 1, Ba = Object.prototype, fA = Ba.hasOwnProperty, Gf = bF;
    });
    function _F(r, s, a, d, m, y) {
      var x = ci(r), w = ci(s), T = x ? qf : Fh(r), P = w ? qf : Fh(s);
      T = T == X_ ? Hf : T, P = P == X_ ? Hf : P;
      var M = T == Hf, F = P == Hf, O = T == P;
      if (O && Sh(r)) {
        if (!Sh(s)) return !1;
        x = !0, M = !1;
      }
      if (O && !M) return y || (y = new Dh()), x || Rx(r) ? or(r, s, a, d, m, y) : Y_(r, s, T, a, d, m, y);
      if (!(a & mA)) {
        var N = M && Po.call(r, "__wrapped__"), B = F && Po.call(s, "__wrapped__");
        if (N || B) {
          var U = N ? r.value() : r, H = B ? s.value() : s;
          return y || (y = new Dh()), m(U, H, a, d, y);
        }
      }
      return O ? (y || (y = new Dh()), Gf(r, s, a, d, m, y)) : !1;
    }
    var mA, X_, qf, Hf, $f, Po, gA, SF = R(() => {
      r_(), Fa(), vF(), xF(), $y(), Or(), Cx(), Ix(), mA = 1, X_ = "[object Arguments]", qf = "[object Array]", Hf = "[object Object]", $f = Object.prototype, Po = $f.hasOwnProperty, gA = _F;
    });
    function Q_(r, s, a, d, m) {
      return r === s ? !0 : r == null || s == null || !Ms(r) && !Ms(s) ? r !== r && s !== s : gA(r, s, a, d, Q_, m);
    }
    var Wf, yA = R(() => {
      SF(), ds(), Wf = Q_;
    });
    function e0(r, s, a, d) {
      var m = a.length, y = m, x = !d;
      if (r == null) return !y;
      for (r = Object(r); m--; ) {
        var w = a[m];
        if (x && w[2] ? w[1] !== r[w[0]] : !(w[0] in r)) return !1;
      }
      for (; ++m < y; ) {
        w = a[m];
        var T = w[0], P = r[T], M = w[1];
        if (x && w[2]) {
          if (P === void 0 && !(T in r)) return !1;
        } else {
          var F = new Dh();
          if (d) var O = d(P, M, T, r, s, F);
          if (!(O === void 0 ? Wf(M, P, Z_ | t0, d, F) : O)) return !1;
        }
      }
      return !0;
    }
    var Z_, t0, vA, wF = R(() => {
      r_(), yA(), Z_ = 1, t0 = 2, vA = e0;
    });
    function EF(r) {
      return r === r && !Gt(r);
    }
    var J_, bA = R(() => {
      rr(), J_ = EF;
    });
    function e1(r) {
      for (var s = Th(r), a = s.length; a--; ) {
        var d = s[a], m = r[d];
        s[a] = [d, m, J_(m)];
      }
      return s;
    }
    var xA, TF = R(() => {
      bA(), Af(), xA = e1;
    });
    function Wc(r, s) {
      return function(a) {
        return a == null ? !1 : a[r] === s && (s !== void 0 || r in Object(a));
      };
    }
    var Sl, Kc = R(() => {
      Sl = Wc;
    });
    function t1(r) {
      var s = xA(r);
      return s.length == 1 && s[0][2] ? Sl(s[0][0], s[0][1]) : function(a) {
        return a === r || vA(a, r, s);
      };
    }
    var n1, CF = R(() => {
      wF(), TF(), Kc(), n1 = t1;
    });
    function gs(r, s) {
      return r != null && s in Object(r);
    }
    var _A, r1 = R(() => {
      _A = gs;
    });
    function PF(r, s, a) {
      s = Ih(s, r);
      for (var d = -1, m = s.length, y = !1; ++d < m; ) {
        var x = Gc(s[d]);
        if (!(y = r != null && a(r, x))) break;
        r = r[x];
      }
      return y || ++d != m ? y : (m = r == null ? 0 : r.length, !!m && ms(m) && ra(x, m) && (ci(r) || _y(r)));
    }
    var SA, wA = R(() => {
      Fy(), bx(), Or(), Da(), xh(), Nh(), SA = PF;
    });
    function EA(r, s) {
      return r != null && SA(r, s, _A);
    }
    var TA, wl = R(() => {
      r1(), wA(), TA = EA;
    });
    function CA(r, s) {
      return Cy(r) && J_(s) ? Sl(Gc(r), s) : function(a) {
        var d = qc(a, r);
        return d === void 0 && d === s ? TA(a, r) : Wf(s, d, PA | AA);
      };
    }
    var PA, AA, Fu, n0 = R(() => {
      yA(), Nf(), wl(), Fx(), bA(), Kc(), Nh(), PA = 1, AA = 2, Fu = CA;
    });
    function AF(r) {
      return function(s) {
        return s?.[r];
      };
    }
    var kA, kF = R(() => {
      kA = AF;
    });
    function MF(r) {
      return function(s) {
        return By(s, r);
      };
    }
    var i1, RF = R(() => {
      Kx(), i1 = MF;
    });
    function IF(r) {
      return Cy(r) ? kA(Gc(r)) : i1(r);
    }
    var MA, NF = R(() => {
      kF(), RF(), Fx(), Nh(), MA = IF;
    });
    function OF(r) {
      return typeof r == "function" ? r : r == null ? Rc : typeof r == "object" ? ci(r) ? Fu(r[0], r[1]) : n1(r) : MA(r);
    }
    var Lh, jh = R(() => {
      CF(), n0(), yl(), Or(), NF(), Lh = OF;
    });
    function DF(r, s, a, d) {
      for (var m = -1, y = r == null ? 0 : r.length; ++m < y; ) {
        var x = r[m];
        s(d, x, a(x), r);
      }
      return d;
    }
    var Uh, RA = R(() => {
      Uh = DF;
    });
    function FF(r) {
      return function(s, a, d) {
        for (var m = -1, y = Object(s), x = d(s), w = x.length; w--; ) {
          var T = x[r ? w : ++m];
          if (a(y[T], T, y) === !1) break;
        }
        return s;
      };
    }
    var IA, BF = R(() => {
      IA = FF;
    }), NA, OA, r0 = R(() => {
      BF(), NA = IA(), OA = NA;
    });
    function LF(r, s) {
      return r && OA(r, s, Th);
    }
    var Kf, DA = R(() => {
      r0(), Af(), Kf = LF;
    });
    function Yf(r, s) {
      return function(a, d) {
        if (a == null) return a;
        if (!Co(a)) return r(a, d);
        for (var m = a.length, y = s ? m : -1, x = Object(a); (s ? y-- : ++y < m) && d(x[y], y, x) !== !1; ) ;
        return a;
      };
    }
    var FA, jF = R(() => {
      _h(), FA = Yf;
    }), BA, s1, i0 = R(() => {
      DA(), jF(), BA = FA(Kf), s1 = BA;
    });
    function LA(r, s, a, d) {
      return s1(r, function(m, y, x) {
        s(d, m, a(m), x);
      }), d;
    }
    var jA, UF = R(() => {
      i0(), jA = LA;
    });
    function Ti(r, s) {
      return function(a, d) {
        var m = ci(a) ? Uh : jA, y = s ? s() : {};
        return m(a, r, Lh(d, 2), y);
      };
    }
    var Bu, Yc = R(() => {
      RA(), UF(), jh(), Or(), Bu = Ti;
    }), UA, Lu, zh = R(() => {
      Ki(), UA = function() {
        return Fi.Date.now();
      }, Lu = UA;
    });
    function o1(r, s, a) {
      var d, m, y, x, w, T, P = 0, M = !1, F = !1, O = !0;
      if (typeof r != "function") throw new TypeError(zA);
      s = fs(s) || 0, Gt(a) && (M = !!a.leading, F = "maxWait" in a, y = F ? a1(fs(a.maxWait) || 0, s) : y, O = "trailing" in a ? !!a.trailing : O);
      function N(se) {
        var Oe = d, he = m;
        return d = m = void 0, P = se, x = r.apply(he, Oe), x;
      }
      function B(se) {
        return P = se, w = setTimeout(W, s), M ? N(se) : x;
      }
      function U(se) {
        var Oe = se - T, he = se - P, ie = s - Oe;
        return F ? VA(ie, y - he) : ie;
      }
      function H(se) {
        var Oe = se - T, he = se - P;
        return T === void 0 || Oe >= s || Oe < 0 || F && he >= y;
      }
      function W() {
        var se = Lu();
        if (H(se)) return Q(se);
        w = setTimeout(W, U(se));
      }
      function Q(se) {
        return w = void 0, O && d ? N(se) : (d = m = void 0, x);
      }
      function ne() {
        w !== void 0 && clearTimeout(w), P = 0, d = T = m = w = void 0;
      }
      function ce() {
        return w === void 0 ? x : Q(Lu());
      }
      function ue() {
        var se = Lu(), Oe = H(se);
        if (d = arguments, m = this, T = se, Oe) {
          if (w === void 0) return B(T);
          if (F) return clearTimeout(w), w = setTimeout(W, s), N(T);
        }
        return w === void 0 && (w = setTimeout(W, s)), x;
      }
      return ue.cancel = ne, ue.flush = ce, ue;
    }
    var zA, a1, VA, Xf, s0 = R(() => {
      rr(), zh(), gl(), zA = "Expected a function", a1 = Math.max, VA = Math.min, Xf = o1;
    });
    function Xc(r, s, a) {
      for (var d = -1, m = r == null ? 0 : r.length; ++d < m; ) if (a(s, r[d])) return !0;
      return !1;
    }
    var o0, l1 = R(() => {
      o0 = Xc;
    });
    function zF(r) {
      var s = r == null ? 0 : r.length;
      return s ? r[s - 1] : void 0;
    }
    var Qc, ia = R(() => {
      Qc = zF;
    });
    function GA(r, s, a) {
      var d = r == null ? 0 : r.length;
      if (!d) return -1;
      var m = a == null ? 0 : Eo(a);
      return m < 0 && (m = a0(d + m, 0)), Cu(r, Lh(s, 3), m);
    }
    var a0, Vh, u1 = R(() => {
      xf(), jh(), Mc(), a0 = Math.max, Vh = GA;
    });
    function qA(r, s, a) {
      var d = r == null ? 0 : r.length;
      if (!d) return -1;
      var m = d - 1;
      return a !== void 0 && (m = Eo(a), m = a < 0 ? HA(d + m, 0) : l0(m, d - 1)), Cu(r, Lh(s, 3), m, !0);
    }
    var HA, l0, Qf, $A = R(() => {
      xf(), jh(), Mc(), HA = Math.max, l0 = Math.min, Qf = qA;
    });
    function u0(r, s) {
      var a = -1, d = Co(r) ? Array(r.length) : [];
      return s1(r, function(m, y, x) {
        d[++a] = s(m, y, x);
      }), d;
    }
    var c0, WA = R(() => {
      i0(), _h(), c0 = u0;
    });
    function c1(r, s, a) {
      return r >= h0(s, a) && r < d0(s, a);
    }
    var d0, h0, KA, YA = R(() => {
      d0 = Math.max, h0 = Math.min, KA = c1;
    });
    function XA(r, s, a) {
      return s = hh(s), a === void 0 ? (a = s, s = 0) : a = hh(a), r = fs(r), KA(r, s, a);
    }
    var ju, d1 = R(() => {
      YA(), Og(), gl(), ju = XA;
    });
    function VF(r) {
      return typeof r == "number" && r == Eo(r);
    }
    var h1, p1 = R(() => {
      Mc(), h1 = VF;
    }), f1, El, Is = R(() => {
      Un(), Yc(), f1 = Bu(function(r, s, a) {
        Pu(r, a, s);
      }), El = f1;
    });
    function GF(r, s) {
      var a = {};
      return s = Lh(s, 3), Kf(r, function(d, m, y) {
        Pu(a, m, s(d, m, y));
      }), a;
    }
    var Zc, p0 = R(() => {
      Un(), DA(), jh(), Zc = GF;
    });
    function qF(r, s, a, d) {
      if (!Gt(r)) return r;
      s = Ih(s, r);
      for (var m = -1, y = s.length, x = y - 1, w = r; w != null && ++m < y; ) {
        var T = Gc(s[m]), P = a;
        if (T === "__proto__" || T === "constructor" || T === "prototype") return r;
        if (m != x) {
          var M = w[T];
          P = d ? d(M, T, w) : void 0, P === void 0 && (P = Gt(M) ? M : ra(s[m + 1]) ? [] : {});
        }
        xl(w, T, P), w = w[T];
      }
      return r;
    }
    var QA, f0 = R(() => {
      jc(), Fy(), Da(), rr(), Nh(), QA = qF;
    });
    function m0(r, s) {
      var a = r.length;
      for (r.sort(s); a--; ) r[a] = r[a].value;
      return r;
    }
    var ZA, ro = R(() => {
      ZA = m0;
    });
    function HF(r, s) {
      if (r !== s) {
        var a = r !== void 0, d = r === null, m = r === r, y = ps(r), x = s !== void 0, w = s === null, T = s === s, P = ps(s);
        if (!w && !P && !y && r > s || y && x && T && !w && !P || d && x && T || !a && T || !m) return 1;
        if (!d && !y && !P && r < s || P && a && m && !d && !y || w && a && m || !x && m || !T) return -1;
      }
      return 0;
    }
    var g0, $F = R(() => {
      So(), g0 = HF;
    });
    function JA(r, s, a) {
      for (var d = -1, m = r.criteria, y = s.criteria, x = m.length, w = a.length; ++d < x; ) {
        var T = g0(m[d], y[d]);
        if (T) {
          if (d >= w) return T;
          var P = a[d];
          return T * (P == "desc" ? -1 : 1);
        }
      }
      return r.index - s.index;
    }
    var m1, WF = R(() => {
      $F(), m1 = JA;
    });
    function ek(r, s, a) {
      s.length ? s = Ma(s, function(y) {
        return ci(y) ? function(x) {
          return By(x, y.length === 1 ? y[0] : y);
        } : y;
      }) : s = [Rc];
      var d = -1;
      s = Ma(s, wh(Lh));
      var m = c0(r, function(y, x, w) {
        var T = Ma(s, function(P) {
          return P(y);
        });
        return { criteria: T, index: ++d, value: y };
      });
      return ZA(m, function(y, x) {
        return m1(y, x, a);
      });
    }
    var tk, KF = R(() => {
      gu(), Kx(), jh(), WA(), ro(), Pf(), WF(), yl(), Or(), tk = ek;
    });
    function YF(r, s, a, d) {
      for (var m = a - 1, y = r.length; ++m < y; ) if (d(r[m], s)) return m;
      return -1;
    }
    var nk, rk = R(() => {
      nk = YF;
    });
    function g1(r, s, a, d) {
      var m = d ? nk : bh, y = -1, x = s.length, w = r;
      for (r === s && (s = yf(s)), a && (w = Ma(r, wh(a))); ++y < x; ) for (var T = 0, P = s[y], M = a ? a(P) : P; (T = m(w, M, T, d)) > -1; ) w !== r && y0.call(w, T, 1), y0.call(r, T, 1);
      return r;
    }
    var y1, y0, ik, XF = R(() => {
      gu(), Yi(), rk(), Pf(), Oc(), y1 = Array.prototype, y0 = y1.splice, ik = g1;
    });
    function v1(r, s) {
      return r && r.length && s && s.length ? ik(r, s) : r;
    }
    var b1, QF = R(() => {
      XF(), b1 = v1;
    }), sk, g, S = R(() => {
      Kt(), QF(), sk = Ye(b1), g = sk;
    }), k, z, X = R(() => {
      fD(), k = SC("round"), z = k;
    });
    function te(r, s, a) {
      return r == null ? r : QA(r, s, a);
    }
    var fe, Re = R(() => {
      f0(), fe = te;
    }), Le, We, ot = R(() => {
      Qx(), KF(), Kt(), v2(), Le = Ye(function(r, s) {
        if (r == null) return [];
        var a = s.length;
        return a > 1 && mx(r, s[0], s[1]) ? s = [] : a > 2 && mx(s[0], s[1], s[2]) && (s = [s[0]]), tk(r, fC(s, 1), []);
      }), We = Le;
    }), pt, _t, Rt, Mt = R(() => {
      $C(), ey(), z_(), pt = 1 / 0, _t = $c && 1 / Jy(new $c([, -0]))[1] == pt ? function(r) {
        return new $c(r);
      } : gf, Rt = _t;
    });
    function ln(r, s, a) {
      var d = -1, m = hy, y = r.length, x = !0, w = [], T = w;
      if (a) x = !1, m = o0;
      else if (y >= mn) {
        var P = s ? null : Rt(r);
        if (P) return Jy(P);
        x = !1, m = U_, T = new L_();
      } else T = s ? [] : w;
      e: for (; ++d < y; ) {
        var M = r[d], F = s ? s(M) : M;
        if (M = a || M !== 0 ? M : 0, x && F === F) {
          for (var O = T.length; O--; ) if (T[O] === F) continue e;
          s && T.push(F), w.push(M);
        } else m(T, F, a) || (T !== w && T.push(F), w.push(M));
      }
      return w;
    }
    var mn, Jt, Dn = R(() => {
      iA(), hx(), l1(), cr(), Mt(), z_(), mn = 200, Jt = ln;
    });
    function hi(r) {
      return r && r.length ? Jt(r) : [];
    }
    var ar, pi = R(() => {
      Dn(), ar = hi;
    }), tn = R(() => {
      Df(), s0(), u1(), d1(), p1(), bC(), ia(), p0(), Hx(), X(), pi();
    }), fi = J((r, s) => {
      var a;
      s.exports = typeof queueMicrotask == "function" ? queueMicrotask.bind(typeof window < "u" ? window : ks) : (d) => (a || (a = Promise.resolve())).then(d).catch((m) => setTimeout(() => {
        throw m;
      }, 0));
    }), Xi = J((r) => {
      var s = Symbol.for("react.element"), a = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), m = Symbol.for("react.strict_mode"), y = Symbol.for("react.profiler"), x = Symbol.for("react.provider"), w = Symbol.for("react.context"), T = Symbol.for("react.forward_ref"), P = Symbol.for("react.suspense"), M = Symbol.for("react.memo"), F = Symbol.for("react.lazy"), O = Symbol.iterator;
      function N(de) {
        return de === null || typeof de != "object" ? null : (de = O && de[O] || de["@@iterator"], typeof de == "function" ? de : null);
      }
      var B = { isMounted: function() {
        return !1;
      }, enqueueForceUpdate: function() {
      }, enqueueReplaceState: function() {
      }, enqueueSetState: function() {
      } }, U = Object.assign, H = {};
      function W(de, Ae, Je) {
        this.props = de, this.context = Ae, this.refs = H, this.updater = Je || B;
      }
      W.prototype.isReactComponent = {}, W.prototype.setState = function(de, Ae) {
        if (typeof de != "object" && typeof de != "function" && de != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, de, Ae, "setState");
      }, W.prototype.forceUpdate = function(de) {
        this.updater.enqueueForceUpdate(this, de, "forceUpdate");
      };
      function Q() {
      }
      Q.prototype = W.prototype;
      function ne(de, Ae, Je) {
        this.props = de, this.context = Ae, this.refs = H, this.updater = Je || B;
      }
      var ce = ne.prototype = new Q();
      ce.constructor = ne, U(ce, W.prototype), ce.isPureReactComponent = !0;
      var ue = Array.isArray, se = Object.prototype.hasOwnProperty, Oe = { current: null }, he = { key: !0, ref: !0, __self: !0, __source: !0 };
      function ie(de, Ae, Je) {
        var rt, Ve = {}, oe = null, je = null;
        if (Ae != null) for (rt in Ae.ref !== void 0 && (je = Ae.ref), Ae.key !== void 0 && (oe = "" + Ae.key), Ae) se.call(Ae, rt) && !he.hasOwnProperty(rt) && (Ve[rt] = Ae[rt]);
        var Ge = arguments.length - 2;
        if (Ge === 1) Ve.children = Je;
        else if (1 < Ge) {
          for (var yt = Array(Ge), Nt = 0; Nt < Ge; Nt++) yt[Nt] = arguments[Nt + 2];
          Ve.children = yt;
        }
        if (de && de.defaultProps) for (rt in Ge = de.defaultProps, Ge) Ve[rt] === void 0 && (Ve[rt] = Ge[rt]);
        return { $$typeof: s, type: de, key: oe, ref: je, props: Ve, _owner: Oe.current };
      }
      function ye(de, Ae) {
        return { $$typeof: s, type: de.type, key: Ae, ref: de.ref, props: de.props, _owner: de._owner };
      }
      function Ee(de) {
        return typeof de == "object" && de !== null && de.$$typeof === s;
      }
      function ve(de) {
        var Ae = { "=": "=0", ":": "=2" };
        return "$" + de.replace(/[=:]/g, function(Je) {
          return Ae[Je];
        });
      }
      var Xe = /\/+/g;
      function Se(de, Ae) {
        return typeof de == "object" && de !== null && de.key != null ? ve("" + de.key) : Ae.toString(36);
      }
      function nt(de, Ae, Je, rt, Ve) {
        var oe = typeof de;
        (oe === "undefined" || oe === "boolean") && (de = null);
        var je = !1;
        if (de === null) je = !0;
        else switch (oe) {
          case "string":
          case "number":
            je = !0;
            break;
          case "object":
            switch (de.$$typeof) {
              case s:
              case a:
                je = !0;
            }
        }
        if (je) return je = de, Ve = Ve(je), de = rt === "" ? "." + Se(je, 0) : rt, ue(Ve) ? (Je = "", de != null && (Je = de.replace(Xe, "$&/") + "/"), nt(Ve, Ae, Je, "", function(Nt) {
          return Nt;
        })) : Ve != null && (Ee(Ve) && (Ve = ye(Ve, Je + (!Ve.key || je && je.key === Ve.key ? "" : ("" + Ve.key).replace(Xe, "$&/") + "/") + de)), Ae.push(Ve)), 1;
        if (je = 0, rt = rt === "" ? "." : rt + ":", ue(de)) for (var Ge = 0; Ge < de.length; Ge++) {
          oe = de[Ge];
          var yt = rt + Se(oe, Ge);
          je += nt(oe, Ae, Je, yt, Ve);
        }
        else if (yt = N(de), typeof yt == "function") for (de = yt.call(de), Ge = 0; !(oe = de.next()).done; ) oe = oe.value, yt = rt + Se(oe, Ge++), je += nt(oe, Ae, Je, yt, Ve);
        else if (oe === "object") throw Ae = String(de), Error("Objects are not valid as a React child (found: " + (Ae === "[object Object]" ? "object with keys {" + Object.keys(de).join(", ") + "}" : Ae) + "). If you meant to render a collection of children, use an array instead.");
        return je;
      }
      function De(de, Ae, Je) {
        if (de == null) return de;
        var rt = [], Ve = 0;
        return nt(de, rt, "", "", function(oe) {
          return Ae.call(Je, oe, Ve++);
        }), rt;
      }
      function Ce(de) {
        if (de._status === -1) {
          var Ae = de._result;
          Ae = Ae(), Ae.then(function(Je) {
            (de._status === 0 || de._status === -1) && (de._status = 1, de._result = Je);
          }, function(Je) {
            (de._status === 0 || de._status === -1) && (de._status = 2, de._result = Je);
          }), de._status === -1 && (de._status = 0, de._result = Ae);
        }
        if (de._status === 1) return de._result.default;
        throw de._result;
      }
      var le = { current: null }, Ie = { transition: null }, $e = { ReactCurrentDispatcher: le, ReactCurrentBatchConfig: Ie, ReactCurrentOwner: Oe };
      r.Children = { map: De, forEach: function(de, Ae, Je) {
        De(de, function() {
          Ae.apply(this, arguments);
        }, Je);
      }, count: function(de) {
        var Ae = 0;
        return De(de, function() {
          Ae++;
        }), Ae;
      }, toArray: function(de) {
        return De(de, function(Ae) {
          return Ae;
        }) || [];
      }, only: function(de) {
        if (!Ee(de)) throw Error("React.Children.only expected to receive a single React element child.");
        return de;
      } }, r.Component = W, r.Fragment = d, r.Profiler = y, r.PureComponent = ne, r.StrictMode = m, r.Suspense = P, r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = $e, r.cloneElement = function(de, Ae, Je) {
        if (de == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + de + ".");
        var rt = U({}, de.props), Ve = de.key, oe = de.ref, je = de._owner;
        if (Ae != null) {
          if (Ae.ref !== void 0 && (oe = Ae.ref, je = Oe.current), Ae.key !== void 0 && (Ve = "" + Ae.key), de.type && de.type.defaultProps) var Ge = de.type.defaultProps;
          for (yt in Ae) se.call(Ae, yt) && !he.hasOwnProperty(yt) && (rt[yt] = Ae[yt] === void 0 && Ge !== void 0 ? Ge[yt] : Ae[yt]);
        }
        var yt = arguments.length - 2;
        if (yt === 1) rt.children = Je;
        else if (1 < yt) {
          Ge = Array(yt);
          for (var Nt = 0; Nt < yt; Nt++) Ge[Nt] = arguments[Nt + 2];
          rt.children = Ge;
        }
        return { $$typeof: s, type: de.type, key: Ve, ref: oe, props: rt, _owner: je };
      }, r.createContext = function(de) {
        return de = { $$typeof: w, _currentValue: de, _currentValue2: de, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, de.Provider = { $$typeof: x, _context: de }, de.Consumer = de;
      }, r.createElement = ie, r.createFactory = function(de) {
        var Ae = ie.bind(null, de);
        return Ae.type = de, Ae;
      }, r.createRef = function() {
        return { current: null };
      }, r.forwardRef = function(de) {
        return { $$typeof: T, render: de };
      }, r.isValidElement = Ee, r.lazy = function(de) {
        return { $$typeof: F, _payload: { _status: -1, _result: de }, _init: Ce };
      }, r.memo = function(de, Ae) {
        return { $$typeof: M, type: de, compare: Ae === void 0 ? null : Ae };
      }, r.startTransition = function(de) {
        var Ae = Ie.transition;
        Ie.transition = {};
        try {
          de();
        } finally {
          Ie.transition = Ae;
        }
      }, r.unstable_act = function() {
        throw Error("act(...) is not supported in production builds of React.");
      }, r.useCallback = function(de, Ae) {
        return le.current.useCallback(de, Ae);
      }, r.useContext = function(de) {
        return le.current.useContext(de);
      }, r.useDebugValue = function() {
      }, r.useDeferredValue = function(de) {
        return le.current.useDeferredValue(de);
      }, r.useEffect = function(de, Ae) {
        return le.current.useEffect(de, Ae);
      }, r.useId = function() {
        return le.current.useId();
      }, r.useImperativeHandle = function(de, Ae, Je) {
        return le.current.useImperativeHandle(de, Ae, Je);
      }, r.useInsertionEffect = function(de, Ae) {
        return le.current.useInsertionEffect(de, Ae);
      }, r.useLayoutEffect = function(de, Ae) {
        return le.current.useLayoutEffect(de, Ae);
      }, r.useMemo = function(de, Ae) {
        return le.current.useMemo(de, Ae);
      }, r.useReducer = function(de, Ae, Je) {
        return le.current.useReducer(de, Ae, Je);
      }, r.useRef = function(de) {
        return le.current.useRef(de);
      }, r.useState = function(de) {
        return le.current.useState(de);
      }, r.useSyncExternalStore = function(de, Ae, Je) {
        return le.current.useSyncExternalStore(de, Ae, Je);
      }, r.useTransition = function() {
        return le.current.useTransition();
      }, r.version = "18.2.0";
    }), xe = J((r, s) => {
      s.exports = Xi();
    }), La = J((r) => {
      function s(le, Ie) {
        var $e = le.length;
        le.push(Ie);
        e: for (; 0 < $e; ) {
          var de = $e - 1 >>> 1, Ae = le[de];
          if (0 < m(Ae, Ie)) le[de] = Ie, le[$e] = Ae, $e = de;
          else break e;
        }
      }
      function a(le) {
        return le.length === 0 ? null : le[0];
      }
      function d(le) {
        if (le.length === 0) return null;
        var Ie = le[0], $e = le.pop();
        if ($e !== Ie) {
          le[0] = $e;
          e: for (var de = 0, Ae = le.length, Je = Ae >>> 1; de < Je; ) {
            var rt = 2 * (de + 1) - 1, Ve = le[rt], oe = rt + 1, je = le[oe];
            if (0 > m(Ve, $e)) oe < Ae && 0 > m(je, Ve) ? (le[de] = je, le[oe] = $e, de = oe) : (le[de] = Ve, le[rt] = $e, de = rt);
            else if (oe < Ae && 0 > m(je, $e)) le[de] = je, le[oe] = $e, de = oe;
            else break e;
          }
        }
        return Ie;
      }
      function m(le, Ie) {
        var $e = le.sortIndex - Ie.sortIndex;
        return $e !== 0 ? $e : le.id - Ie.id;
      }
      typeof performance == "object" && typeof performance.now == "function" ? (y = performance, r.unstable_now = function() {
        return y.now();
      }) : (x = Date, w = x.now(), r.unstable_now = function() {
        return x.now() - w;
      });
      var y, x, w, T = [], P = [], M = 1, F = null, O = 3, N = !1, B = !1, U = !1, H = typeof setTimeout == "function" ? setTimeout : null, W = typeof clearTimeout == "function" ? clearTimeout : null, Q = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function ne(le) {
        for (var Ie = a(P); Ie !== null; ) {
          if (Ie.callback === null) d(P);
          else if (Ie.startTime <= le) d(P), Ie.sortIndex = Ie.expirationTime, s(T, Ie);
          else break;
          Ie = a(P);
        }
      }
      function ce(le) {
        if (U = !1, ne(le), !B) if (a(T) !== null) B = !0, De(ue);
        else {
          var Ie = a(P);
          Ie !== null && Ce(ce, Ie.startTime - le);
        }
      }
      function ue(le, Ie) {
        B = !1, U && (U = !1, W(he), he = -1), N = !0;
        var $e = O;
        try {
          for (ne(Ie), F = a(T); F !== null && (!(F.expirationTime > Ie) || le && !Ee()); ) {
            var de = F.callback;
            if (typeof de == "function") {
              F.callback = null, O = F.priorityLevel;
              var Ae = de(F.expirationTime <= Ie);
              Ie = r.unstable_now(), typeof Ae == "function" ? F.callback = Ae : F === a(T) && d(T), ne(Ie);
            } else d(T);
            F = a(T);
          }
          if (F !== null) var Je = !0;
          else {
            var rt = a(P);
            rt !== null && Ce(ce, rt.startTime - Ie), Je = !1;
          }
          return Je;
        } finally {
          F = null, O = $e, N = !1;
        }
      }
      var se = !1, Oe = null, he = -1, ie = 5, ye = -1;
      function Ee() {
        return !(r.unstable_now() - ye < ie);
      }
      function ve() {
        if (Oe !== null) {
          var le = r.unstable_now();
          ye = le;
          var Ie = !0;
          try {
            Ie = Oe(!0, le);
          } finally {
            Ie ? Xe() : (se = !1, Oe = null);
          }
        } else se = !1;
      }
      var Xe;
      typeof Q == "function" ? Xe = function() {
        Q(ve);
      } : typeof MessageChannel < "u" ? (Se = new MessageChannel(), nt = Se.port2, Se.port1.onmessage = ve, Xe = function() {
        nt.postMessage(null);
      }) : Xe = function() {
        H(ve, 0);
      };
      var Se, nt;
      function De(le) {
        Oe = le, se || (se = !0, Xe());
      }
      function Ce(le, Ie) {
        he = H(function() {
          le(r.unstable_now());
        }, Ie);
      }
      r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(le) {
        le.callback = null;
      }, r.unstable_continueExecution = function() {
        B || N || (B = !0, De(ue));
      }, r.unstable_forceFrameRate = function(le) {
        0 > le || 125 < le ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ie = 0 < le ? Math.floor(1e3 / le) : 5;
      }, r.unstable_getCurrentPriorityLevel = function() {
        return O;
      }, r.unstable_getFirstCallbackNode = function() {
        return a(T);
      }, r.unstable_next = function(le) {
        switch (O) {
          case 1:
          case 2:
          case 3:
            var Ie = 3;
            break;
          default:
            Ie = O;
        }
        var $e = O;
        O = Ie;
        try {
          return le();
        } finally {
          O = $e;
        }
      }, r.unstable_pauseExecution = function() {
      }, r.unstable_requestPaint = function() {
      }, r.unstable_runWithPriority = function(le, Ie) {
        switch (le) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            le = 3;
        }
        var $e = O;
        O = le;
        try {
          return Ie();
        } finally {
          O = $e;
        }
      }, r.unstable_scheduleCallback = function(le, Ie, $e) {
        var de = r.unstable_now();
        switch (typeof $e == "object" && $e !== null ? ($e = $e.delay, $e = typeof $e == "number" && 0 < $e ? de + $e : de) : $e = de, le) {
          case 1:
            var Ae = -1;
            break;
          case 2:
            Ae = 250;
            break;
          case 5:
            Ae = 1073741823;
            break;
          case 4:
            Ae = 1e4;
            break;
          default:
            Ae = 5e3;
        }
        return Ae = $e + Ae, le = { id: M++, callback: Ie, priorityLevel: le, startTime: $e, expirationTime: Ae, sortIndex: -1 }, $e > de ? (le.sortIndex = $e, s(P, le), a(T) === null && le === a(P) && (U ? (W(he), he = -1) : U = !0, Ce(ce, $e - de))) : (le.sortIndex = Ae, s(T, le), B || N || (B = !0, De(ue))), le;
      }, r.unstable_shouldYield = Ee, r.unstable_wrapCallback = function(le) {
        var Ie = O;
        return function() {
          var $e = O;
          O = Ie;
          try {
            return le.apply(this, arguments);
          } finally {
            O = $e;
          }
        };
      };
    }), ja = J((r, s) => {
      s.exports = La();
    }), Ua = J((r) => {
      var s = xe(), a = ja();
      function d(u) {
        for (var h = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, b = 1; b < arguments.length; b++) h += "&args[]=" + encodeURIComponent(arguments[b]);
        return "Minified React error #" + u + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      var m = /* @__PURE__ */ new Set(), y = {};
      function x(u, h) {
        w(u, h), w(u + "Capture", h);
      }
      function w(u, h) {
        for (y[u] = h, u = 0; u < h.length; u++) m.add(h[u]);
      }
      var T = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), P = Object.prototype.hasOwnProperty, M = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, F = {}, O = {};
      function N(u) {
        return P.call(O, u) ? !0 : P.call(F, u) ? !1 : M.test(u) ? O[u] = !0 : (F[u] = !0, !1);
      }
      function B(u, h, b, C) {
        if (b !== null && b.type === 0) return !1;
        switch (typeof h) {
          case "function":
          case "symbol":
            return !0;
          case "boolean":
            return C ? !1 : b !== null ? !b.acceptsBooleans : (u = u.toLowerCase().slice(0, 5), u !== "data-" && u !== "aria-");
          default:
            return !1;
        }
      }
      function U(u, h, b, C) {
        if (h === null || typeof h > "u" || B(u, h, b, C)) return !0;
        if (C) return !1;
        if (b !== null) switch (b.type) {
          case 3:
            return !h;
          case 4:
            return h === !1;
          case 5:
            return isNaN(h);
          case 6:
            return isNaN(h) || 1 > h;
        }
        return !1;
      }
      function H(u, h, b, C, D, G, Z) {
        this.acceptsBooleans = h === 2 || h === 3 || h === 4, this.attributeName = C, this.attributeNamespace = D, this.mustUseProperty = b, this.propertyName = u, this.type = h, this.sanitizeURL = G, this.removeEmptyString = Z;
      }
      var W = {};
      "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u) {
        W[u] = new H(u, 0, !1, u, null, !1, !1);
      }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
        var h = u[0];
        W[h] = new H(h, 1, !1, u[1], null, !1, !1);
      }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
        W[u] = new H(u, 2, !1, u.toLowerCase(), null, !1, !1);
      }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
        W[u] = new H(u, 2, !1, u, null, !1, !1);
      }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u) {
        W[u] = new H(u, 3, !1, u.toLowerCase(), null, !1, !1);
      }), ["checked", "multiple", "muted", "selected"].forEach(function(u) {
        W[u] = new H(u, 3, !0, u, null, !1, !1);
      }), ["capture", "download"].forEach(function(u) {
        W[u] = new H(u, 4, !1, u, null, !1, !1);
      }), ["cols", "rows", "size", "span"].forEach(function(u) {
        W[u] = new H(u, 6, !1, u, null, !1, !1);
      }), ["rowSpan", "start"].forEach(function(u) {
        W[u] = new H(u, 5, !1, u.toLowerCase(), null, !1, !1);
      });
      var Q = /[\-:]([a-z])/g;
      function ne(u) {
        return u[1].toUpperCase();
      }
      "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u) {
        var h = u.replace(Q, ne);
        W[h] = new H(h, 1, !1, u, null, !1, !1);
      }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u) {
        var h = u.replace(Q, ne);
        W[h] = new H(h, 1, !1, u, "http://www.w3.org/1999/xlink", !1, !1);
      }), ["xml:base", "xml:lang", "xml:space"].forEach(function(u) {
        var h = u.replace(Q, ne);
        W[h] = new H(h, 1, !1, u, "http://www.w3.org/XML/1998/namespace", !1, !1);
      }), ["tabIndex", "crossOrigin"].forEach(function(u) {
        W[u] = new H(u, 1, !1, u.toLowerCase(), null, !1, !1);
      }), W.xlinkHref = new H("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(u) {
        W[u] = new H(u, 1, !1, u.toLowerCase(), null, !0, !0);
      });
      function ce(u, h, b, C) {
        var D = W.hasOwnProperty(h) ? W[h] : null;
        (D !== null ? D.type !== 0 : C || !(2 < h.length) || h[0] !== "o" && h[0] !== "O" || h[1] !== "n" && h[1] !== "N") && (U(h, b, D, C) && (b = null), C || D === null ? N(h) && (b === null ? u.removeAttribute(h) : u.setAttribute(h, "" + b)) : D.mustUseProperty ? u[D.propertyName] = b === null ? D.type === 3 ? !1 : "" : b : (h = D.attributeName, C = D.attributeNamespace, b === null ? u.removeAttribute(h) : (D = D.type, b = D === 3 || D === 4 && b === !0 ? "" : "" + b, C ? u.setAttributeNS(C, h, b) : u.setAttribute(h, b))));
      }
      var ue = s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, se = Symbol.for("react.element"), Oe = Symbol.for("react.portal"), he = Symbol.for("react.fragment"), ie = Symbol.for("react.strict_mode"), ye = Symbol.for("react.profiler"), Ee = Symbol.for("react.provider"), ve = Symbol.for("react.context"), Xe = Symbol.for("react.forward_ref"), Se = Symbol.for("react.suspense"), nt = Symbol.for("react.suspense_list"), De = Symbol.for("react.memo"), Ce = Symbol.for("react.lazy"), le = Symbol.for("react.offscreen"), Ie = Symbol.iterator;
      function $e(u) {
        return u === null || typeof u != "object" ? null : (u = Ie && u[Ie] || u["@@iterator"], typeof u == "function" ? u : null);
      }
      var de = Object.assign, Ae;
      function Je(u) {
        if (Ae === void 0) try {
          throw Error();
        } catch (b) {
          var h = b.stack.trim().match(/\n( *(at )?)/);
          Ae = h && h[1] || "";
        }
        return `
` + Ae + u;
      }
      var rt = !1;
      function Ve(u, h) {
        if (!u || rt) return "";
        rt = !0;
        var b = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          if (h) if (h = function() {
            throw Error();
          }, Object.defineProperty(h.prototype, "props", { set: function() {
            throw Error();
          } }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(h, []);
            } catch (Ke) {
              var C = Ke;
            }
            Reflect.construct(u, [], h);
          } else {
            try {
              h.call();
            } catch (Ke) {
              C = Ke;
            }
            u.call(h.prototype);
          }
          else {
            try {
              throw Error();
            } catch (Ke) {
              C = Ke;
            }
            u();
          }
        } catch (Ke) {
          if (Ke && C && typeof Ke.stack == "string") {
            for (var D = Ke.stack.split(`
`), G = C.stack.split(`
`), Z = D.length - 1, me = G.length - 1; 1 <= Z && 0 <= me && D[Z] !== G[me]; ) me--;
            for (; 1 <= Z && 0 <= me; Z--, me--) if (D[Z] !== G[me]) {
              if (Z !== 1 || me !== 1) do
                if (Z--, me--, 0 > me || D[Z] !== G[me]) {
                  var Te = `
` + D[Z].replace(" at new ", " at ");
                  return u.displayName && Te.includes("<anonymous>") && (Te = Te.replace("<anonymous>", u.displayName)), Te;
                }
              while (1 <= Z && 0 <= me);
              break;
            }
          }
        } finally {
          rt = !1, Error.prepareStackTrace = b;
        }
        return (u = u ? u.displayName || u.name : "") ? Je(u) : "";
      }
      function oe(u) {
        switch (u.tag) {
          case 5:
            return Je(u.type);
          case 16:
            return Je("Lazy");
          case 13:
            return Je("Suspense");
          case 19:
            return Je("SuspenseList");
          case 0:
          case 2:
          case 15:
            return u = Ve(u.type, !1), u;
          case 11:
            return u = Ve(u.type.render, !1), u;
          case 1:
            return u = Ve(u.type, !0), u;
          default:
            return "";
        }
      }
      function je(u) {
        if (u == null) return null;
        if (typeof u == "function") return u.displayName || u.name || null;
        if (typeof u == "string") return u;
        switch (u) {
          case he:
            return "Fragment";
          case Oe:
            return "Portal";
          case ye:
            return "Profiler";
          case ie:
            return "StrictMode";
          case Se:
            return "Suspense";
          case nt:
            return "SuspenseList";
        }
        if (typeof u == "object") switch (u.$$typeof) {
          case ve:
            return (u.displayName || "Context") + ".Consumer";
          case Ee:
            return (u._context.displayName || "Context") + ".Provider";
          case Xe:
            var h = u.render;
            return u = u.displayName, u || (u = h.displayName || h.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u;
          case De:
            return h = u.displayName || null, h !== null ? h : je(u.type) || "Memo";
          case Ce:
            h = u._payload, u = u._init;
            try {
              return je(u(h));
            } catch {
            }
        }
        return null;
      }
      function Ge(u) {
        var h = u.type;
        switch (u.tag) {
          case 24:
            return "Cache";
          case 9:
            return (h.displayName || "Context") + ".Consumer";
          case 10:
            return (h._context.displayName || "Context") + ".Provider";
          case 18:
            return "DehydratedFragment";
          case 11:
            return u = h.render, u = u.displayName || u.name || "", h.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
          case 7:
            return "Fragment";
          case 5:
            return h;
          case 4:
            return "Portal";
          case 3:
            return "Root";
          case 6:
            return "Text";
          case 16:
            return je(h);
          case 8:
            return h === ie ? "StrictMode" : "Mode";
          case 22:
            return "Offscreen";
          case 12:
            return "Profiler";
          case 21:
            return "Scope";
          case 13:
            return "Suspense";
          case 19:
            return "SuspenseList";
          case 25:
            return "TracingMarker";
          case 1:
          case 0:
          case 17:
          case 2:
          case 14:
          case 15:
            if (typeof h == "function") return h.displayName || h.name || null;
            if (typeof h == "string") return h;
        }
        return null;
      }
      function yt(u) {
        switch (typeof u) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return u;
          case "object":
            return u;
          default:
            return "";
        }
      }
      function Nt(u) {
        var h = u.type;
        return (u = u.nodeName) && u.toLowerCase() === "input" && (h === "checkbox" || h === "radio");
      }
      function Lt(u) {
        var h = Nt(u) ? "checked" : "value", b = Object.getOwnPropertyDescriptor(u.constructor.prototype, h), C = "" + u[h];
        if (!u.hasOwnProperty(h) && typeof b < "u" && typeof b.get == "function" && typeof b.set == "function") {
          var D = b.get, G = b.set;
          return Object.defineProperty(u, h, { configurable: !0, get: function() {
            return D.call(this);
          }, set: function(Z) {
            C = "" + Z, G.call(this, Z);
          } }), Object.defineProperty(u, h, { enumerable: b.enumerable }), { getValue: function() {
            return C;
          }, setValue: function(Z) {
            C = "" + Z;
          }, stopTracking: function() {
            u._valueTracker = null, delete u[h];
          } };
        }
      }
      function qt(u) {
        u._valueTracker || (u._valueTracker = Lt(u));
      }
      function Tn(u) {
        if (!u) return !1;
        var h = u._valueTracker;
        if (!h) return !0;
        var b = h.getValue(), C = "";
        return u && (C = Nt(u) ? u.checked ? "true" : "false" : u.value), u = C, u !== b ? (h.setValue(u), !0) : !1;
      }
      function dr(u) {
        if (u = u || (typeof document < "u" ? document : void 0), typeof u > "u") return null;
        try {
          return u.activeElement || u.body;
        } catch {
          return u.body;
        }
      }
      function dn(u, h) {
        var b = h.checked;
        return de({}, h, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: b ?? u._wrapperState.initialChecked });
      }
      function jr(u, h) {
        var b = h.defaultValue == null ? "" : h.defaultValue, C = h.checked != null ? h.checked : h.defaultChecked;
        b = yt(h.value != null ? h.value : b), u._wrapperState = { initialChecked: C, initialValue: b, controlled: h.type === "checkbox" || h.type === "radio" ? h.checked != null : h.value != null };
      }
      function Sn(u, h) {
        h = h.checked, h != null && ce(u, "checked", h, !1);
      }
      function Rn(u, h) {
        Sn(u, h);
        var b = yt(h.value), C = h.type;
        if (b != null) C === "number" ? (b === 0 && u.value === "" || u.value != b) && (u.value = "" + b) : u.value !== "" + b && (u.value = "" + b);
        else if (C === "submit" || C === "reset") {
          u.removeAttribute("value");
          return;
        }
        h.hasOwnProperty("value") ? ei(u, h.type, b) : h.hasOwnProperty("defaultValue") && ei(u, h.type, yt(h.defaultValue)), h.checked == null && h.defaultChecked != null && (u.defaultChecked = !!h.defaultChecked);
      }
      function ns(u, h, b) {
        if (h.hasOwnProperty("value") || h.hasOwnProperty("defaultValue")) {
          var C = h.type;
          if (!(C !== "submit" && C !== "reset" || h.value !== void 0 && h.value !== null)) return;
          h = "" + u._wrapperState.initialValue, b || h === u.value || (u.value = h), u.defaultValue = h;
        }
        b = u.name, b !== "" && (u.name = ""), u.defaultChecked = !!u._wrapperState.initialChecked, b !== "" && (u.name = b);
      }
      function ei(u, h, b) {
        (h !== "number" || dr(u.ownerDocument) !== u) && (b == null ? u.defaultValue = "" + u._wrapperState.initialValue : u.defaultValue !== "" + b && (u.defaultValue = "" + b));
      }
      var Ka = Array.isArray;
      function Fo(u, h, b, C) {
        if (u = u.options, h) {
          h = {};
          for (var D = 0; D < b.length; D++) h["$" + b[D]] = !0;
          for (b = 0; b < u.length; b++) D = h.hasOwnProperty("$" + u[b].value), u[b].selected !== D && (u[b].selected = D), D && C && (u[b].defaultSelected = !0);
        } else {
          for (b = "" + yt(b), h = null, D = 0; D < u.length; D++) {
            if (u[D].value === b) {
              u[D].selected = !0, C && (u[D].defaultSelected = !0);
              return;
            }
            h !== null || u[D].disabled || (h = u[D]);
          }
          h !== null && (h.selected = !0);
        }
      }
      function rs(u, h) {
        if (h.dangerouslySetInnerHTML != null) throw Error(d(91));
        return de({}, h, { value: void 0, defaultValue: void 0, children: "" + u._wrapperState.initialValue });
      }
      function en(u, h) {
        var b = h.value;
        if (b == null) {
          if (b = h.children, h = h.defaultValue, b != null) {
            if (h != null) throw Error(d(92));
            if (Ka(b)) {
              if (1 < b.length) throw Error(d(93));
              b = b[0];
            }
            h = b;
          }
          h == null && (h = ""), b = h;
        }
        u._wrapperState = { initialValue: yt(b) };
      }
      function bn(u, h) {
        var b = yt(h.value), C = yt(h.defaultValue);
        b != null && (b = "" + b, b !== u.value && (u.value = b), h.defaultValue == null && u.defaultValue !== b && (u.defaultValue = b)), C != null && (u.defaultValue = "" + C);
      }
      function bd(u) {
        var h = u.textContent;
        h === u._wrapperState.initialValue && h !== "" && h !== null && (u.value = h);
      }
      function _v(u) {
        switch (u) {
          case "svg":
            return "http://www.w3.org/2000/svg";
          case "math":
            return "http://www.w3.org/1998/Math/MathML";
          default:
            return "http://www.w3.org/1999/xhtml";
        }
      }
      function Ya(u, h) {
        return u == null || u === "http://www.w3.org/1999/xhtml" ? _v(h) : u === "http://www.w3.org/2000/svg" && h === "foreignObject" ? "http://www.w3.org/1999/xhtml" : u;
      }
      var oI, Oce = function(u) {
        return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(h, b, C, D) {
          MSApp.execUnsafeLocalFunction(function() {
            return u(h, b, C, D);
          });
        } : u;
      }(function(u, h) {
        if (u.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in u) u.innerHTML = h;
        else {
          for (oI = oI || document.createElement("div"), oI.innerHTML = "<svg>" + h.valueOf().toString() + "</svg>", h = oI.firstChild; u.firstChild; ) u.removeChild(u.firstChild);
          for (; h.firstChild; ) u.appendChild(h.firstChild);
        }
      });
      function jS(u, h) {
        if (h) {
          var b = u.firstChild;
          if (b && b === u.lastChild && b.nodeType === 3) {
            b.nodeValue = h;
            return;
          }
        }
        u.textContent = h;
      }
      var US = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, RCe = ["Webkit", "ms", "Moz", "O"];
      Object.keys(US).forEach(function(u) {
        RCe.forEach(function(h) {
          h = h + u.charAt(0).toUpperCase() + u.substring(1), US[h] = US[u];
        });
      });
      function Dce(u, h, b) {
        return h == null || typeof h == "boolean" || h === "" ? "" : b || typeof h != "number" || h === 0 || US.hasOwnProperty(u) && US[u] ? ("" + h).trim() : h + "px";
      }
      function Fce(u, h) {
        u = u.style;
        for (var b in h) if (h.hasOwnProperty(b)) {
          var C = b.indexOf("--") === 0, D = Dce(b, h[b], C);
          b === "float" && (b = "cssFloat"), C ? u.setProperty(b, D) : u[b] = D;
        }
      }
      var ICe = de({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
      function vz(u, h) {
        if (h) {
          if (ICe[u] && (h.children != null || h.dangerouslySetInnerHTML != null)) throw Error(d(137, u));
          if (h.dangerouslySetInnerHTML != null) {
            if (h.children != null) throw Error(d(60));
            if (typeof h.dangerouslySetInnerHTML != "object" || !("__html" in h.dangerouslySetInnerHTML)) throw Error(d(61));
          }
          if (h.style != null && typeof h.style != "object") throw Error(d(62));
        }
      }
      function bz(u, h) {
        if (u.indexOf("-") === -1) return typeof h.is == "string";
        switch (u) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return !1;
          default:
            return !0;
        }
      }
      var xz = null;
      function _z(u) {
        return u = u.target || u.srcElement || window, u.correspondingUseElement && (u = u.correspondingUseElement), u.nodeType === 3 ? u.parentNode : u;
      }
      var Sz = null, Sv = null, wv = null;
      function Bce(u) {
        if (u = aw(u)) {
          if (typeof Sz != "function") throw Error(d(280));
          var h = u.stateNode;
          h && (h = II(h), Sz(u.stateNode, u.type, h));
        }
      }
      function Lce(u) {
        Sv ? wv ? wv.push(u) : wv = [u] : Sv = u;
      }
      function jce() {
        if (Sv) {
          var u = Sv, h = wv;
          if (wv = Sv = null, Bce(u), h) for (u = 0; u < h.length; u++) Bce(h[u]);
        }
      }
      function Uce(u, h) {
        return u(h);
      }
      function zce() {
      }
      var wz = !1;
      function Vce(u, h, b) {
        if (wz) return u(h, b);
        wz = !0;
        try {
          return Uce(u, h, b);
        } finally {
          wz = !1, (Sv !== null || wv !== null) && (zce(), jce());
        }
      }
      function zS(u, h) {
        var b = u.stateNode;
        if (b === null) return null;
        var C = II(b);
        if (C === null) return null;
        b = C[h];
        e: switch (h) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (C = !C.disabled) || (u = u.type, C = !(u === "button" || u === "input" || u === "select" || u === "textarea")), u = !C;
            break e;
          default:
            u = !1;
        }
        if (u) return null;
        if (b && typeof b != "function") throw Error(d(231, h, typeof b));
        return b;
      }
      var Ez = !1;
      if (T) try {
        Ev = {}, Object.defineProperty(Ev, "passive", { get: function() {
          Ez = !0;
        } }), window.addEventListener("test", Ev, Ev), window.removeEventListener("test", Ev, Ev);
      } catch {
        Ez = !1;
      }
      var Ev;
      function NCe(u, h, b, C, D, G, Z, me, Te) {
        var Ke = Array.prototype.slice.call(arguments, 3);
        try {
          h.apply(b, Ke);
        } catch (mt) {
          this.onError(mt);
        }
      }
      var VS = !1, aI = null, lI = !1, Tz = null, OCe = { onError: function(u) {
        VS = !0, aI = u;
      } };
      function DCe(u, h, b, C, D, G, Z, me, Te) {
        VS = !1, aI = null, NCe.apply(OCe, arguments);
      }
      function FCe(u, h, b, C, D, G, Z, me, Te) {
        if (DCe.apply(this, arguments), VS) {
          if (VS) {
            var Ke = aI;
            VS = !1, aI = null;
          } else throw Error(d(198));
          lI || (lI = !0, Tz = Ke);
        }
      }
      function Um(u) {
        var h = u, b = u;
        if (u.alternate) for (; h.return; ) h = h.return;
        else {
          u = h;
          do
            h = u, h.flags & 4098 && (b = h.return), u = h.return;
          while (u);
        }
        return h.tag === 3 ? b : null;
      }
      function Gce(u) {
        if (u.tag === 13) {
          var h = u.memoizedState;
          if (h === null && (u = u.alternate, u !== null && (h = u.memoizedState)), h !== null) return h.dehydrated;
        }
        return null;
      }
      function qce(u) {
        if (Um(u) !== u) throw Error(d(188));
      }
      function BCe(u) {
        var h = u.alternate;
        if (!h) {
          if (h = Um(u), h === null) throw Error(d(188));
          return h !== u ? null : u;
        }
        for (var b = u, C = h; ; ) {
          var D = b.return;
          if (D === null) break;
          var G = D.alternate;
          if (G === null) {
            if (C = D.return, C !== null) {
              b = C;
              continue;
            }
            break;
          }
          if (D.child === G.child) {
            for (G = D.child; G; ) {
              if (G === b) return qce(D), u;
              if (G === C) return qce(D), h;
              G = G.sibling;
            }
            throw Error(d(188));
          }
          if (b.return !== C.return) b = D, C = G;
          else {
            for (var Z = !1, me = D.child; me; ) {
              if (me === b) {
                Z = !0, b = D, C = G;
                break;
              }
              if (me === C) {
                Z = !0, C = D, b = G;
                break;
              }
              me = me.sibling;
            }
            if (!Z) {
              for (me = G.child; me; ) {
                if (me === b) {
                  Z = !0, b = G, C = D;
                  break;
                }
                if (me === C) {
                  Z = !0, C = G, b = D;
                  break;
                }
                me = me.sibling;
              }
              if (!Z) throw Error(d(189));
            }
          }
          if (b.alternate !== C) throw Error(d(190));
        }
        if (b.tag !== 3) throw Error(d(188));
        return b.stateNode.current === b ? u : h;
      }
      function Hce(u) {
        return u = BCe(u), u !== null ? $ce(u) : null;
      }
      function $ce(u) {
        if (u.tag === 5 || u.tag === 6) return u;
        for (u = u.child; u !== null; ) {
          var h = $ce(u);
          if (h !== null) return h;
          u = u.sibling;
        }
        return null;
      }
      var Wce = a.unstable_scheduleCallback, Kce = a.unstable_cancelCallback, LCe = a.unstable_shouldYield, jCe = a.unstable_requestPaint, yi = a.unstable_now, UCe = a.unstable_getCurrentPriorityLevel, Cz = a.unstable_ImmediatePriority, Yce = a.unstable_UserBlockingPriority, uI = a.unstable_NormalPriority, zCe = a.unstable_LowPriority, Xce = a.unstable_IdlePriority, cI = null, rc = null;
      function VCe(u) {
        if (rc && typeof rc.onCommitFiberRoot == "function") try {
          rc.onCommitFiberRoot(cI, u, void 0, (u.current.flags & 128) === 128);
        } catch {
        }
      }
      var Kl = Math.clz32 ? Math.clz32 : HCe, GCe = Math.log, qCe = Math.LN2;
      function HCe(u) {
        return u >>>= 0, u === 0 ? 32 : 31 - (GCe(u) / qCe | 0) | 0;
      }
      var dI = 64, hI = 4194304;
      function GS(u) {
        switch (u & -u) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return u & 4194240;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return u & 130023424;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 1073741824;
          default:
            return u;
        }
      }
      function pI(u, h) {
        var b = u.pendingLanes;
        if (b === 0) return 0;
        var C = 0, D = u.suspendedLanes, G = u.pingedLanes, Z = b & 268435455;
        if (Z !== 0) {
          var me = Z & ~D;
          me !== 0 ? C = GS(me) : (G &= Z, G !== 0 && (C = GS(G)));
        } else Z = b & ~D, Z !== 0 ? C = GS(Z) : G !== 0 && (C = GS(G));
        if (C === 0) return 0;
        if (h !== 0 && h !== C && !(h & D) && (D = C & -C, G = h & -h, D >= G || D === 16 && (G & 4194240) !== 0)) return h;
        if (C & 4 && (C |= b & 16), h = u.entangledLanes, h !== 0) for (u = u.entanglements, h &= C; 0 < h; ) b = 31 - Kl(h), D = 1 << b, C |= u[b], h &= ~D;
        return C;
      }
      function $Ce(u, h) {
        switch (u) {
          case 1:
          case 2:
          case 4:
            return h + 250;
          case 8:
          case 16:
          case 32:
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return h + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            return -1;
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function WCe(u, h) {
        for (var b = u.suspendedLanes, C = u.pingedLanes, D = u.expirationTimes, G = u.pendingLanes; 0 < G; ) {
          var Z = 31 - Kl(G), me = 1 << Z, Te = D[Z];
          Te === -1 ? (!(me & b) || me & C) && (D[Z] = $Ce(me, h)) : Te <= h && (u.expiredLanes |= me), G &= ~me;
        }
      }
      function Pz(u) {
        return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0;
      }
      function Qce() {
        var u = dI;
        return dI <<= 1, !(dI & 4194240) && (dI = 64), u;
      }
      function Az(u) {
        for (var h = [], b = 0; 31 > b; b++) h.push(u);
        return h;
      }
      function qS(u, h, b) {
        u.pendingLanes |= h, h !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, h = 31 - Kl(h), u[h] = b;
      }
      function KCe(u, h) {
        var b = u.pendingLanes & ~h;
        u.pendingLanes = h, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= h, u.mutableReadLanes &= h, u.entangledLanes &= h, h = u.entanglements;
        var C = u.eventTimes;
        for (u = u.expirationTimes; 0 < b; ) {
          var D = 31 - Kl(b), G = 1 << D;
          h[D] = 0, C[D] = -1, u[D] = -1, b &= ~G;
        }
      }
      function kz(u, h) {
        var b = u.entangledLanes |= h;
        for (u = u.entanglements; b; ) {
          var C = 31 - Kl(b), D = 1 << C;
          D & h | u[C] & h && (u[C] |= h), b &= ~D;
        }
      }
      var hr = 0;
      function Zce(u) {
        return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1;
      }
      var Jce, Mz, ede, tde, nde, Rz = !1, fI = [], hp = null, pp = null, fp = null, HS = /* @__PURE__ */ new Map(), $S = /* @__PURE__ */ new Map(), mp = [], YCe = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
      function rde(u, h) {
        switch (u) {
          case "focusin":
          case "focusout":
            hp = null;
            break;
          case "dragenter":
          case "dragleave":
            pp = null;
            break;
          case "mouseover":
          case "mouseout":
            fp = null;
            break;
          case "pointerover":
          case "pointerout":
            HS.delete(h.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            $S.delete(h.pointerId);
        }
      }
      function WS(u, h, b, C, D, G) {
        return u === null || u.nativeEvent !== G ? (u = { blockedOn: h, domEventName: b, eventSystemFlags: C, nativeEvent: G, targetContainers: [D] }, h !== null && (h = aw(h), h !== null && Mz(h)), u) : (u.eventSystemFlags |= C, h = u.targetContainers, D !== null && h.indexOf(D) === -1 && h.push(D), u);
      }
      function XCe(u, h, b, C, D) {
        switch (h) {
          case "focusin":
            return hp = WS(hp, u, h, b, C, D), !0;
          case "dragenter":
            return pp = WS(pp, u, h, b, C, D), !0;
          case "mouseover":
            return fp = WS(fp, u, h, b, C, D), !0;
          case "pointerover":
            var G = D.pointerId;
            return HS.set(G, WS(HS.get(G) || null, u, h, b, C, D)), !0;
          case "gotpointercapture":
            return G = D.pointerId, $S.set(G, WS($S.get(G) || null, u, h, b, C, D)), !0;
        }
        return !1;
      }
      function ide(u) {
        var h = zm(u.target);
        if (h !== null) {
          var b = Um(h);
          if (b !== null) {
            if (h = b.tag, h === 13) {
              if (h = Gce(b), h !== null) {
                u.blockedOn = h, nde(u.priority, function() {
                  ede(b);
                });
                return;
              }
            } else if (h === 3 && b.stateNode.current.memoizedState.isDehydrated) {
              u.blockedOn = b.tag === 3 ? b.stateNode.containerInfo : null;
              return;
            }
          }
        }
        u.blockedOn = null;
      }
      function mI(u) {
        if (u.blockedOn !== null) return !1;
        for (var h = u.targetContainers; 0 < h.length; ) {
          var b = Nz(u.domEventName, u.eventSystemFlags, h[0], u.nativeEvent);
          if (b === null) {
            b = u.nativeEvent;
            var C = new b.constructor(b.type, b);
            xz = C, b.target.dispatchEvent(C), xz = null;
          } else return h = aw(b), h !== null && Mz(h), u.blockedOn = b, !1;
          h.shift();
        }
        return !0;
      }
      function sde(u, h, b) {
        mI(u) && b.delete(h);
      }
      function QCe() {
        Rz = !1, hp !== null && mI(hp) && (hp = null), pp !== null && mI(pp) && (pp = null), fp !== null && mI(fp) && (fp = null), HS.forEach(sde), $S.forEach(sde);
      }
      function KS(u, h) {
        u.blockedOn === h && (u.blockedOn = null, Rz || (Rz = !0, a.unstable_scheduleCallback(a.unstable_NormalPriority, QCe)));
      }
      function YS(u) {
        function h(D) {
          return KS(D, u);
        }
        if (0 < fI.length) {
          KS(fI[0], u);
          for (var b = 1; b < fI.length; b++) {
            var C = fI[b];
            C.blockedOn === u && (C.blockedOn = null);
          }
        }
        for (hp !== null && KS(hp, u), pp !== null && KS(pp, u), fp !== null && KS(fp, u), HS.forEach(h), $S.forEach(h), b = 0; b < mp.length; b++) C = mp[b], C.blockedOn === u && (C.blockedOn = null);
        for (; 0 < mp.length && (b = mp[0], b.blockedOn === null); ) ide(b), b.blockedOn === null && mp.shift();
      }
      var Tv = ue.ReactCurrentBatchConfig, gI = !0;
      function ZCe(u, h, b, C) {
        var D = hr, G = Tv.transition;
        Tv.transition = null;
        try {
          hr = 1, Iz(u, h, b, C);
        } finally {
          hr = D, Tv.transition = G;
        }
      }
      function JCe(u, h, b, C) {
        var D = hr, G = Tv.transition;
        Tv.transition = null;
        try {
          hr = 4, Iz(u, h, b, C);
        } finally {
          hr = D, Tv.transition = G;
        }
      }
      function Iz(u, h, b, C) {
        if (gI) {
          var D = Nz(u, h, b, C);
          if (D === null) Kz(u, h, C, yI, b), rde(u, C);
          else if (XCe(D, u, h, b, C)) C.stopPropagation();
          else if (rde(u, C), h & 4 && -1 < YCe.indexOf(u)) {
            for (; D !== null; ) {
              var G = aw(D);
              if (G !== null && Jce(G), G = Nz(u, h, b, C), G === null && Kz(u, h, C, yI, b), G === D) break;
              D = G;
            }
            D !== null && C.stopPropagation();
          } else Kz(u, h, C, null, b);
        }
      }
      var yI = null;
      function Nz(u, h, b, C) {
        if (yI = null, u = _z(C), u = zm(u), u !== null) if (h = Um(u), h === null) u = null;
        else if (b = h.tag, b === 13) {
          if (u = Gce(h), u !== null) return u;
          u = null;
        } else if (b === 3) {
          if (h.stateNode.current.memoizedState.isDehydrated) return h.tag === 3 ? h.stateNode.containerInfo : null;
          u = null;
        } else h !== u && (u = null);
        return yI = u, null;
      }
      function ode(u) {
        switch (u) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 1;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 4;
          case "message":
            switch (UCe()) {
              case Cz:
                return 1;
              case Yce:
                return 4;
              case uI:
              case zCe:
                return 16;
              case Xce:
                return 536870912;
              default:
                return 16;
            }
          default:
            return 16;
        }
      }
      var gp = null, Oz = null, vI = null;
      function ade() {
        if (vI) return vI;
        var u, h = Oz, b = h.length, C, D = "value" in gp ? gp.value : gp.textContent, G = D.length;
        for (u = 0; u < b && h[u] === D[u]; u++) ;
        var Z = b - u;
        for (C = 1; C <= Z && h[b - C] === D[G - C]; C++) ;
        return vI = D.slice(u, 1 < C ? 1 - C : void 0);
      }
      function bI(u) {
        var h = u.keyCode;
        return "charCode" in u ? (u = u.charCode, u === 0 && h === 13 && (u = 13)) : u = h, u === 10 && (u = 13), 32 <= u || u === 13 ? u : 0;
      }
      function xI() {
        return !0;
      }
      function lde() {
        return !1;
      }
      function da(u) {
        function h(b, C, D, G, Z) {
          this._reactName = b, this._targetInst = D, this.type = C, this.nativeEvent = G, this.target = Z, this.currentTarget = null;
          for (var me in u) u.hasOwnProperty(me) && (b = u[me], this[me] = b ? b(G) : G[me]);
          return this.isDefaultPrevented = (G.defaultPrevented != null ? G.defaultPrevented : G.returnValue === !1) ? xI : lde, this.isPropagationStopped = lde, this;
        }
        return de(h.prototype, { preventDefault: function() {
          this.defaultPrevented = !0;
          var b = this.nativeEvent;
          b && (b.preventDefault ? b.preventDefault() : typeof b.returnValue != "unknown" && (b.returnValue = !1), this.isDefaultPrevented = xI);
        }, stopPropagation: function() {
          var b = this.nativeEvent;
          b && (b.stopPropagation ? b.stopPropagation() : typeof b.cancelBubble != "unknown" && (b.cancelBubble = !0), this.isPropagationStopped = xI);
        }, persist: function() {
        }, isPersistent: xI }), h;
      }
      var Cv = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(u) {
        return u.timeStamp || Date.now();
      }, defaultPrevented: 0, isTrusted: 0 }, Dz = da(Cv), XS = de({}, Cv, { view: 0, detail: 0 }), ePe = da(XS), Fz, Bz, QS, _I = de({}, XS, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: jz, button: 0, buttons: 0, relatedTarget: function(u) {
        return u.relatedTarget === void 0 ? u.fromElement === u.srcElement ? u.toElement : u.fromElement : u.relatedTarget;
      }, movementX: function(u) {
        return "movementX" in u ? u.movementX : (u !== QS && (QS && u.type === "mousemove" ? (Fz = u.screenX - QS.screenX, Bz = u.screenY - QS.screenY) : Bz = Fz = 0, QS = u), Fz);
      }, movementY: function(u) {
        return "movementY" in u ? u.movementY : Bz;
      } }), ude = da(_I), tPe = de({}, _I, { dataTransfer: 0 }), nPe = da(tPe), rPe = de({}, XS, { relatedTarget: 0 }), Lz = da(rPe), iPe = de({}, Cv, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), sPe = da(iPe), oPe = de({}, Cv, { clipboardData: function(u) {
        return "clipboardData" in u ? u.clipboardData : window.clipboardData;
      } }), aPe = da(oPe), lPe = de({}, Cv, { data: 0 }), cde = da(lPe), uPe = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, cPe = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, dPe = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
      function hPe(u) {
        var h = this.nativeEvent;
        return h.getModifierState ? h.getModifierState(u) : (u = dPe[u]) ? !!h[u] : !1;
      }
      function jz() {
        return hPe;
      }
      var pPe = de({}, XS, { key: function(u) {
        if (u.key) {
          var h = uPe[u.key] || u.key;
          if (h !== "Unidentified") return h;
        }
        return u.type === "keypress" ? (u = bI(u), u === 13 ? "Enter" : String.fromCharCode(u)) : u.type === "keydown" || u.type === "keyup" ? cPe[u.keyCode] || "Unidentified" : "";
      }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: jz, charCode: function(u) {
        return u.type === "keypress" ? bI(u) : 0;
      }, keyCode: function(u) {
        return u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
      }, which: function(u) {
        return u.type === "keypress" ? bI(u) : u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
      } }), fPe = da(pPe), mPe = de({}, _I, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), dde = da(mPe), gPe = de({}, XS, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: jz }), yPe = da(gPe), vPe = de({}, Cv, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), bPe = da(vPe), xPe = de({}, _I, { deltaX: function(u) {
        return "deltaX" in u ? u.deltaX : "wheelDeltaX" in u ? -u.wheelDeltaX : 0;
      }, deltaY: function(u) {
        return "deltaY" in u ? u.deltaY : "wheelDeltaY" in u ? -u.wheelDeltaY : "wheelDelta" in u ? -u.wheelDelta : 0;
      }, deltaZ: 0, deltaMode: 0 }), _Pe = da(xPe), SPe = [9, 13, 27, 32], Uz = T && "CompositionEvent" in window, ZS = null;
      T && "documentMode" in document && (ZS = document.documentMode);
      var wPe = T && "TextEvent" in window && !ZS, hde = T && (!Uz || ZS && 8 < ZS && 11 >= ZS), pde = " ", fde = !1;
      function mde(u, h) {
        switch (u) {
          case "keyup":
            return SPe.indexOf(h.keyCode) !== -1;
          case "keydown":
            return h.keyCode !== 229;
          case "keypress":
          case "mousedown":
          case "focusout":
            return !0;
          default:
            return !1;
        }
      }
      function gde(u) {
        return u = u.detail, typeof u == "object" && "data" in u ? u.data : null;
      }
      var Pv = !1;
      function EPe(u, h) {
        switch (u) {
          case "compositionend":
            return gde(h);
          case "keypress":
            return h.which !== 32 ? null : (fde = !0, pde);
          case "textInput":
            return u = h.data, u === pde && fde ? null : u;
          default:
            return null;
        }
      }
      function TPe(u, h) {
        if (Pv) return u === "compositionend" || !Uz && mde(u, h) ? (u = ade(), vI = Oz = gp = null, Pv = !1, u) : null;
        switch (u) {
          case "paste":
            return null;
          case "keypress":
            if (!(h.ctrlKey || h.altKey || h.metaKey) || h.ctrlKey && h.altKey) {
              if (h.char && 1 < h.char.length) return h.char;
              if (h.which) return String.fromCharCode(h.which);
            }
            return null;
          case "compositionend":
            return hde && h.locale !== "ko" ? null : h.data;
          default:
            return null;
        }
      }
      var CPe = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
      function yde(u) {
        var h = u && u.nodeName && u.nodeName.toLowerCase();
        return h === "input" ? !!CPe[u.type] : h === "textarea";
      }
      function vde(u, h, b, C) {
        Lce(C), h = kI(h, "onChange"), 0 < h.length && (b = new Dz("onChange", "change", null, b, C), u.push({ event: b, listeners: h }));
      }
      var JS = null, ew = null;
      function PPe(u) {
        Bde(u, 0);
      }
      function SI(u) {
        var h = Iv(u);
        if (Tn(h)) return u;
      }
      function APe(u, h) {
        if (u === "change") return h;
      }
      var bde = !1;
      T && (T ? (wI = "oninput" in document, wI || (Vz = document.createElement("div"), Vz.setAttribute("oninput", "return;"), wI = typeof Vz.oninput == "function"), zz = wI) : zz = !1, bde = zz && (!document.documentMode || 9 < document.documentMode));
      var zz, wI, Vz;
      function xde() {
        JS && (JS.detachEvent("onpropertychange", _de), ew = JS = null);
      }
      function _de(u) {
        if (u.propertyName === "value" && SI(ew)) {
          var h = [];
          vde(h, ew, u, _z(u)), Vce(PPe, h);
        }
      }
      function kPe(u, h, b) {
        u === "focusin" ? (xde(), JS = h, ew = b, JS.attachEvent("onpropertychange", _de)) : u === "focusout" && xde();
      }
      function MPe(u) {
        if (u === "selectionchange" || u === "keyup" || u === "keydown") return SI(ew);
      }
      function RPe(u, h) {
        if (u === "click") return SI(h);
      }
      function IPe(u, h) {
        if (u === "input" || u === "change") return SI(h);
      }
      function NPe(u, h) {
        return u === h && (u !== 0 || 1 / u === 1 / h) || u !== u && h !== h;
      }
      var Yl = typeof Object.is == "function" ? Object.is : NPe;
      function tw(u, h) {
        if (Yl(u, h)) return !0;
        if (typeof u != "object" || u === null || typeof h != "object" || h === null) return !1;
        var b = Object.keys(u), C = Object.keys(h);
        if (b.length !== C.length) return !1;
        for (C = 0; C < b.length; C++) {
          var D = b[C];
          if (!P.call(h, D) || !Yl(u[D], h[D])) return !1;
        }
        return !0;
      }
      function Sde(u) {
        for (; u && u.firstChild; ) u = u.firstChild;
        return u;
      }
      function wde(u, h) {
        var b = Sde(u);
        u = 0;
        for (var C; b; ) {
          if (b.nodeType === 3) {
            if (C = u + b.textContent.length, u <= h && C >= h) return { node: b, offset: h - u };
            u = C;
          }
          e: {
            for (; b; ) {
              if (b.nextSibling) {
                b = b.nextSibling;
                break e;
              }
              b = b.parentNode;
            }
            b = void 0;
          }
          b = Sde(b);
        }
      }
      function Ede(u, h) {
        return u && h ? u === h ? !0 : u && u.nodeType === 3 ? !1 : h && h.nodeType === 3 ? Ede(u, h.parentNode) : "contains" in u ? u.contains(h) : u.compareDocumentPosition ? !!(u.compareDocumentPosition(h) & 16) : !1 : !1;
      }
      function Tde() {
        for (var u = window, h = dr(); h instanceof u.HTMLIFrameElement; ) {
          try {
            var b = typeof h.contentWindow.location.href == "string";
          } catch {
            b = !1;
          }
          if (b) u = h.contentWindow;
          else break;
          h = dr(u.document);
        }
        return h;
      }
      function Gz(u) {
        var h = u && u.nodeName && u.nodeName.toLowerCase();
        return h && (h === "input" && (u.type === "text" || u.type === "search" || u.type === "tel" || u.type === "url" || u.type === "password") || h === "textarea" || u.contentEditable === "true");
      }
      function OPe(u) {
        var h = Tde(), b = u.focusedElem, C = u.selectionRange;
        if (h !== b && b && b.ownerDocument && Ede(b.ownerDocument.documentElement, b)) {
          if (C !== null && Gz(b)) {
            if (h = C.start, u = C.end, u === void 0 && (u = h), "selectionStart" in b) b.selectionStart = h, b.selectionEnd = Math.min(u, b.value.length);
            else if (u = (h = b.ownerDocument || document) && h.defaultView || window, u.getSelection) {
              u = u.getSelection();
              var D = b.textContent.length, G = Math.min(C.start, D);
              C = C.end === void 0 ? G : Math.min(C.end, D), !u.extend && G > C && (D = C, C = G, G = D), D = wde(b, G);
              var Z = wde(b, C);
              D && Z && (u.rangeCount !== 1 || u.anchorNode !== D.node || u.anchorOffset !== D.offset || u.focusNode !== Z.node || u.focusOffset !== Z.offset) && (h = h.createRange(), h.setStart(D.node, D.offset), u.removeAllRanges(), G > C ? (u.addRange(h), u.extend(Z.node, Z.offset)) : (h.setEnd(Z.node, Z.offset), u.addRange(h)));
            }
          }
          for (h = [], u = b; u = u.parentNode; ) u.nodeType === 1 && h.push({ element: u, left: u.scrollLeft, top: u.scrollTop });
          for (typeof b.focus == "function" && b.focus(), b = 0; b < h.length; b++) u = h[b], u.element.scrollLeft = u.left, u.element.scrollTop = u.top;
        }
      }
      var DPe = T && "documentMode" in document && 11 >= document.documentMode, Av = null, qz = null, nw = null, Hz = !1;
      function Cde(u, h, b) {
        var C = b.window === b ? b.document : b.nodeType === 9 ? b : b.ownerDocument;
        Hz || Av == null || Av !== dr(C) || (C = Av, "selectionStart" in C && Gz(C) ? C = { start: C.selectionStart, end: C.selectionEnd } : (C = (C.ownerDocument && C.ownerDocument.defaultView || window).getSelection(), C = { anchorNode: C.anchorNode, anchorOffset: C.anchorOffset, focusNode: C.focusNode, focusOffset: C.focusOffset }), nw && tw(nw, C) || (nw = C, C = kI(qz, "onSelect"), 0 < C.length && (h = new Dz("onSelect", "select", null, h, b), u.push({ event: h, listeners: C }), h.target = Av)));
      }
      function EI(u, h) {
        var b = {};
        return b[u.toLowerCase()] = h.toLowerCase(), b["Webkit" + u] = "webkit" + h, b["Moz" + u] = "moz" + h, b;
      }
      var kv = { animationend: EI("Animation", "AnimationEnd"), animationiteration: EI("Animation", "AnimationIteration"), animationstart: EI("Animation", "AnimationStart"), transitionend: EI("Transition", "TransitionEnd") }, $z = {}, Pde = {};
      T && (Pde = document.createElement("div").style, "AnimationEvent" in window || (delete kv.animationend.animation, delete kv.animationiteration.animation, delete kv.animationstart.animation), "TransitionEvent" in window || delete kv.transitionend.transition);
      function TI(u) {
        if ($z[u]) return $z[u];
        if (!kv[u]) return u;
        var h = kv[u], b;
        for (b in h) if (h.hasOwnProperty(b) && b in Pde) return $z[u] = h[b];
        return u;
      }
      var Ade = TI("animationend"), kde = TI("animationiteration"), Mde = TI("animationstart"), Rde = TI("transitionend"), Ide = /* @__PURE__ */ new Map(), Nde = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
      function yp(u, h) {
        Ide.set(u, h), x(h, [u]);
      }
      for (PI = 0; PI < Nde.length; PI++) CI = Nde[PI], Ode = CI.toLowerCase(), Dde = CI[0].toUpperCase() + CI.slice(1), yp(Ode, "on" + Dde);
      var CI, Ode, Dde, PI;
      yp(Ade, "onAnimationEnd"), yp(kde, "onAnimationIteration"), yp(Mde, "onAnimationStart"), yp("dblclick", "onDoubleClick"), yp("focusin", "onFocus"), yp("focusout", "onBlur"), yp(Rde, "onTransitionEnd"), w("onMouseEnter", ["mouseout", "mouseover"]), w("onMouseLeave", ["mouseout", "mouseover"]), w("onPointerEnter", ["pointerout", "pointerover"]), w("onPointerLeave", ["pointerout", "pointerover"]), x("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), x("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), x("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), x("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), x("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), x("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
      var rw = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), FPe = new Set("cancel close invalid load scroll toggle".split(" ").concat(rw));
      function Fde(u, h, b) {
        var C = u.type || "unknown-event";
        u.currentTarget = b, FCe(C, h, void 0, u), u.currentTarget = null;
      }
      function Bde(u, h) {
        h = (h & 4) !== 0;
        for (var b = 0; b < u.length; b++) {
          var C = u[b], D = C.event;
          C = C.listeners;
          e: {
            var G = void 0;
            if (h) for (var Z = C.length - 1; 0 <= Z; Z--) {
              var me = C[Z], Te = me.instance, Ke = me.currentTarget;
              if (me = me.listener, Te !== G && D.isPropagationStopped()) break e;
              Fde(D, me, Ke), G = Te;
            }
            else for (Z = 0; Z < C.length; Z++) {
              if (me = C[Z], Te = me.instance, Ke = me.currentTarget, me = me.listener, Te !== G && D.isPropagationStopped()) break e;
              Fde(D, me, Ke), G = Te;
            }
          }
        }
        if (lI) throw u = Tz, lI = !1, Tz = null, u;
      }
      function Ur(u, h) {
        var b = h[e4];
        b === void 0 && (b = h[e4] = /* @__PURE__ */ new Set());
        var C = u + "__bubble";
        b.has(C) || (Lde(h, u, 2, !1), b.add(C));
      }
      function Wz(u, h, b) {
        var C = 0;
        h && (C |= 4), Lde(b, u, C, h);
      }
      var AI = "_reactListening" + Math.random().toString(36).slice(2);
      function iw(u) {
        if (!u[AI]) {
          u[AI] = !0, m.forEach(function(b) {
            b !== "selectionchange" && (FPe.has(b) || Wz(b, !1, u), Wz(b, !0, u));
          });
          var h = u.nodeType === 9 ? u : u.ownerDocument;
          h === null || h[AI] || (h[AI] = !0, Wz("selectionchange", !1, h));
        }
      }
      function Lde(u, h, b, C) {
        switch (ode(h)) {
          case 1:
            var D = ZCe;
            break;
          case 4:
            D = JCe;
            break;
          default:
            D = Iz;
        }
        b = D.bind(null, h, b, u), D = void 0, !Ez || h !== "touchstart" && h !== "touchmove" && h !== "wheel" || (D = !0), C ? D !== void 0 ? u.addEventListener(h, b, { capture: !0, passive: D }) : u.addEventListener(h, b, !0) : D !== void 0 ? u.addEventListener(h, b, { passive: D }) : u.addEventListener(h, b, !1);
      }
      function Kz(u, h, b, C, D) {
        var G = C;
        if (!(h & 1) && !(h & 2) && C !== null) e: for (; ; ) {
          if (C === null) return;
          var Z = C.tag;
          if (Z === 3 || Z === 4) {
            var me = C.stateNode.containerInfo;
            if (me === D || me.nodeType === 8 && me.parentNode === D) break;
            if (Z === 4) for (Z = C.return; Z !== null; ) {
              var Te = Z.tag;
              if ((Te === 3 || Te === 4) && (Te = Z.stateNode.containerInfo, Te === D || Te.nodeType === 8 && Te.parentNode === D)) return;
              Z = Z.return;
            }
            for (; me !== null; ) {
              if (Z = zm(me), Z === null) return;
              if (Te = Z.tag, Te === 5 || Te === 6) {
                C = G = Z;
                continue e;
              }
              me = me.parentNode;
            }
          }
          C = C.return;
        }
        Vce(function() {
          var Ke = G, mt = _z(b), gt = [];
          e: {
            var ft = Ide.get(u);
            if (ft !== void 0) {
              var kt = Dz, Ft = u;
              switch (u) {
                case "keypress":
                  if (bI(b) === 0) break e;
                case "keydown":
                case "keyup":
                  kt = fPe;
                  break;
                case "focusin":
                  Ft = "focus", kt = Lz;
                  break;
                case "focusout":
                  Ft = "blur", kt = Lz;
                  break;
                case "beforeblur":
                case "afterblur":
                  kt = Lz;
                  break;
                case "click":
                  if (b.button === 2) break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  kt = ude;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  kt = nPe;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  kt = yPe;
                  break;
                case Ade:
                case kde:
                case Mde:
                  kt = sPe;
                  break;
                case Rde:
                  kt = bPe;
                  break;
                case "scroll":
                  kt = ePe;
                  break;
                case "wheel":
                  kt = _Pe;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  kt = aPe;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  kt = dde;
              }
              var Bt = (h & 4) !== 0, vi = !Bt && u === "scroll", ze = Bt ? ft !== null ? ft + "Capture" : null : ft;
              Bt = [];
              for (var Ne = Ke, qe; Ne !== null; ) {
                qe = Ne;
                var vt = qe.stateNode;
                if (qe.tag === 5 && vt !== null && (qe = vt, ze !== null && (vt = zS(Ne, ze), vt != null && Bt.push(sw(Ne, vt, qe)))), vi) break;
                Ne = Ne.return;
              }
              0 < Bt.length && (ft = new kt(ft, Ft, null, b, mt), gt.push({ event: ft, listeners: Bt }));
            }
          }
          if (!(h & 7)) {
            e: {
              if (ft = u === "mouseover" || u === "pointerover", kt = u === "mouseout" || u === "pointerout", ft && b !== xz && (Ft = b.relatedTarget || b.fromElement) && (zm(Ft) || Ft[xd])) break e;
              if ((kt || ft) && (ft = mt.window === mt ? mt : (ft = mt.ownerDocument) ? ft.defaultView || ft.parentWindow : window, kt ? (Ft = b.relatedTarget || b.toElement, kt = Ke, Ft = Ft ? zm(Ft) : null, Ft !== null && (vi = Um(Ft), Ft !== vi || Ft.tag !== 5 && Ft.tag !== 6) && (Ft = null)) : (kt = null, Ft = Ke), kt !== Ft)) {
                if (Bt = ude, vt = "onMouseLeave", ze = "onMouseEnter", Ne = "mouse", (u === "pointerout" || u === "pointerover") && (Bt = dde, vt = "onPointerLeave", ze = "onPointerEnter", Ne = "pointer"), vi = kt == null ? ft : Iv(kt), qe = Ft == null ? ft : Iv(Ft), ft = new Bt(vt, Ne + "leave", kt, b, mt), ft.target = vi, ft.relatedTarget = qe, vt = null, zm(mt) === Ke && (Bt = new Bt(ze, Ne + "enter", Ft, b, mt), Bt.target = qe, Bt.relatedTarget = vi, vt = Bt), vi = vt, kt && Ft) t: {
                  for (Bt = kt, ze = Ft, Ne = 0, qe = Bt; qe; qe = Mv(qe)) Ne++;
                  for (qe = 0, vt = ze; vt; vt = Mv(vt)) qe++;
                  for (; 0 < Ne - qe; ) Bt = Mv(Bt), Ne--;
                  for (; 0 < qe - Ne; ) ze = Mv(ze), qe--;
                  for (; Ne--; ) {
                    if (Bt === ze || ze !== null && Bt === ze.alternate) break t;
                    Bt = Mv(Bt), ze = Mv(ze);
                  }
                  Bt = null;
                }
                else Bt = null;
                kt !== null && jde(gt, ft, kt, Bt, !1), Ft !== null && vi !== null && jde(gt, vi, Ft, Bt, !0);
              }
            }
            e: {
              if (ft = Ke ? Iv(Ke) : window, kt = ft.nodeName && ft.nodeName.toLowerCase(), kt === "select" || kt === "input" && ft.type === "file") var Ut = APe;
              else if (yde(ft)) if (bde) Ut = IPe;
              else {
                Ut = MPe;
                var Xt = kPe;
              }
              else (kt = ft.nodeName) && kt.toLowerCase() === "input" && (ft.type === "checkbox" || ft.type === "radio") && (Ut = RPe);
              if (Ut && (Ut = Ut(u, Ke))) {
                vde(gt, Ut, b, mt);
                break e;
              }
              Xt && Xt(u, ft, Ke), u === "focusout" && (Xt = ft._wrapperState) && Xt.controlled && ft.type === "number" && ei(ft, "number", ft.value);
            }
            switch (Xt = Ke ? Iv(Ke) : window, u) {
              case "focusin":
                (yde(Xt) || Xt.contentEditable === "true") && (Av = Xt, qz = Ke, nw = null);
                break;
              case "focusout":
                nw = qz = Av = null;
                break;
              case "mousedown":
                Hz = !0;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                Hz = !1, Cde(gt, b, mt);
                break;
              case "selectionchange":
                if (DPe) break;
              case "keydown":
              case "keyup":
                Cde(gt, b, mt);
            }
            var Qt;
            if (Uz) e: {
              switch (u) {
                case "compositionstart":
                  var un = "onCompositionStart";
                  break e;
                case "compositionend":
                  un = "onCompositionEnd";
                  break e;
                case "compositionupdate":
                  un = "onCompositionUpdate";
                  break e;
              }
              un = void 0;
            }
            else Pv ? mde(u, b) && (un = "onCompositionEnd") : u === "keydown" && b.keyCode === 229 && (un = "onCompositionStart");
            un && (hde && b.locale !== "ko" && (Pv || un !== "onCompositionStart" ? un === "onCompositionEnd" && Pv && (Qt = ade()) : (gp = mt, Oz = "value" in gp ? gp.value : gp.textContent, Pv = !0)), Xt = kI(Ke, un), 0 < Xt.length && (un = new cde(un, u, null, b, mt), gt.push({ event: un, listeners: Xt }), Qt ? un.data = Qt : (Qt = gde(b), Qt !== null && (un.data = Qt)))), (Qt = wPe ? EPe(u, b) : TPe(u, b)) && (Ke = kI(Ke, "onBeforeInput"), 0 < Ke.length && (mt = new cde("onBeforeInput", "beforeinput", null, b, mt), gt.push({ event: mt, listeners: Ke }), mt.data = Qt));
          }
          Bde(gt, h);
        });
      }
      function sw(u, h, b) {
        return { instance: u, listener: h, currentTarget: b };
      }
      function kI(u, h) {
        for (var b = h + "Capture", C = []; u !== null; ) {
          var D = u, G = D.stateNode;
          D.tag === 5 && G !== null && (D = G, G = zS(u, b), G != null && C.unshift(sw(u, G, D)), G = zS(u, h), G != null && C.push(sw(u, G, D))), u = u.return;
        }
        return C;
      }
      function Mv(u) {
        if (u === null) return null;
        do
          u = u.return;
        while (u && u.tag !== 5);
        return u || null;
      }
      function jde(u, h, b, C, D) {
        for (var G = h._reactName, Z = []; b !== null && b !== C; ) {
          var me = b, Te = me.alternate, Ke = me.stateNode;
          if (Te !== null && Te === C) break;
          me.tag === 5 && Ke !== null && (me = Ke, D ? (Te = zS(b, G), Te != null && Z.unshift(sw(b, Te, me))) : D || (Te = zS(b, G), Te != null && Z.push(sw(b, Te, me)))), b = b.return;
        }
        Z.length !== 0 && u.push({ event: h, listeners: Z });
      }
      var BPe = /\r\n?/g, LPe = /\u0000|\uFFFD/g;
      function Ude(u) {
        return (typeof u == "string" ? u : "" + u).replace(BPe, `
`).replace(LPe, "");
      }
      function MI(u, h, b) {
        if (h = Ude(h), Ude(u) !== h && b) throw Error(d(425));
      }
      function RI() {
      }
      var Yz = null, Xz = null;
      function Qz(u, h) {
        return u === "textarea" || u === "noscript" || typeof h.children == "string" || typeof h.children == "number" || typeof h.dangerouslySetInnerHTML == "object" && h.dangerouslySetInnerHTML !== null && h.dangerouslySetInnerHTML.__html != null;
      }
      var Zz = typeof setTimeout == "function" ? setTimeout : void 0, jPe = typeof clearTimeout == "function" ? clearTimeout : void 0, zde = typeof Promise == "function" ? Promise : void 0, UPe = typeof queueMicrotask == "function" ? queueMicrotask : typeof zde < "u" ? function(u) {
        return zde.resolve(null).then(u).catch(zPe);
      } : Zz;
      function zPe(u) {
        setTimeout(function() {
          throw u;
        });
      }
      function Jz(u, h) {
        var b = h, C = 0;
        do {
          var D = b.nextSibling;
          if (u.removeChild(b), D && D.nodeType === 8) if (b = D.data, b === "/$") {
            if (C === 0) {
              u.removeChild(D), YS(h);
              return;
            }
            C--;
          } else b !== "$" && b !== "$?" && b !== "$!" || C++;
          b = D;
        } while (b);
        YS(h);
      }
      function vp(u) {
        for (; u != null; u = u.nextSibling) {
          var h = u.nodeType;
          if (h === 1 || h === 3) break;
          if (h === 8) {
            if (h = u.data, h === "$" || h === "$!" || h === "$?") break;
            if (h === "/$") return null;
          }
        }
        return u;
      }
      function Vde(u) {
        u = u.previousSibling;
        for (var h = 0; u; ) {
          if (u.nodeType === 8) {
            var b = u.data;
            if (b === "$" || b === "$!" || b === "$?") {
              if (h === 0) return u;
              h--;
            } else b === "/$" && h++;
          }
          u = u.previousSibling;
        }
        return null;
      }
      var Rv = Math.random().toString(36).slice(2), ic = "__reactFiber$" + Rv, ow = "__reactProps$" + Rv, xd = "__reactContainer$" + Rv, e4 = "__reactEvents$" + Rv, VPe = "__reactListeners$" + Rv, GPe = "__reactHandles$" + Rv;
      function zm(u) {
        var h = u[ic];
        if (h) return h;
        for (var b = u.parentNode; b; ) {
          if (h = b[xd] || b[ic]) {
            if (b = h.alternate, h.child !== null || b !== null && b.child !== null) for (u = Vde(u); u !== null; ) {
              if (b = u[ic]) return b;
              u = Vde(u);
            }
            return h;
          }
          u = b, b = u.parentNode;
        }
        return null;
      }
      function aw(u) {
        return u = u[ic] || u[xd], !u || u.tag !== 5 && u.tag !== 6 && u.tag !== 13 && u.tag !== 3 ? null : u;
      }
      function Iv(u) {
        if (u.tag === 5 || u.tag === 6) return u.stateNode;
        throw Error(d(33));
      }
      function II(u) {
        return u[ow] || null;
      }
      var t4 = [], Nv = -1;
      function bp(u) {
        return { current: u };
      }
      function zr(u) {
        0 > Nv || (u.current = t4[Nv], t4[Nv] = null, Nv--);
      }
      function Mr(u, h) {
        Nv++, t4[Nv] = u.current, u.current = h;
      }
      var xp = {}, Gs = bp(xp), Bo = bp(!1), Vm = xp;
      function Ov(u, h) {
        var b = u.type.contextTypes;
        if (!b) return xp;
        var C = u.stateNode;
        if (C && C.__reactInternalMemoizedUnmaskedChildContext === h) return C.__reactInternalMemoizedMaskedChildContext;
        var D = {}, G;
        for (G in b) D[G] = h[G];
        return C && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = h, u.__reactInternalMemoizedMaskedChildContext = D), D;
      }
      function Lo(u) {
        return u = u.childContextTypes, u != null;
      }
      function NI() {
        zr(Bo), zr(Gs);
      }
      function Gde(u, h, b) {
        if (Gs.current !== xp) throw Error(d(168));
        Mr(Gs, h), Mr(Bo, b);
      }
      function qde(u, h, b) {
        var C = u.stateNode;
        if (h = h.childContextTypes, typeof C.getChildContext != "function") return b;
        C = C.getChildContext();
        for (var D in C) if (!(D in h)) throw Error(d(108, Ge(u) || "Unknown", D));
        return de({}, b, C);
      }
      function OI(u) {
        return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || xp, Vm = Gs.current, Mr(Gs, u), Mr(Bo, Bo.current), !0;
      }
      function Hde(u, h, b) {
        var C = u.stateNode;
        if (!C) throw Error(d(169));
        b ? (u = qde(u, h, Vm), C.__reactInternalMemoizedMergedChildContext = u, zr(Bo), zr(Gs), Mr(Gs, u)) : zr(Bo), Mr(Bo, b);
      }
      var _d = null, DI = !1, n4 = !1;
      function $de(u) {
        _d === null ? _d = [u] : _d.push(u);
      }
      function qPe(u) {
        DI = !0, $de(u);
      }
      function _p() {
        if (!n4 && _d !== null) {
          n4 = !0;
          var u = 0, h = hr;
          try {
            var b = _d;
            for (hr = 1; u < b.length; u++) {
              var C = b[u];
              do
                C = C(!0);
              while (C !== null);
            }
            _d = null, DI = !1;
          } catch (D) {
            throw _d !== null && (_d = _d.slice(u + 1)), Wce(Cz, _p), D;
          } finally {
            hr = h, n4 = !1;
          }
        }
        return null;
      }
      var Dv = [], Fv = 0, FI = null, BI = 0, Xa = [], Qa = 0, Gm = null, Sd = 1, wd = "";
      function qm(u, h) {
        Dv[Fv++] = BI, Dv[Fv++] = FI, FI = u, BI = h;
      }
      function Wde(u, h, b) {
        Xa[Qa++] = Sd, Xa[Qa++] = wd, Xa[Qa++] = Gm, Gm = u;
        var C = Sd;
        u = wd;
        var D = 32 - Kl(C) - 1;
        C &= ~(1 << D), b += 1;
        var G = 32 - Kl(h) + D;
        if (30 < G) {
          var Z = D - D % 5;
          G = (C & (1 << Z) - 1).toString(32), C >>= Z, D -= Z, Sd = 1 << 32 - Kl(h) + D | b << D | C, wd = G + u;
        } else Sd = 1 << G | b << D | C, wd = u;
      }
      function r4(u) {
        u.return !== null && (qm(u, 1), Wde(u, 1, 0));
      }
      function i4(u) {
        for (; u === FI; ) FI = Dv[--Fv], Dv[Fv] = null, BI = Dv[--Fv], Dv[Fv] = null;
        for (; u === Gm; ) Gm = Xa[--Qa], Xa[Qa] = null, wd = Xa[--Qa], Xa[Qa] = null, Sd = Xa[--Qa], Xa[Qa] = null;
      }
      var ha = null, pa = null, Wr = !1, Xl = null;
      function Kde(u, h) {
        var b = tl(5, null, null, 0);
        b.elementType = "DELETED", b.stateNode = h, b.return = u, h = u.deletions, h === null ? (u.deletions = [b], u.flags |= 16) : h.push(b);
      }
      function Yde(u, h) {
        switch (u.tag) {
          case 5:
            var b = u.type;
            return h = h.nodeType !== 1 || b.toLowerCase() !== h.nodeName.toLowerCase() ? null : h, h !== null ? (u.stateNode = h, ha = u, pa = vp(h.firstChild), !0) : !1;
          case 6:
            return h = u.pendingProps === "" || h.nodeType !== 3 ? null : h, h !== null ? (u.stateNode = h, ha = u, pa = null, !0) : !1;
          case 13:
            return h = h.nodeType !== 8 ? null : h, h !== null ? (b = Gm !== null ? { id: Sd, overflow: wd } : null, u.memoizedState = { dehydrated: h, treeContext: b, retryLane: 1073741824 }, b = tl(18, null, null, 0), b.stateNode = h, b.return = u, u.child = b, ha = u, pa = null, !0) : !1;
          default:
            return !1;
        }
      }
      function s4(u) {
        return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
      }
      function o4(u) {
        if (Wr) {
          var h = pa;
          if (h) {
            var b = h;
            if (!Yde(u, h)) {
              if (s4(u)) throw Error(d(418));
              h = vp(b.nextSibling);
              var C = ha;
              h && Yde(u, h) ? Kde(C, b) : (u.flags = u.flags & -4097 | 2, Wr = !1, ha = u);
            }
          } else {
            if (s4(u)) throw Error(d(418));
            u.flags = u.flags & -4097 | 2, Wr = !1, ha = u;
          }
        }
      }
      function Xde(u) {
        for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; ) u = u.return;
        ha = u;
      }
      function LI(u) {
        if (u !== ha) return !1;
        if (!Wr) return Xde(u), Wr = !0, !1;
        var h;
        if ((h = u.tag !== 3) && !(h = u.tag !== 5) && (h = u.type, h = h !== "head" && h !== "body" && !Qz(u.type, u.memoizedProps)), h && (h = pa)) {
          if (s4(u)) throw Qde(), Error(d(418));
          for (; h; ) Kde(u, h), h = vp(h.nextSibling);
        }
        if (Xde(u), u.tag === 13) {
          if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(d(317));
          e: {
            for (u = u.nextSibling, h = 0; u; ) {
              if (u.nodeType === 8) {
                var b = u.data;
                if (b === "/$") {
                  if (h === 0) {
                    pa = vp(u.nextSibling);
                    break e;
                  }
                  h--;
                } else b !== "$" && b !== "$!" && b !== "$?" || h++;
              }
              u = u.nextSibling;
            }
            pa = null;
          }
        } else pa = ha ? vp(u.stateNode.nextSibling) : null;
        return !0;
      }
      function Qde() {
        for (var u = pa; u; ) u = vp(u.nextSibling);
      }
      function Bv() {
        pa = ha = null, Wr = !1;
      }
      function a4(u) {
        Xl === null ? Xl = [u] : Xl.push(u);
      }
      var HPe = ue.ReactCurrentBatchConfig;
      function Ql(u, h) {
        if (u && u.defaultProps) {
          h = de({}, h), u = u.defaultProps;
          for (var b in u) h[b] === void 0 && (h[b] = u[b]);
          return h;
        }
        return h;
      }
      var jI = bp(null), UI = null, Lv = null, l4 = null;
      function u4() {
        l4 = Lv = UI = null;
      }
      function c4(u) {
        var h = jI.current;
        zr(jI), u._currentValue = h;
      }
      function d4(u, h, b) {
        for (; u !== null; ) {
          var C = u.alternate;
          if ((u.childLanes & h) !== h ? (u.childLanes |= h, C !== null && (C.childLanes |= h)) : C !== null && (C.childLanes & h) !== h && (C.childLanes |= h), u === b) break;
          u = u.return;
        }
      }
      function jv(u, h) {
        UI = u, l4 = Lv = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & h && (jo = !0), u.firstContext = null);
      }
      function Za(u) {
        var h = u._currentValue;
        if (l4 !== u) if (u = { context: u, memoizedValue: h, next: null }, Lv === null) {
          if (UI === null) throw Error(d(308));
          Lv = u, UI.dependencies = { lanes: 0, firstContext: u };
        } else Lv = Lv.next = u;
        return h;
      }
      var Hm = null;
      function h4(u) {
        Hm === null ? Hm = [u] : Hm.push(u);
      }
      function Zde(u, h, b, C) {
        var D = h.interleaved;
        return D === null ? (b.next = b, h4(h)) : (b.next = D.next, D.next = b), h.interleaved = b, Ed(u, C);
      }
      function Ed(u, h) {
        u.lanes |= h;
        var b = u.alternate;
        for (b !== null && (b.lanes |= h), b = u, u = u.return; u !== null; ) u.childLanes |= h, b = u.alternate, b !== null && (b.childLanes |= h), b = u, u = u.return;
        return b.tag === 3 ? b.stateNode : null;
      }
      var Sp = !1;
      function p4(u) {
        u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
      }
      function Jde(u, h) {
        u = u.updateQueue, h.updateQueue === u && (h.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects });
      }
      function Td(u, h) {
        return { eventTime: u, lane: h, tag: 0, payload: null, callback: null, next: null };
      }
      function wp(u, h, b) {
        var C = u.updateQueue;
        if (C === null) return null;
        if (C = C.shared, $n & 2) {
          var D = C.pending;
          return D === null ? h.next = h : (h.next = D.next, D.next = h), C.pending = h, Ed(u, b);
        }
        return D = C.interleaved, D === null ? (h.next = h, h4(C)) : (h.next = D.next, D.next = h), C.interleaved = h, Ed(u, b);
      }
      function zI(u, h, b) {
        if (h = h.updateQueue, h !== null && (h = h.shared, (b & 4194240) !== 0)) {
          var C = h.lanes;
          C &= u.pendingLanes, b |= C, h.lanes = b, kz(u, b);
        }
      }
      function ehe(u, h) {
        var b = u.updateQueue, C = u.alternate;
        if (C !== null && (C = C.updateQueue, b === C)) {
          var D = null, G = null;
          if (b = b.firstBaseUpdate, b !== null) {
            do {
              var Z = { eventTime: b.eventTime, lane: b.lane, tag: b.tag, payload: b.payload, callback: b.callback, next: null };
              G === null ? D = G = Z : G = G.next = Z, b = b.next;
            } while (b !== null);
            G === null ? D = G = h : G = G.next = h;
          } else D = G = h;
          b = { baseState: C.baseState, firstBaseUpdate: D, lastBaseUpdate: G, shared: C.shared, effects: C.effects }, u.updateQueue = b;
          return;
        }
        u = b.lastBaseUpdate, u === null ? b.firstBaseUpdate = h : u.next = h, b.lastBaseUpdate = h;
      }
      function VI(u, h, b, C) {
        var D = u.updateQueue;
        Sp = !1;
        var G = D.firstBaseUpdate, Z = D.lastBaseUpdate, me = D.shared.pending;
        if (me !== null) {
          D.shared.pending = null;
          var Te = me, Ke = Te.next;
          Te.next = null, Z === null ? G = Ke : Z.next = Ke, Z = Te;
          var mt = u.alternate;
          mt !== null && (mt = mt.updateQueue, me = mt.lastBaseUpdate, me !== Z && (me === null ? mt.firstBaseUpdate = Ke : me.next = Ke, mt.lastBaseUpdate = Te));
        }
        if (G !== null) {
          var gt = D.baseState;
          Z = 0, mt = Ke = Te = null, me = G;
          do {
            var ft = me.lane, kt = me.eventTime;
            if ((C & ft) === ft) {
              mt !== null && (mt = mt.next = { eventTime: kt, lane: 0, tag: me.tag, payload: me.payload, callback: me.callback, next: null });
              e: {
                var Ft = u, Bt = me;
                switch (ft = h, kt = b, Bt.tag) {
                  case 1:
                    if (Ft = Bt.payload, typeof Ft == "function") {
                      gt = Ft.call(kt, gt, ft);
                      break e;
                    }
                    gt = Ft;
                    break e;
                  case 3:
                    Ft.flags = Ft.flags & -65537 | 128;
                  case 0:
                    if (Ft = Bt.payload, ft = typeof Ft == "function" ? Ft.call(kt, gt, ft) : Ft, ft == null) break e;
                    gt = de({}, gt, ft);
                    break e;
                  case 2:
                    Sp = !0;
                }
              }
              me.callback !== null && me.lane !== 0 && (u.flags |= 64, ft = D.effects, ft === null ? D.effects = [me] : ft.push(me));
            } else kt = { eventTime: kt, lane: ft, tag: me.tag, payload: me.payload, callback: me.callback, next: null }, mt === null ? (Ke = mt = kt, Te = gt) : mt = mt.next = kt, Z |= ft;
            if (me = me.next, me === null) {
              if (me = D.shared.pending, me === null) break;
              ft = me, me = ft.next, ft.next = null, D.lastBaseUpdate = ft, D.shared.pending = null;
            }
          } while (!0);
          if (mt === null && (Te = gt), D.baseState = Te, D.firstBaseUpdate = Ke, D.lastBaseUpdate = mt, h = D.shared.interleaved, h !== null) {
            D = h;
            do
              Z |= D.lane, D = D.next;
            while (D !== h);
          } else G === null && (D.shared.lanes = 0);
          Km |= Z, u.lanes = Z, u.memoizedState = gt;
        }
      }
      function the(u, h, b) {
        if (u = h.effects, h.effects = null, u !== null) for (h = 0; h < u.length; h++) {
          var C = u[h], D = C.callback;
          if (D !== null) {
            if (C.callback = null, C = b, typeof D != "function") throw Error(d(191, D));
            D.call(C);
          }
        }
      }
      var nhe = new s.Component().refs;
      function f4(u, h, b, C) {
        h = u.memoizedState, b = b(C, h), b = b == null ? h : de({}, h, b), u.memoizedState = b, u.lanes === 0 && (u.updateQueue.baseState = b);
      }
      var GI = { isMounted: function(u) {
        return (u = u._reactInternals) ? Um(u) === u : !1;
      }, enqueueSetState: function(u, h, b) {
        u = u._reactInternals;
        var C = co(), D = Pp(u), G = Td(C, D);
        G.payload = h, b != null && (G.callback = b), h = wp(u, G, D), h !== null && (eu(h, u, D, C), zI(h, u, D));
      }, enqueueReplaceState: function(u, h, b) {
        u = u._reactInternals;
        var C = co(), D = Pp(u), G = Td(C, D);
        G.tag = 1, G.payload = h, b != null && (G.callback = b), h = wp(u, G, D), h !== null && (eu(h, u, D, C), zI(h, u, D));
      }, enqueueForceUpdate: function(u, h) {
        u = u._reactInternals;
        var b = co(), C = Pp(u), D = Td(b, C);
        D.tag = 2, h != null && (D.callback = h), h = wp(u, D, C), h !== null && (eu(h, u, C, b), zI(h, u, C));
      } };
      function rhe(u, h, b, C, D, G, Z) {
        return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(C, G, Z) : h.prototype && h.prototype.isPureReactComponent ? !tw(b, C) || !tw(D, G) : !0;
      }
      function ihe(u, h, b) {
        var C = !1, D = xp, G = h.contextType;
        return typeof G == "object" && G !== null ? G = Za(G) : (D = Lo(h) ? Vm : Gs.current, C = h.contextTypes, G = (C = C != null) ? Ov(u, D) : xp), h = new h(b, G), u.memoizedState = h.state !== null && h.state !== void 0 ? h.state : null, h.updater = GI, u.stateNode = h, h._reactInternals = u, C && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = D, u.__reactInternalMemoizedMaskedChildContext = G), h;
      }
      function she(u, h, b, C) {
        u = h.state, typeof h.componentWillReceiveProps == "function" && h.componentWillReceiveProps(b, C), typeof h.UNSAFE_componentWillReceiveProps == "function" && h.UNSAFE_componentWillReceiveProps(b, C), h.state !== u && GI.enqueueReplaceState(h, h.state, null);
      }
      function m4(u, h, b, C) {
        var D = u.stateNode;
        D.props = b, D.state = u.memoizedState, D.refs = nhe, p4(u);
        var G = h.contextType;
        typeof G == "object" && G !== null ? D.context = Za(G) : (G = Lo(h) ? Vm : Gs.current, D.context = Ov(u, G)), D.state = u.memoizedState, G = h.getDerivedStateFromProps, typeof G == "function" && (f4(u, h, G, b), D.state = u.memoizedState), typeof h.getDerivedStateFromProps == "function" || typeof D.getSnapshotBeforeUpdate == "function" || typeof D.UNSAFE_componentWillMount != "function" && typeof D.componentWillMount != "function" || (h = D.state, typeof D.componentWillMount == "function" && D.componentWillMount(), typeof D.UNSAFE_componentWillMount == "function" && D.UNSAFE_componentWillMount(), h !== D.state && GI.enqueueReplaceState(D, D.state, null), VI(u, b, D, C), D.state = u.memoizedState), typeof D.componentDidMount == "function" && (u.flags |= 4194308);
      }
      function lw(u, h, b) {
        if (u = b.ref, u !== null && typeof u != "function" && typeof u != "object") {
          if (b._owner) {
            if (b = b._owner, b) {
              if (b.tag !== 1) throw Error(d(309));
              var C = b.stateNode;
            }
            if (!C) throw Error(d(147, u));
            var D = C, G = "" + u;
            return h !== null && h.ref !== null && typeof h.ref == "function" && h.ref._stringRef === G ? h.ref : (h = function(Z) {
              var me = D.refs;
              me === nhe && (me = D.refs = {}), Z === null ? delete me[G] : me[G] = Z;
            }, h._stringRef = G, h);
          }
          if (typeof u != "string") throw Error(d(284));
          if (!b._owner) throw Error(d(290, u));
        }
        return u;
      }
      function qI(u, h) {
        throw u = Object.prototype.toString.call(h), Error(d(31, u === "[object Object]" ? "object with keys {" + Object.keys(h).join(", ") + "}" : u));
      }
      function ohe(u) {
        var h = u._init;
        return h(u._payload);
      }
      function ahe(u) {
        function h(ze, Ne) {
          if (u) {
            var qe = ze.deletions;
            qe === null ? (ze.deletions = [Ne], ze.flags |= 16) : qe.push(Ne);
          }
        }
        function b(ze, Ne) {
          if (!u) return null;
          for (; Ne !== null; ) h(ze, Ne), Ne = Ne.sibling;
          return null;
        }
        function C(ze, Ne) {
          for (ze = /* @__PURE__ */ new Map(); Ne !== null; ) Ne.key !== null ? ze.set(Ne.key, Ne) : ze.set(Ne.index, Ne), Ne = Ne.sibling;
          return ze;
        }
        function D(ze, Ne) {
          return ze = kp(ze, Ne), ze.index = 0, ze.sibling = null, ze;
        }
        function G(ze, Ne, qe) {
          return ze.index = qe, u ? (qe = ze.alternate, qe !== null ? (qe = qe.index, qe < Ne ? (ze.flags |= 2, Ne) : qe) : (ze.flags |= 2, Ne)) : (ze.flags |= 1048576, Ne);
        }
        function Z(ze) {
          return u && ze.alternate === null && (ze.flags |= 2), ze;
        }
        function me(ze, Ne, qe, vt) {
          return Ne === null || Ne.tag !== 6 ? (Ne = Q4(qe, ze.mode, vt), Ne.return = ze, Ne) : (Ne = D(Ne, qe), Ne.return = ze, Ne);
        }
        function Te(ze, Ne, qe, vt) {
          var Ut = qe.type;
          return Ut === he ? mt(ze, Ne, qe.props.children, vt, qe.key) : Ne !== null && (Ne.elementType === Ut || typeof Ut == "object" && Ut !== null && Ut.$$typeof === Ce && ohe(Ut) === Ne.type) ? (vt = D(Ne, qe.props), vt.ref = lw(ze, Ne, qe), vt.return = ze, vt) : (vt = uN(qe.type, qe.key, qe.props, null, ze.mode, vt), vt.ref = lw(ze, Ne, qe), vt.return = ze, vt);
        }
        function Ke(ze, Ne, qe, vt) {
          return Ne === null || Ne.tag !== 4 || Ne.stateNode.containerInfo !== qe.containerInfo || Ne.stateNode.implementation !== qe.implementation ? (Ne = Z4(qe, ze.mode, vt), Ne.return = ze, Ne) : (Ne = D(Ne, qe.children || []), Ne.return = ze, Ne);
        }
        function mt(ze, Ne, qe, vt, Ut) {
          return Ne === null || Ne.tag !== 7 ? (Ne = Zm(qe, ze.mode, vt, Ut), Ne.return = ze, Ne) : (Ne = D(Ne, qe), Ne.return = ze, Ne);
        }
        function gt(ze, Ne, qe) {
          if (typeof Ne == "string" && Ne !== "" || typeof Ne == "number") return Ne = Q4("" + Ne, ze.mode, qe), Ne.return = ze, Ne;
          if (typeof Ne == "object" && Ne !== null) {
            switch (Ne.$$typeof) {
              case se:
                return qe = uN(Ne.type, Ne.key, Ne.props, null, ze.mode, qe), qe.ref = lw(ze, null, Ne), qe.return = ze, qe;
              case Oe:
                return Ne = Z4(Ne, ze.mode, qe), Ne.return = ze, Ne;
              case Ce:
                var vt = Ne._init;
                return gt(ze, vt(Ne._payload), qe);
            }
            if (Ka(Ne) || $e(Ne)) return Ne = Zm(Ne, ze.mode, qe, null), Ne.return = ze, Ne;
            qI(ze, Ne);
          }
          return null;
        }
        function ft(ze, Ne, qe, vt) {
          var Ut = Ne !== null ? Ne.key : null;
          if (typeof qe == "string" && qe !== "" || typeof qe == "number") return Ut !== null ? null : me(ze, Ne, "" + qe, vt);
          if (typeof qe == "object" && qe !== null) {
            switch (qe.$$typeof) {
              case se:
                return qe.key === Ut ? Te(ze, Ne, qe, vt) : null;
              case Oe:
                return qe.key === Ut ? Ke(ze, Ne, qe, vt) : null;
              case Ce:
                return Ut = qe._init, ft(ze, Ne, Ut(qe._payload), vt);
            }
            if (Ka(qe) || $e(qe)) return Ut !== null ? null : mt(ze, Ne, qe, vt, null);
            qI(ze, qe);
          }
          return null;
        }
        function kt(ze, Ne, qe, vt, Ut) {
          if (typeof vt == "string" && vt !== "" || typeof vt == "number") return ze = ze.get(qe) || null, me(Ne, ze, "" + vt, Ut);
          if (typeof vt == "object" && vt !== null) {
            switch (vt.$$typeof) {
              case se:
                return ze = ze.get(vt.key === null ? qe : vt.key) || null, Te(Ne, ze, vt, Ut);
              case Oe:
                return ze = ze.get(vt.key === null ? qe : vt.key) || null, Ke(Ne, ze, vt, Ut);
              case Ce:
                var Xt = vt._init;
                return kt(ze, Ne, qe, Xt(vt._payload), Ut);
            }
            if (Ka(vt) || $e(vt)) return ze = ze.get(qe) || null, mt(Ne, ze, vt, Ut, null);
            qI(Ne, vt);
          }
          return null;
        }
        function Ft(ze, Ne, qe, vt) {
          for (var Ut = null, Xt = null, Qt = Ne, un = Ne = 0, os = null; Qt !== null && un < qe.length; un++) {
            Qt.index > un ? (os = Qt, Qt = null) : os = Qt.sibling;
            var Qn = ft(ze, Qt, qe[un], vt);
            if (Qn === null) {
              Qt === null && (Qt = os);
              break;
            }
            u && Qt && Qn.alternate === null && h(ze, Qt), Ne = G(Qn, Ne, un), Xt === null ? Ut = Qn : Xt.sibling = Qn, Xt = Qn, Qt = os;
          }
          if (un === qe.length) return b(ze, Qt), Wr && qm(ze, un), Ut;
          if (Qt === null) {
            for (; un < qe.length; un++) Qt = gt(ze, qe[un], vt), Qt !== null && (Ne = G(Qt, Ne, un), Xt === null ? Ut = Qt : Xt.sibling = Qt, Xt = Qt);
            return Wr && qm(ze, un), Ut;
          }
          for (Qt = C(ze, Qt); un < qe.length; un++) os = kt(Qt, ze, un, qe[un], vt), os !== null && (u && os.alternate !== null && Qt.delete(os.key === null ? un : os.key), Ne = G(os, Ne, un), Xt === null ? Ut = os : Xt.sibling = os, Xt = os);
          return u && Qt.forEach(function(Mp) {
            return h(ze, Mp);
          }), Wr && qm(ze, un), Ut;
        }
        function Bt(ze, Ne, qe, vt) {
          var Ut = $e(qe);
          if (typeof Ut != "function") throw Error(d(150));
          if (qe = Ut.call(qe), qe == null) throw Error(d(151));
          for (var Xt = Ut = null, Qt = Ne, un = Ne = 0, os = null, Qn = qe.next(); Qt !== null && !Qn.done; un++, Qn = qe.next()) {
            Qt.index > un ? (os = Qt, Qt = null) : os = Qt.sibling;
            var Mp = ft(ze, Qt, Qn.value, vt);
            if (Mp === null) {
              Qt === null && (Qt = os);
              break;
            }
            u && Qt && Mp.alternate === null && h(ze, Qt), Ne = G(Mp, Ne, un), Xt === null ? Ut = Mp : Xt.sibling = Mp, Xt = Mp, Qt = os;
          }
          if (Qn.done) return b(ze, Qt), Wr && qm(ze, un), Ut;
          if (Qt === null) {
            for (; !Qn.done; un++, Qn = qe.next()) Qn = gt(ze, Qn.value, vt), Qn !== null && (Ne = G(Qn, Ne, un), Xt === null ? Ut = Qn : Xt.sibling = Qn, Xt = Qn);
            return Wr && qm(ze, un), Ut;
          }
          for (Qt = C(ze, Qt); !Qn.done; un++, Qn = qe.next()) Qn = kt(Qt, ze, un, Qn.value, vt), Qn !== null && (u && Qn.alternate !== null && Qt.delete(Qn.key === null ? un : Qn.key), Ne = G(Qn, Ne, un), Xt === null ? Ut = Qn : Xt.sibling = Qn, Xt = Qn);
          return u && Qt.forEach(function(EAe) {
            return h(ze, EAe);
          }), Wr && qm(ze, un), Ut;
        }
        function vi(ze, Ne, qe, vt) {
          if (typeof qe == "object" && qe !== null && qe.type === he && qe.key === null && (qe = qe.props.children), typeof qe == "object" && qe !== null) {
            switch (qe.$$typeof) {
              case se:
                e: {
                  for (var Ut = qe.key, Xt = Ne; Xt !== null; ) {
                    if (Xt.key === Ut) {
                      if (Ut = qe.type, Ut === he) {
                        if (Xt.tag === 7) {
                          b(ze, Xt.sibling), Ne = D(Xt, qe.props.children), Ne.return = ze, ze = Ne;
                          break e;
                        }
                      } else if (Xt.elementType === Ut || typeof Ut == "object" && Ut !== null && Ut.$$typeof === Ce && ohe(Ut) === Xt.type) {
                        b(ze, Xt.sibling), Ne = D(Xt, qe.props), Ne.ref = lw(ze, Xt, qe), Ne.return = ze, ze = Ne;
                        break e;
                      }
                      b(ze, Xt);
                      break;
                    } else h(ze, Xt);
                    Xt = Xt.sibling;
                  }
                  qe.type === he ? (Ne = Zm(qe.props.children, ze.mode, vt, qe.key), Ne.return = ze, ze = Ne) : (vt = uN(qe.type, qe.key, qe.props, null, ze.mode, vt), vt.ref = lw(ze, Ne, qe), vt.return = ze, ze = vt);
                }
                return Z(ze);
              case Oe:
                e: {
                  for (Xt = qe.key; Ne !== null; ) {
                    if (Ne.key === Xt) if (Ne.tag === 4 && Ne.stateNode.containerInfo === qe.containerInfo && Ne.stateNode.implementation === qe.implementation) {
                      b(ze, Ne.sibling), Ne = D(Ne, qe.children || []), Ne.return = ze, ze = Ne;
                      break e;
                    } else {
                      b(ze, Ne);
                      break;
                    }
                    else h(ze, Ne);
                    Ne = Ne.sibling;
                  }
                  Ne = Z4(qe, ze.mode, vt), Ne.return = ze, ze = Ne;
                }
                return Z(ze);
              case Ce:
                return Xt = qe._init, vi(ze, Ne, Xt(qe._payload), vt);
            }
            if (Ka(qe)) return Ft(ze, Ne, qe, vt);
            if ($e(qe)) return Bt(ze, Ne, qe, vt);
            qI(ze, qe);
          }
          return typeof qe == "string" && qe !== "" || typeof qe == "number" ? (qe = "" + qe, Ne !== null && Ne.tag === 6 ? (b(ze, Ne.sibling), Ne = D(Ne, qe), Ne.return = ze, ze = Ne) : (b(ze, Ne), Ne = Q4(qe, ze.mode, vt), Ne.return = ze, ze = Ne), Z(ze)) : b(ze, Ne);
        }
        return vi;
      }
      var Uv = ahe(!0), lhe = ahe(!1), uw = {}, sc = bp(uw), cw = bp(uw), dw = bp(uw);
      function $m(u) {
        if (u === uw) throw Error(d(174));
        return u;
      }
      function g4(u, h) {
        switch (Mr(dw, h), Mr(cw, u), Mr(sc, uw), u = h.nodeType, u) {
          case 9:
          case 11:
            h = (h = h.documentElement) ? h.namespaceURI : Ya(null, "");
            break;
          default:
            u = u === 8 ? h.parentNode : h, h = u.namespaceURI || null, u = u.tagName, h = Ya(h, u);
        }
        zr(sc), Mr(sc, h);
      }
      function zv() {
        zr(sc), zr(cw), zr(dw);
      }
      function uhe(u) {
        $m(dw.current);
        var h = $m(sc.current), b = Ya(h, u.type);
        h !== b && (Mr(cw, u), Mr(sc, b));
      }
      function y4(u) {
        cw.current === u && (zr(sc), zr(cw));
      }
      var ti = bp(0);
      function HI(u) {
        for (var h = u; h !== null; ) {
          if (h.tag === 13) {
            var b = h.memoizedState;
            if (b !== null && (b = b.dehydrated, b === null || b.data === "$?" || b.data === "$!")) return h;
          } else if (h.tag === 19 && h.memoizedProps.revealOrder !== void 0) {
            if (h.flags & 128) return h;
          } else if (h.child !== null) {
            h.child.return = h, h = h.child;
            continue;
          }
          if (h === u) break;
          for (; h.sibling === null; ) {
            if (h.return === null || h.return === u) return null;
            h = h.return;
          }
          h.sibling.return = h.return, h = h.sibling;
        }
        return null;
      }
      var v4 = [];
      function b4() {
        for (var u = 0; u < v4.length; u++) v4[u]._workInProgressVersionPrimary = null;
        v4.length = 0;
      }
      var $I = ue.ReactCurrentDispatcher, x4 = ue.ReactCurrentBatchConfig, Wm = 0, ni = null, zi = null, is = null, WI = !1, hw = !1, pw = 0, $Pe = 0;
      function qs() {
        throw Error(d(321));
      }
      function _4(u, h) {
        if (h === null) return !1;
        for (var b = 0; b < h.length && b < u.length; b++) if (!Yl(u[b], h[b])) return !1;
        return !0;
      }
      function S4(u, h, b, C, D, G) {
        if (Wm = G, ni = h, h.memoizedState = null, h.updateQueue = null, h.lanes = 0, $I.current = u === null || u.memoizedState === null ? XPe : QPe, u = b(C, D), hw) {
          G = 0;
          do {
            if (hw = !1, pw = 0, 25 <= G) throw Error(d(301));
            G += 1, is = zi = null, h.updateQueue = null, $I.current = ZPe, u = b(C, D);
          } while (hw);
        }
        if ($I.current = XI, h = zi !== null && zi.next !== null, Wm = 0, is = zi = ni = null, WI = !1, h) throw Error(d(300));
        return u;
      }
      function w4() {
        var u = pw !== 0;
        return pw = 0, u;
      }
      function oc() {
        var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
        return is === null ? ni.memoizedState = is = u : is = is.next = u, is;
      }
      function Ja() {
        if (zi === null) {
          var u = ni.alternate;
          u = u !== null ? u.memoizedState : null;
        } else u = zi.next;
        var h = is === null ? ni.memoizedState : is.next;
        if (h !== null) is = h, zi = u;
        else {
          if (u === null) throw Error(d(310));
          zi = u, u = { memoizedState: zi.memoizedState, baseState: zi.baseState, baseQueue: zi.baseQueue, queue: zi.queue, next: null }, is === null ? ni.memoizedState = is = u : is = is.next = u;
        }
        return is;
      }
      function fw(u, h) {
        return typeof h == "function" ? h(u) : h;
      }
      function E4(u) {
        var h = Ja(), b = h.queue;
        if (b === null) throw Error(d(311));
        b.lastRenderedReducer = u;
        var C = zi, D = C.baseQueue, G = b.pending;
        if (G !== null) {
          if (D !== null) {
            var Z = D.next;
            D.next = G.next, G.next = Z;
          }
          C.baseQueue = D = G, b.pending = null;
        }
        if (D !== null) {
          G = D.next, C = C.baseState;
          var me = Z = null, Te = null, Ke = G;
          do {
            var mt = Ke.lane;
            if ((Wm & mt) === mt) Te !== null && (Te = Te.next = { lane: 0, action: Ke.action, hasEagerState: Ke.hasEagerState, eagerState: Ke.eagerState, next: null }), C = Ke.hasEagerState ? Ke.eagerState : u(C, Ke.action);
            else {
              var gt = { lane: mt, action: Ke.action, hasEagerState: Ke.hasEagerState, eagerState: Ke.eagerState, next: null };
              Te === null ? (me = Te = gt, Z = C) : Te = Te.next = gt, ni.lanes |= mt, Km |= mt;
            }
            Ke = Ke.next;
          } while (Ke !== null && Ke !== G);
          Te === null ? Z = C : Te.next = me, Yl(C, h.memoizedState) || (jo = !0), h.memoizedState = C, h.baseState = Z, h.baseQueue = Te, b.lastRenderedState = C;
        }
        if (u = b.interleaved, u !== null) {
          D = u;
          do
            G = D.lane, ni.lanes |= G, Km |= G, D = D.next;
          while (D !== u);
        } else D === null && (b.lanes = 0);
        return [h.memoizedState, b.dispatch];
      }
      function T4(u) {
        var h = Ja(), b = h.queue;
        if (b === null) throw Error(d(311));
        b.lastRenderedReducer = u;
        var C = b.dispatch, D = b.pending, G = h.memoizedState;
        if (D !== null) {
          b.pending = null;
          var Z = D = D.next;
          do
            G = u(G, Z.action), Z = Z.next;
          while (Z !== D);
          Yl(G, h.memoizedState) || (jo = !0), h.memoizedState = G, h.baseQueue === null && (h.baseState = G), b.lastRenderedState = G;
        }
        return [G, C];
      }
      function che() {
      }
      function dhe(u, h) {
        var b = ni, C = Ja(), D = h(), G = !Yl(C.memoizedState, D);
        if (G && (C.memoizedState = D, jo = !0), C = C.queue, C4(fhe.bind(null, b, C, u), [u]), C.getSnapshot !== h || G || is !== null && is.memoizedState.tag & 1) {
          if (b.flags |= 2048, mw(9, phe.bind(null, b, C, D, h), void 0, null), ss === null) throw Error(d(349));
          Wm & 30 || hhe(b, h, D);
        }
        return D;
      }
      function hhe(u, h, b) {
        u.flags |= 16384, u = { getSnapshot: h, value: b }, h = ni.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, ni.updateQueue = h, h.stores = [u]) : (b = h.stores, b === null ? h.stores = [u] : b.push(u));
      }
      function phe(u, h, b, C) {
        h.value = b, h.getSnapshot = C, mhe(h) && ghe(u);
      }
      function fhe(u, h, b) {
        return b(function() {
          mhe(h) && ghe(u);
        });
      }
      function mhe(u) {
        var h = u.getSnapshot;
        u = u.value;
        try {
          var b = h();
          return !Yl(u, b);
        } catch {
          return !0;
        }
      }
      function ghe(u) {
        var h = Ed(u, 1);
        h !== null && eu(h, u, 1, -1);
      }
      function yhe(u) {
        var h = oc();
        return typeof u == "function" && (u = u()), h.memoizedState = h.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: fw, lastRenderedState: u }, h.queue = u, u = u.dispatch = YPe.bind(null, ni, u), [h.memoizedState, u];
      }
      function mw(u, h, b, C) {
        return u = { tag: u, create: h, destroy: b, deps: C, next: null }, h = ni.updateQueue, h === null ? (h = { lastEffect: null, stores: null }, ni.updateQueue = h, h.lastEffect = u.next = u) : (b = h.lastEffect, b === null ? h.lastEffect = u.next = u : (C = b.next, b.next = u, u.next = C, h.lastEffect = u)), u;
      }
      function vhe() {
        return Ja().memoizedState;
      }
      function KI(u, h, b, C) {
        var D = oc();
        ni.flags |= u, D.memoizedState = mw(1 | h, b, void 0, C === void 0 ? null : C);
      }
      function YI(u, h, b, C) {
        var D = Ja();
        C = C === void 0 ? null : C;
        var G = void 0;
        if (zi !== null) {
          var Z = zi.memoizedState;
          if (G = Z.destroy, C !== null && _4(C, Z.deps)) {
            D.memoizedState = mw(h, b, G, C);
            return;
          }
        }
        ni.flags |= u, D.memoizedState = mw(1 | h, b, G, C);
      }
      function bhe(u, h) {
        return KI(8390656, 8, u, h);
      }
      function C4(u, h) {
        return YI(2048, 8, u, h);
      }
      function xhe(u, h) {
        return YI(4, 2, u, h);
      }
      function _he(u, h) {
        return YI(4, 4, u, h);
      }
      function She(u, h) {
        if (typeof h == "function") return u = u(), h(u), function() {
          h(null);
        };
        if (h != null) return u = u(), h.current = u, function() {
          h.current = null;
        };
      }
      function whe(u, h, b) {
        return b = b != null ? b.concat([u]) : null, YI(4, 4, She.bind(null, h, u), b);
      }
      function P4() {
      }
      function Ehe(u, h) {
        var b = Ja();
        h = h === void 0 ? null : h;
        var C = b.memoizedState;
        return C !== null && h !== null && _4(h, C[1]) ? C[0] : (b.memoizedState = [u, h], u);
      }
      function The(u, h) {
        var b = Ja();
        h = h === void 0 ? null : h;
        var C = b.memoizedState;
        return C !== null && h !== null && _4(h, C[1]) ? C[0] : (u = u(), b.memoizedState = [u, h], u);
      }
      function Che(u, h, b) {
        return Wm & 21 ? (Yl(b, h) || (b = Qce(), ni.lanes |= b, Km |= b, u.baseState = !0), h) : (u.baseState && (u.baseState = !1, jo = !0), u.memoizedState = b);
      }
      function WPe(u, h) {
        var b = hr;
        hr = b !== 0 && 4 > b ? b : 4, u(!0);
        var C = x4.transition;
        x4.transition = {};
        try {
          u(!1), h();
        } finally {
          hr = b, x4.transition = C;
        }
      }
      function Phe() {
        return Ja().memoizedState;
      }
      function KPe(u, h, b) {
        var C = Pp(u);
        if (b = { lane: C, action: b, hasEagerState: !1, eagerState: null, next: null }, Ahe(u)) khe(h, b);
        else if (b = Zde(u, h, b, C), b !== null) {
          var D = co();
          eu(b, u, C, D), Mhe(b, h, C);
        }
      }
      function YPe(u, h, b) {
        var C = Pp(u), D = { lane: C, action: b, hasEagerState: !1, eagerState: null, next: null };
        if (Ahe(u)) khe(h, D);
        else {
          var G = u.alternate;
          if (u.lanes === 0 && (G === null || G.lanes === 0) && (G = h.lastRenderedReducer, G !== null)) try {
            var Z = h.lastRenderedState, me = G(Z, b);
            if (D.hasEagerState = !0, D.eagerState = me, Yl(me, Z)) {
              var Te = h.interleaved;
              Te === null ? (D.next = D, h4(h)) : (D.next = Te.next, Te.next = D), h.interleaved = D;
              return;
            }
          } catch {
          } finally {
          }
          b = Zde(u, h, D, C), b !== null && (D = co(), eu(b, u, C, D), Mhe(b, h, C));
        }
      }
      function Ahe(u) {
        var h = u.alternate;
        return u === ni || h !== null && h === ni;
      }
      function khe(u, h) {
        hw = WI = !0;
        var b = u.pending;
        b === null ? h.next = h : (h.next = b.next, b.next = h), u.pending = h;
      }
      function Mhe(u, h, b) {
        if (b & 4194240) {
          var C = h.lanes;
          C &= u.pendingLanes, b |= C, h.lanes = b, kz(u, b);
        }
      }
      var XI = { readContext: Za, useCallback: qs, useContext: qs, useEffect: qs, useImperativeHandle: qs, useInsertionEffect: qs, useLayoutEffect: qs, useMemo: qs, useReducer: qs, useRef: qs, useState: qs, useDebugValue: qs, useDeferredValue: qs, useTransition: qs, useMutableSource: qs, useSyncExternalStore: qs, useId: qs, unstable_isNewReconciler: !1 }, XPe = { readContext: Za, useCallback: function(u, h) {
        return oc().memoizedState = [u, h === void 0 ? null : h], u;
      }, useContext: Za, useEffect: bhe, useImperativeHandle: function(u, h, b) {
        return b = b != null ? b.concat([u]) : null, KI(4194308, 4, She.bind(null, h, u), b);
      }, useLayoutEffect: function(u, h) {
        return KI(4194308, 4, u, h);
      }, useInsertionEffect: function(u, h) {
        return KI(4, 2, u, h);
      }, useMemo: function(u, h) {
        var b = oc();
        return h = h === void 0 ? null : h, u = u(), b.memoizedState = [u, h], u;
      }, useReducer: function(u, h, b) {
        var C = oc();
        return h = b !== void 0 ? b(h) : h, C.memoizedState = C.baseState = h, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: h }, C.queue = u, u = u.dispatch = KPe.bind(null, ni, u), [C.memoizedState, u];
      }, useRef: function(u) {
        var h = oc();
        return u = { current: u }, h.memoizedState = u;
      }, useState: yhe, useDebugValue: P4, useDeferredValue: function(u) {
        return oc().memoizedState = u;
      }, useTransition: function() {
        var u = yhe(!1), h = u[0];
        return u = WPe.bind(null, u[1]), oc().memoizedState = u, [h, u];
      }, useMutableSource: function() {
      }, useSyncExternalStore: function(u, h, b) {
        var C = ni, D = oc();
        if (Wr) {
          if (b === void 0) throw Error(d(407));
          b = b();
        } else {
          if (b = h(), ss === null) throw Error(d(349));
          Wm & 30 || hhe(C, h, b);
        }
        D.memoizedState = b;
        var G = { value: b, getSnapshot: h };
        return D.queue = G, bhe(fhe.bind(null, C, G, u), [u]), C.flags |= 2048, mw(9, phe.bind(null, C, G, b, h), void 0, null), b;
      }, useId: function() {
        var u = oc(), h = ss.identifierPrefix;
        if (Wr) {
          var b = wd, C = Sd;
          b = (C & ~(1 << 32 - Kl(C) - 1)).toString(32) + b, h = ":" + h + "R" + b, b = pw++, 0 < b && (h += "H" + b.toString(32)), h += ":";
        } else b = $Pe++, h = ":" + h + "r" + b.toString(32) + ":";
        return u.memoizedState = h;
      }, unstable_isNewReconciler: !1 }, QPe = { readContext: Za, useCallback: Ehe, useContext: Za, useEffect: C4, useImperativeHandle: whe, useInsertionEffect: xhe, useLayoutEffect: _he, useMemo: The, useReducer: E4, useRef: vhe, useState: function() {
        return E4(fw);
      }, useDebugValue: P4, useDeferredValue: function(u) {
        var h = Ja();
        return Che(h, zi.memoizedState, u);
      }, useTransition: function() {
        var u = E4(fw)[0], h = Ja().memoizedState;
        return [u, h];
      }, useMutableSource: che, useSyncExternalStore: dhe, useId: Phe, unstable_isNewReconciler: !1 }, ZPe = { readContext: Za, useCallback: Ehe, useContext: Za, useEffect: C4, useImperativeHandle: whe, useInsertionEffect: xhe, useLayoutEffect: _he, useMemo: The, useReducer: T4, useRef: vhe, useState: function() {
        return T4(fw);
      }, useDebugValue: P4, useDeferredValue: function(u) {
        var h = Ja();
        return zi === null ? h.memoizedState = u : Che(h, zi.memoizedState, u);
      }, useTransition: function() {
        var u = T4(fw)[0], h = Ja().memoizedState;
        return [u, h];
      }, useMutableSource: che, useSyncExternalStore: dhe, useId: Phe, unstable_isNewReconciler: !1 };
      function Vv(u, h) {
        try {
          var b = "", C = h;
          do
            b += oe(C), C = C.return;
          while (C);
          var D = b;
        } catch (G) {
          D = `
Error generating stack: ` + G.message + `
` + G.stack;
        }
        return { value: u, source: h, stack: D, digest: null };
      }
      function A4(u, h, b) {
        return { value: u, source: null, stack: b ?? null, digest: h ?? null };
      }
      function k4(u, h) {
        try {
          console.error(h.value);
        } catch (b) {
          setTimeout(function() {
            throw b;
          });
        }
      }
      var JPe = typeof WeakMap == "function" ? WeakMap : Map;
      function Rhe(u, h, b) {
        b = Td(-1, b), b.tag = 3, b.payload = { element: null };
        var C = h.value;
        return b.callback = function() {
          rN || (rN = !0, G4 = C), k4(u, h);
        }, b;
      }
      function Ihe(u, h, b) {
        b = Td(-1, b), b.tag = 3;
        var C = u.type.getDerivedStateFromError;
        if (typeof C == "function") {
          var D = h.value;
          b.payload = function() {
            return C(D);
          }, b.callback = function() {
            k4(u, h);
          };
        }
        var G = u.stateNode;
        return G !== null && typeof G.componentDidCatch == "function" && (b.callback = function() {
          k4(u, h), typeof C != "function" && (Tp === null ? Tp = /* @__PURE__ */ new Set([this]) : Tp.add(this));
          var Z = h.stack;
          this.componentDidCatch(h.value, { componentStack: Z !== null ? Z : "" });
        }), b;
      }
      function Nhe(u, h, b) {
        var C = u.pingCache;
        if (C === null) {
          C = u.pingCache = new JPe();
          var D = /* @__PURE__ */ new Set();
          C.set(h, D);
        } else D = C.get(h), D === void 0 && (D = /* @__PURE__ */ new Set(), C.set(h, D));
        D.has(b) || (D.add(b), u = pAe.bind(null, u, h, b), h.then(u, u));
      }
      function Ohe(u) {
        do {
          var h;
          if ((h = u.tag === 13) && (h = u.memoizedState, h = h !== null ? h.dehydrated !== null : !0), h) return u;
          u = u.return;
        } while (u !== null);
        return null;
      }
      function Dhe(u, h, b, C, D) {
        return u.mode & 1 ? (u.flags |= 65536, u.lanes = D, u) : (u === h ? u.flags |= 65536 : (u.flags |= 128, b.flags |= 131072, b.flags &= -52805, b.tag === 1 && (b.alternate === null ? b.tag = 17 : (h = Td(-1, 1), h.tag = 2, wp(b, h, 1))), b.lanes |= 1), u);
      }
      var eAe = ue.ReactCurrentOwner, jo = !1;
      function uo(u, h, b, C) {
        h.child = u === null ? lhe(h, null, b, C) : Uv(h, u.child, b, C);
      }
      function Fhe(u, h, b, C, D) {
        b = b.render;
        var G = h.ref;
        return jv(h, D), C = S4(u, h, b, C, G, D), b = w4(), u !== null && !jo ? (h.updateQueue = u.updateQueue, h.flags &= -2053, u.lanes &= ~D, Cd(u, h, D)) : (Wr && b && r4(h), h.flags |= 1, uo(u, h, C, D), h.child);
      }
      function Bhe(u, h, b, C, D) {
        if (u === null) {
          var G = b.type;
          return typeof G == "function" && !X4(G) && G.defaultProps === void 0 && b.compare === null && b.defaultProps === void 0 ? (h.tag = 15, h.type = G, Lhe(u, h, G, C, D)) : (u = uN(b.type, null, C, h, h.mode, D), u.ref = h.ref, u.return = h, h.child = u);
        }
        if (G = u.child, !(u.lanes & D)) {
          var Z = G.memoizedProps;
          if (b = b.compare, b = b !== null ? b : tw, b(Z, C) && u.ref === h.ref) return Cd(u, h, D);
        }
        return h.flags |= 1, u = kp(G, C), u.ref = h.ref, u.return = h, h.child = u;
      }
      function Lhe(u, h, b, C, D) {
        if (u !== null) {
          var G = u.memoizedProps;
          if (tw(G, C) && u.ref === h.ref) if (jo = !1, h.pendingProps = C = G, (u.lanes & D) !== 0) u.flags & 131072 && (jo = !0);
          else return h.lanes = u.lanes, Cd(u, h, D);
        }
        return M4(u, h, b, C, D);
      }
      function jhe(u, h, b) {
        var C = h.pendingProps, D = C.children, G = u !== null ? u.memoizedState : null;
        if (C.mode === "hidden") if (!(h.mode & 1)) h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Mr(qv, fa), fa |= b;
        else {
          if (!(b & 1073741824)) return u = G !== null ? G.baseLanes | b : b, h.lanes = h.childLanes = 1073741824, h.memoizedState = { baseLanes: u, cachePool: null, transitions: null }, h.updateQueue = null, Mr(qv, fa), fa |= u, null;
          h.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, C = G !== null ? G.baseLanes : b, Mr(qv, fa), fa |= C;
        }
        else G !== null ? (C = G.baseLanes | b, h.memoizedState = null) : C = b, Mr(qv, fa), fa |= C;
        return uo(u, h, D, b), h.child;
      }
      function Uhe(u, h) {
        var b = h.ref;
        (u === null && b !== null || u !== null && u.ref !== b) && (h.flags |= 512, h.flags |= 2097152);
      }
      function M4(u, h, b, C, D) {
        var G = Lo(b) ? Vm : Gs.current;
        return G = Ov(h, G), jv(h, D), b = S4(u, h, b, C, G, D), C = w4(), u !== null && !jo ? (h.updateQueue = u.updateQueue, h.flags &= -2053, u.lanes &= ~D, Cd(u, h, D)) : (Wr && C && r4(h), h.flags |= 1, uo(u, h, b, D), h.child);
      }
      function zhe(u, h, b, C, D) {
        if (Lo(b)) {
          var G = !0;
          OI(h);
        } else G = !1;
        if (jv(h, D), h.stateNode === null) ZI(u, h), ihe(h, b, C), m4(h, b, C, D), C = !0;
        else if (u === null) {
          var Z = h.stateNode, me = h.memoizedProps;
          Z.props = me;
          var Te = Z.context, Ke = b.contextType;
          typeof Ke == "object" && Ke !== null ? Ke = Za(Ke) : (Ke = Lo(b) ? Vm : Gs.current, Ke = Ov(h, Ke));
          var mt = b.getDerivedStateFromProps, gt = typeof mt == "function" || typeof Z.getSnapshotBeforeUpdate == "function";
          gt || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (me !== C || Te !== Ke) && she(h, Z, C, Ke), Sp = !1;
          var ft = h.memoizedState;
          Z.state = ft, VI(h, C, Z, D), Te = h.memoizedState, me !== C || ft !== Te || Bo.current || Sp ? (typeof mt == "function" && (f4(h, b, mt, C), Te = h.memoizedState), (me = Sp || rhe(h, b, me, C, ft, Te, Ke)) ? (gt || typeof Z.UNSAFE_componentWillMount != "function" && typeof Z.componentWillMount != "function" || (typeof Z.componentWillMount == "function" && Z.componentWillMount(), typeof Z.UNSAFE_componentWillMount == "function" && Z.UNSAFE_componentWillMount()), typeof Z.componentDidMount == "function" && (h.flags |= 4194308)) : (typeof Z.componentDidMount == "function" && (h.flags |= 4194308), h.memoizedProps = C, h.memoizedState = Te), Z.props = C, Z.state = Te, Z.context = Ke, C = me) : (typeof Z.componentDidMount == "function" && (h.flags |= 4194308), C = !1);
        } else {
          Z = h.stateNode, Jde(u, h), me = h.memoizedProps, Ke = h.type === h.elementType ? me : Ql(h.type, me), Z.props = Ke, gt = h.pendingProps, ft = Z.context, Te = b.contextType, typeof Te == "object" && Te !== null ? Te = Za(Te) : (Te = Lo(b) ? Vm : Gs.current, Te = Ov(h, Te));
          var kt = b.getDerivedStateFromProps;
          (mt = typeof kt == "function" || typeof Z.getSnapshotBeforeUpdate == "function") || typeof Z.UNSAFE_componentWillReceiveProps != "function" && typeof Z.componentWillReceiveProps != "function" || (me !== gt || ft !== Te) && she(h, Z, C, Te), Sp = !1, ft = h.memoizedState, Z.state = ft, VI(h, C, Z, D);
          var Ft = h.memoizedState;
          me !== gt || ft !== Ft || Bo.current || Sp ? (typeof kt == "function" && (f4(h, b, kt, C), Ft = h.memoizedState), (Ke = Sp || rhe(h, b, Ke, C, ft, Ft, Te) || !1) ? (mt || typeof Z.UNSAFE_componentWillUpdate != "function" && typeof Z.componentWillUpdate != "function" || (typeof Z.componentWillUpdate == "function" && Z.componentWillUpdate(C, Ft, Te), typeof Z.UNSAFE_componentWillUpdate == "function" && Z.UNSAFE_componentWillUpdate(C, Ft, Te)), typeof Z.componentDidUpdate == "function" && (h.flags |= 4), typeof Z.getSnapshotBeforeUpdate == "function" && (h.flags |= 1024)) : (typeof Z.componentDidUpdate != "function" || me === u.memoizedProps && ft === u.memoizedState || (h.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || me === u.memoizedProps && ft === u.memoizedState || (h.flags |= 1024), h.memoizedProps = C, h.memoizedState = Ft), Z.props = C, Z.state = Ft, Z.context = Te, C = Ke) : (typeof Z.componentDidUpdate != "function" || me === u.memoizedProps && ft === u.memoizedState || (h.flags |= 4), typeof Z.getSnapshotBeforeUpdate != "function" || me === u.memoizedProps && ft === u.memoizedState || (h.flags |= 1024), C = !1);
        }
        return R4(u, h, b, C, G, D);
      }
      function R4(u, h, b, C, D, G) {
        Uhe(u, h);
        var Z = (h.flags & 128) !== 0;
        if (!C && !Z) return D && Hde(h, b, !1), Cd(u, h, G);
        C = h.stateNode, eAe.current = h;
        var me = Z && typeof b.getDerivedStateFromError != "function" ? null : C.render();
        return h.flags |= 1, u !== null && Z ? (h.child = Uv(h, u.child, null, G), h.child = Uv(h, null, me, G)) : uo(u, h, me, G), h.memoizedState = C.state, D && Hde(h, b, !0), h.child;
      }
      function Vhe(u) {
        var h = u.stateNode;
        h.pendingContext ? Gde(u, h.pendingContext, h.pendingContext !== h.context) : h.context && Gde(u, h.context, !1), g4(u, h.containerInfo);
      }
      function Ghe(u, h, b, C, D) {
        return Bv(), a4(D), h.flags |= 256, uo(u, h, b, C), h.child;
      }
      var I4 = { dehydrated: null, treeContext: null, retryLane: 0 };
      function N4(u) {
        return { baseLanes: u, cachePool: null, transitions: null };
      }
      function qhe(u, h, b) {
        var C = h.pendingProps, D = ti.current, G = !1, Z = (h.flags & 128) !== 0, me;
        if ((me = Z) || (me = u !== null && u.memoizedState === null ? !1 : (D & 2) !== 0), me ? (G = !0, h.flags &= -129) : (u === null || u.memoizedState !== null) && (D |= 1), Mr(ti, D & 1), u === null) return o4(h), u = h.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (h.mode & 1 ? u.data === "$!" ? h.lanes = 8 : h.lanes = 1073741824 : h.lanes = 1, null) : (Z = C.children, u = C.fallback, G ? (C = h.mode, G = h.child, Z = { mode: "hidden", children: Z }, !(C & 1) && G !== null ? (G.childLanes = 0, G.pendingProps = Z) : G = cN(Z, C, 0, null), u = Zm(u, C, b, null), G.return = h, u.return = h, G.sibling = u, h.child = G, h.child.memoizedState = N4(b), h.memoizedState = I4, u) : O4(h, Z));
        if (D = u.memoizedState, D !== null && (me = D.dehydrated, me !== null)) return tAe(u, h, Z, C, me, D, b);
        if (G) {
          G = C.fallback, Z = h.mode, D = u.child, me = D.sibling;
          var Te = { mode: "hidden", children: C.children };
          return !(Z & 1) && h.child !== D ? (C = h.child, C.childLanes = 0, C.pendingProps = Te, h.deletions = null) : (C = kp(D, Te), C.subtreeFlags = D.subtreeFlags & 14680064), me !== null ? G = kp(me, G) : (G = Zm(G, Z, b, null), G.flags |= 2), G.return = h, C.return = h, C.sibling = G, h.child = C, C = G, G = h.child, Z = u.child.memoizedState, Z = Z === null ? N4(b) : { baseLanes: Z.baseLanes | b, cachePool: null, transitions: Z.transitions }, G.memoizedState = Z, G.childLanes = u.childLanes & ~b, h.memoizedState = I4, C;
        }
        return G = u.child, u = G.sibling, C = kp(G, { mode: "visible", children: C.children }), !(h.mode & 1) && (C.lanes = b), C.return = h, C.sibling = null, u !== null && (b = h.deletions, b === null ? (h.deletions = [u], h.flags |= 16) : b.push(u)), h.child = C, h.memoizedState = null, C;
      }
      function O4(u, h) {
        return h = cN({ mode: "visible", children: h }, u.mode, 0, null), h.return = u, u.child = h;
      }
      function QI(u, h, b, C) {
        return C !== null && a4(C), Uv(h, u.child, null, b), u = O4(h, h.pendingProps.children), u.flags |= 2, h.memoizedState = null, u;
      }
      function tAe(u, h, b, C, D, G, Z) {
        if (b) return h.flags & 256 ? (h.flags &= -257, C = A4(Error(d(422))), QI(u, h, Z, C)) : h.memoizedState !== null ? (h.child = u.child, h.flags |= 128, null) : (G = C.fallback, D = h.mode, C = cN({ mode: "visible", children: C.children }, D, 0, null), G = Zm(G, D, Z, null), G.flags |= 2, C.return = h, G.return = h, C.sibling = G, h.child = C, h.mode & 1 && Uv(h, u.child, null, Z), h.child.memoizedState = N4(Z), h.memoizedState = I4, G);
        if (!(h.mode & 1)) return QI(u, h, Z, null);
        if (D.data === "$!") {
          if (C = D.nextSibling && D.nextSibling.dataset, C) var me = C.dgst;
          return C = me, G = Error(d(419)), C = A4(G, C, void 0), QI(u, h, Z, C);
        }
        if (me = (Z & u.childLanes) !== 0, jo || me) {
          if (C = ss, C !== null) {
            switch (Z & -Z) {
              case 4:
                D = 2;
                break;
              case 16:
                D = 8;
                break;
              case 64:
              case 128:
              case 256:
              case 512:
              case 1024:
              case 2048:
              case 4096:
              case 8192:
              case 16384:
              case 32768:
              case 65536:
              case 131072:
              case 262144:
              case 524288:
              case 1048576:
              case 2097152:
              case 4194304:
              case 8388608:
              case 16777216:
              case 33554432:
              case 67108864:
                D = 32;
                break;
              case 536870912:
                D = 268435456;
                break;
              default:
                D = 0;
            }
            D = D & (C.suspendedLanes | Z) ? 0 : D, D !== 0 && D !== G.retryLane && (G.retryLane = D, Ed(u, D), eu(C, u, D, -1));
          }
          return Y4(), C = A4(Error(d(421))), QI(u, h, Z, C);
        }
        return D.data === "$?" ? (h.flags |= 128, h.child = u.child, h = fAe.bind(null, u), D._reactRetry = h, null) : (u = G.treeContext, pa = vp(D.nextSibling), ha = h, Wr = !0, Xl = null, u !== null && (Xa[Qa++] = Sd, Xa[Qa++] = wd, Xa[Qa++] = Gm, Sd = u.id, wd = u.overflow, Gm = h), h = O4(h, C.children), h.flags |= 4096, h);
      }
      function Hhe(u, h, b) {
        u.lanes |= h;
        var C = u.alternate;
        C !== null && (C.lanes |= h), d4(u.return, h, b);
      }
      function D4(u, h, b, C, D) {
        var G = u.memoizedState;
        G === null ? u.memoizedState = { isBackwards: h, rendering: null, renderingStartTime: 0, last: C, tail: b, tailMode: D } : (G.isBackwards = h, G.rendering = null, G.renderingStartTime = 0, G.last = C, G.tail = b, G.tailMode = D);
      }
      function $he(u, h, b) {
        var C = h.pendingProps, D = C.revealOrder, G = C.tail;
        if (uo(u, h, C.children, b), C = ti.current, C & 2) C = C & 1 | 2, h.flags |= 128;
        else {
          if (u !== null && u.flags & 128) e: for (u = h.child; u !== null; ) {
            if (u.tag === 13) u.memoizedState !== null && Hhe(u, b, h);
            else if (u.tag === 19) Hhe(u, b, h);
            else if (u.child !== null) {
              u.child.return = u, u = u.child;
              continue;
            }
            if (u === h) break e;
            for (; u.sibling === null; ) {
              if (u.return === null || u.return === h) break e;
              u = u.return;
            }
            u.sibling.return = u.return, u = u.sibling;
          }
          C &= 1;
        }
        if (Mr(ti, C), !(h.mode & 1)) h.memoizedState = null;
        else switch (D) {
          case "forwards":
            for (b = h.child, D = null; b !== null; ) u = b.alternate, u !== null && HI(u) === null && (D = b), b = b.sibling;
            b = D, b === null ? (D = h.child, h.child = null) : (D = b.sibling, b.sibling = null), D4(h, !1, D, b, G);
            break;
          case "backwards":
            for (b = null, D = h.child, h.child = null; D !== null; ) {
              if (u = D.alternate, u !== null && HI(u) === null) {
                h.child = D;
                break;
              }
              u = D.sibling, D.sibling = b, b = D, D = u;
            }
            D4(h, !0, b, null, G);
            break;
          case "together":
            D4(h, !1, null, null, void 0);
            break;
          default:
            h.memoizedState = null;
        }
        return h.child;
      }
      function ZI(u, h) {
        !(h.mode & 1) && u !== null && (u.alternate = null, h.alternate = null, h.flags |= 2);
      }
      function Cd(u, h, b) {
        if (u !== null && (h.dependencies = u.dependencies), Km |= h.lanes, !(b & h.childLanes)) return null;
        if (u !== null && h.child !== u.child) throw Error(d(153));
        if (h.child !== null) {
          for (u = h.child, b = kp(u, u.pendingProps), h.child = b, b.return = h; u.sibling !== null; ) u = u.sibling, b = b.sibling = kp(u, u.pendingProps), b.return = h;
          b.sibling = null;
        }
        return h.child;
      }
      function nAe(u, h, b) {
        switch (h.tag) {
          case 3:
            Vhe(h), Bv();
            break;
          case 5:
            uhe(h);
            break;
          case 1:
            Lo(h.type) && OI(h);
            break;
          case 4:
            g4(h, h.stateNode.containerInfo);
            break;
          case 10:
            var C = h.type._context, D = h.memoizedProps.value;
            Mr(jI, C._currentValue), C._currentValue = D;
            break;
          case 13:
            if (C = h.memoizedState, C !== null) return C.dehydrated !== null ? (Mr(ti, ti.current & 1), h.flags |= 128, null) : b & h.child.childLanes ? qhe(u, h, b) : (Mr(ti, ti.current & 1), u = Cd(u, h, b), u !== null ? u.sibling : null);
            Mr(ti, ti.current & 1);
            break;
          case 19:
            if (C = (b & h.childLanes) !== 0, u.flags & 128) {
              if (C) return $he(u, h, b);
              h.flags |= 128;
            }
            if (D = h.memoizedState, D !== null && (D.rendering = null, D.tail = null, D.lastEffect = null), Mr(ti, ti.current), C) break;
            return null;
          case 22:
          case 23:
            return h.lanes = 0, jhe(u, h, b);
        }
        return Cd(u, h, b);
      }
      var Whe, F4, Khe, Yhe;
      Whe = function(u, h) {
        for (var b = h.child; b !== null; ) {
          if (b.tag === 5 || b.tag === 6) u.appendChild(b.stateNode);
          else if (b.tag !== 4 && b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
          if (b === h) break;
          for (; b.sibling === null; ) {
            if (b.return === null || b.return === h) return;
            b = b.return;
          }
          b.sibling.return = b.return, b = b.sibling;
        }
      }, F4 = function() {
      }, Khe = function(u, h, b, C) {
        var D = u.memoizedProps;
        if (D !== C) {
          u = h.stateNode, $m(sc.current);
          var G = null;
          switch (b) {
            case "input":
              D = dn(u, D), C = dn(u, C), G = [];
              break;
            case "select":
              D = de({}, D, { value: void 0 }), C = de({}, C, { value: void 0 }), G = [];
              break;
            case "textarea":
              D = rs(u, D), C = rs(u, C), G = [];
              break;
            default:
              typeof D.onClick != "function" && typeof C.onClick == "function" && (u.onclick = RI);
          }
          vz(b, C);
          var Z;
          b = null;
          for (Ke in D) if (!C.hasOwnProperty(Ke) && D.hasOwnProperty(Ke) && D[Ke] != null) if (Ke === "style") {
            var me = D[Ke];
            for (Z in me) me.hasOwnProperty(Z) && (b || (b = {}), b[Z] = "");
          } else Ke !== "dangerouslySetInnerHTML" && Ke !== "children" && Ke !== "suppressContentEditableWarning" && Ke !== "suppressHydrationWarning" && Ke !== "autoFocus" && (y.hasOwnProperty(Ke) ? G || (G = []) : (G = G || []).push(Ke, null));
          for (Ke in C) {
            var Te = C[Ke];
            if (me = D?.[Ke], C.hasOwnProperty(Ke) && Te !== me && (Te != null || me != null)) if (Ke === "style") if (me) {
              for (Z in me) !me.hasOwnProperty(Z) || Te && Te.hasOwnProperty(Z) || (b || (b = {}), b[Z] = "");
              for (Z in Te) Te.hasOwnProperty(Z) && me[Z] !== Te[Z] && (b || (b = {}), b[Z] = Te[Z]);
            } else b || (G || (G = []), G.push(Ke, b)), b = Te;
            else Ke === "dangerouslySetInnerHTML" ? (Te = Te ? Te.__html : void 0, me = me ? me.__html : void 0, Te != null && me !== Te && (G = G || []).push(Ke, Te)) : Ke === "children" ? typeof Te != "string" && typeof Te != "number" || (G = G || []).push(Ke, "" + Te) : Ke !== "suppressContentEditableWarning" && Ke !== "suppressHydrationWarning" && (y.hasOwnProperty(Ke) ? (Te != null && Ke === "onScroll" && Ur("scroll", u), G || me === Te || (G = [])) : (G = G || []).push(Ke, Te));
          }
          b && (G = G || []).push("style", b);
          var Ke = G;
          (h.updateQueue = Ke) && (h.flags |= 4);
        }
      }, Yhe = function(u, h, b, C) {
        b !== C && (h.flags |= 4);
      };
      function gw(u, h) {
        if (!Wr) switch (u.tailMode) {
          case "hidden":
            h = u.tail;
            for (var b = null; h !== null; ) h.alternate !== null && (b = h), h = h.sibling;
            b === null ? u.tail = null : b.sibling = null;
            break;
          case "collapsed":
            b = u.tail;
            for (var C = null; b !== null; ) b.alternate !== null && (C = b), b = b.sibling;
            C === null ? h || u.tail === null ? u.tail = null : u.tail.sibling = null : C.sibling = null;
        }
      }
      function Hs(u) {
        var h = u.alternate !== null && u.alternate.child === u.child, b = 0, C = 0;
        if (h) for (var D = u.child; D !== null; ) b |= D.lanes | D.childLanes, C |= D.subtreeFlags & 14680064, C |= D.flags & 14680064, D.return = u, D = D.sibling;
        else for (D = u.child; D !== null; ) b |= D.lanes | D.childLanes, C |= D.subtreeFlags, C |= D.flags, D.return = u, D = D.sibling;
        return u.subtreeFlags |= C, u.childLanes = b, h;
      }
      function rAe(u, h, b) {
        var C = h.pendingProps;
        switch (i4(h), h.tag) {
          case 2:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return Hs(h), null;
          case 1:
            return Lo(h.type) && NI(), Hs(h), null;
          case 3:
            return C = h.stateNode, zv(), zr(Bo), zr(Gs), b4(), C.pendingContext && (C.context = C.pendingContext, C.pendingContext = null), (u === null || u.child === null) && (LI(h) ? h.flags |= 4 : u === null || u.memoizedState.isDehydrated && !(h.flags & 256) || (h.flags |= 1024, Xl !== null && ($4(Xl), Xl = null))), F4(u, h), Hs(h), null;
          case 5:
            y4(h);
            var D = $m(dw.current);
            if (b = h.type, u !== null && h.stateNode != null) Khe(u, h, b, C, D), u.ref !== h.ref && (h.flags |= 512, h.flags |= 2097152);
            else {
              if (!C) {
                if (h.stateNode === null) throw Error(d(166));
                return Hs(h), null;
              }
              if (u = $m(sc.current), LI(h)) {
                C = h.stateNode, b = h.type;
                var G = h.memoizedProps;
                switch (C[ic] = h, C[ow] = G, u = (h.mode & 1) !== 0, b) {
                  case "dialog":
                    Ur("cancel", C), Ur("close", C);
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    Ur("load", C);
                    break;
                  case "video":
                  case "audio":
                    for (D = 0; D < rw.length; D++) Ur(rw[D], C);
                    break;
                  case "source":
                    Ur("error", C);
                    break;
                  case "img":
                  case "image":
                  case "link":
                    Ur("error", C), Ur("load", C);
                    break;
                  case "details":
                    Ur("toggle", C);
                    break;
                  case "input":
                    jr(C, G), Ur("invalid", C);
                    break;
                  case "select":
                    C._wrapperState = { wasMultiple: !!G.multiple }, Ur("invalid", C);
                    break;
                  case "textarea":
                    en(C, G), Ur("invalid", C);
                }
                vz(b, G), D = null;
                for (var Z in G) if (G.hasOwnProperty(Z)) {
                  var me = G[Z];
                  Z === "children" ? typeof me == "string" ? C.textContent !== me && (G.suppressHydrationWarning !== !0 && MI(C.textContent, me, u), D = ["children", me]) : typeof me == "number" && C.textContent !== "" + me && (G.suppressHydrationWarning !== !0 && MI(C.textContent, me, u), D = ["children", "" + me]) : y.hasOwnProperty(Z) && me != null && Z === "onScroll" && Ur("scroll", C);
                }
                switch (b) {
                  case "input":
                    qt(C), ns(C, G, !0);
                    break;
                  case "textarea":
                    qt(C), bd(C);
                    break;
                  case "select":
                  case "option":
                    break;
                  default:
                    typeof G.onClick == "function" && (C.onclick = RI);
                }
                C = D, h.updateQueue = C, C !== null && (h.flags |= 4);
              } else {
                Z = D.nodeType === 9 ? D : D.ownerDocument, u === "http://www.w3.org/1999/xhtml" && (u = _v(b)), u === "http://www.w3.org/1999/xhtml" ? b === "script" ? (u = Z.createElement("div"), u.innerHTML = "<script><\/script>", u = u.removeChild(u.firstChild)) : typeof C.is == "string" ? u = Z.createElement(b, { is: C.is }) : (u = Z.createElement(b), b === "select" && (Z = u, C.multiple ? Z.multiple = !0 : C.size && (Z.size = C.size))) : u = Z.createElementNS(u, b), u[ic] = h, u[ow] = C, Whe(u, h, !1, !1), h.stateNode = u;
                e: {
                  switch (Z = bz(b, C), b) {
                    case "dialog":
                      Ur("cancel", u), Ur("close", u), D = C;
                      break;
                    case "iframe":
                    case "object":
                    case "embed":
                      Ur("load", u), D = C;
                      break;
                    case "video":
                    case "audio":
                      for (D = 0; D < rw.length; D++) Ur(rw[D], u);
                      D = C;
                      break;
                    case "source":
                      Ur("error", u), D = C;
                      break;
                    case "img":
                    case "image":
                    case "link":
                      Ur("error", u), Ur("load", u), D = C;
                      break;
                    case "details":
                      Ur("toggle", u), D = C;
                      break;
                    case "input":
                      jr(u, C), D = dn(u, C), Ur("invalid", u);
                      break;
                    case "option":
                      D = C;
                      break;
                    case "select":
                      u._wrapperState = { wasMultiple: !!C.multiple }, D = de({}, C, { value: void 0 }), Ur("invalid", u);
                      break;
                    case "textarea":
                      en(u, C), D = rs(u, C), Ur("invalid", u);
                      break;
                    default:
                      D = C;
                  }
                  vz(b, D), me = D;
                  for (G in me) if (me.hasOwnProperty(G)) {
                    var Te = me[G];
                    G === "style" ? Fce(u, Te) : G === "dangerouslySetInnerHTML" ? (Te = Te ? Te.__html : void 0, Te != null && Oce(u, Te)) : G === "children" ? typeof Te == "string" ? (b !== "textarea" || Te !== "") && jS(u, Te) : typeof Te == "number" && jS(u, "" + Te) : G !== "suppressContentEditableWarning" && G !== "suppressHydrationWarning" && G !== "autoFocus" && (y.hasOwnProperty(G) ? Te != null && G === "onScroll" && Ur("scroll", u) : Te != null && ce(u, G, Te, Z));
                  }
                  switch (b) {
                    case "input":
                      qt(u), ns(u, C, !1);
                      break;
                    case "textarea":
                      qt(u), bd(u);
                      break;
                    case "option":
                      C.value != null && u.setAttribute("value", "" + yt(C.value));
                      break;
                    case "select":
                      u.multiple = !!C.multiple, G = C.value, G != null ? Fo(u, !!C.multiple, G, !1) : C.defaultValue != null && Fo(u, !!C.multiple, C.defaultValue, !0);
                      break;
                    default:
                      typeof D.onClick == "function" && (u.onclick = RI);
                  }
                  switch (b) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                      C = !!C.autoFocus;
                      break e;
                    case "img":
                      C = !0;
                      break e;
                    default:
                      C = !1;
                  }
                }
                C && (h.flags |= 4);
              }
              h.ref !== null && (h.flags |= 512, h.flags |= 2097152);
            }
            return Hs(h), null;
          case 6:
            if (u && h.stateNode != null) Yhe(u, h, u.memoizedProps, C);
            else {
              if (typeof C != "string" && h.stateNode === null) throw Error(d(166));
              if (b = $m(dw.current), $m(sc.current), LI(h)) {
                if (C = h.stateNode, b = h.memoizedProps, C[ic] = h, (G = C.nodeValue !== b) && (u = ha, u !== null)) switch (u.tag) {
                  case 3:
                    MI(C.nodeValue, b, (u.mode & 1) !== 0);
                    break;
                  case 5:
                    u.memoizedProps.suppressHydrationWarning !== !0 && MI(C.nodeValue, b, (u.mode & 1) !== 0);
                }
                G && (h.flags |= 4);
              } else C = (b.nodeType === 9 ? b : b.ownerDocument).createTextNode(C), C[ic] = h, h.stateNode = C;
            }
            return Hs(h), null;
          case 13:
            if (zr(ti), C = h.memoizedState, u === null || u.memoizedState !== null && u.memoizedState.dehydrated !== null) {
              if (Wr && pa !== null && h.mode & 1 && !(h.flags & 128)) Qde(), Bv(), h.flags |= 98560, G = !1;
              else if (G = LI(h), C !== null && C.dehydrated !== null) {
                if (u === null) {
                  if (!G) throw Error(d(318));
                  if (G = h.memoizedState, G = G !== null ? G.dehydrated : null, !G) throw Error(d(317));
                  G[ic] = h;
                } else Bv(), !(h.flags & 128) && (h.memoizedState = null), h.flags |= 4;
                Hs(h), G = !1;
              } else Xl !== null && ($4(Xl), Xl = null), G = !0;
              if (!G) return h.flags & 65536 ? h : null;
            }
            return h.flags & 128 ? (h.lanes = b, h) : (C = C !== null, C !== (u !== null && u.memoizedState !== null) && C && (h.child.flags |= 8192, h.mode & 1 && (u === null || ti.current & 1 ? Vi === 0 && (Vi = 3) : Y4())), h.updateQueue !== null && (h.flags |= 4), Hs(h), null);
          case 4:
            return zv(), F4(u, h), u === null && iw(h.stateNode.containerInfo), Hs(h), null;
          case 10:
            return c4(h.type._context), Hs(h), null;
          case 17:
            return Lo(h.type) && NI(), Hs(h), null;
          case 19:
            if (zr(ti), G = h.memoizedState, G === null) return Hs(h), null;
            if (C = (h.flags & 128) !== 0, Z = G.rendering, Z === null) if (C) gw(G, !1);
            else {
              if (Vi !== 0 || u !== null && u.flags & 128) for (u = h.child; u !== null; ) {
                if (Z = HI(u), Z !== null) {
                  for (h.flags |= 128, gw(G, !1), C = Z.updateQueue, C !== null && (h.updateQueue = C, h.flags |= 4), h.subtreeFlags = 0, C = b, b = h.child; b !== null; ) G = b, u = C, G.flags &= 14680066, Z = G.alternate, Z === null ? (G.childLanes = 0, G.lanes = u, G.child = null, G.subtreeFlags = 0, G.memoizedProps = null, G.memoizedState = null, G.updateQueue = null, G.dependencies = null, G.stateNode = null) : (G.childLanes = Z.childLanes, G.lanes = Z.lanes, G.child = Z.child, G.subtreeFlags = 0, G.deletions = null, G.memoizedProps = Z.memoizedProps, G.memoizedState = Z.memoizedState, G.updateQueue = Z.updateQueue, G.type = Z.type, u = Z.dependencies, G.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }), b = b.sibling;
                  return Mr(ti, ti.current & 1 | 2), h.child;
                }
                u = u.sibling;
              }
              G.tail !== null && yi() > Hv && (h.flags |= 128, C = !0, gw(G, !1), h.lanes = 4194304);
            }
            else {
              if (!C) if (u = HI(Z), u !== null) {
                if (h.flags |= 128, C = !0, b = u.updateQueue, b !== null && (h.updateQueue = b, h.flags |= 4), gw(G, !0), G.tail === null && G.tailMode === "hidden" && !Z.alternate && !Wr) return Hs(h), null;
              } else 2 * yi() - G.renderingStartTime > Hv && b !== 1073741824 && (h.flags |= 128, C = !0, gw(G, !1), h.lanes = 4194304);
              G.isBackwards ? (Z.sibling = h.child, h.child = Z) : (b = G.last, b !== null ? b.sibling = Z : h.child = Z, G.last = Z);
            }
            return G.tail !== null ? (h = G.tail, G.rendering = h, G.tail = h.sibling, G.renderingStartTime = yi(), h.sibling = null, b = ti.current, Mr(ti, C ? b & 1 | 2 : b & 1), h) : (Hs(h), null);
          case 22:
          case 23:
            return K4(), C = h.memoizedState !== null, u !== null && u.memoizedState !== null !== C && (h.flags |= 8192), C && h.mode & 1 ? fa & 1073741824 && (Hs(h), h.subtreeFlags & 6 && (h.flags |= 8192)) : Hs(h), null;
          case 24:
            return null;
          case 25:
            return null;
        }
        throw Error(d(156, h.tag));
      }
      function iAe(u, h) {
        switch (i4(h), h.tag) {
          case 1:
            return Lo(h.type) && NI(), u = h.flags, u & 65536 ? (h.flags = u & -65537 | 128, h) : null;
          case 3:
            return zv(), zr(Bo), zr(Gs), b4(), u = h.flags, u & 65536 && !(u & 128) ? (h.flags = u & -65537 | 128, h) : null;
          case 5:
            return y4(h), null;
          case 13:
            if (zr(ti), u = h.memoizedState, u !== null && u.dehydrated !== null) {
              if (h.alternate === null) throw Error(d(340));
              Bv();
            }
            return u = h.flags, u & 65536 ? (h.flags = u & -65537 | 128, h) : null;
          case 19:
            return zr(ti), null;
          case 4:
            return zv(), null;
          case 10:
            return c4(h.type._context), null;
          case 22:
          case 23:
            return K4(), null;
          case 24:
            return null;
          default:
            return null;
        }
      }
      var JI = !1, $s = !1, sAe = typeof WeakSet == "function" ? WeakSet : Set, Ot = null;
      function Gv(u, h) {
        var b = u.ref;
        if (b !== null) if (typeof b == "function") try {
          b(null);
        } catch (C) {
          ui(u, h, C);
        }
        else b.current = null;
      }
      function Xhe(u, h, b) {
        try {
          b();
        } catch (C) {
          ui(u, h, C);
        }
      }
      var Qhe = !1;
      function oAe(u, h) {
        if (Yz = gI, u = Tde(), Gz(u)) {
          if ("selectionStart" in u) var b = { start: u.selectionStart, end: u.selectionEnd };
          else e: {
            b = (b = u.ownerDocument) && b.defaultView || window;
            var C = b.getSelection && b.getSelection();
            if (C && C.rangeCount !== 0) {
              b = C.anchorNode;
              var D = C.anchorOffset, G = C.focusNode;
              C = C.focusOffset;
              try {
                b.nodeType, G.nodeType;
              } catch {
                b = null;
                break e;
              }
              var Z = 0, me = -1, Te = -1, Ke = 0, mt = 0, gt = u, ft = null;
              t: for (; ; ) {
                for (var kt; gt !== b || D !== 0 && gt.nodeType !== 3 || (me = Z + D), gt !== G || C !== 0 && gt.nodeType !== 3 || (Te = Z + C), gt.nodeType === 3 && (Z += gt.nodeValue.length), (kt = gt.firstChild) !== null; ) ft = gt, gt = kt;
                for (; ; ) {
                  if (gt === u) break t;
                  if (ft === b && ++Ke === D && (me = Z), ft === G && ++mt === C && (Te = Z), (kt = gt.nextSibling) !== null) break;
                  gt = ft, ft = gt.parentNode;
                }
                gt = kt;
              }
              b = me === -1 || Te === -1 ? null : { start: me, end: Te };
            } else b = null;
          }
          b = b || { start: 0, end: 0 };
        } else b = null;
        for (Xz = { focusedElem: u, selectionRange: b }, gI = !1, Ot = h; Ot !== null; ) if (h = Ot, u = h.child, (h.subtreeFlags & 1028) !== 0 && u !== null) u.return = h, Ot = u;
        else for (; Ot !== null; ) {
          h = Ot;
          try {
            var Ft = h.alternate;
            if (h.flags & 1024) switch (h.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (Ft !== null) {
                  var Bt = Ft.memoizedProps, vi = Ft.memoizedState, ze = h.stateNode, Ne = ze.getSnapshotBeforeUpdate(h.elementType === h.type ? Bt : Ql(h.type, Bt), vi);
                  ze.__reactInternalSnapshotBeforeUpdate = Ne;
                }
                break;
              case 3:
                var qe = h.stateNode.containerInfo;
                qe.nodeType === 1 ? qe.textContent = "" : qe.nodeType === 9 && qe.documentElement && qe.removeChild(qe.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(d(163));
            }
          } catch (vt) {
            ui(h, h.return, vt);
          }
          if (u = h.sibling, u !== null) {
            u.return = h.return, Ot = u;
            break;
          }
          Ot = h.return;
        }
        return Ft = Qhe, Qhe = !1, Ft;
      }
      function yw(u, h, b) {
        var C = h.updateQueue;
        if (C = C !== null ? C.lastEffect : null, C !== null) {
          var D = C = C.next;
          do {
            if ((D.tag & u) === u) {
              var G = D.destroy;
              D.destroy = void 0, G !== void 0 && Xhe(h, b, G);
            }
            D = D.next;
          } while (D !== C);
        }
      }
      function eN(u, h) {
        if (h = h.updateQueue, h = h !== null ? h.lastEffect : null, h !== null) {
          var b = h = h.next;
          do {
            if ((b.tag & u) === u) {
              var C = b.create;
              b.destroy = C();
            }
            b = b.next;
          } while (b !== h);
        }
      }
      function B4(u) {
        var h = u.ref;
        if (h !== null) {
          var b = u.stateNode;
          switch (u.tag) {
            case 5:
              u = b;
              break;
            default:
              u = b;
          }
          typeof h == "function" ? h(u) : h.current = u;
        }
      }
      function Zhe(u) {
        var h = u.alternate;
        h !== null && (u.alternate = null, Zhe(h)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (h = u.stateNode, h !== null && (delete h[ic], delete h[ow], delete h[e4], delete h[VPe], delete h[GPe])), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
      }
      function Jhe(u) {
        return u.tag === 5 || u.tag === 3 || u.tag === 4;
      }
      function epe(u) {
        e: for (; ; ) {
          for (; u.sibling === null; ) {
            if (u.return === null || Jhe(u.return)) return null;
            u = u.return;
          }
          for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
            if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
            u.child.return = u, u = u.child;
          }
          if (!(u.flags & 2)) return u.stateNode;
        }
      }
      function L4(u, h, b) {
        var C = u.tag;
        if (C === 5 || C === 6) u = u.stateNode, h ? b.nodeType === 8 ? b.parentNode.insertBefore(u, h) : b.insertBefore(u, h) : (b.nodeType === 8 ? (h = b.parentNode, h.insertBefore(u, b)) : (h = b, h.appendChild(u)), b = b._reactRootContainer, b != null || h.onclick !== null || (h.onclick = RI));
        else if (C !== 4 && (u = u.child, u !== null)) for (L4(u, h, b), u = u.sibling; u !== null; ) L4(u, h, b), u = u.sibling;
      }
      function j4(u, h, b) {
        var C = u.tag;
        if (C === 5 || C === 6) u = u.stateNode, h ? b.insertBefore(u, h) : b.appendChild(u);
        else if (C !== 4 && (u = u.child, u !== null)) for (j4(u, h, b), u = u.sibling; u !== null; ) j4(u, h, b), u = u.sibling;
      }
      var Ts = null, Zl = !1;
      function Ep(u, h, b) {
        for (b = b.child; b !== null; ) tpe(u, h, b), b = b.sibling;
      }
      function tpe(u, h, b) {
        if (rc && typeof rc.onCommitFiberUnmount == "function") try {
          rc.onCommitFiberUnmount(cI, b);
        } catch {
        }
        switch (b.tag) {
          case 5:
            $s || Gv(b, h);
          case 6:
            var C = Ts, D = Zl;
            Ts = null, Ep(u, h, b), Ts = C, Zl = D, Ts !== null && (Zl ? (u = Ts, b = b.stateNode, u.nodeType === 8 ? u.parentNode.removeChild(b) : u.removeChild(b)) : Ts.removeChild(b.stateNode));
            break;
          case 18:
            Ts !== null && (Zl ? (u = Ts, b = b.stateNode, u.nodeType === 8 ? Jz(u.parentNode, b) : u.nodeType === 1 && Jz(u, b), YS(u)) : Jz(Ts, b.stateNode));
            break;
          case 4:
            C = Ts, D = Zl, Ts = b.stateNode.containerInfo, Zl = !0, Ep(u, h, b), Ts = C, Zl = D;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            if (!$s && (C = b.updateQueue, C !== null && (C = C.lastEffect, C !== null))) {
              D = C = C.next;
              do {
                var G = D, Z = G.destroy;
                G = G.tag, Z !== void 0 && (G & 2 || G & 4) && Xhe(b, h, Z), D = D.next;
              } while (D !== C);
            }
            Ep(u, h, b);
            break;
          case 1:
            if (!$s && (Gv(b, h), C = b.stateNode, typeof C.componentWillUnmount == "function")) try {
              C.props = b.memoizedProps, C.state = b.memoizedState, C.componentWillUnmount();
            } catch (me) {
              ui(b, h, me);
            }
            Ep(u, h, b);
            break;
          case 21:
            Ep(u, h, b);
            break;
          case 22:
            b.mode & 1 ? ($s = (C = $s) || b.memoizedState !== null, Ep(u, h, b), $s = C) : Ep(u, h, b);
            break;
          default:
            Ep(u, h, b);
        }
      }
      function npe(u) {
        var h = u.updateQueue;
        if (h !== null) {
          u.updateQueue = null;
          var b = u.stateNode;
          b === null && (b = u.stateNode = new sAe()), h.forEach(function(C) {
            var D = mAe.bind(null, u, C);
            b.has(C) || (b.add(C), C.then(D, D));
          });
        }
      }
      function Jl(u, h) {
        var b = h.deletions;
        if (b !== null) for (var C = 0; C < b.length; C++) {
          var D = b[C];
          try {
            var G = u, Z = h, me = Z;
            e: for (; me !== null; ) {
              switch (me.tag) {
                case 5:
                  Ts = me.stateNode, Zl = !1;
                  break e;
                case 3:
                  Ts = me.stateNode.containerInfo, Zl = !0;
                  break e;
                case 4:
                  Ts = me.stateNode.containerInfo, Zl = !0;
                  break e;
              }
              me = me.return;
            }
            if (Ts === null) throw Error(d(160));
            tpe(G, Z, D), Ts = null, Zl = !1;
            var Te = D.alternate;
            Te !== null && (Te.return = null), D.return = null;
          } catch (Ke) {
            ui(D, h, Ke);
          }
        }
        if (h.subtreeFlags & 12854) for (h = h.child; h !== null; ) rpe(h, u), h = h.sibling;
      }
      function rpe(u, h) {
        var b = u.alternate, C = u.flags;
        switch (u.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            if (Jl(h, u), ac(u), C & 4) {
              try {
                yw(3, u, u.return), eN(3, u);
              } catch (Bt) {
                ui(u, u.return, Bt);
              }
              try {
                yw(5, u, u.return);
              } catch (Bt) {
                ui(u, u.return, Bt);
              }
            }
            break;
          case 1:
            Jl(h, u), ac(u), C & 512 && b !== null && Gv(b, b.return);
            break;
          case 5:
            if (Jl(h, u), ac(u), C & 512 && b !== null && Gv(b, b.return), u.flags & 32) {
              var D = u.stateNode;
              try {
                jS(D, "");
              } catch (Bt) {
                ui(u, u.return, Bt);
              }
            }
            if (C & 4 && (D = u.stateNode, D != null)) {
              var G = u.memoizedProps, Z = b !== null ? b.memoizedProps : G, me = u.type, Te = u.updateQueue;
              if (u.updateQueue = null, Te !== null) try {
                me === "input" && G.type === "radio" && G.name != null && Sn(D, G), bz(me, Z);
                var Ke = bz(me, G);
                for (Z = 0; Z < Te.length; Z += 2) {
                  var mt = Te[Z], gt = Te[Z + 1];
                  mt === "style" ? Fce(D, gt) : mt === "dangerouslySetInnerHTML" ? Oce(D, gt) : mt === "children" ? jS(D, gt) : ce(D, mt, gt, Ke);
                }
                switch (me) {
                  case "input":
                    Rn(D, G);
                    break;
                  case "textarea":
                    bn(D, G);
                    break;
                  case "select":
                    var ft = D._wrapperState.wasMultiple;
                    D._wrapperState.wasMultiple = !!G.multiple;
                    var kt = G.value;
                    kt != null ? Fo(D, !!G.multiple, kt, !1) : ft !== !!G.multiple && (G.defaultValue != null ? Fo(D, !!G.multiple, G.defaultValue, !0) : Fo(D, !!G.multiple, G.multiple ? [] : "", !1));
                }
                D[ow] = G;
              } catch (Bt) {
                ui(u, u.return, Bt);
              }
            }
            break;
          case 6:
            if (Jl(h, u), ac(u), C & 4) {
              if (u.stateNode === null) throw Error(d(162));
              D = u.stateNode, G = u.memoizedProps;
              try {
                D.nodeValue = G;
              } catch (Bt) {
                ui(u, u.return, Bt);
              }
            }
            break;
          case 3:
            if (Jl(h, u), ac(u), C & 4 && b !== null && b.memoizedState.isDehydrated) try {
              YS(h.containerInfo);
            } catch (Bt) {
              ui(u, u.return, Bt);
            }
            break;
          case 4:
            Jl(h, u), ac(u);
            break;
          case 13:
            Jl(h, u), ac(u), D = u.child, D.flags & 8192 && (G = D.memoizedState !== null, D.stateNode.isHidden = G, !G || D.alternate !== null && D.alternate.memoizedState !== null || (V4 = yi())), C & 4 && npe(u);
            break;
          case 22:
            if (mt = b !== null && b.memoizedState !== null, u.mode & 1 ? ($s = (Ke = $s) || mt, Jl(h, u), $s = Ke) : Jl(h, u), ac(u), C & 8192) {
              if (Ke = u.memoizedState !== null, (u.stateNode.isHidden = Ke) && !mt && u.mode & 1) for (Ot = u, mt = u.child; mt !== null; ) {
                for (gt = Ot = mt; Ot !== null; ) {
                  switch (ft = Ot, kt = ft.child, ft.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      yw(4, ft, ft.return);
                      break;
                    case 1:
                      Gv(ft, ft.return);
                      var Ft = ft.stateNode;
                      if (typeof Ft.componentWillUnmount == "function") {
                        C = ft, b = ft.return;
                        try {
                          h = C, Ft.props = h.memoizedProps, Ft.state = h.memoizedState, Ft.componentWillUnmount();
                        } catch (Bt) {
                          ui(C, b, Bt);
                        }
                      }
                      break;
                    case 5:
                      Gv(ft, ft.return);
                      break;
                    case 22:
                      if (ft.memoizedState !== null) {
                        ope(gt);
                        continue;
                      }
                  }
                  kt !== null ? (kt.return = ft, Ot = kt) : ope(gt);
                }
                mt = mt.sibling;
              }
              e: for (mt = null, gt = u; ; ) {
                if (gt.tag === 5) {
                  if (mt === null) {
                    mt = gt;
                    try {
                      D = gt.stateNode, Ke ? (G = D.style, typeof G.setProperty == "function" ? G.setProperty("display", "none", "important") : G.display = "none") : (me = gt.stateNode, Te = gt.memoizedProps.style, Z = Te != null && Te.hasOwnProperty("display") ? Te.display : null, me.style.display = Dce("display", Z));
                    } catch (Bt) {
                      ui(u, u.return, Bt);
                    }
                  }
                } else if (gt.tag === 6) {
                  if (mt === null) try {
                    gt.stateNode.nodeValue = Ke ? "" : gt.memoizedProps;
                  } catch (Bt) {
                    ui(u, u.return, Bt);
                  }
                } else if ((gt.tag !== 22 && gt.tag !== 23 || gt.memoizedState === null || gt === u) && gt.child !== null) {
                  gt.child.return = gt, gt = gt.child;
                  continue;
                }
                if (gt === u) break e;
                for (; gt.sibling === null; ) {
                  if (gt.return === null || gt.return === u) break e;
                  mt === gt && (mt = null), gt = gt.return;
                }
                mt === gt && (mt = null), gt.sibling.return = gt.return, gt = gt.sibling;
              }
            }
            break;
          case 19:
            Jl(h, u), ac(u), C & 4 && npe(u);
            break;
          case 21:
            break;
          default:
            Jl(h, u), ac(u);
        }
      }
      function ac(u) {
        var h = u.flags;
        if (h & 2) {
          try {
            e: {
              for (var b = u.return; b !== null; ) {
                if (Jhe(b)) {
                  var C = b;
                  break e;
                }
                b = b.return;
              }
              throw Error(d(160));
            }
            switch (C.tag) {
              case 5:
                var D = C.stateNode;
                C.flags & 32 && (jS(D, ""), C.flags &= -33);
                var G = epe(u);
                j4(u, G, D);
                break;
              case 3:
              case 4:
                var Z = C.stateNode.containerInfo, me = epe(u);
                L4(u, me, Z);
                break;
              default:
                throw Error(d(161));
            }
          } catch (Te) {
            ui(u, u.return, Te);
          }
          u.flags &= -3;
        }
        h & 4096 && (u.flags &= -4097);
      }
      function aAe(u, h, b) {
        Ot = u, ipe(u);
      }
      function ipe(u, h, b) {
        for (var C = (u.mode & 1) !== 0; Ot !== null; ) {
          var D = Ot, G = D.child;
          if (D.tag === 22 && C) {
            var Z = D.memoizedState !== null || JI;
            if (!Z) {
              var me = D.alternate, Te = me !== null && me.memoizedState !== null || $s;
              me = JI;
              var Ke = $s;
              if (JI = Z, ($s = Te) && !Ke) for (Ot = D; Ot !== null; ) Z = Ot, Te = Z.child, Z.tag === 22 && Z.memoizedState !== null ? ape(D) : Te !== null ? (Te.return = Z, Ot = Te) : ape(D);
              for (; G !== null; ) Ot = G, ipe(G), G = G.sibling;
              Ot = D, JI = me, $s = Ke;
            }
            spe(u);
          } else D.subtreeFlags & 8772 && G !== null ? (G.return = D, Ot = G) : spe(u);
        }
      }
      function spe(u) {
        for (; Ot !== null; ) {
          var h = Ot;
          if (h.flags & 8772) {
            var b = h.alternate;
            try {
              if (h.flags & 8772) switch (h.tag) {
                case 0:
                case 11:
                case 15:
                  $s || eN(5, h);
                  break;
                case 1:
                  var C = h.stateNode;
                  if (h.flags & 4 && !$s) if (b === null) C.componentDidMount();
                  else {
                    var D = h.elementType === h.type ? b.memoizedProps : Ql(h.type, b.memoizedProps);
                    C.componentDidUpdate(D, b.memoizedState, C.__reactInternalSnapshotBeforeUpdate);
                  }
                  var G = h.updateQueue;
                  G !== null && the(h, G, C);
                  break;
                case 3:
                  var Z = h.updateQueue;
                  if (Z !== null) {
                    if (b = null, h.child !== null) switch (h.child.tag) {
                      case 5:
                        b = h.child.stateNode;
                        break;
                      case 1:
                        b = h.child.stateNode;
                    }
                    the(h, Z, b);
                  }
                  break;
                case 5:
                  var me = h.stateNode;
                  if (b === null && h.flags & 4) {
                    b = me;
                    var Te = h.memoizedProps;
                    switch (h.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        Te.autoFocus && b.focus();
                        break;
                      case "img":
                        Te.src && (b.src = Te.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (h.memoizedState === null) {
                    var Ke = h.alternate;
                    if (Ke !== null) {
                      var mt = Ke.memoizedState;
                      if (mt !== null) {
                        var gt = mt.dehydrated;
                        gt !== null && YS(gt);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(d(163));
              }
              $s || h.flags & 512 && B4(h);
            } catch (ft) {
              ui(h, h.return, ft);
            }
          }
          if (h === u) {
            Ot = null;
            break;
          }
          if (b = h.sibling, b !== null) {
            b.return = h.return, Ot = b;
            break;
          }
          Ot = h.return;
        }
      }
      function ope(u) {
        for (; Ot !== null; ) {
          var h = Ot;
          if (h === u) {
            Ot = null;
            break;
          }
          var b = h.sibling;
          if (b !== null) {
            b.return = h.return, Ot = b;
            break;
          }
          Ot = h.return;
        }
      }
      function ape(u) {
        for (; Ot !== null; ) {
          var h = Ot;
          try {
            switch (h.tag) {
              case 0:
              case 11:
              case 15:
                var b = h.return;
                try {
                  eN(4, h);
                } catch (Te) {
                  ui(h, b, Te);
                }
                break;
              case 1:
                var C = h.stateNode;
                if (typeof C.componentDidMount == "function") {
                  var D = h.return;
                  try {
                    C.componentDidMount();
                  } catch (Te) {
                    ui(h, D, Te);
                  }
                }
                var G = h.return;
                try {
                  B4(h);
                } catch (Te) {
                  ui(h, G, Te);
                }
                break;
              case 5:
                var Z = h.return;
                try {
                  B4(h);
                } catch (Te) {
                  ui(h, Z, Te);
                }
            }
          } catch (Te) {
            ui(h, h.return, Te);
          }
          if (h === u) {
            Ot = null;
            break;
          }
          var me = h.sibling;
          if (me !== null) {
            me.return = h.return, Ot = me;
            break;
          }
          Ot = h.return;
        }
      }
      var lAe = Math.ceil, tN = ue.ReactCurrentDispatcher, U4 = ue.ReactCurrentOwner, el = ue.ReactCurrentBatchConfig, $n = 0, ss = null, Ai = null, Cs = 0, fa = 0, qv = bp(0), Vi = 0, vw = null, Km = 0, nN = 0, z4 = 0, bw = null, Uo = null, V4 = 0, Hv = 1 / 0, Pd = null, rN = !1, G4 = null, Tp = null, iN = !1, Cp = null, sN = 0, xw = 0, q4 = null, oN = -1, aN = 0;
      function co() {
        return $n & 6 ? yi() : oN !== -1 ? oN : oN = yi();
      }
      function Pp(u) {
        return u.mode & 1 ? $n & 2 && Cs !== 0 ? Cs & -Cs : HPe.transition !== null ? (aN === 0 && (aN = Qce()), aN) : (u = hr, u !== 0 || (u = window.event, u = u === void 0 ? 16 : ode(u.type)), u) : 1;
      }
      function eu(u, h, b, C) {
        if (50 < xw) throw xw = 0, q4 = null, Error(d(185));
        qS(u, b, C), (!($n & 2) || u !== ss) && (u === ss && (!($n & 2) && (nN |= b), Vi === 4 && Ap(u, Cs)), zo(u, C), b === 1 && $n === 0 && !(h.mode & 1) && (Hv = yi() + 500, DI && _p()));
      }
      function zo(u, h) {
        var b = u.callbackNode;
        WCe(u, h);
        var C = pI(u, u === ss ? Cs : 0);
        if (C === 0) b !== null && Kce(b), u.callbackNode = null, u.callbackPriority = 0;
        else if (h = C & -C, u.callbackPriority !== h) {
          if (b != null && Kce(b), h === 1) u.tag === 0 ? qPe(upe.bind(null, u)) : $de(upe.bind(null, u)), UPe(function() {
            !($n & 6) && _p();
          }), b = null;
          else {
            switch (Zce(C)) {
              case 1:
                b = Cz;
                break;
              case 4:
                b = Yce;
                break;
              case 16:
                b = uI;
                break;
              case 536870912:
                b = Xce;
                break;
              default:
                b = uI;
            }
            b = ype(b, lpe.bind(null, u));
          }
          u.callbackPriority = h, u.callbackNode = b;
        }
      }
      function lpe(u, h) {
        if (oN = -1, aN = 0, $n & 6) throw Error(d(327));
        var b = u.callbackNode;
        if ($v() && u.callbackNode !== b) return null;
        var C = pI(u, u === ss ? Cs : 0);
        if (C === 0) return null;
        if (C & 30 || C & u.expiredLanes || h) h = lN(u, C);
        else {
          h = C;
          var D = $n;
          $n |= 2;
          var G = dpe();
          (ss !== u || Cs !== h) && (Pd = null, Hv = yi() + 500, Xm(u, h));
          do
            try {
              dAe();
              break;
            } catch (me) {
              cpe(u, me);
            }
          while (!0);
          u4(), tN.current = G, $n = D, Ai !== null ? h = 0 : (ss = null, Cs = 0, h = Vi);
        }
        if (h !== 0) {
          if (h === 2 && (D = Pz(u), D !== 0 && (C = D, h = H4(u, D))), h === 1) throw b = vw, Xm(u, 0), Ap(u, C), zo(u, yi()), b;
          if (h === 6) Ap(u, C);
          else {
            if (D = u.current.alternate, !(C & 30) && !uAe(D) && (h = lN(u, C), h === 2 && (G = Pz(u), G !== 0 && (C = G, h = H4(u, G))), h === 1)) throw b = vw, Xm(u, 0), Ap(u, C), zo(u, yi()), b;
            switch (u.finishedWork = D, u.finishedLanes = C, h) {
              case 0:
              case 1:
                throw Error(d(345));
              case 2:
                Qm(u, Uo, Pd);
                break;
              case 3:
                if (Ap(u, C), (C & 130023424) === C && (h = V4 + 500 - yi(), 10 < h)) {
                  if (pI(u, 0) !== 0) break;
                  if (D = u.suspendedLanes, (D & C) !== C) {
                    co(), u.pingedLanes |= u.suspendedLanes & D;
                    break;
                  }
                  u.timeoutHandle = Zz(Qm.bind(null, u, Uo, Pd), h);
                  break;
                }
                Qm(u, Uo, Pd);
                break;
              case 4:
                if (Ap(u, C), (C & 4194240) === C) break;
                for (h = u.eventTimes, D = -1; 0 < C; ) {
                  var Z = 31 - Kl(C);
                  G = 1 << Z, Z = h[Z], Z > D && (D = Z), C &= ~G;
                }
                if (C = D, C = yi() - C, C = (120 > C ? 120 : 480 > C ? 480 : 1080 > C ? 1080 : 1920 > C ? 1920 : 3e3 > C ? 3e3 : 4320 > C ? 4320 : 1960 * lAe(C / 1960)) - C, 10 < C) {
                  u.timeoutHandle = Zz(Qm.bind(null, u, Uo, Pd), C);
                  break;
                }
                Qm(u, Uo, Pd);
                break;
              case 5:
                Qm(u, Uo, Pd);
                break;
              default:
                throw Error(d(329));
            }
          }
        }
        return zo(u, yi()), u.callbackNode === b ? lpe.bind(null, u) : null;
      }
      function H4(u, h) {
        var b = bw;
        return u.current.memoizedState.isDehydrated && (Xm(u, h).flags |= 256), u = lN(u, h), u !== 2 && (h = Uo, Uo = b, h !== null && $4(h)), u;
      }
      function $4(u) {
        Uo === null ? Uo = u : Uo.push.apply(Uo, u);
      }
      function uAe(u) {
        for (var h = u; ; ) {
          if (h.flags & 16384) {
            var b = h.updateQueue;
            if (b !== null && (b = b.stores, b !== null)) for (var C = 0; C < b.length; C++) {
              var D = b[C], G = D.getSnapshot;
              D = D.value;
              try {
                if (!Yl(G(), D)) return !1;
              } catch {
                return !1;
              }
            }
          }
          if (b = h.child, h.subtreeFlags & 16384 && b !== null) b.return = h, h = b;
          else {
            if (h === u) break;
            for (; h.sibling === null; ) {
              if (h.return === null || h.return === u) return !0;
              h = h.return;
            }
            h.sibling.return = h.return, h = h.sibling;
          }
        }
        return !0;
      }
      function Ap(u, h) {
        for (h &= ~z4, h &= ~nN, u.suspendedLanes |= h, u.pingedLanes &= ~h, u = u.expirationTimes; 0 < h; ) {
          var b = 31 - Kl(h), C = 1 << b;
          u[b] = -1, h &= ~C;
        }
      }
      function upe(u) {
        if ($n & 6) throw Error(d(327));
        $v();
        var h = pI(u, 0);
        if (!(h & 1)) return zo(u, yi()), null;
        var b = lN(u, h);
        if (u.tag !== 0 && b === 2) {
          var C = Pz(u);
          C !== 0 && (h = C, b = H4(u, C));
        }
        if (b === 1) throw b = vw, Xm(u, 0), Ap(u, h), zo(u, yi()), b;
        if (b === 6) throw Error(d(345));
        return u.finishedWork = u.current.alternate, u.finishedLanes = h, Qm(u, Uo, Pd), zo(u, yi()), null;
      }
      function W4(u, h) {
        var b = $n;
        $n |= 1;
        try {
          return u(h);
        } finally {
          $n = b, $n === 0 && (Hv = yi() + 500, DI && _p());
        }
      }
      function Ym(u) {
        Cp !== null && Cp.tag === 0 && !($n & 6) && $v();
        var h = $n;
        $n |= 1;
        var b = el.transition, C = hr;
        try {
          if (el.transition = null, hr = 1, u) return u();
        } finally {
          hr = C, el.transition = b, $n = h, !($n & 6) && _p();
        }
      }
      function K4() {
        fa = qv.current, zr(qv);
      }
      function Xm(u, h) {
        u.finishedWork = null, u.finishedLanes = 0;
        var b = u.timeoutHandle;
        if (b !== -1 && (u.timeoutHandle = -1, jPe(b)), Ai !== null) for (b = Ai.return; b !== null; ) {
          var C = b;
          switch (i4(C), C.tag) {
            case 1:
              C = C.type.childContextTypes, C != null && NI();
              break;
            case 3:
              zv(), zr(Bo), zr(Gs), b4();
              break;
            case 5:
              y4(C);
              break;
            case 4:
              zv();
              break;
            case 13:
              zr(ti);
              break;
            case 19:
              zr(ti);
              break;
            case 10:
              c4(C.type._context);
              break;
            case 22:
            case 23:
              K4();
          }
          b = b.return;
        }
        if (ss = u, Ai = u = kp(u.current, null), Cs = fa = h, Vi = 0, vw = null, z4 = nN = Km = 0, Uo = bw = null, Hm !== null) {
          for (h = 0; h < Hm.length; h++) if (b = Hm[h], C = b.interleaved, C !== null) {
            b.interleaved = null;
            var D = C.next, G = b.pending;
            if (G !== null) {
              var Z = G.next;
              G.next = D, C.next = Z;
            }
            b.pending = C;
          }
          Hm = null;
        }
        return u;
      }
      function cpe(u, h) {
        do {
          var b = Ai;
          try {
            if (u4(), $I.current = XI, WI) {
              for (var C = ni.memoizedState; C !== null; ) {
                var D = C.queue;
                D !== null && (D.pending = null), C = C.next;
              }
              WI = !1;
            }
            if (Wm = 0, is = zi = ni = null, hw = !1, pw = 0, U4.current = null, b === null || b.return === null) {
              Vi = 1, vw = h, Ai = null;
              break;
            }
            e: {
              var G = u, Z = b.return, me = b, Te = h;
              if (h = Cs, me.flags |= 32768, Te !== null && typeof Te == "object" && typeof Te.then == "function") {
                var Ke = Te, mt = me, gt = mt.tag;
                if (!(mt.mode & 1) && (gt === 0 || gt === 11 || gt === 15)) {
                  var ft = mt.alternate;
                  ft ? (mt.updateQueue = ft.updateQueue, mt.memoizedState = ft.memoizedState, mt.lanes = ft.lanes) : (mt.updateQueue = null, mt.memoizedState = null);
                }
                var kt = Ohe(Z);
                if (kt !== null) {
                  kt.flags &= -257, Dhe(kt, Z, me, G, h), kt.mode & 1 && Nhe(G, Ke, h), h = kt, Te = Ke;
                  var Ft = h.updateQueue;
                  if (Ft === null) {
                    var Bt = /* @__PURE__ */ new Set();
                    Bt.add(Te), h.updateQueue = Bt;
                  } else Ft.add(Te);
                  break e;
                } else {
                  if (!(h & 1)) {
                    Nhe(G, Ke, h), Y4();
                    break e;
                  }
                  Te = Error(d(426));
                }
              } else if (Wr && me.mode & 1) {
                var vi = Ohe(Z);
                if (vi !== null) {
                  !(vi.flags & 65536) && (vi.flags |= 256), Dhe(vi, Z, me, G, h), a4(Vv(Te, me));
                  break e;
                }
              }
              G = Te = Vv(Te, me), Vi !== 4 && (Vi = 2), bw === null ? bw = [G] : bw.push(G), G = Z;
              do {
                switch (G.tag) {
                  case 3:
                    G.flags |= 65536, h &= -h, G.lanes |= h;
                    var ze = Rhe(G, Te, h);
                    ehe(G, ze);
                    break e;
                  case 1:
                    me = Te;
                    var Ne = G.type, qe = G.stateNode;
                    if (!(G.flags & 128) && (typeof Ne.getDerivedStateFromError == "function" || qe !== null && typeof qe.componentDidCatch == "function" && (Tp === null || !Tp.has(qe)))) {
                      G.flags |= 65536, h &= -h, G.lanes |= h;
                      var vt = Ihe(G, me, h);
                      ehe(G, vt);
                      break e;
                    }
                }
                G = G.return;
              } while (G !== null);
            }
            ppe(b);
          } catch (Ut) {
            h = Ut, Ai === b && b !== null && (Ai = b = b.return);
            continue;
          }
          break;
        } while (!0);
      }
      function dpe() {
        var u = tN.current;
        return tN.current = XI, u === null ? XI : u;
      }
      function Y4() {
        (Vi === 0 || Vi === 3 || Vi === 2) && (Vi = 4), ss === null || !(Km & 268435455) && !(nN & 268435455) || Ap(ss, Cs);
      }
      function lN(u, h) {
        var b = $n;
        $n |= 2;
        var C = dpe();
        (ss !== u || Cs !== h) && (Pd = null, Xm(u, h));
        do
          try {
            cAe();
            break;
          } catch (D) {
            cpe(u, D);
          }
        while (!0);
        if (u4(), $n = b, tN.current = C, Ai !== null) throw Error(d(261));
        return ss = null, Cs = 0, Vi;
      }
      function cAe() {
        for (; Ai !== null; ) hpe(Ai);
      }
      function dAe() {
        for (; Ai !== null && !LCe(); ) hpe(Ai);
      }
      function hpe(u) {
        var h = gpe(u.alternate, u, fa);
        u.memoizedProps = u.pendingProps, h === null ? ppe(u) : Ai = h, U4.current = null;
      }
      function ppe(u) {
        var h = u;
        do {
          var b = h.alternate;
          if (u = h.return, h.flags & 32768) {
            if (b = iAe(b, h), b !== null) {
              b.flags &= 32767, Ai = b;
              return;
            }
            if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null;
            else {
              Vi = 6, Ai = null;
              return;
            }
          } else if (b = rAe(b, h, fa), b !== null) {
            Ai = b;
            return;
          }
          if (h = h.sibling, h !== null) {
            Ai = h;
            return;
          }
          Ai = h = u;
        } while (h !== null);
        Vi === 0 && (Vi = 5);
      }
      function Qm(u, h, b) {
        var C = hr, D = el.transition;
        try {
          el.transition = null, hr = 1, hAe(u, h, b, C);
        } finally {
          el.transition = D, hr = C;
        }
        return null;
      }
      function hAe(u, h, b, C) {
        do
          $v();
        while (Cp !== null);
        if ($n & 6) throw Error(d(327));
        b = u.finishedWork;
        var D = u.finishedLanes;
        if (b === null) return null;
        if (u.finishedWork = null, u.finishedLanes = 0, b === u.current) throw Error(d(177));
        u.callbackNode = null, u.callbackPriority = 0;
        var G = b.lanes | b.childLanes;
        if (KCe(u, G), u === ss && (Ai = ss = null, Cs = 0), !(b.subtreeFlags & 2064) && !(b.flags & 2064) || iN || (iN = !0, ype(uI, function() {
          return $v(), null;
        })), G = (b.flags & 15990) !== 0, b.subtreeFlags & 15990 || G) {
          G = el.transition, el.transition = null;
          var Z = hr;
          hr = 1;
          var me = $n;
          $n |= 4, U4.current = null, oAe(u, b), rpe(b, u), OPe(Xz), gI = !!Yz, Xz = Yz = null, u.current = b, aAe(b), jCe(), $n = me, hr = Z, el.transition = G;
        } else u.current = b;
        if (iN && (iN = !1, Cp = u, sN = D), G = u.pendingLanes, G === 0 && (Tp = null), VCe(b.stateNode), zo(u, yi()), h !== null) for (C = u.onRecoverableError, b = 0; b < h.length; b++) D = h[b], C(D.value, { componentStack: D.stack, digest: D.digest });
        if (rN) throw rN = !1, u = G4, G4 = null, u;
        return sN & 1 && u.tag !== 0 && $v(), G = u.pendingLanes, G & 1 ? u === q4 ? xw++ : (xw = 0, q4 = u) : xw = 0, _p(), null;
      }
      function $v() {
        if (Cp !== null) {
          var u = Zce(sN), h = el.transition, b = hr;
          try {
            if (el.transition = null, hr = 16 > u ? 16 : u, Cp === null) var C = !1;
            else {
              if (u = Cp, Cp = null, sN = 0, $n & 6) throw Error(d(331));
              var D = $n;
              for ($n |= 4, Ot = u.current; Ot !== null; ) {
                var G = Ot, Z = G.child;
                if (Ot.flags & 16) {
                  var me = G.deletions;
                  if (me !== null) {
                    for (var Te = 0; Te < me.length; Te++) {
                      var Ke = me[Te];
                      for (Ot = Ke; Ot !== null; ) {
                        var mt = Ot;
                        switch (mt.tag) {
                          case 0:
                          case 11:
                          case 15:
                            yw(8, mt, G);
                        }
                        var gt = mt.child;
                        if (gt !== null) gt.return = mt, Ot = gt;
                        else for (; Ot !== null; ) {
                          mt = Ot;
                          var ft = mt.sibling, kt = mt.return;
                          if (Zhe(mt), mt === Ke) {
                            Ot = null;
                            break;
                          }
                          if (ft !== null) {
                            ft.return = kt, Ot = ft;
                            break;
                          }
                          Ot = kt;
                        }
                      }
                    }
                    var Ft = G.alternate;
                    if (Ft !== null) {
                      var Bt = Ft.child;
                      if (Bt !== null) {
                        Ft.child = null;
                        do {
                          var vi = Bt.sibling;
                          Bt.sibling = null, Bt = vi;
                        } while (Bt !== null);
                      }
                    }
                    Ot = G;
                  }
                }
                if (G.subtreeFlags & 2064 && Z !== null) Z.return = G, Ot = Z;
                else e: for (; Ot !== null; ) {
                  if (G = Ot, G.flags & 2048) switch (G.tag) {
                    case 0:
                    case 11:
                    case 15:
                      yw(9, G, G.return);
                  }
                  var ze = G.sibling;
                  if (ze !== null) {
                    ze.return = G.return, Ot = ze;
                    break e;
                  }
                  Ot = G.return;
                }
              }
              var Ne = u.current;
              for (Ot = Ne; Ot !== null; ) {
                Z = Ot;
                var qe = Z.child;
                if (Z.subtreeFlags & 2064 && qe !== null) qe.return = Z, Ot = qe;
                else e: for (Z = Ne; Ot !== null; ) {
                  if (me = Ot, me.flags & 2048) try {
                    switch (me.tag) {
                      case 0:
                      case 11:
                      case 15:
                        eN(9, me);
                    }
                  } catch (Ut) {
                    ui(me, me.return, Ut);
                  }
                  if (me === Z) {
                    Ot = null;
                    break e;
                  }
                  var vt = me.sibling;
                  if (vt !== null) {
                    vt.return = me.return, Ot = vt;
                    break e;
                  }
                  Ot = me.return;
                }
              }
              if ($n = D, _p(), rc && typeof rc.onPostCommitFiberRoot == "function") try {
                rc.onPostCommitFiberRoot(cI, u);
              } catch {
              }
              C = !0;
            }
            return C;
          } finally {
            hr = b, el.transition = h;
          }
        }
        return !1;
      }
      function fpe(u, h, b) {
        h = Vv(b, h), h = Rhe(u, h, 1), u = wp(u, h, 1), h = co(), u !== null && (qS(u, 1, h), zo(u, h));
      }
      function ui(u, h, b) {
        if (u.tag === 3) fpe(u, u, b);
        else for (; h !== null; ) {
          if (h.tag === 3) {
            fpe(h, u, b);
            break;
          } else if (h.tag === 1) {
            var C = h.stateNode;
            if (typeof h.type.getDerivedStateFromError == "function" || typeof C.componentDidCatch == "function" && (Tp === null || !Tp.has(C))) {
              u = Vv(b, u), u = Ihe(h, u, 1), h = wp(h, u, 1), u = co(), h !== null && (qS(h, 1, u), zo(h, u));
              break;
            }
          }
          h = h.return;
        }
      }
      function pAe(u, h, b) {
        var C = u.pingCache;
        C !== null && C.delete(h), h = co(), u.pingedLanes |= u.suspendedLanes & b, ss === u && (Cs & b) === b && (Vi === 4 || Vi === 3 && (Cs & 130023424) === Cs && 500 > yi() - V4 ? Xm(u, 0) : z4 |= b), zo(u, h);
      }
      function mpe(u, h) {
        h === 0 && (u.mode & 1 ? (h = hI, hI <<= 1, !(hI & 130023424) && (hI = 4194304)) : h = 1);
        var b = co();
        u = Ed(u, h), u !== null && (qS(u, h, b), zo(u, b));
      }
      function fAe(u) {
        var h = u.memoizedState, b = 0;
        h !== null && (b = h.retryLane), mpe(u, b);
      }
      function mAe(u, h) {
        var b = 0;
        switch (u.tag) {
          case 13:
            var C = u.stateNode, D = u.memoizedState;
            D !== null && (b = D.retryLane);
            break;
          case 19:
            C = u.stateNode;
            break;
          default:
            throw Error(d(314));
        }
        C !== null && C.delete(h), mpe(u, b);
      }
      var gpe;
      gpe = function(u, h, b) {
        if (u !== null) if (u.memoizedProps !== h.pendingProps || Bo.current) jo = !0;
        else {
          if (!(u.lanes & b) && !(h.flags & 128)) return jo = !1, nAe(u, h, b);
          jo = !!(u.flags & 131072);
        }
        else jo = !1, Wr && h.flags & 1048576 && Wde(h, BI, h.index);
        switch (h.lanes = 0, h.tag) {
          case 2:
            var C = h.type;
            ZI(u, h), u = h.pendingProps;
            var D = Ov(h, Gs.current);
            jv(h, b), D = S4(null, h, C, u, D, b);
            var G = w4();
            return h.flags |= 1, typeof D == "object" && D !== null && typeof D.render == "function" && D.$$typeof === void 0 ? (h.tag = 1, h.memoizedState = null, h.updateQueue = null, Lo(C) ? (G = !0, OI(h)) : G = !1, h.memoizedState = D.state !== null && D.state !== void 0 ? D.state : null, p4(h), D.updater = GI, h.stateNode = D, D._reactInternals = h, m4(h, C, u, b), h = R4(null, h, C, !0, G, b)) : (h.tag = 0, Wr && G && r4(h), uo(null, h, D, b), h = h.child), h;
          case 16:
            C = h.elementType;
            e: {
              switch (ZI(u, h), u = h.pendingProps, D = C._init, C = D(C._payload), h.type = C, D = h.tag = yAe(C), u = Ql(C, u), D) {
                case 0:
                  h = M4(null, h, C, u, b);
                  break e;
                case 1:
                  h = zhe(null, h, C, u, b);
                  break e;
                case 11:
                  h = Fhe(null, h, C, u, b);
                  break e;
                case 14:
                  h = Bhe(null, h, C, Ql(C.type, u), b);
                  break e;
              }
              throw Error(d(306, C, ""));
            }
            return h;
          case 0:
            return C = h.type, D = h.pendingProps, D = h.elementType === C ? D : Ql(C, D), M4(u, h, C, D, b);
          case 1:
            return C = h.type, D = h.pendingProps, D = h.elementType === C ? D : Ql(C, D), zhe(u, h, C, D, b);
          case 3:
            e: {
              if (Vhe(h), u === null) throw Error(d(387));
              C = h.pendingProps, G = h.memoizedState, D = G.element, Jde(u, h), VI(h, C, null, b);
              var Z = h.memoizedState;
              if (C = Z.element, G.isDehydrated) if (G = { element: C, isDehydrated: !1, cache: Z.cache, pendingSuspenseBoundaries: Z.pendingSuspenseBoundaries, transitions: Z.transitions }, h.updateQueue.baseState = G, h.memoizedState = G, h.flags & 256) {
                D = Vv(Error(d(423)), h), h = Ghe(u, h, C, b, D);
                break e;
              } else if (C !== D) {
                D = Vv(Error(d(424)), h), h = Ghe(u, h, C, b, D);
                break e;
              } else for (pa = vp(h.stateNode.containerInfo.firstChild), ha = h, Wr = !0, Xl = null, b = lhe(h, null, C, b), h.child = b; b; ) b.flags = b.flags & -3 | 4096, b = b.sibling;
              else {
                if (Bv(), C === D) {
                  h = Cd(u, h, b);
                  break e;
                }
                uo(u, h, C, b);
              }
              h = h.child;
            }
            return h;
          case 5:
            return uhe(h), u === null && o4(h), C = h.type, D = h.pendingProps, G = u !== null ? u.memoizedProps : null, Z = D.children, Qz(C, D) ? Z = null : G !== null && Qz(C, G) && (h.flags |= 32), Uhe(u, h), uo(u, h, Z, b), h.child;
          case 6:
            return u === null && o4(h), null;
          case 13:
            return qhe(u, h, b);
          case 4:
            return g4(h, h.stateNode.containerInfo), C = h.pendingProps, u === null ? h.child = Uv(h, null, C, b) : uo(u, h, C, b), h.child;
          case 11:
            return C = h.type, D = h.pendingProps, D = h.elementType === C ? D : Ql(C, D), Fhe(u, h, C, D, b);
          case 7:
            return uo(u, h, h.pendingProps, b), h.child;
          case 8:
            return uo(u, h, h.pendingProps.children, b), h.child;
          case 12:
            return uo(u, h, h.pendingProps.children, b), h.child;
          case 10:
            e: {
              if (C = h.type._context, D = h.pendingProps, G = h.memoizedProps, Z = D.value, Mr(jI, C._currentValue), C._currentValue = Z, G !== null) if (Yl(G.value, Z)) {
                if (G.children === D.children && !Bo.current) {
                  h = Cd(u, h, b);
                  break e;
                }
              } else for (G = h.child, G !== null && (G.return = h); G !== null; ) {
                var me = G.dependencies;
                if (me !== null) {
                  Z = G.child;
                  for (var Te = me.firstContext; Te !== null; ) {
                    if (Te.context === C) {
                      if (G.tag === 1) {
                        Te = Td(-1, b & -b), Te.tag = 2;
                        var Ke = G.updateQueue;
                        if (Ke !== null) {
                          Ke = Ke.shared;
                          var mt = Ke.pending;
                          mt === null ? Te.next = Te : (Te.next = mt.next, mt.next = Te), Ke.pending = Te;
                        }
                      }
                      G.lanes |= b, Te = G.alternate, Te !== null && (Te.lanes |= b), d4(G.return, b, h), me.lanes |= b;
                      break;
                    }
                    Te = Te.next;
                  }
                } else if (G.tag === 10) Z = G.type === h.type ? null : G.child;
                else if (G.tag === 18) {
                  if (Z = G.return, Z === null) throw Error(d(341));
                  Z.lanes |= b, me = Z.alternate, me !== null && (me.lanes |= b), d4(Z, b, h), Z = G.sibling;
                } else Z = G.child;
                if (Z !== null) Z.return = G;
                else for (Z = G; Z !== null; ) {
                  if (Z === h) {
                    Z = null;
                    break;
                  }
                  if (G = Z.sibling, G !== null) {
                    G.return = Z.return, Z = G;
                    break;
                  }
                  Z = Z.return;
                }
                G = Z;
              }
              uo(u, h, D.children, b), h = h.child;
            }
            return h;
          case 9:
            return D = h.type, C = h.pendingProps.children, jv(h, b), D = Za(D), C = C(D), h.flags |= 1, uo(u, h, C, b), h.child;
          case 14:
            return C = h.type, D = Ql(C, h.pendingProps), D = Ql(C.type, D), Bhe(u, h, C, D, b);
          case 15:
            return Lhe(u, h, h.type, h.pendingProps, b);
          case 17:
            return C = h.type, D = h.pendingProps, D = h.elementType === C ? D : Ql(C, D), ZI(u, h), h.tag = 1, Lo(C) ? (u = !0, OI(h)) : u = !1, jv(h, b), ihe(h, C, D), m4(h, C, D, b), R4(null, h, C, !0, u, b);
          case 19:
            return $he(u, h, b);
          case 22:
            return jhe(u, h, b);
        }
        throw Error(d(156, h.tag));
      };
      function ype(u, h) {
        return Wce(u, h);
      }
      function gAe(u, h, b, C) {
        this.tag = u, this.key = b, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = h, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = C, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
      }
      function tl(u, h, b, C) {
        return new gAe(u, h, b, C);
      }
      function X4(u) {
        return u = u.prototype, !(!u || !u.isReactComponent);
      }
      function yAe(u) {
        if (typeof u == "function") return X4(u) ? 1 : 0;
        if (u != null) {
          if (u = u.$$typeof, u === Xe) return 11;
          if (u === De) return 14;
        }
        return 2;
      }
      function kp(u, h) {
        var b = u.alternate;
        return b === null ? (b = tl(u.tag, h, u.key, u.mode), b.elementType = u.elementType, b.type = u.type, b.stateNode = u.stateNode, b.alternate = u, u.alternate = b) : (b.pendingProps = h, b.type = u.type, b.flags = 0, b.subtreeFlags = 0, b.deletions = null), b.flags = u.flags & 14680064, b.childLanes = u.childLanes, b.lanes = u.lanes, b.child = u.child, b.memoizedProps = u.memoizedProps, b.memoizedState = u.memoizedState, b.updateQueue = u.updateQueue, h = u.dependencies, b.dependencies = h === null ? null : { lanes: h.lanes, firstContext: h.firstContext }, b.sibling = u.sibling, b.index = u.index, b.ref = u.ref, b;
      }
      function uN(u, h, b, C, D, G) {
        var Z = 2;
        if (C = u, typeof u == "function") X4(u) && (Z = 1);
        else if (typeof u == "string") Z = 5;
        else e: switch (u) {
          case he:
            return Zm(b.children, D, G, h);
          case ie:
            Z = 8, D |= 8;
            break;
          case ye:
            return u = tl(12, b, h, D | 2), u.elementType = ye, u.lanes = G, u;
          case Se:
            return u = tl(13, b, h, D), u.elementType = Se, u.lanes = G, u;
          case nt:
            return u = tl(19, b, h, D), u.elementType = nt, u.lanes = G, u;
          case le:
            return cN(b, D, G, h);
          default:
            if (typeof u == "object" && u !== null) switch (u.$$typeof) {
              case Ee:
                Z = 10;
                break e;
              case ve:
                Z = 9;
                break e;
              case Xe:
                Z = 11;
                break e;
              case De:
                Z = 14;
                break e;
              case Ce:
                Z = 16, C = null;
                break e;
            }
            throw Error(d(130, u == null ? u : typeof u, ""));
        }
        return h = tl(Z, b, h, D), h.elementType = u, h.type = C, h.lanes = G, h;
      }
      function Zm(u, h, b, C) {
        return u = tl(7, u, C, h), u.lanes = b, u;
      }
      function cN(u, h, b, C) {
        return u = tl(22, u, C, h), u.elementType = le, u.lanes = b, u.stateNode = { isHidden: !1 }, u;
      }
      function Q4(u, h, b) {
        return u = tl(6, u, null, h), u.lanes = b, u;
      }
      function Z4(u, h, b) {
        return h = tl(4, u.children !== null ? u.children : [], u.key, h), h.lanes = b, h.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, h;
      }
      function vAe(u, h, b, C, D) {
        this.tag = h, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Az(0), this.expirationTimes = Az(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Az(0), this.identifierPrefix = C, this.onRecoverableError = D, this.mutableSourceEagerHydrationData = null;
      }
      function J4(u, h, b, C, D, G, Z, me, Te) {
        return u = new vAe(u, h, b, me, Te), h === 1 ? (h = 1, G === !0 && (h |= 8)) : h = 0, G = tl(3, null, null, h), u.current = G, G.stateNode = u, G.memoizedState = { element: C, isDehydrated: b, cache: null, transitions: null, pendingSuspenseBoundaries: null }, p4(G), u;
      }
      function bAe(u, h, b) {
        var C = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return { $$typeof: Oe, key: C == null ? null : "" + C, children: u, containerInfo: h, implementation: b };
      }
      function vpe(u) {
        if (!u) return xp;
        u = u._reactInternals;
        e: {
          if (Um(u) !== u || u.tag !== 1) throw Error(d(170));
          var h = u;
          do {
            switch (h.tag) {
              case 3:
                h = h.stateNode.context;
                break e;
              case 1:
                if (Lo(h.type)) {
                  h = h.stateNode.__reactInternalMemoizedMergedChildContext;
                  break e;
                }
            }
            h = h.return;
          } while (h !== null);
          throw Error(d(171));
        }
        if (u.tag === 1) {
          var b = u.type;
          if (Lo(b)) return qde(u, b, h);
        }
        return h;
      }
      function bpe(u, h, b, C, D, G, Z, me, Te) {
        return u = J4(b, C, !0, u, D, G, Z, me, Te), u.context = vpe(null), b = u.current, C = co(), D = Pp(b), G = Td(C, D), G.callback = h ?? null, wp(b, G, D), u.current.lanes = D, qS(u, D, C), zo(u, C), u;
      }
      function dN(u, h, b, C) {
        var D = h.current, G = co(), Z = Pp(D);
        return b = vpe(b), h.context === null ? h.context = b : h.pendingContext = b, h = Td(G, Z), h.payload = { element: u }, C = C === void 0 ? null : C, C !== null && (h.callback = C), u = wp(D, h, Z), u !== null && (eu(u, D, Z, G), zI(u, D, Z)), Z;
      }
      function hN(u) {
        if (u = u.current, !u.child) return null;
        switch (u.child.tag) {
          case 5:
            return u.child.stateNode;
          default:
            return u.child.stateNode;
        }
      }
      function xpe(u, h) {
        if (u = u.memoizedState, u !== null && u.dehydrated !== null) {
          var b = u.retryLane;
          u.retryLane = b !== 0 && b < h ? b : h;
        }
      }
      function e5(u, h) {
        xpe(u, h), (u = u.alternate) && xpe(u, h);
      }
      function xAe() {
        return null;
      }
      var _pe = typeof reportError == "function" ? reportError : function(u) {
        console.error(u);
      };
      function t5(u) {
        this._internalRoot = u;
      }
      pN.prototype.render = t5.prototype.render = function(u) {
        var h = this._internalRoot;
        if (h === null) throw Error(d(409));
        dN(u, h, null, null);
      }, pN.prototype.unmount = t5.prototype.unmount = function() {
        var u = this._internalRoot;
        if (u !== null) {
          this._internalRoot = null;
          var h = u.containerInfo;
          Ym(function() {
            dN(null, u, null, null);
          }), h[xd] = null;
        }
      };
      function pN(u) {
        this._internalRoot = u;
      }
      pN.prototype.unstable_scheduleHydration = function(u) {
        if (u) {
          var h = tde();
          u = { blockedOn: null, target: u, priority: h };
          for (var b = 0; b < mp.length && h !== 0 && h < mp[b].priority; b++) ;
          mp.splice(b, 0, u), b === 0 && ide(u);
        }
      };
      function n5(u) {
        return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11);
      }
      function fN(u) {
        return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11 && (u.nodeType !== 8 || u.nodeValue !== " react-mount-point-unstable "));
      }
      function Spe() {
      }
      function _Ae(u, h, b, C, D) {
        if (D) {
          if (typeof C == "function") {
            var G = C;
            C = function() {
              var Ke = hN(Z);
              G.call(Ke);
            };
          }
          var Z = bpe(h, C, u, 0, null, !1, !1, "", Spe);
          return u._reactRootContainer = Z, u[xd] = Z.current, iw(u.nodeType === 8 ? u.parentNode : u), Ym(), Z;
        }
        for (; D = u.lastChild; ) u.removeChild(D);
        if (typeof C == "function") {
          var me = C;
          C = function() {
            var Ke = hN(Te);
            me.call(Ke);
          };
        }
        var Te = J4(u, 0, !1, null, null, !1, !1, "", Spe);
        return u._reactRootContainer = Te, u[xd] = Te.current, iw(u.nodeType === 8 ? u.parentNode : u), Ym(function() {
          dN(h, Te, b, C);
        }), Te;
      }
      function mN(u, h, b, C, D) {
        var G = b._reactRootContainer;
        if (G) {
          var Z = G;
          if (typeof D == "function") {
            var me = D;
            D = function() {
              var Te = hN(Z);
              me.call(Te);
            };
          }
          dN(h, Z, u, D);
        } else Z = _Ae(b, h, u, D, C);
        return hN(Z);
      }
      Jce = function(u) {
        switch (u.tag) {
          case 3:
            var h = u.stateNode;
            if (h.current.memoizedState.isDehydrated) {
              var b = GS(h.pendingLanes);
              b !== 0 && (kz(h, b | 1), zo(h, yi()), !($n & 6) && (Hv = yi() + 500, _p()));
            }
            break;
          case 13:
            Ym(function() {
              var C = Ed(u, 1);
              if (C !== null) {
                var D = co();
                eu(C, u, 1, D);
              }
            }), e5(u, 1);
        }
      }, Mz = function(u) {
        if (u.tag === 13) {
          var h = Ed(u, 134217728);
          if (h !== null) {
            var b = co();
            eu(h, u, 134217728, b);
          }
          e5(u, 134217728);
        }
      }, ede = function(u) {
        if (u.tag === 13) {
          var h = Pp(u), b = Ed(u, h);
          if (b !== null) {
            var C = co();
            eu(b, u, h, C);
          }
          e5(u, h);
        }
      }, tde = function() {
        return hr;
      }, nde = function(u, h) {
        var b = hr;
        try {
          return hr = u, h();
        } finally {
          hr = b;
        }
      }, Sz = function(u, h, b) {
        switch (h) {
          case "input":
            if (Rn(u, b), h = b.name, b.type === "radio" && h != null) {
              for (b = u; b.parentNode; ) b = b.parentNode;
              for (b = b.querySelectorAll("input[name=" + JSON.stringify("" + h) + '][type="radio"]'), h = 0; h < b.length; h++) {
                var C = b[h];
                if (C !== u && C.form === u.form) {
                  var D = II(C);
                  if (!D) throw Error(d(90));
                  Tn(C), Rn(C, D);
                }
              }
            }
            break;
          case "textarea":
            bn(u, b);
            break;
          case "select":
            h = b.value, h != null && Fo(u, !!b.multiple, h, !1);
        }
      }, Uce = W4, zce = Ym;
      var SAe = { usingClientEntryPoint: !1, Events: [aw, Iv, II, Lce, jce, W4] }, _w = { findFiberByHostInstance: zm, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, wAe = { bundleType: _w.bundleType, version: _w.version, rendererPackageName: _w.rendererPackageName, rendererConfig: _w.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ue.ReactCurrentDispatcher, findHostInstanceByFiber: function(u) {
        return u = Hce(u), u === null ? null : u.stateNode;
      }, findFiberByHostInstance: _w.findFiberByHostInstance || xAe, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && (Sw = __REACT_DEVTOOLS_GLOBAL_HOOK__, !Sw.isDisabled && Sw.supportsFiber)) try {
        cI = Sw.inject(wAe), rc = Sw;
      } catch {
      }
      var Sw;
      r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = SAe, r.createPortal = function(u, h) {
        var b = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
        if (!n5(h)) throw Error(d(200));
        return bAe(u, h, null, b);
      }, r.createRoot = function(u, h) {
        if (!n5(u)) throw Error(d(299));
        var b = !1, C = "", D = _pe;
        return h != null && (h.unstable_strictMode === !0 && (b = !0), h.identifierPrefix !== void 0 && (C = h.identifierPrefix), h.onRecoverableError !== void 0 && (D = h.onRecoverableError)), h = J4(u, 1, !1, null, null, b, !1, C, D), u[xd] = h.current, iw(u.nodeType === 8 ? u.parentNode : u), new t5(h);
      }, r.findDOMNode = function(u) {
        if (u == null) return null;
        if (u.nodeType === 1) return u;
        var h = u._reactInternals;
        if (h === void 0) throw typeof u.render == "function" ? Error(d(188)) : (u = Object.keys(u).join(","), Error(d(268, u)));
        return u = Hce(h), u = u === null ? null : u.stateNode, u;
      }, r.flushSync = function(u) {
        return Ym(u);
      }, r.hydrate = function(u, h, b) {
        if (!fN(h)) throw Error(d(200));
        return mN(null, u, h, !0, b);
      }, r.hydrateRoot = function(u, h, b) {
        if (!n5(u)) throw Error(d(405));
        var C = b != null && b.hydratedSources || null, D = !1, G = "", Z = _pe;
        if (b != null && (b.unstable_strictMode === !0 && (D = !0), b.identifierPrefix !== void 0 && (G = b.identifierPrefix), b.onRecoverableError !== void 0 && (Z = b.onRecoverableError)), h = bpe(h, null, u, 1, b ?? null, D, !1, G, Z), u[xd] = h.current, iw(u), C) for (u = 0; u < C.length; u++) b = C[u], D = b._getVersion, D = D(b._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [b, D] : h.mutableSourceEagerHydrationData.push(b, D);
        return new pN(h);
      }, r.render = function(u, h, b) {
        if (!fN(h)) throw Error(d(200));
        return mN(null, u, h, !1, b);
      }, r.unmountComponentAtNode = function(u) {
        if (!fN(u)) throw Error(d(40));
        return u._reactRootContainer ? (Ym(function() {
          mN(null, null, u, !1, function() {
            u._reactRootContainer = null, u[xd] = null;
          });
        }), !0) : !1;
      }, r.unstable_batchedUpdates = W4, r.unstable_renderSubtreeIntoContainer = function(u, h, b, C) {
        if (!fN(b)) throw Error(d(200));
        if (u == null || u._reactInternals === void 0) throw Error(d(38));
        return mN(u, h, b, !1, C);
      }, r.version = "18.2.0-next-9e3b772b8-20220608";
    }), oi = J((r, s) => {
      function a() {
        if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(a);
        } catch (d) {
          console.error(d);
        }
      }
      a(), s.exports = Ua();
    });
    function ji(r) {
      let [, s] = (0, Gh.useState)(0);
      return (0, Gh.useCallback)(() => {
        s((a) => a + 1);
      }, []);
    }
    function At(r, s, a) {
      let d = (0, Gh.useCallback)(r, s), m = (0, Gh.useRef)(null);
      m.current ? m.current.set(d) : m.current = new Qi.Atom(d);
      let y = (0, Gh.useRef)(null);
      return y.current || (y.current = (0, Qi.prism)(() => m.current.prism.getValue()())), Yn(y.current, a);
    }
    function ai() {
      ok || (ok = !0, (0, za.default)(() => {
        (0, AG.unstable_batchedUpdates)(function() {
          for (var r, s; Tl.length > 0; ) {
            let a = Tl.shift();
            v0.delete(a);
            let d;
            Zf && ((r = a.debug) == null || r.history.push("queue reached"));
            try {
              d = a.der.getValue();
            } catch (m) {
              Zf && ((s = a.debug) == null || s.history.push("queue: der.getValue() errored")), console.error("A `der.getValue()` in `usePrismInstance(der)` threw an error. This may be a zombie child issue, so we're gonna try to get its value again in a normal react render phase.If you see the same error again, then you either have an error in your prism code, or the deps array in `usePrism(fn, deps)` is missing a dependency and causing the prism to read stale values."), console.error(m), a.runUpdate();
              continue;
            }
            d !== a.lastValue && (a.lastValue = d, a.runUpdate());
          }
          ok = !1;
        }, 1);
      }));
    }
    function Yn(r, s) {
      var a;
      let d = ji(), m = (0, Gh.useRef)(void 0);
      m.current || (ZF++, m.current = { order: ZF, runUpdate: () => {
        m.current.unmounted || d();
      }, der: r, lastValue: void 0, unmounted: !1, queueUpdate: () => {
        var x;
        Zf && ((x = m.current.debug) == null || x.history.push("queueUpdate()")), kG(m.current);
      }, untap: r.onStale(() => {
        Zf && m.current.debug.history.push("onStale(cb)"), m.current.queueUpdate();
      }) }, Zf && (m.current.debug = { label: s, traceOfFirstTimeRender: new Error(), history: [] })), (0, Gh.useLayoutEffect)(() => function() {
        m.current.unmounted = !0, m.current.untap(), JF(m.current);
      }, []), JF(m.current);
      let y = m.current.der.getValue();
      return m.current.lastValue = y, Zf && ((a = m.current.debug) == null || a.history.push("rendered")), y;
    }
    var Qi, za, Gh, AG, Zf, nn, ZF, Tl, v0, ok, kG, MG, JF, zt = R(() => {
      Qi = ut(), tn(), za = Y(fi()), Gh = Y(xe()), AG = Y(oi()), Zf = !1, nn = (r, s) => At(() => (0, Qi.val)(r), [r], s), ZF = 0, Tl = [], v0 = /* @__PURE__ */ new Set(), ok = !1, kG = (r) => {
        MG(r), ai();
      }, MG = (r) => {
        if (!v0.has(r)) if (v0.add(r), Tl.length === 0) Tl.push(r);
        else {
          let s = Vh(Tl, (a) => a.order >= r.order);
          s === -1 ? Tl.push(r) : Tl[s].order > r.order && Tl.splice(s, 0, r);
        }
      }, JF = (r) => {
        if (!v0.has(r)) return;
        v0.delete(r);
        let s = Vh(Tl, (a) => a === r);
        Tl.splice(s, 1);
      };
    }), Eve = J((r) => {
      var s = 60103, a = 60106, d = 60107, m = 60108, y = 60114, x = 60109, w = 60110, T = 60112, P = 60113, M = 60120, F = 60115, O = 60116, N = 60121, B = 60122, U = 60117, H = 60129, W = 60131;
      typeof Symbol == "function" && Symbol.for && (Q = Symbol.for, s = Q("react.element"), a = Q("react.portal"), d = Q("react.fragment"), m = Q("react.strict_mode"), y = Q("react.profiler"), x = Q("react.provider"), w = Q("react.context"), T = Q("react.forward_ref"), P = Q("react.suspense"), M = Q("react.suspense_list"), F = Q("react.memo"), O = Q("react.lazy"), N = Q("react.block"), B = Q("react.server.block"), U = Q("react.fundamental"), H = Q("react.debug_trace_mode"), W = Q("react.legacy_hidden"));
      var Q;
      function ne(Se) {
        if (typeof Se == "object" && Se !== null) {
          var nt = Se.$$typeof;
          switch (nt) {
            case s:
              switch (Se = Se.type, Se) {
                case d:
                case y:
                case m:
                case P:
                case M:
                  return Se;
                default:
                  switch (Se = Se && Se.$$typeof, Se) {
                    case w:
                    case T:
                    case O:
                    case F:
                    case x:
                      return Se;
                    default:
                      return nt;
                  }
              }
            case a:
              return nt;
          }
        }
      }
      var ce = x, ue = s, se = T, Oe = d, he = O, ie = F, ye = a, Ee = y, ve = m, Xe = P;
      r.ContextConsumer = w, r.ContextProvider = ce, r.Element = ue, r.ForwardRef = se, r.Fragment = Oe, r.Lazy = he, r.Memo = ie, r.Portal = ye, r.Profiler = Ee, r.StrictMode = ve, r.Suspense = Xe, r.isAsyncMode = function() {
        return !1;
      }, r.isConcurrentMode = function() {
        return !1;
      }, r.isContextConsumer = function(Se) {
        return ne(Se) === w;
      }, r.isContextProvider = function(Se) {
        return ne(Se) === x;
      }, r.isElement = function(Se) {
        return typeof Se == "object" && Se !== null && Se.$$typeof === s;
      }, r.isForwardRef = function(Se) {
        return ne(Se) === T;
      }, r.isFragment = function(Se) {
        return ne(Se) === d;
      }, r.isLazy = function(Se) {
        return ne(Se) === O;
      }, r.isMemo = function(Se) {
        return ne(Se) === F;
      }, r.isPortal = function(Se) {
        return ne(Se) === a;
      }, r.isProfiler = function(Se) {
        return ne(Se) === y;
      }, r.isStrictMode = function(Se) {
        return ne(Se) === m;
      }, r.isSuspense = function(Se) {
        return ne(Se) === P;
      }, r.isValidElementType = function(Se) {
        return typeof Se == "string" || typeof Se == "function" || Se === d || Se === y || Se === H || Se === m || Se === P || Se === M || Se === W || typeof Se == "object" && Se !== null && (Se.$$typeof === O || Se.$$typeof === F || Se.$$typeof === x || Se.$$typeof === w || Se.$$typeof === T || Se.$$typeof === U || Se.$$typeof === N || Se[0] === B);
      }, r.typeOf = ne;
    }), Tve = J((r, s) => {
      s.exports = Eve();
    }), RG = J((r, s) => {
      s.exports = function(a, d, m, y) {
        var x = m ? m.call(y, a, d) : void 0;
        if (x !== void 0) return !!x;
        if (a === d) return !0;
        if (typeof a != "object" || !a || typeof d != "object" || !d) return !1;
        var w = Object.keys(a), T = Object.keys(d);
        if (w.length !== T.length) return !1;
        for (var P = Object.prototype.hasOwnProperty.bind(d), M = 0; M < w.length; M++) {
          var F = w[M];
          if (!P(F)) return !1;
          var O = a[F], N = d[F];
          if (x = m ? m.call(y, O, N, F) : void 0, x === !1 || x === void 0 && O !== N) return !1;
        }
        return !0;
      };
    });
    function Cve(r) {
      function s(Ae, Je, rt, Ve, oe) {
        for (var je = 0, Ge = 0, yt = 0, Nt = 0, Lt, qt, Tn = 0, dr = 0, dn, jr = dn = Lt = 0, Sn = 0, Rn = 0, ns = 0, ei = 0, Ka = rt.length, Fo = Ka - 1, rs, en = "", bn = "", bd = "", _v = "", Ya; Sn < Ka; ) {
          if (qt = rt.charCodeAt(Sn), Sn === Fo && Ge + Nt + yt + je !== 0 && (Ge !== 0 && (qt = Ge === 47 ? 10 : 47), Nt = yt = je = 0, Ka++, Fo++), Ge + Nt + yt + je === 0) {
            if (Sn === Fo && (0 < Rn && (en = en.replace(O, "")), 0 < en.trim().length)) {
              switch (qt) {
                case 32:
                case 9:
                case 59:
                case 13:
                case 10:
                  break;
                default:
                  en += rt.charAt(Sn);
              }
              qt = 59;
            }
            switch (qt) {
              case 123:
                for (en = en.trim(), Lt = en.charCodeAt(0), dn = 1, ei = ++Sn; Sn < Ka; ) {
                  switch (qt = rt.charCodeAt(Sn)) {
                    case 123:
                      dn++;
                      break;
                    case 125:
                      dn--;
                      break;
                    case 47:
                      switch (qt = rt.charCodeAt(Sn + 1)) {
                        case 42:
                        case 47:
                          e: {
                            for (jr = Sn + 1; jr < Fo; ++jr) switch (rt.charCodeAt(jr)) {
                              case 47:
                                if (qt === 42 && rt.charCodeAt(jr - 1) === 42 && Sn + 2 !== jr) {
                                  Sn = jr + 1;
                                  break e;
                                }
                                break;
                              case 10:
                                if (qt === 47) {
                                  Sn = jr + 1;
                                  break e;
                                }
                            }
                            Sn = jr;
                          }
                      }
                      break;
                    case 91:
                      qt++;
                    case 40:
                      qt++;
                    case 34:
                    case 39:
                      for (; Sn++ < Fo && rt.charCodeAt(Sn) !== qt; ) ;
                  }
                  if (dn === 0) break;
                  Sn++;
                }
                switch (dn = rt.substring(ei, Sn), Lt === 0 && (Lt = (en = en.replace(F, "").trim()).charCodeAt(0)), Lt) {
                  case 64:
                    switch (0 < Rn && (en = en.replace(O, "")), qt = en.charCodeAt(1), qt) {
                      case 100:
                      case 109:
                      case 115:
                      case 45:
                        Rn = Je;
                        break;
                      default:
                        Rn = De;
                    }
                    if (dn = s(Je, Rn, dn, qt, oe + 1), ei = dn.length, 0 < le && (Rn = a(De, en, ns), Ya = w(3, dn, Rn, Je, Xe, ve, ei, qt, oe, Ve), en = Rn.join(""), Ya !== void 0 && (ei = (dn = Ya.trim()).length) === 0 && (qt = 0, dn = "")), 0 < ei) switch (qt) {
                      case 115:
                        en = en.replace(se, x);
                      case 100:
                      case 109:
                      case 45:
                        dn = en + "{" + dn + "}";
                        break;
                      case 107:
                        en = en.replace(Q, "$1 $2"), dn = en + "{" + dn + "}", dn = nt === 1 || nt === 2 && y("@" + dn, 3) ? "@-webkit-" + dn + "@" + dn : "@" + dn;
                        break;
                      default:
                        dn = en + dn, Ve === 112 && (dn = (bn += dn, ""));
                    }
                    else dn = "";
                    break;
                  default:
                    dn = s(Je, a(Je, en, ns), dn, Ve, oe + 1);
                }
                bd += dn, dn = ns = Rn = jr = Lt = 0, en = "", qt = rt.charCodeAt(++Sn);
                break;
              case 125:
              case 59:
                if (en = (0 < Rn ? en.replace(O, "") : en).trim(), 1 < (ei = en.length)) switch (jr === 0 && (Lt = en.charCodeAt(0), Lt === 45 || 96 < Lt && 123 > Lt) && (ei = (en = en.replace(" ", ":")).length), 0 < le && (Ya = w(1, en, Je, Ae, Xe, ve, bn.length, Ve, oe, Ve)) !== void 0 && (ei = (en = Ya.trim()).length) === 0 && (en = "\0\0"), Lt = en.charCodeAt(0), qt = en.charCodeAt(1), Lt) {
                  case 0:
                    break;
                  case 64:
                    if (qt === 105 || qt === 99) {
                      _v += en + rt.charAt(Sn);
                      break;
                    }
                  default:
                    en.charCodeAt(ei - 1) !== 58 && (bn += m(en, Lt, qt, en.charCodeAt(2)));
                }
                ns = Rn = jr = Lt = 0, en = "", qt = rt.charCodeAt(++Sn);
            }
          }
          switch (qt) {
            case 13:
            case 10:
              Ge === 47 ? Ge = 0 : 1 + Lt === 0 && Ve !== 107 && 0 < en.length && (Rn = 1, en += "\0"), 0 < le * $e && w(0, en, Je, Ae, Xe, ve, bn.length, Ve, oe, Ve), ve = 1, Xe++;
              break;
            case 59:
            case 125:
              if (Ge + Nt + yt + je === 0) {
                ve++;
                break;
              }
            default:
              switch (ve++, rs = rt.charAt(Sn), qt) {
                case 9:
                case 32:
                  if (Nt + je + Ge === 0) switch (Tn) {
                    case 44:
                    case 58:
                    case 9:
                    case 32:
                      rs = "";
                      break;
                    default:
                      qt !== 32 && (rs = " ");
                  }
                  break;
                case 0:
                  rs = "\\0";
                  break;
                case 12:
                  rs = "\\f";
                  break;
                case 11:
                  rs = "\\v";
                  break;
                case 38:
                  Nt + Ge + je === 0 && (Rn = ns = 1, rs = "\f" + rs);
                  break;
                case 108:
                  if (Nt + Ge + je + Se === 0 && 0 < jr) switch (Sn - jr) {
                    case 2:
                      Tn === 112 && rt.charCodeAt(Sn - 3) === 58 && (Se = Tn);
                    case 8:
                      dr === 111 && (Se = dr);
                  }
                  break;
                case 58:
                  Nt + Ge + je === 0 && (jr = Sn);
                  break;
                case 44:
                  Ge + yt + Nt + je === 0 && (Rn = 1, rs += "\r");
                  break;
                case 34:
                case 39:
                  Ge === 0 && (Nt = Nt === qt ? 0 : Nt === 0 ? qt : Nt);
                  break;
                case 91:
                  Nt + Ge + yt === 0 && je++;
                  break;
                case 93:
                  Nt + Ge + yt === 0 && je--;
                  break;
                case 41:
                  Nt + Ge + je === 0 && yt--;
                  break;
                case 40:
                  if (Nt + Ge + je === 0) {
                    if (Lt === 0) switch (2 * Tn + 3 * dr) {
                      case 533:
                        break;
                      default:
                        Lt = 1;
                    }
                    yt++;
                  }
                  break;
                case 64:
                  Ge + yt + Nt + je + jr + dn === 0 && (dn = 1);
                  break;
                case 42:
                case 47:
                  if (!(0 < Nt + je + yt)) switch (Ge) {
                    case 0:
                      switch (2 * qt + 3 * rt.charCodeAt(Sn + 1)) {
                        case 235:
                          Ge = 47;
                          break;
                        case 220:
                          ei = Sn, Ge = 42;
                      }
                      break;
                    case 42:
                      qt === 47 && Tn === 42 && ei + 2 !== Sn && (rt.charCodeAt(ei + 2) === 33 && (bn += rt.substring(ei, Sn + 1)), rs = "", Ge = 0);
                  }
              }
              Ge === 0 && (en += rs);
          }
          dr = Tn, Tn = qt, Sn++;
        }
        if (ei = bn.length, 0 < ei) {
          if (Rn = Je, 0 < le && (Ya = w(2, bn, Rn, Ae, Xe, ve, ei, Ve, oe, Ve), Ya !== void 0 && (bn = Ya).length === 0)) return _v + bn + bd;
          if (bn = Rn.join(",") + "{" + bn + "}", nt * Se !== 0) {
            switch (nt !== 2 || y(bn, 2) || (Se = 0), Se) {
              case 111:
                bn = bn.replace(ce, ":-moz-$1") + bn;
                break;
              case 112:
                bn = bn.replace(ne, "::-webkit-input-$1") + bn.replace(ne, "::-moz-$1") + bn.replace(ne, ":-ms-input-$1") + bn;
            }
            Se = 0;
          }
        }
        return _v + bn + bd;
      }
      function a(Ae, Je, rt) {
        var Ve = Je.trim().split(H);
        Je = Ve;
        var oe = Ve.length, je = Ae.length;
        switch (je) {
          case 0:
          case 1:
            var Ge = 0;
            for (Ae = je === 0 ? "" : Ae[0] + " "; Ge < oe; ++Ge) Je[Ge] = d(Ae, Je[Ge], rt).trim();
            break;
          default:
            var yt = Ge = 0;
            for (Je = []; Ge < oe; ++Ge) for (var Nt = 0; Nt < je; ++Nt) Je[yt++] = d(Ae[Nt] + " ", Ve[Ge], rt).trim();
        }
        return Je;
      }
      function d(Ae, Je, rt) {
        var Ve = Je.charCodeAt(0);
        switch (33 > Ve && (Ve = (Je = Je.trim()).charCodeAt(0)), Ve) {
          case 38:
            return Je.replace(W, "$1" + Ae.trim());
          case 58:
            return Ae.trim() + Je.replace(W, "$1" + Ae.trim());
          default:
            if (0 < 1 * rt && 0 < Je.indexOf("\f")) return Je.replace(W, (Ae.charCodeAt(0) === 58 ? "" : "$1") + Ae.trim());
        }
        return Ae + Je;
      }
      function m(Ae, Je, rt, Ve) {
        var oe = Ae + ";", je = 2 * Je + 3 * rt + 4 * Ve;
        if (je === 944) {
          Ae = oe.indexOf(":", 9) + 1;
          var Ge = oe.substring(Ae, oe.length - 1).trim();
          return Ge = oe.substring(0, Ae).trim() + Ge + ";", nt === 1 || nt === 2 && y(Ge, 1) ? "-webkit-" + Ge + Ge : Ge;
        }
        if (nt === 0 || nt === 2 && !y(oe, 1)) return oe;
        switch (je) {
          case 1015:
            return oe.charCodeAt(10) === 97 ? "-webkit-" + oe + oe : oe;
          case 951:
            return oe.charCodeAt(3) === 116 ? "-webkit-" + oe + oe : oe;
          case 963:
            return oe.charCodeAt(5) === 110 ? "-webkit-" + oe + oe : oe;
          case 1009:
            if (oe.charCodeAt(4) !== 100) break;
          case 969:
          case 942:
            return "-webkit-" + oe + oe;
          case 978:
            return "-webkit-" + oe + "-moz-" + oe + oe;
          case 1019:
          case 983:
            return "-webkit-" + oe + "-moz-" + oe + "-ms-" + oe + oe;
          case 883:
            if (oe.charCodeAt(8) === 45) return "-webkit-" + oe + oe;
            if (0 < oe.indexOf("image-set(", 11)) return oe.replace(Ee, "$1-webkit-$2") + oe;
            break;
          case 932:
            if (oe.charCodeAt(4) === 45) switch (oe.charCodeAt(5)) {
              case 103:
                return "-webkit-box-" + oe.replace("-grow", "") + "-webkit-" + oe + "-ms-" + oe.replace("grow", "positive") + oe;
              case 115:
                return "-webkit-" + oe + "-ms-" + oe.replace("shrink", "negative") + oe;
              case 98:
                return "-webkit-" + oe + "-ms-" + oe.replace("basis", "preferred-size") + oe;
            }
            return "-webkit-" + oe + "-ms-" + oe + oe;
          case 964:
            return "-webkit-" + oe + "-ms-flex-" + oe + oe;
          case 1023:
            if (oe.charCodeAt(8) !== 99) break;
            return Ge = oe.substring(oe.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify"), "-webkit-box-pack" + Ge + "-webkit-" + oe + "-ms-flex-pack" + Ge + oe;
          case 1005:
            return B.test(oe) ? oe.replace(N, ":-webkit-") + oe.replace(N, ":-moz-") + oe : oe;
          case 1e3:
            switch (Ge = oe.substring(13).trim(), Je = Ge.indexOf("-") + 1, Ge.charCodeAt(0) + Ge.charCodeAt(Je)) {
              case 226:
                Ge = oe.replace(ue, "tb");
                break;
              case 232:
                Ge = oe.replace(ue, "tb-rl");
                break;
              case 220:
                Ge = oe.replace(ue, "lr");
                break;
              default:
                return oe;
            }
            return "-webkit-" + oe + "-ms-" + Ge + oe;
          case 1017:
            if (oe.indexOf("sticky", 9) === -1) break;
          case 975:
            switch (Je = (oe = Ae).length - 10, Ge = (oe.charCodeAt(Je) === 33 ? oe.substring(0, Je) : oe).substring(Ae.indexOf(":", 7) + 1).trim(), je = Ge.charCodeAt(0) + (Ge.charCodeAt(7) | 0)) {
              case 203:
                if (111 > Ge.charCodeAt(8)) break;
              case 115:
                oe = oe.replace(Ge, "-webkit-" + Ge) + ";" + oe;
                break;
              case 207:
              case 102:
                oe = oe.replace(Ge, "-webkit-" + (102 < je ? "inline-" : "") + "box") + ";" + oe.replace(Ge, "-webkit-" + Ge) + ";" + oe.replace(Ge, "-ms-" + Ge + "box") + ";" + oe;
            }
            return oe + ";";
          case 938:
            if (oe.charCodeAt(5) === 45) switch (oe.charCodeAt(6)) {
              case 105:
                return Ge = oe.replace("-items", ""), "-webkit-" + oe + "-webkit-box-" + Ge + "-ms-flex-" + Ge + oe;
              case 115:
                return "-webkit-" + oe + "-ms-flex-item-" + oe.replace(he, "") + oe;
              default:
                return "-webkit-" + oe + "-ms-flex-line-pack" + oe.replace("align-content", "").replace(he, "") + oe;
            }
            break;
          case 973:
          case 989:
            if (oe.charCodeAt(3) !== 45 || oe.charCodeAt(4) === 122) break;
          case 931:
          case 953:
            if (ye.test(Ae) === !0) return (Ge = Ae.substring(Ae.indexOf(":") + 1)).charCodeAt(0) === 115 ? m(Ae.replace("stretch", "fill-available"), Je, rt, Ve).replace(":fill-available", ":stretch") : oe.replace(Ge, "-webkit-" + Ge) + oe.replace(Ge, "-moz-" + Ge.replace("fill-", "")) + oe;
            break;
          case 962:
            if (oe = "-webkit-" + oe + (oe.charCodeAt(5) === 102 ? "-ms-" + oe : "") + oe, rt + Ve === 211 && oe.charCodeAt(13) === 105 && 0 < oe.indexOf("transform", 10)) return oe.substring(0, oe.indexOf(";", 27) + 1).replace(U, "$1-webkit-$2") + oe;
        }
        return oe;
      }
      function y(Ae, Je) {
        var rt = Ae.indexOf(Je === 1 ? ":" : "{"), Ve = Ae.substring(0, Je !== 3 ? rt : 10);
        return rt = Ae.substring(rt + 1, Ae.length - 1), Ie(Je !== 2 ? Ve : Ve.replace(ie, "$1"), rt, Je);
      }
      function x(Ae, Je) {
        var rt = m(Je, Je.charCodeAt(0), Je.charCodeAt(1), Je.charCodeAt(2));
        return rt !== Je + ";" ? rt.replace(Oe, " or ($1)").substring(4) : "(" + Je + ")";
      }
      function w(Ae, Je, rt, Ve, oe, je, Ge, yt, Nt, Lt) {
        for (var qt = 0, Tn = Je, dr; qt < le; ++qt) switch (dr = Ce[qt].call(M, Ae, Tn, rt, Ve, oe, je, Ge, yt, Nt, Lt)) {
          case void 0:
          case !1:
          case !0:
          case null:
            break;
          default:
            Tn = dr;
        }
        if (Tn !== Je) return Tn;
      }
      function T(Ae) {
        switch (Ae) {
          case void 0:
          case null:
            le = Ce.length = 0;
            break;
          default:
            if (typeof Ae == "function") Ce[le++] = Ae;
            else if (typeof Ae == "object") for (var Je = 0, rt = Ae.length; Je < rt; ++Je) T(Ae[Je]);
            else $e = !!Ae | 0;
        }
        return T;
      }
      function P(Ae) {
        return Ae = Ae.prefix, Ae !== void 0 && (Ie = null, Ae ? typeof Ae != "function" ? nt = 1 : (nt = 2, Ie = Ae) : nt = 0), P;
      }
      function M(Ae, Je) {
        var rt = Ae;
        if (33 > rt.charCodeAt(0) && (rt = rt.trim()), de = rt, rt = [de], 0 < le) {
          var Ve = w(-1, Je, rt, rt, Xe, ve, 0, 0, 0, 0);
          Ve !== void 0 && typeof Ve == "string" && (Je = Ve);
        }
        var oe = s(De, rt, Je, 0, 0);
        return 0 < le && (Ve = w(-2, oe, rt, rt, Xe, ve, oe.length, 0, 0, 0), Ve !== void 0 && (oe = Ve)), de = "", Se = 0, ve = Xe = 1, oe;
      }
      var F = /^\0+/g, O = /[\0\r\f]/g, N = /: */g, B = /zoo|gra/, U = /([,: ])(transform)/g, H = /,\r+?/g, W = /([\t\r\n ])*\f?&/g, Q = /@(k\w+)\s*(\S*)\s*/, ne = /::(place)/g, ce = /:(read-only)/g, ue = /[svh]\w+-[tblr]{2}/, se = /\(\s*(.*)\s*\)/g, Oe = /([\s\S]*?);/g, he = /-self|flex-/g, ie = /[^]*?(:[rp][el]a[\w-]+)[^]*/, ye = /stretch|:\s*\w+\-(?:conte|avail)/, Ee = /([^-])(image-set\()/, ve = 1, Xe = 1, Se = 0, nt = 1, De = [], Ce = [], le = 0, Ie = null, $e = 0, de = "";
      return M.use = T, M.set = P, r !== void 0 && P(r), M;
    }
    var IG, Pve = R(() => {
      IG = Cve;
    }), NG, OG, Ave = R(() => {
      NG = { animationIterationCount: 1, borderImageOutset: 1, borderImageSlice: 1, borderImageWidth: 1, boxFlex: 1, boxFlexGroup: 1, boxOrdinalGroup: 1, columnCount: 1, columns: 1, flex: 1, flexGrow: 1, flexPositive: 1, flexShrink: 1, flexNegative: 1, flexOrder: 1, gridRow: 1, gridRowEnd: 1, gridRowSpan: 1, gridRowStart: 1, gridColumn: 1, gridColumnEnd: 1, gridColumnSpan: 1, gridColumnStart: 1, msGridRow: 1, msGridRowSpan: 1, msGridColumn: 1, msGridColumnSpan: 1, fontWeight: 1, lineHeight: 1, opacity: 1, order: 1, orphans: 1, tabSize: 1, widows: 1, zIndex: 1, zoom: 1, WebkitLineClamp: 1, fillOpacity: 1, floodOpacity: 1, stopOpacity: 1, strokeDasharray: 1, strokeDashoffset: 1, strokeMiterlimit: 1, strokeOpacity: 1, strokeWidth: 1 }, OG = NG;
    });
    function kve(r) {
      var s = /* @__PURE__ */ Object.create(null);
      return function(a) {
        return s[a] === void 0 && (s[a] = r(a)), s[a];
      };
    }
    var DG, Mve = R(() => {
      DG = kve;
    }), FG, BG, eB, Rve = R(() => {
      Mve(), FG = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, BG = DG(function(r) {
        return FG.test(r) || r.charCodeAt(0) === 111 && r.charCodeAt(1) === 110 && r.charCodeAt(2) < 91;
      }), eB = BG;
    }), Ive = J((r) => {
      var s = typeof Symbol == "function" && Symbol.for, a = s ? Symbol.for("react.element") : 60103, d = s ? Symbol.for("react.portal") : 60106, m = s ? Symbol.for("react.fragment") : 60107, y = s ? Symbol.for("react.strict_mode") : 60108, x = s ? Symbol.for("react.profiler") : 60114, w = s ? Symbol.for("react.provider") : 60109, T = s ? Symbol.for("react.context") : 60110, P = s ? Symbol.for("react.async_mode") : 60111, M = s ? Symbol.for("react.concurrent_mode") : 60111, F = s ? Symbol.for("react.forward_ref") : 60112, O = s ? Symbol.for("react.suspense") : 60113, N = s ? Symbol.for("react.suspense_list") : 60120, B = s ? Symbol.for("react.memo") : 60115, U = s ? Symbol.for("react.lazy") : 60116, H = s ? Symbol.for("react.block") : 60121, W = s ? Symbol.for("react.fundamental") : 60117, Q = s ? Symbol.for("react.responder") : 60118, ne = s ? Symbol.for("react.scope") : 60119;
      function ce(se) {
        if (typeof se == "object" && se !== null) {
          var Oe = se.$$typeof;
          switch (Oe) {
            case a:
              switch (se = se.type, se) {
                case P:
                case M:
                case m:
                case x:
                case y:
                case O:
                  return se;
                default:
                  switch (se = se && se.$$typeof, se) {
                    case T:
                    case F:
                    case U:
                    case B:
                    case w:
                      return se;
                    default:
                      return Oe;
                  }
              }
            case d:
              return Oe;
          }
        }
      }
      function ue(se) {
        return ce(se) === M;
      }
      r.AsyncMode = P, r.ConcurrentMode = M, r.ContextConsumer = T, r.ContextProvider = w, r.Element = a, r.ForwardRef = F, r.Fragment = m, r.Lazy = U, r.Memo = B, r.Portal = d, r.Profiler = x, r.StrictMode = y, r.Suspense = O, r.isAsyncMode = function(se) {
        return ue(se) || ce(se) === P;
      }, r.isConcurrentMode = ue, r.isContextConsumer = function(se) {
        return ce(se) === T;
      }, r.isContextProvider = function(se) {
        return ce(se) === w;
      }, r.isElement = function(se) {
        return typeof se == "object" && se !== null && se.$$typeof === a;
      }, r.isForwardRef = function(se) {
        return ce(se) === F;
      }, r.isFragment = function(se) {
        return ce(se) === m;
      }, r.isLazy = function(se) {
        return ce(se) === U;
      }, r.isMemo = function(se) {
        return ce(se) === B;
      }, r.isPortal = function(se) {
        return ce(se) === d;
      }, r.isProfiler = function(se) {
        return ce(se) === x;
      }, r.isStrictMode = function(se) {
        return ce(se) === y;
      }, r.isSuspense = function(se) {
        return ce(se) === O;
      }, r.isValidElementType = function(se) {
        return typeof se == "string" || typeof se == "function" || se === m || se === M || se === x || se === y || se === O || se === N || typeof se == "object" && se !== null && (se.$$typeof === U || se.$$typeof === B || se.$$typeof === w || se.$$typeof === T || se.$$typeof === F || se.$$typeof === W || se.$$typeof === Q || se.$$typeof === ne || se.$$typeof === H);
      }, r.typeOf = ce;
    }), Nve = J((r, s) => {
      s.exports = Ive();
    }), Ove = J((r, s) => {
      var a = Nve(), d = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, m = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, y = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, x = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, w = {};
      w[a.ForwardRef] = y, w[a.Memo] = x;
      function T(H) {
        return a.isMemo(H) ? x : w[H.$$typeof] || d;
      }
      var P = Object.defineProperty, M = Object.getOwnPropertyNames, F = Object.getOwnPropertySymbols, O = Object.getOwnPropertyDescriptor, N = Object.getPrototypeOf, B = Object.prototype;
      function U(H, W, Q) {
        if (typeof W != "string") {
          if (B) {
            var ne = N(W);
            ne && ne !== B && U(H, ne, Q);
          }
          var ce = M(W);
          F && (ce = ce.concat(F(W)));
          for (var ue = T(H), se = T(W), Oe = 0; Oe < ce.length; ++Oe) {
            var he = ce[Oe];
            if (!m[he] && !(Q && Q[he]) && !(se && se[he]) && !(ue && ue[he])) {
              var ie = O(W, he);
              try {
                P(H, he, ie);
              } catch {
              }
            }
          }
        }
        return H;
      }
      s.exports = U;
    });
    function Cl() {
      return (Cl = Object.assign || function(r) {
        for (var s = 1; s < arguments.length; s++) {
          var a = arguments[s];
          for (var d in a) Object.prototype.hasOwnProperty.call(a, d) && (r[d] = a[d]);
        }
        return r;
      }).apply(this, arguments);
    }
    function x1(r) {
      return typeof r == "function";
    }
    function LG(r) {
      return r.displayName || r.name || "Component";
    }
    function tB(r) {
      return r && typeof r.styledComponentId == "string";
    }
    function Jc(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      throw new Error("An error occurred. See https://git.io/JUIaE#" + r + " for more information." + (a.length > 0 ? " Args: " + a.join(", ") : ""));
    }
    function nB(r) {
      var s, a = "";
      for (s = Math.abs(r); s > 52; s = s / 52 | 0) a = uB(s % 52) + a;
      return (uB(s % 52) + a).replace(l8, "$1-$2");
    }
    function jG(r) {
      for (var s = 0; s < r.length; s += 1) {
        var a = r[s];
        if (x1(a) && !tB(a)) return !1;
      }
      return !0;
    }
    function UG(r) {
      var s, a, d, m, y = r === void 0 ? ed : r, x = y.options, w = x === void 0 ? ed : x, T = y.plugins, P = T === void 0 ? _1 : T, M = new IG(w), F = [], O = /* @__PURE__ */ function(U) {
        function H(W) {
          if (W) try {
            U(W + "}");
          } catch {
          }
        }
        return function(W, Q, ne, ce, ue, se, Oe, he, ie, ye) {
          switch (W) {
            case 1:
              if (ie === 0 && Q.charCodeAt(0) === 64) return U(Q + ";"), "";
              break;
            case 2:
              if (he === 0) return Q + "/*|*/";
              break;
            case 3:
              switch (he) {
                case 102:
                case 112:
                  return U(ne[0] + Q), "";
                default:
                  return Q + (ye === 0 ? "/*|*/" : "");
              }
            case -2:
              Q.split("/*|*/}").forEach(H);
          }
        };
      }(function(U) {
        F.push(U);
      }), N = function(U, H, W) {
        return H === 0 && h8.indexOf(W[a.length]) !== -1 || W.match(m) ? U : "." + s;
      };
      function B(U, H, W, Q) {
        Q === void 0 && (Q = "&");
        var ne = U.replace(d8, ""), ce = H && W ? W + " " + H + " { " + ne + " }" : ne;
        return s = Q, a = H, d = new RegExp("\\" + a + "\\b", "g"), m = new RegExp("(\\" + a + "\\b){2,}"), M(W || !H ? "" : H, ce);
      }
      return M.use([].concat(P, [function(U, H, W) {
        U === 2 && W.length && W[0].lastIndexOf(a) > 0 && (W[0] = W[0].replace(d, N));
      }, O, function(U) {
        if (U === -2) {
          var H = F;
          return F = [], H;
        }
      }])), B.hash = P.length ? P.reduce(function(U, H) {
        return H.name || Jc(15), em(U, H.name);
      }, 5381).toString() : "", B;
    }
    function rB() {
      return (0, mi.useContext)(dk) || p8;
    }
    function zG() {
      return (0, mi.useContext)(hk) || pk;
    }
    function VG(r) {
      var s = (0, mi.useState)(r.stylisPlugins), a = s[0], d = s[1], m = rB(), y = (0, mi.useMemo)(function() {
        var w = m;
        return r.sheet ? w = r.sheet : r.target && (w = w.reconstructWithOptions({ target: r.target }, !1)), r.disableCSSOMInjection && (w = w.reconstructWithOptions({ useCSSOMInjection: !1 })), w;
      }, [r.disableCSSOMInjection, r.sheet, r.target]), x = (0, mi.useMemo)(function() {
        return UG({ options: { prefix: !r.disableVendorPrefixes }, plugins: a });
      }, [r.disableVendorPrefixes, a]);
      return (0, mi.useEffect)(function() {
        (0, WG.default)(a, r.stylisPlugins) || d(r.stylisPlugins);
      }, [r.stylisPlugins]), mi.default.createElement(dk.Provider, { value: y }, mi.default.createElement(hk.Provider, { value: x }, r.children));
    }
    function GG(r) {
      return m8.test(r) ? r.replace(g8, v8).replace(y8, "-ms-") : r;
    }
    function Jf(r, s, a, d) {
      if (Array.isArray(r)) {
        for (var m, y = [], x = 0, w = r.length; x < w; x += 1) (m = Jf(r[x], s, a, d)) !== "" && (Array.isArray(m) ? y.push.apply(y, m) : y.push(m));
        return y;
      }
      if (dB(r)) return "";
      if (tB(r)) return "." + r.styledComponentId;
      if (x1(r)) {
        if (typeof (P = r) != "function" || P.prototype && P.prototype.isReactComponent || !s) return r;
        var T = r(s);
        return Jf(T, s, a, d);
      }
      var P;
      return r instanceof f8 ? a ? (r.inject(a, d), r.getName(d)) : r : lk(r) ? function M(F, O) {
        var N, B, U = [];
        for (var H in F) F.hasOwnProperty(H) && !dB(F[H]) && (Array.isArray(F[H]) && F[H].isCss || x1(F[H]) ? U.push(GG(H) + ":", F[H], ";") : lk(F[H]) ? U.push.apply(U, M(F[H], H)) : U.push(GG(H) + ": " + (N = H, (B = F[H]) == null || typeof B == "boolean" || B === "" ? "" : typeof B != "number" || B === 0 || N in OG || N.startsWith("--") ? String(B).trim() : B + "px") + ";"));
        return O ? [O + " {"].concat(U, ["}"]) : U;
      }(r) : r.toString();
    }
    function sa(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      return x1(r) || lk(r) ? hB(Jf(oB(_1, [r].concat(a)))) : a.length === 0 && r.length === 1 && typeof r[0] == "string" ? r : hB(Jf(oB(r, a)));
    }
    function iB(r) {
      return r.replace(b8, "-").replace(x8, "");
    }
    function ak(r) {
      return typeof r == "string" && !0;
    }
    function Dve(r, s, a) {
      var d = r[a];
      fk(s) && fk(d) ? qG(d, s) : r[a] = s;
    }
    function qG(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      for (var m = 0, y = a; m < y.length; m++) {
        var x = y[m];
        if (fk(x)) for (var w in x) _8(w) && Dve(r, x[w], w);
      }
      return r;
    }
    function HG(r, s, a) {
      var d = tB(r), m = !ak(r), y = s.attrs, x = y === void 0 ? _1 : y, w = s.componentId, T = w === void 0 ? function(Q, ne) {
        var ce = typeof Q != "string" ? "sc" : iB(Q);
        gk[ce] = (gk[ce] || 0) + 1;
        var ue = ce + "-" + fB("5.3.11" + ce + gk[ce]);
        return ne ? ne + "-" + ue : ue;
      }(s.displayName, s.parentComponentId) : w, P = s.displayName, M = P === void 0 ? function(Q) {
        return ak(Q) ? "styled." + Q : "Styled(" + LG(Q) + ")";
      }(r) : P, F = s.displayName && s.componentId ? iB(s.displayName) + "-" + s.componentId : s.componentId || T, O = d && r.attrs ? Array.prototype.concat(r.attrs, x).filter(Boolean) : x, N = s.shouldForwardProp;
      d && r.shouldForwardProp && (N = s.shouldForwardProp ? function(Q, ne, ce) {
        return r.shouldForwardProp(Q, ne, ce) && s.shouldForwardProp(Q, ne, ce);
      } : r.shouldForwardProp);
      var B, U = new c8(a, F, d ? r.componentStyle : void 0), H = U.isStatic && x.length === 0, W = function(Q, ne) {
        return function(ce, ue, se, Oe) {
          var he = ce.attrs, ie = ce.componentStyle, ye = ce.defaultProps, Ee = ce.foldedComponentIds, ve = ce.shouldForwardProp, Xe = ce.styledComponentId, Se = ce.target, nt = function(Ve, oe, je) {
            Ve === void 0 && (Ve = ed);
            var Ge = Cl({}, oe, { theme: Ve }), yt = {};
            return je.forEach(function(Nt) {
              var Lt, qt, Tn, dr = Nt;
              for (Lt in x1(dr) && (dr = dr(Ge)), dr) Ge[Lt] = yt[Lt] = Lt === "className" ? (qt = yt[Lt], Tn = dr[Lt], qt && Tn ? qt + " " + Tn : qt || Tn) : dr[Lt];
            }), [Ge, yt];
          }(pB(ue, (0, mi.useContext)(mk), ye) || ed, ue, he), De = nt[0], Ce = nt[1], le = function(Ve, oe, je, Ge) {
            var yt = rB(), Nt = zG(), Lt = oe ? Ve.generateAndInjectStyles(ed, yt, Nt) : Ve.generateAndInjectStyles(je, yt, Nt);
            return Lt;
          }(ie, Oe, De), Ie = se, $e = Ce.$as || ue.$as || Ce.as || ue.as || Se, de = ak($e), Ae = Ce !== ue ? Cl({}, ue, {}, Ce) : ue, Je = {};
          for (var rt in Ae) rt[0] !== "$" && rt !== "as" && (rt === "forwardedAs" ? Je.as = Ae[rt] : (ve ? ve(rt, eB, $e) : !de || eB(rt)) && (Je[rt] = Ae[rt]));
          return ue.style && Ce.style !== ue.style && (Je.style = Cl({}, ue.style, {}, Ce.style)), Je.className = Array.prototype.concat(Ee, Xe, le !== Xe ? le : null, ue.className, Ce.className).filter(Boolean).join(" "), Je.ref = Ie, (0, mi.createElement)($e, Je);
        }(B, Q, ne, H);
      };
      return W.displayName = M, (B = mi.default.forwardRef(W)).attrs = O, B.componentStyle = U, B.displayName = M, B.shouldForwardProp = N, B.foldedComponentIds = d ? Array.prototype.concat(r.foldedComponentIds, r.styledComponentId) : _1, B.styledComponentId = F, B.target = d ? r.target : r, B.withComponent = function(Q) {
        var ne = s.componentId, ce = function(se, Oe) {
          if (se == null) return {};
          var he, ie, ye = {}, Ee = Object.keys(se);
          for (ie = 0; ie < Ee.length; ie++) he = Ee[ie], Oe.indexOf(he) >= 0 || (ye[he] = se[he]);
          return ye;
        }(s, ["componentId"]), ue = ne && ne + "-" + (ak(Q) ? Q : iB(LG(Q)));
        return HG(Q, Cl({}, ce, { attrs: O, componentId: ue }), a);
      }, Object.defineProperty(B, "defaultProps", { get: function() {
        return this._foldedDefaultProps;
      }, set: function(Q) {
        this._foldedDefaultProps = d ? qG({}, r.defaultProps, Q) : Q;
      } }), Object.defineProperty(B, "toString", { value: function() {
        return "." + B.styledComponentId;
      } }), m && (0, KG.default)(B, r, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0, withComponent: !0 }), B;
    }
    function $G(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      var m = sa.apply(void 0, [r].concat(a)), y = "sc-global-" + fB(JSON.stringify(m)), x = new S8(m, y);
      function w(P) {
        var M = rB(), F = zG(), O = (0, mi.useContext)(mk), N = (0, mi.useRef)(M.allocateGSInstance(y)).current;
        return M.server && T(N, P, M, O, F), (0, mi.useLayoutEffect)(function() {
          if (!M.server) return T(N, P, M, O, F), function() {
            return x.removeStyles(N, M);
          };
        }, [N, P, M, O, F]), null;
      }
      function T(P, M, F, O, N) {
        if (x.isStatic) x.renderStyles(P, XG, F, N);
        else {
          var B = Cl({}, M, { theme: pB(M, O, w.defaultProps) });
          x.renderStyles(P, B, F, N);
        }
      }
      return mi.default.memo(w);
    }
    var sB, mi, WG, KG, oB, lk, _1, ed, td, uk, YG, XG, QG, S1, w1, b0, E1, ZG, JG, e8, t8, n8, r8, ck, aB, i8, s8, o8, lB, a8, x0, l8, uB, em, cB, u8, c8, d8, h8, dk, hk, p8, pk, f8, m8, g8, y8, v8, dB, hB, pB, b8, x8, fB, fk, _8, mk, gk, yk, S8, ee, it = R(() => {
      sB = Y(Tve()), mi = Y(xe()), WG = Y(RG()), Pve(), Ave(), Rve(), KG = Y(Ove()), oB = function(r, s) {
        for (var a = [r[0]], d = 0, m = s.length; d < m; d += 1) a.push(s[d], r[d + 1]);
        return a;
      }, lk = function(r) {
        return r !== null && typeof r == "object" && (r.toString ? r.toString() : Object.prototype.toString.call(r)) === "[object Object]" && !(0, sB.typeOf)(r);
      }, _1 = Object.freeze([]), ed = Object.freeze({}), td = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", uk = typeof window < "u" && "HTMLElement" in window, YG = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" && process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY)), XG = {}, QG = function() {
        function r(a) {
          this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = a;
        }
        var s = r.prototype;
        return s.indexOfGroup = function(a) {
          for (var d = 0, m = 0; m < a; m++) d += this.groupSizes[m];
          return d;
        }, s.insertRules = function(a, d) {
          if (a >= this.groupSizes.length) {
            for (var m = this.groupSizes, y = m.length, x = y; a >= x; ) (x <<= 1) < 0 && Jc(16, "" + a);
            this.groupSizes = new Uint32Array(x), this.groupSizes.set(m), this.length = x;
            for (var w = y; w < x; w++) this.groupSizes[w] = 0;
          }
          for (var T = this.indexOfGroup(a + 1), P = 0, M = d.length; P < M; P++) this.tag.insertRule(T, d[P]) && (this.groupSizes[a]++, T++);
        }, s.clearGroup = function(a) {
          if (a < this.length) {
            var d = this.groupSizes[a], m = this.indexOfGroup(a), y = m + d;
            this.groupSizes[a] = 0;
            for (var x = m; x < y; x++) this.tag.deleteRule(m);
          }
        }, s.getGroup = function(a) {
          var d = "";
          if (a >= this.length || this.groupSizes[a] === 0) return d;
          for (var m = this.groupSizes[a], y = this.indexOfGroup(a), x = y + m, w = y; w < x; w++) d += this.tag.getRule(w) + `/*!sc*/
`;
          return d;
        }, r;
      }(), S1 = /* @__PURE__ */ new Map(), w1 = /* @__PURE__ */ new Map(), b0 = 1, E1 = function(r) {
        if (S1.has(r)) return S1.get(r);
        for (; w1.has(b0); ) b0++;
        var s = b0++;
        return S1.set(r, s), w1.set(s, r), s;
      }, ZG = function(r) {
        return w1.get(r);
      }, JG = function(r, s) {
        s >= b0 && (b0 = s + 1), S1.set(r, s), w1.set(s, r);
      }, e8 = "style[" + td + '][data-styled-version="5.3.11"]', t8 = new RegExp("^" + td + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'), n8 = function(r, s, a) {
        for (var d, m = a.split(","), y = 0, x = m.length; y < x; y++) (d = m[y]) && r.registerName(s, d);
      }, r8 = function(r, s) {
        for (var a = (s.textContent || "").split(`/*!sc*/
`), d = [], m = 0, y = a.length; m < y; m++) {
          var x = a[m].trim();
          if (x) {
            var w = x.match(t8);
            if (w) {
              var T = 0 | parseInt(w[1], 10), P = w[2];
              T !== 0 && (JG(P, T), n8(r, P, w[3]), r.getTag().insertRules(T, d)), d.length = 0;
            } else d.push(x);
          }
        }
      }, ck = function() {
        return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
      }, aB = function(r) {
        var s = document.head, a = r || s, d = document.createElement("style"), m = function(w) {
          for (var T = w.childNodes, P = T.length; P >= 0; P--) {
            var M = T[P];
            if (M && M.nodeType === 1 && M.hasAttribute(td)) return M;
          }
        }(a), y = m !== void 0 ? m.nextSibling : null;
        d.setAttribute(td, "active"), d.setAttribute("data-styled-version", "5.3.11");
        var x = ck();
        return x && d.setAttribute("nonce", x), a.insertBefore(d, y), d;
      }, i8 = function() {
        function r(a) {
          var d = this.element = aB(a);
          d.appendChild(document.createTextNode("")), this.sheet = function(m) {
            if (m.sheet) return m.sheet;
            for (var y = document.styleSheets, x = 0, w = y.length; x < w; x++) {
              var T = y[x];
              if (T.ownerNode === m) return T;
            }
            Jc(17);
          }(d), this.length = 0;
        }
        var s = r.prototype;
        return s.insertRule = function(a, d) {
          try {
            return this.sheet.insertRule(d, a), this.length++, !0;
          } catch {
            return !1;
          }
        }, s.deleteRule = function(a) {
          this.sheet.deleteRule(a), this.length--;
        }, s.getRule = function(a) {
          var d = this.sheet.cssRules[a];
          return d !== void 0 && typeof d.cssText == "string" ? d.cssText : "";
        }, r;
      }(), s8 = function() {
        function r(a) {
          var d = this.element = aB(a);
          this.nodes = d.childNodes, this.length = 0;
        }
        var s = r.prototype;
        return s.insertRule = function(a, d) {
          if (a <= this.length && a >= 0) {
            var m = document.createTextNode(d), y = this.nodes[a];
            return this.element.insertBefore(m, y || null), this.length++, !0;
          }
          return !1;
        }, s.deleteRule = function(a) {
          this.element.removeChild(this.nodes[a]), this.length--;
        }, s.getRule = function(a) {
          return a < this.length ? this.nodes[a].textContent : "";
        }, r;
      }(), o8 = function() {
        function r(a) {
          this.rules = [], this.length = 0;
        }
        var s = r.prototype;
        return s.insertRule = function(a, d) {
          return a <= this.length && (this.rules.splice(a, 0, d), this.length++, !0);
        }, s.deleteRule = function(a) {
          this.rules.splice(a, 1), this.length--;
        }, s.getRule = function(a) {
          return a < this.length ? this.rules[a] : "";
        }, r;
      }(), lB = uk, a8 = { isServer: !uk, useCSSOMInjection: !YG }, x0 = function() {
        function r(a, d, m) {
          a === void 0 && (a = ed), d === void 0 && (d = {}), this.options = Cl({}, a8, {}, a), this.gs = d, this.names = new Map(m), this.server = !!a.isServer, !this.server && uk && lB && (lB = !1, function(y) {
            for (var x = document.querySelectorAll(e8), w = 0, T = x.length; w < T; w++) {
              var P = x[w];
              P && P.getAttribute(td) !== "active" && (r8(y, P), P.parentNode && P.parentNode.removeChild(P));
            }
          }(this));
        }
        r.registerId = function(a) {
          return E1(a);
        };
        var s = r.prototype;
        return s.reconstructWithOptions = function(a, d) {
          return d === void 0 && (d = !0), new r(Cl({}, this.options, {}, a), this.gs, d && this.names || void 0);
        }, s.allocateGSInstance = function(a) {
          return this.gs[a] = (this.gs[a] || 0) + 1;
        }, s.getTag = function() {
          return this.tag || (this.tag = (m = (d = this.options).isServer, y = d.useCSSOMInjection, x = d.target, a = m ? new o8(x) : y ? new i8(x) : new s8(x), new QG(a)));
          var a, d, m, y, x;
        }, s.hasNameForId = function(a, d) {
          return this.names.has(a) && this.names.get(a).has(d);
        }, s.registerName = function(a, d) {
          if (E1(a), this.names.has(a)) this.names.get(a).add(d);
          else {
            var m = /* @__PURE__ */ new Set();
            m.add(d), this.names.set(a, m);
          }
        }, s.insertRules = function(a, d, m) {
          this.registerName(a, d), this.getTag().insertRules(E1(a), m);
        }, s.clearNames = function(a) {
          this.names.has(a) && this.names.get(a).clear();
        }, s.clearRules = function(a) {
          this.getTag().clearGroup(E1(a)), this.clearNames(a);
        }, s.clearTag = function() {
          this.tag = void 0;
        }, s.toString = function() {
          return function(a) {
            for (var d = a.getTag(), m = d.length, y = "", x = 0; x < m; x++) {
              var w = ZG(x);
              if (w !== void 0) {
                var T = a.names.get(w), P = d.getGroup(x);
                if (T && P && T.size) {
                  var M = td + ".g" + x + '[id="' + w + '"]', F = "";
                  T !== void 0 && T.forEach(function(O) {
                    O.length > 0 && (F += O + ",");
                  }), y += "" + P + M + '{content:"' + F + `"}/*!sc*/
`;
                }
              }
            }
            return y;
          }(this);
        }, r;
      }(), l8 = /(a)(d)/gi, uB = function(r) {
        return String.fromCharCode(r + (r > 25 ? 39 : 97));
      }, em = function(r, s) {
        for (var a = s.length; a; ) r = 33 * r ^ s.charCodeAt(--a);
        return r;
      }, cB = function(r) {
        return em(5381, r);
      }, u8 = cB("5.3.11"), c8 = function() {
        function r(s, a, d) {
          this.rules = s, this.staticRulesId = "", this.isStatic = (d === void 0 || d.isStatic) && jG(s), this.componentId = a, this.baseHash = em(u8, a), this.baseStyle = d, x0.registerId(a);
        }
        return r.prototype.generateAndInjectStyles = function(s, a, d) {
          var m = this.componentId, y = [];
          if (this.baseStyle && y.push(this.baseStyle.generateAndInjectStyles(s, a, d)), this.isStatic && !d.hash) if (this.staticRulesId && a.hasNameForId(m, this.staticRulesId)) y.push(this.staticRulesId);
          else {
            var x = Jf(this.rules, s, a, d).join(""), w = nB(em(this.baseHash, x) >>> 0);
            if (!a.hasNameForId(m, w)) {
              var T = d(x, "." + w, void 0, m);
              a.insertRules(m, w, T);
            }
            y.push(w), this.staticRulesId = w;
          }
          else {
            for (var P = this.rules.length, M = em(this.baseHash, d.hash), F = "", O = 0; O < P; O++) {
              var N = this.rules[O];
              if (typeof N == "string") F += N;
              else if (N) {
                var B = Jf(N, s, a, d), U = Array.isArray(B) ? B.join("") : B;
                M = em(M, U + O), F += U;
              }
            }
            if (F) {
              var H = nB(M >>> 0);
              if (!a.hasNameForId(m, H)) {
                var W = d(F, "." + H, void 0, m);
                a.insertRules(m, H, W);
              }
              y.push(H);
            }
          }
          return y.join(" ");
        }, r;
      }(), d8 = /^\s*\/\/.*$/gm, h8 = [":", "[", ".", "#"], dk = mi.default.createContext(), dk.Consumer, hk = mi.default.createContext(), p8 = (hk.Consumer, new x0()), pk = UG(), f8 = function() {
        function r(s, a) {
          var d = this;
          this.inject = function(m, y) {
            y === void 0 && (y = pk);
            var x = d.name + y.hash;
            m.hasNameForId(d.id, x) || m.insertRules(d.id, x, y(d.rules, x, "@keyframes"));
          }, this.toString = function() {
            return Jc(12, String(d.name));
          }, this.name = s, this.id = "sc-keyframes-" + s, this.rules = a;
        }
        return r.prototype.getName = function(s) {
          return s === void 0 && (s = pk), this.name + s.hash;
        }, r;
      }(), m8 = /([A-Z])/, g8 = /([A-Z])/g, y8 = /^ms-/, v8 = function(r) {
        return "-" + r.toLowerCase();
      }, dB = function(r) {
        return r == null || r === !1 || r === "";
      }, hB = function(r) {
        return Array.isArray(r) && (r.isCss = !0), r;
      }, pB = function(r, s, a) {
        return a === void 0 && (a = ed), r.theme !== a.theme && r.theme || s || a.theme;
      }, b8 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, x8 = /(^-|-$)/g, fB = function(r) {
        return nB(cB(r) >>> 0);
      }, fk = function(r) {
        return typeof r == "function" || typeof r == "object" && r !== null && !Array.isArray(r);
      }, _8 = function(r) {
        return r !== "__proto__" && r !== "constructor" && r !== "prototype";
      }, mk = mi.default.createContext(), mk.Consumer, gk = {}, yk = function(r) {
        return function s(a, d, m) {
          if (m === void 0 && (m = ed), !(0, sB.isValidElementType)(d)) return Jc(1, String(d));
          var y = function() {
            return a(d, m, sa.apply(void 0, arguments));
          };
          return y.withConfig = function(x) {
            return s(a, d, Cl({}, m, {}, x));
          }, y.attrs = function(x) {
            return s(a, d, Cl({}, m, { attrs: Array.prototype.concat(m.attrs, x).filter(Boolean) }));
          }, y;
        }(HG, r);
      }, ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(r) {
        yk[r] = yk(r);
      }), S8 = function() {
        function r(a, d) {
          this.rules = a, this.componentId = d, this.isStatic = jG(a), x0.registerId(this.componentId + 1);
        }
        var s = r.prototype;
        return s.createStyles = function(a, d, m, y) {
          var x = y(Jf(this.rules, d, m, y).join(""), ""), w = this.componentId + a;
          m.insertRules(w, w, x);
        }, s.removeStyles = function(a, d) {
          d.clearRules(this.componentId + a);
        }, s.renderStyles = function(a, d, m, y) {
          a > 2 && x0.registerId(this.componentId + a), this.removeStyles(a, m), this.createStyles(a, d, m, y);
        }, r;
      }(), function() {
        function r() {
          var a = this;
          this._emitSheetCSS = function() {
            var d = a.instance.toString();
            if (!d) return "";
            var m = ck();
            return "<style " + [m && 'nonce="' + m + '"', td + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + d + "</style>";
          }, this.getStyleTags = function() {
            return a.sealed ? Jc(2) : a._emitSheetCSS();
          }, this.getStyleElement = function() {
            var d;
            if (a.sealed) return Jc(2);
            var m = ((d = {})[td] = "", d["data-styled-version"] = "5.3.11", d.dangerouslySetInnerHTML = { __html: a.instance.toString() }, d), y = ck();
            return y && (m.nonce = y), [mi.default.createElement("style", Cl({}, m, { key: "sc-0-0" }))];
          }, this.seal = function() {
            a.sealed = !0;
          }, this.instance = new x0({ isServer: !0 }), this.sealed = !1;
        }
        var s = r.prototype;
        return s.collectStyles = function(a) {
          return this.sealed ? Jc(2) : mi.default.createElement(VG, { sheet: this.instance }, a);
        }, s.interleaveWithNodeStream = function(a) {
          return Jc(3);
        }, r;
      }(), ee = yk;
    });
    function tm() {
      return tm = Object.assign || function(r) {
        for (var s = 1; s < arguments.length; s++) {
          var a = arguments[s];
          for (var d in a) Object.prototype.hasOwnProperty.call(a, d) && (r[d] = a[d]);
        }
        return r;
      }, tm.apply(this, arguments);
    }
    var Fve = R(() => {
    });
    function Bve(r) {
      if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return r;
    }
    var Lve = R(() => {
    });
    function T1(r, s) {
      return T1 = Object.setPrototypeOf || function(a, d) {
        return a.__proto__ = d, a;
      }, T1(r, s);
    }
    var mB = R(() => {
    });
    function jve(r, s) {
      r.prototype = Object.create(s.prototype), r.prototype.constructor = r, T1(r, s);
    }
    var Uve = R(() => {
      mB();
    });
    function gB(r) {
      return gB = Object.setPrototypeOf ? Object.getPrototypeOf : function(s) {
        return s.__proto__ || Object.getPrototypeOf(s);
      }, gB(r);
    }
    var zve = R(() => {
    });
    function Vve(r) {
      return Function.toString.call(r).indexOf("[native code]") !== -1;
    }
    var Gve = R(() => {
    });
    function qve() {
      if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
      if (typeof Proxy == "function") return !0;
      try {
        return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        })), !0;
      } catch {
        return !1;
      }
    }
    var Hve = R(() => {
    });
    function vk(r, s, a) {
      return qve() ? vk = Reflect.construct : vk = function(d, m, y) {
        var x = [null];
        x.push.apply(x, m);
        var w = Function.bind.apply(d, x), T = new w();
        return y && T1(T, y.prototype), T;
      }, vk.apply(null, arguments);
    }
    var $ve = R(() => {
      mB(), Hve();
    });
    function yB(r) {
      var s = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
      return yB = function(a) {
        if (a === null || !Vve(a)) return a;
        if (typeof a != "function") throw new TypeError("Super expression must either be null or a function");
        if (typeof s < "u") {
          if (s.has(a)) return s.get(a);
          s.set(a, d);
        }
        function d() {
          return vk(a, arguments, gB(this).constructor);
        }
        return d.prototype = Object.create(a.prototype, { constructor: { value: d, enumerable: !1, writable: !0, configurable: !0 } }), T1(d, a);
      }, yB(r);
    }
    var Wve = R(() => {
      zve(), mB(), Gve(), $ve();
    }), Kve = R(() => {
    });
    function Yve(r) {
      return r.charAt(0).toUpperCase() + r.slice(1);
    }
    function Xve(r, s) {
      if (!r) return s.toLowerCase();
      var a = r.split("-");
      if (a.length > 1) return a.splice(1, 0, s), a.reduce(function(m, y) {
        return "" + m + Yve(y);
      });
      var d = r.replace(/([a-z])([A-Z])/g, "$1" + s + "$2");
      return r === d ? "" + r + s : d;
    }
    function Qve(r, s) {
      for (var a = {}, d = 0; d < s.length; d += 1) (s[d] || s[d] === 0) && (a[Xve(r, k8[d])] = s[d]);
      return a;
    }
    function w8(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      var m = a[0], y = a[1], x = y === void 0 ? m : y, w = a[2], T = w === void 0 ? m : w, P = a[3], M = P === void 0 ? x : P, F = [m, x, T, M];
      return Qve(r, F);
    }
    function vB(r) {
      return Math.round(r * 255);
    }
    function Zve(r, s, a) {
      return vB(r) + "," + vB(s) + "," + vB(a);
    }
    function bk(r, s, a, d) {
      if (d === void 0 && (d = Zve), s === 0) return d(a, a, a);
      var m = (r % 360 + 360) % 360 / 60, y = (1 - Math.abs(2 * a - 1)) * s, x = y * (1 - Math.abs(m % 2 - 1)), w = 0, T = 0, P = 0;
      m >= 0 && m < 1 ? (w = y, T = x) : m >= 1 && m < 2 ? (w = x, T = y) : m >= 2 && m < 3 ? (T = y, P = x) : m >= 3 && m < 4 ? (T = x, P = y) : m >= 4 && m < 5 ? (w = x, P = y) : m >= 5 && m < 6 && (w = y, P = x);
      var M = a - y / 2, F = w + M, O = T + M, N = P + M;
      return d(F, O, N);
    }
    function Jve(r) {
      if (typeof r != "string") return r;
      var s = r.toLowerCase();
      return wB[s] ? "#" + wB[s] : r;
    }
    function E8(r) {
      if (typeof r != "string") throw new Pl(3);
      var s = Jve(r);
      if (s.match(M8)) return { red: parseInt("" + s[1] + s[2], 16), green: parseInt("" + s[3] + s[4], 16), blue: parseInt("" + s[5] + s[6], 16) };
      if (s.match(R8)) {
        var a = parseFloat((parseInt("" + s[7] + s[8], 16) / 255).toFixed(2));
        return { red: parseInt("" + s[1] + s[2], 16), green: parseInt("" + s[3] + s[4], 16), blue: parseInt("" + s[5] + s[6], 16), alpha: a };
      }
      if (s.match(I8)) return { red: parseInt("" + s[1] + s[1], 16), green: parseInt("" + s[2] + s[2], 16), blue: parseInt("" + s[3] + s[3], 16) };
      if (s.match(N8)) {
        var d = parseFloat((parseInt("" + s[4] + s[4], 16) / 255).toFixed(2));
        return { red: parseInt("" + s[1] + s[1], 16), green: parseInt("" + s[2] + s[2], 16), blue: parseInt("" + s[3] + s[3], 16), alpha: d };
      }
      var m = Sk.exec(s);
      if (m) return { red: parseInt("" + m[1], 10), green: parseInt("" + m[2], 10), blue: parseInt("" + m[3], 10) };
      var y = O8.exec(s.substring(0, 50));
      if (y) return { red: parseInt("" + y[1], 10), green: parseInt("" + y[2], 10), blue: parseInt("" + y[3], 10), alpha: parseFloat("" + y[4]) };
      var x = D8.exec(s);
      if (x) {
        var w = parseInt("" + x[1], 10), T = parseInt("" + x[2], 10) / 100, P = parseInt("" + x[3], 10) / 100, M = "rgb(" + bk(w, T, P) + ")", F = Sk.exec(M);
        if (!F) throw new Pl(4, s, M);
        return { red: parseInt("" + F[1], 10), green: parseInt("" + F[2], 10), blue: parseInt("" + F[3], 10) };
      }
      var O = F8.exec(s.substring(0, 50));
      if (O) {
        var N = parseInt("" + O[1], 10), B = parseInt("" + O[2], 10) / 100, U = parseInt("" + O[3], 10) / 100, H = "rgb(" + bk(N, B, U) + ")", W = Sk.exec(H);
        if (!W) throw new Pl(4, s, H);
        return { red: parseInt("" + W[1], 10), green: parseInt("" + W[2], 10), blue: parseInt("" + W[3], 10), alpha: parseFloat("" + O[4]) };
      }
      throw new Pl(5);
    }
    function ebe(r) {
      var s = r.red / 255, a = r.green / 255, d = r.blue / 255, m = Math.max(s, a, d), y = Math.min(s, a, d), x = (m + y) / 2;
      if (m === y) return r.alpha !== void 0 ? { hue: 0, saturation: 0, lightness: x, alpha: r.alpha } : { hue: 0, saturation: 0, lightness: x };
      var w, T = m - y, P = x > 0.5 ? T / (2 - m - y) : T / (m + y);
      switch (m) {
        case s:
          w = (a - d) / T + (a < d ? 6 : 0);
          break;
        case a:
          w = (d - s) / T + 2;
          break;
        default:
          w = (s - a) / T + 4;
          break;
      }
      return w *= 60, r.alpha !== void 0 ? { hue: w, saturation: P, lightness: x, alpha: r.alpha } : { hue: w, saturation: P, lightness: x };
    }
    function bB(r) {
      return ebe(E8(r));
    }
    function nm(r) {
      var s = r.toString(16);
      return s.length === 1 ? "0" + s : s;
    }
    function xB(r) {
      return nm(Math.round(r * 255));
    }
    function tbe(r, s, a) {
      return wk("#" + xB(r) + xB(s) + xB(a));
    }
    function T8(r, s, a) {
      return bk(r, s, a, tbe);
    }
    function nbe(r, s, a) {
      if (typeof r == "object" && s === void 0 && a === void 0) return T8(r.hue, r.saturation, r.lightness);
      throw new Pl(1);
    }
    function rbe(r, s, a, d) {
      if (typeof r == "object" && s === void 0 && a === void 0 && d === void 0) return r.alpha >= 1 ? T8(r.hue, r.saturation, r.lightness) : "rgba(" + bk(r.hue, r.saturation, r.lightness) + "," + r.alpha + ")";
      throw new Pl(2);
    }
    function C8(r, s, a) {
      if (typeof r == "number" && typeof s == "number" && typeof a == "number") return wk("#" + nm(r) + nm(s) + nm(a));
      if (typeof r == "object" && s === void 0 && a === void 0) return wk("#" + nm(r.red) + nm(r.green) + nm(r.blue));
      throw new Pl(6);
    }
    function P8(r, s, a, d) {
      if (typeof r == "object" && s === void 0 && a === void 0 && d === void 0) return r.alpha >= 1 ? C8(r.red, r.green, r.blue) : "rgba(" + r.red + "," + r.green + "," + r.blue + "," + r.alpha + ")";
      throw new Pl(7);
    }
    function _B(r) {
      if (typeof r != "object") throw new Pl(8);
      if (L8(r)) return P8(r);
      if (B8(r)) return C8(r);
      if (U8(r)) return rbe(r);
      if (j8(r)) return nbe(r);
      throw new Pl(8);
    }
    function A8(r, s, a) {
      return function() {
        var d = a.concat(Array.prototype.slice.call(arguments));
        return d.length >= s ? r.apply(this, d) : A8(r, s, d);
      };
    }
    function xk(r) {
      return A8(r, r.length, []);
    }
    function _k(r, s, a) {
      return Math.max(r, Math.min(s, a));
    }
    function ibe(r, s) {
      if (s === "transparent") return s;
      var a = bB(s);
      return _B(tm({}, a, { lightness: _k(0, 1, a.lightness - parseFloat(r)) }));
    }
    function sbe(r, s) {
      if (s === "transparent") return s;
      var a = bB(s);
      return _B(tm({}, a, { lightness: _k(0, 1, a.lightness + parseFloat(r)) }));
    }
    function obe(r, s) {
      if (s === "transparent") return s;
      var a = bB(s);
      return _B(tm({}, a, { saturation: _k(0, 1, a.saturation + parseFloat(r)) }));
    }
    function abe(r, s) {
      if (s === "transparent") return s;
      var a = E8(s), d = typeof a.alpha == "number" ? a.alpha : 1, m = tm({}, a, { alpha: _k(0, 1, +(d * 100 - parseFloat(r) * 100).toFixed(2) / 100) });
      return P8(m);
    }
    function SB(r) {
      for (var s = arguments.length, a = new Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      return z8.indexOf(r) >= 0 && r ? tm({}, w8.apply(void 0, [""].concat(a)), { position: r }) : w8.apply(void 0, ["", r].concat(a));
    }
    var Pl, k8, wB, M8, R8, I8, N8, Sk, O8, D8, F8, wk, B8, L8, j8, U8, EB, _0, Ek, Uu, z8, Al = R(() => {
      Fve(), Lve(), Uve(), Wve(), Kve(), Pl = function(r) {
        jve(s, r);
        function s(a) {
          var d;
          return d = r.call(this, "An error occurred. See https://github.com/styled-components/polished/blob/main/src/internalHelpers/errors.md#" + a + " for more information.") || this, Bve(d);
        }
        return s;
      }(yB(Error)), k8 = ["Top", "Right", "Bottom", "Left"], wB = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "639", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, M8 = /^#[a-fA-F0-9]{6}$/, R8 = /^#[a-fA-F0-9]{8}$/, I8 = /^#[a-fA-F0-9]{3}$/, N8 = /^#[a-fA-F0-9]{4}$/, Sk = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/i, O8 = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, D8 = /^hsl\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*\)$/i, F8 = /^hsla\(\s*(\d{0,3}[.]?[0-9]+)\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*(\d{1,3}[.]?[0-9]?)%\s*,\s*([-+]?[0-9]*[.]?[0-9]+)\s*\)$/i, wk = function(r) {
        return r.length === 7 && r[1] === r[2] && r[3] === r[4] && r[5] === r[6] ? "#" + r[1] + r[3] + r[5] : r;
      }, B8 = function(r) {
        return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
      }, L8 = function(r) {
        return typeof r.red == "number" && typeof r.green == "number" && typeof r.blue == "number" && typeof r.alpha == "number";
      }, j8 = function(r) {
        return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && (typeof r.alpha != "number" || typeof r.alpha > "u");
      }, U8 = function(r) {
        return typeof r.hue == "number" && typeof r.saturation == "number" && typeof r.lightness == "number" && typeof r.alpha == "number";
      }, EB = xk(ibe), _0 = xk(sbe), Ek = xk(obe), Uu = xk(abe), z8 = ["absolute", "fixed", "relative", "static", "sticky"];
    });
    function lbe(r, s, a) {
      return s in r ? Object.defineProperty(r, s, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : r[s] = a, r;
    }
    function V8(r, s) {
      var a = Object.keys(r);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(r);
        s && (d = d.filter(function(m) {
          return Object.getOwnPropertyDescriptor(r, m).enumerable;
        })), a.push.apply(a, d);
      }
      return a;
    }
    function rm(r) {
      for (var s = 1; s < arguments.length; s++) {
        var a = arguments[s] != null ? arguments[s] : {};
        s % 2 ? V8(Object(a), !0).forEach(function(d) {
          lbe(r, d, a[d]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(a)) : V8(Object(a)).forEach(function(d) {
          Object.defineProperty(r, d, Object.getOwnPropertyDescriptor(a, d));
        });
      }
      return r;
    }
    function S0(r, s) {
      if (r == null) return {};
      var a = {}, d = Object.keys(r), m, y;
      for (y = 0; y < d.length; y++) m = d[y], !(s.indexOf(m) >= 0) && (a[m] = r[m]);
      return a;
    }
    var C1 = R(() => {
    }), G8, TB, q8 = R(() => {
      G8 = Y(xe()), TB = (0, G8.createContext)({});
    });
    function ube(r, s, a) {
      return s in r ? Object.defineProperty(r, s, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : r[s] = a, r;
    }
    function H8(r, s) {
      var a = Object.keys(r);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(r);
        s && (d = d.filter(function(m) {
          return Object.getOwnPropertyDescriptor(r, m).enumerable;
        })), a.push.apply(a, d);
      }
      return a;
    }
    function w0(r) {
      for (var s = 1; s < arguments.length; s++) {
        var a = arguments[s] != null ? arguments[s] : {};
        s % 2 ? H8(Object(a), !0).forEach(function(d) {
          ube(r, d, a[d]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(a)) : H8(Object(a)).forEach(function(d) {
          Object.defineProperty(r, d, Object.getOwnPropertyDescriptor(a, d));
        });
      }
      return r;
    }
    function CB(r, s) {
      if (r == null) return {};
      var a = {}, d = Object.keys(r), m, y;
      for (y = 0; y < d.length; y++) m = d[y], !(s.indexOf(m) >= 0) && (a[m] = r[m]);
      return a;
    }
    function cbe(r, s) {
      if (r) {
        if (typeof r == "string") return $8(r, s);
        var a = Object.prototype.toString.call(r).slice(8, -1);
        if (a === "Object" && r.constructor && (a = r.constructor.name), a === "Map" || a === "Set") return Array.from(r);
        if (a === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(a)) return $8(r, s);
      }
    }
    function $8(r, s) {
      (s == null || s > r.length) && (s = r.length);
      for (var a = 0, d = new Array(s); a < s; a++) d[a] = r[a];
      return d;
    }
    function W8(r, s) {
      var a;
      if (typeof Symbol > "u" || r[Symbol.iterator] == null) {
        if (Array.isArray(r) || (a = cbe(r)) || s) {
          a && (r = a);
          var d = 0;
          return function() {
            return d >= r.length ? { done: !0 } : { done: !1, value: r[d++] };
          };
        }
        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
      }
      return a = r[Symbol.iterator](), a.next.bind(a);
    }
    var Tk = R(() => {
    });
    function dbe(r) {
      return typeof r == "function";
    }
    var PB, K8, hbe = R(() => {
      PB = Y(xe()), q8(), Tk(), K8 = function(r, s, a) {
        a === void 0 && (a = s.children);
        var d = (0, PB.useContext)(TB);
        if (d.useCreateElement) return d.useCreateElement(r, s, a);
        if (typeof r == "string" && dbe(a)) {
          s.children;
          var m = CB(s, ["children"]);
          return a(m);
        }
        return (0, PB.createElement)(r, s, a);
      };
    });
    function pbe(r, s, a) {
      return s in r ? Object.defineProperty(r, s, { value: a, enumerable: !0, configurable: !0, writable: !0 }) : r[s] = a, r;
    }
    function Y8(r, s) {
      var a = Object.keys(r);
      if (Object.getOwnPropertySymbols) {
        var d = Object.getOwnPropertySymbols(r);
        s && (d = d.filter(function(m) {
          return Object.getOwnPropertyDescriptor(r, m).enumerable;
        })), a.push.apply(a, d);
      }
      return a;
    }
    function E0(r) {
      for (var s = 1; s < arguments.length; s++) {
        var a = arguments[s] != null ? arguments[s] : {};
        s % 2 ? Y8(Object(a), !0).forEach(function(d) {
          pbe(r, d, a[d]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(r, Object.getOwnPropertyDescriptors(a)) : Y8(Object(a)).forEach(function(d) {
          Object.defineProperty(r, d, Object.getOwnPropertyDescriptor(a, d));
        });
      }
      return r;
    }
    function fbe(r, s) {
      if (r == null) return {};
      var a = {}, d = Object.keys(r), m, y;
      for (y = 0; y < d.length; y++) m = d[y], !(s.indexOf(m) >= 0) && (a[m] = r[m]);
      return a;
    }
    var X8 = R(() => {
    });
    function mbe(r) {
      return typeof r == "object" && r != null;
    }
    var gbe = R(() => {
    });
    function AB(r) {
      var s;
      if (!mbe(r)) return !1;
      var a = Object.getPrototypeOf(r);
      return a == null ? !0 : ((s = a.constructor) === null || s === void 0 ? void 0 : s.toString()) === Object.toString();
    }
    var Q8 = R(() => {
      gbe();
    });
    function Z8(r, s) {
      for (var a = Object.keys(r), d = {}, m = {}, y = 0, x = a; y < x.length; y++) {
        var w = x[y];
        s.indexOf(w) >= 0 ? d[w] = r[w] : m[w] = r[w];
      }
      return [d, m];
    }
    function J8(r, s) {
      if (s === void 0 && (s = []), !AB(r.state)) return Z8(r, s);
      var a = Z8(r, [].concat(s, ["state"])), d = a[0], m = a[1], y = d.state, x = fbe(d, ["state"]);
      return [E0(E0({}, y), x), m];
    }
    var ybe = R(() => {
      X8(), Q8();
    });
    function Ck(r, s) {
      if (r === s) return !0;
      if (!r || !s || typeof r != "object" || typeof s != "object") return !1;
      var a = Object.keys(r), d = Object.keys(s), m = a.length;
      if (d.length !== m) return !1;
      for (var y = 0, x = a; y < x.length; y++) {
        var w = x[y];
        if (r[w] !== s[w]) return !1;
      }
      return !0;
    }
    var kB = R(() => {
    });
    function eq(r) {
      return r.name === "normalizePropsAreEqualInner" ? r : function(s, a) {
        return !AB(s.state) || !AB(a.state) ? r(s, a) : r(E0(E0({}, s.state), s), E0(E0({}, a.state), a));
      };
    }
    var vbe = R(() => {
      X8(), Q8();
    });
    function bbe(r) {
      return (0, MB.forwardRef)(r);
    }
    function xbe(r, s) {
      return (0, MB.memo)(r, s);
    }
    function P1(r) {
      var s = r.as, a = r.useHook, d = r.memo, m = r.propsAreEqual, y = m === void 0 ? a?.unstable_propsAreEqual : m, x = r.keys, w = x === void 0 ? a?.__keys || [] : x, T = r.useCreateElement, P = T === void 0 ? K8 : T, M = function(F, O) {
        var N = F.as, B = N === void 0 ? s : N, U = CB(F, ["as"]);
        if (a) {
          var H, W = J8(U, w), Q = W[0], ne = W[1], ce = a(Q, w0({ ref: O }, ne)), ue = ce.wrapElement, se = CB(ce, ["wrapElement"]), Oe = ((H = B.render) === null || H === void 0 ? void 0 : H.__keys) || B.__keys, he = Oe && J8(U, Oe)[0], ie = he ? w0(w0({}, se), he) : se, ye = P(B, ie);
          return ue ? ue(ye) : ye;
        }
        return P(B, w0({ ref: O }, U));
      };
      return M = bbe(M), d && (M = xbe(M, y && eq(y))), M.__keys = w, M.unstable_propsAreEqual = eq(y || Ck), M;
    }
    var MB, A1 = R(() => {
      MB = Y(xe()), Tk(), hbe(), ybe(), kB(), vbe();
    });
    function tq(r, s) {
      (0, RB.useDebugValue)(r);
      var a = (0, RB.useContext)(TB);
      return a[r] != null ? a[r] : s;
    }
    var RB, nq = R(() => {
      RB = Y(xe()), q8();
    });
    function _be(r, s, a) {
      s === void 0 && (s = {}), a === void 0 && (a = {});
      var d = "use" + r + "Props";
      (0, rq.useDebugValue)(d);
      var m = tq(d);
      return m ? m(s, a) : a;
    }
    var rq, Sbe = R(() => {
      rq = Y(xe()), nq();
    });
    function wbe(r, s, a) {
      s === void 0 && (s = {}), a === void 0 && (a = {});
      var d = "use" + r + "Options";
      (0, iq.useDebugValue)(d);
      var m = tq(d);
      return m ? w0(w0({}, s), m(s, a)) : s;
    }
    var iq, Ebe = R(() => {
      iq = Y(xe()), nq(), Tk();
    });
    function Tbe(r) {
      return Array.isArray(r) ? r : typeof r < "u" ? [r] : [];
    }
    var Cbe = R(() => {
    });
    function k1(r) {
      var s, a, d = Tbe(r.compose), m = function(w, T) {
        if (r.useOptions && (w = r.useOptions(w, T)), r.name && (w = wbe(r.name, w, T)), r.compose) for (var P = W8(d), M; !(M = P()).done; ) {
          var F = M.value;
          w = F.__useOptions(w, T);
        }
        return w;
      }, y = function(w, T, P) {
        if (w === void 0 && (w = {}), T === void 0 && (T = {}), P === void 0 && (P = !1), P || (w = m(w, T)), r.useProps && (T = r.useProps(w, T)), r.name && (T = _be(r.name, w, T)), r.compose) if (r.useComposeOptions && (w = r.useComposeOptions(w, T)), r.useComposeProps) T = r.useComposeProps(w, T);
        else for (var M = W8(d), F; !(F = M()).done; ) {
          var O = F.value;
          T = O(w, T, !0);
        }
        var N = {}, B = T || {};
        for (var U in B) B[U] !== void 0 && (N[U] = B[U]);
        return N;
      };
      y.__useOptions = m;
      var x = d.reduce(function(w, T) {
        return w.push.apply(w, T.__keys || []), w;
      }, []);
      return y.__keys = [].concat(x, ((s = r.useState) === null || s === void 0 ? void 0 : s.__keys) || [], r.keys || []), y.unstable_propsAreEqual = r.propsAreEqual || ((a = d[0]) === null || a === void 0 ? void 0 : a.unstable_propsAreEqual) || Ck, y;
    }
    var M1 = R(() => {
      Y(xe()), Sbe(), Tk(), Ebe(), kB(), Cbe();
    });
    function sq(r, s) {
      s === void 0 && (s = null), r && (typeof r == "function" ? r(s) : r.current = s);
    }
    function oq(r, s) {
      return (0, aq.useMemo)(function() {
        return r == null && s == null ? null : function(a) {
          sq(r, a), sq(s, a);
        };
      }, [r, s]);
    }
    var aq, lq = R(() => {
      aq = Y(xe());
    });
    function IB(r) {
      if (r.tagName === "BUTTON") return !0;
      if (r.tagName === "INPUT") {
        var s = r;
        return uq.indexOf(s.type) !== -1;
      }
      return !1;
    }
    var uq, NB = R(() => {
      uq = ["button", "color", "file", "image", "reset", "submit"];
    }), OB = R(() => {
    }), Pbe = R(() => {
      OB(), Y(xe());
    }), Pk = R(() => {
      OB(), Y(xe()), Pbe();
    });
    function Abe(r) {
      return r ? r.ownerDocument || r : document;
    }
    var cq = R(() => {
    });
    function kbe(r) {
      return dq;
    }
    var dq, Mbe = R(() => {
      cq();
      try {
        dq = window;
      } catch {
      }
    });
    function Rbe() {
      var r = kbe();
      return !!(typeof r < "u" && r.document && r.document.createElement);
    }
    var Ak, DB = R(() => {
      Mbe(), Ak = Rbe();
    }), FB, BB, LB = R(() => {
      FB = Y(xe()), DB(), BB = Ak ? FB.useLayoutEffect : FB.useEffect;
    });
    function T0(r) {
      var s = (0, hq.useRef)(r);
      return BB(function() {
        s.current = r;
      }), s;
    }
    var hq, pq = R(() => {
      hq = Y(xe()), LB();
    });
    function Ibe(r) {
      return r.target === r.currentTarget;
    }
    var Nbe = R(() => {
    });
    function Obe(r) {
      var s = Abe(r), a = s.activeElement;
      return a != null && a.nodeName ? a : null;
    }
    var Dbe = R(() => {
      cq();
    });
    function fq(r, s) {
      return r === s || r.contains(s);
    }
    var mq = R(() => {
    });
    function Fbe(r) {
      var s = Obe(r);
      if (!s) return !1;
      if (fq(r, s)) return !0;
      var a = s.getAttribute("aria-activedescendant");
      return a ? a === r.id ? !0 : !!r.querySelector("#" + a) : !1;
    }
    var Bbe = R(() => {
      Dbe(), mq();
    });
    function Lbe(r) {
      return !fq(r.currentTarget, r.target);
    }
    var jbe = R(() => {
      mq();
    });
    function kk(r) {
      return Ak ? window.navigator.userAgent.indexOf(r) !== -1 : !1;
    }
    var Ube = R(() => {
      DB();
    });
    function zbe(r, s) {
      return "matches" in r ? r.matches(s) : "msMatchesSelector" in r ? r.msMatchesSelector(s) : r.webkitMatchesSelector(s);
    }
    var Vbe = R(() => {
    });
    function Gbe(r) {
      var s = r;
      return s.offsetWidth > 0 || s.offsetHeight > 0 || r.getClientRects().length > 0;
    }
    function qbe(r) {
      return zbe(r, gq) && Gbe(r);
    }
    var gq, Hbe = R(() => {
      Vbe(), gq = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false'])";
    }), yq, Mk, vq = R(() => {
      C1(), A1(), M1(), kB(), yq = ["unstable_system"], Mk = k1({ name: "Role", keys: yq, propsAreEqual: function(r, s) {
        var a = r.unstable_system, d = S0(r, ["unstable_system"]), m = s.unstable_system, y = S0(s, ["unstable_system"]);
        return a !== m && !Ck(a, m) ? !1 : Ck(d, y);
      } }), P1({ as: "div", useHook: Mk });
    });
    function bq(r) {
      !Fbe(r) && qbe(r) && r.focus();
    }
    function $be(r) {
      return r.tagName === "BUTTON" || r.tagName === "INPUT" || r.tagName === "SELECT" || r.tagName === "TEXTAREA" || r.tagName === "A";
    }
    function Wbe(r) {
      return r.tagName === "BUTTON" || r.tagName === "INPUT" || r.tagName === "SELECT" || r.tagName === "TEXTAREA";
    }
    function Kbe(r, s, a, d) {
      return r ? s && !a ? -1 : void 0 : s ? d : d || 0;
    }
    function jB(r, s) {
      return (0, C0.useCallback)(function(a) {
        var d;
        (d = r.current) === null || d === void 0 || d.call(r, a), !a.defaultPrevented && s && (a.stopPropagation(), a.preventDefault());
      }, [r, s]);
    }
    var C0, xq, _q, UB, Ybe = R(() => {
      C1(), A1(), M1(), C0 = Y(xe()), lq(), NB(), Pk(), pq(), LB(), Bbe(), jbe(), Ube(), Hbe(), vq(), xq = ["disabled", "focusable"], _q = kk("Mac") && !kk("Chrome") && (kk("Safari") || kk("Firefox")), UB = k1({ name: "Tabbable", compose: Mk, keys: xq, useOptions: function(r, s) {
        var a = s.disabled;
        return rm({ disabled: a }, r);
      }, useProps: function(r, s) {
        var a = s.ref, d = s.tabIndex, m = s.onClickCapture, y = s.onMouseDownCapture, x = s.onMouseDown, w = s.onKeyPressCapture, T = s.style, P = S0(s, ["ref", "tabIndex", "onClickCapture", "onMouseDownCapture", "onMouseDown", "onKeyPressCapture", "style"]), M = (0, C0.useRef)(null), F = T0(m), O = T0(y), N = T0(x), B = T0(w), U = !!r.disabled && !r.focusable, H = (0, C0.useState)(!0), W = H[0], Q = H[1], ne = (0, C0.useState)(!0), ce = ne[0], ue = ne[1], se = r.disabled ? rm({ pointerEvents: "none" }, T) : T;
        BB(function() {
          var Ee = M.current;
          Ee && ($be(Ee) || Q(!1), Wbe(Ee) || ue(!1));
        }, []);
        var Oe = jB(F, r.disabled), he = jB(O, r.disabled), ie = jB(B, r.disabled), ye = (0, C0.useCallback)(function(Ee) {
          var ve;
          (ve = N.current) === null || ve === void 0 || ve.call(N, Ee);
          var Xe = Ee.currentTarget;
          if (!Ee.defaultPrevented && _q && !Lbe(Ee) && IB(Xe)) {
            var Se = requestAnimationFrame(function() {
              Xe.removeEventListener("mouseup", nt, !0), bq(Xe);
            }), nt = function() {
              cancelAnimationFrame(Se), bq(Xe);
            };
            Xe.addEventListener("mouseup", nt, { once: !0, capture: !0 });
          }
        }, []);
        return rm({ ref: oq(M, a), style: se, tabIndex: Kbe(U, W, ce, d), disabled: U && ce ? !0 : void 0, "aria-disabled": r.disabled ? !0 : void 0, onClickCapture: Oe, onMouseDownCapture: he, onMouseDown: ye, onKeyPressCapture: ie }, P);
      } }), P1({ as: "div", useHook: UB });
    });
    function Xbe(r) {
      var s = r.currentTarget;
      return r.isTrusted ? IB(s) || s.tagName === "INPUT" || s.tagName === "TEXTAREA" || s.tagName === "A" || s.tagName === "SELECT" : !1;
    }
    var Rk, Sq, zB, Qbe = R(() => {
      C1(), A1(), M1(), Rk = Y(xe()), NB(), Pk(), pq(), Nbe(), Ybe(), Sq = ["unstable_clickOnEnter", "unstable_clickOnSpace"], zB = k1({ name: "Clickable", compose: UB, keys: Sq, useOptions: function(r) {
        var s = r.unstable_clickOnEnter, a = s === void 0 ? !0 : s, d = r.unstable_clickOnSpace, m = d === void 0 ? !0 : d, y = S0(r, ["unstable_clickOnEnter", "unstable_clickOnSpace"]);
        return rm({ unstable_clickOnEnter: a, unstable_clickOnSpace: m }, y);
      }, useProps: function(r, s) {
        var a = s.onKeyDown, d = s.onKeyUp, m = S0(s, ["onKeyDown", "onKeyUp"]), y = (0, Rk.useState)(!1), x = y[0], w = y[1], T = T0(a), P = T0(d), M = (0, Rk.useCallback)(function(O) {
          var N;
          if ((N = T.current) === null || N === void 0 || N.call(T, O), !O.defaultPrevented && !r.disabled && !O.metaKey && Ibe(O)) {
            var B = r.unstable_clickOnEnter && O.key === "Enter", U = r.unstable_clickOnSpace && O.key === " ";
            if (B || U) {
              if (Xbe(O)) return;
              O.preventDefault(), B ? O.currentTarget.click() : U && w(!0);
            }
          }
        }, [r.disabled, r.unstable_clickOnEnter, r.unstable_clickOnSpace]), F = (0, Rk.useCallback)(function(O) {
          var N;
          if ((N = P.current) === null || N === void 0 || N.call(P, O), !O.defaultPrevented && !r.disabled && !O.metaKey) {
            var B = r.unstable_clickOnSpace && O.key === " ";
            x && B && (w(!1), O.currentTarget.click());
          }
        }, [r.disabled, r.unstable_clickOnSpace, x]);
        return rm({ "data-active": x || void 0, onKeyDown: M, onKeyUp: F }, m);
      } }), P1({ as: "button", memo: !0, useHook: zB });
    }), R1, wq, Eq, Tq, Zbe = R(() => {
      C1(), A1(), M1(), R1 = Y(xe()), lq(), NB(), Pk(), Qbe(), wq = [], Eq = k1({ name: "Button", compose: zB, keys: wq, useProps: function(r, s) {
        var a = s.ref, d = S0(s, ["ref"]), m = (0, R1.useRef)(null), y = (0, R1.useState)(void 0), x = y[0], w = y[1], T = (0, R1.useState)("button"), P = T[0], M = T[1];
        return (0, R1.useEffect)(function() {
          var F = m.current;
          F && (IB(F) || (F.tagName !== "A" && w("button"), M(void 0)));
        }, []), rm({ ref: oq(m, a), role: x, type: P }, d);
      } }), Tq = P1({ as: "button", memo: !0, useHook: Eq });
    }), Cq, Pq, Aq, Jbe = R(() => {
      C1(), A1(), M1(), vq(), Cq = [], Pq = k1({ name: "Group", compose: Mk, keys: Cq, useProps: function(r, s) {
        return rm({ role: "group" }, s);
      } }), Aq = P1({ as: "div", useHook: Pq });
    });
    function exe() {
      return Ak ? document.body : null;
    }
    var kq, P0, txe = R(() => {
      kq = Y(xe()), LB(), DB(), Y(oi()), P0 = (0, kq.createContext)(exe());
    }), VB, nxe = R(() => {
      typeof window < "u" && (VB = { get passive() {
      } }, window.addEventListener("testPassive", null, VB), window.removeEventListener("testPassive", null, VB));
    }), im = R(() => {
      Y(xe()), Pk(), Zbe(), Jbe(), Y(oi()), txe(), nxe(), OB();
    });
    function kn(r) {
      let s = (0, GB.useMemo)(() => {
        let m = r;
        return { get current() {
          return m;
        }, set current(y) {
          m = y, d(y);
        } };
      }, []), [a, d] = (0, GB.useState)(() => r);
      return [s, a];
    }
    var GB, Hn = R(() => {
      GB = Y(xe());
    });
    function rxe(r) {
      return (s) => Ns.default.createElement(Dq, null, Ns.default.createElement(r, L({}, s)));
    }
    var Ns, Mq, Rq, Ln, A0, Iq, Nq, Oq, qB, HB, Dq, Xn = R(() => {
      Al(), it(), it(), Ns = Y(xe()), Mq = Y(oi()), im(), Hn(), Ln = sa(Rq || (Rq = $([`
  #pointer-root & {
    pointer-events: none;
  }
  #pointer-root.normal & {
    pointer-events: auto;
  }
`]))), A0 = { panel: { bg: "#282b2f", head: { title: { color: "#bbb" }, punctuation: { color: "#808080" } }, body: { compoudThing: { label: { get color() {
        return _0(0.6, A0.panel.bg);
      } } } } } }, Nq = typeof window < "u" ? $G(Iq || (Iq = $([`
  :host {
    all: initial;
    color: white;
    font: 11px -apple-system, BlinkMacSystemFont, Segoe WPC, Segoe Editor,
      HelveticaNeue-Light, Ubuntu, Droid Sans, sans-serif;
  }

  * {
    padding: 0;
    margin: 0;
    font-size: 100%;
    font: inherit;
    vertical-align: baseline;
    list-style: none;
  }
`]))) : {}, qB = ee.div(Oq || (Oq = $([`
  z-index: 51;
  position: fixed;
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
  pointer-events: none;
`]))), HB = (r) => Ns.default.createElement(VG, { disableVendorPrefixes: !0, target: r.target }, Ns.default.createElement(Ns.default.Fragment, null, Ns.default.createElement(Nq, null), r.children)), Dq = (r) => {
        let [s, a] = (0, Ns.useState)(null), [d, m] = (0, Ns.useState)(null);
        (0, Ns.useLayoutEffect)(() => {
          if (!s) return;
          let { parentNode: w } = s;
          if (!w) return;
          let T = w.shadowRoot ? parent.shadowRoot : w.attachShadow({ mode: "open" });
          m(T);
        }, [s]);
        let [y, x] = kn(void 0);
        return d ? Mq.default.createPortal(Ns.default.createElement(HB, { target: d }, Ns.default.createElement(Ns.default.Fragment, null, Ns.default.createElement(qB, { ref: y }), Ns.default.createElement(P0.Provider, { value: x }, r.children))), d) : Ns.default.createElement("template", { ref: a, "shadow-root": "open" }, r.children);
      };
    }), sm, Fq, Bq, $B, Lq, Ik, jq, Uq, zq, Vq, Nk, zu, qh = R(() => {
      Xn(), it(), sm = { get outlinePanel() {
        return 1;
      }, get propsPanel() {
        return sm.outlinePanel;
      }, get sequenceEditorPanel() {
        return this.outlinePanel - 1;
      }, get toolbar() {
        return this.outlinePanel + 1;
      }, get pluginPanes() {
        return this.sequenceEditorPanel - 1;
      } }, Fq = A0.panel.bg, $B = ee.span(Bq || (Bq = $([`
  white-space: nowrap;
`]))), Ik = ee.span(Lq || (Lq = $([`
  white-space: nowrap;
  color: `, `;
`])), A0.panel.head.punctuation.color), Uq = ee.div(jq || (jq = $([`
  background: `, `;
  flex-grow: 1;
  overflow-y: scroll;
  padding: 0;
`])), Fq), zq = 18, Nk = ee.div(Vq || (Vq = $([`
  height: `, `px;
  box-sizing: border-box;
  display: flex;
  align-items: center;
  padding: 0 10px;
  position: relative;
  color: #adadadb3;
  border-bottom: 1px solid rgb(0 0 0 / 13%);
  background-color: #25272b;
  font-size: 10px;
  font-weight: 500;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
`])), zq), zu = 100;
    }), Gq, kl, k0 = R(() => {
      Gq = () => {
      }, kl = Gq;
    });
    function ixe(r) {
      return WB.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), WB.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M1.775 2.781a.5.5 0 01.5.5v1.7H4.67c.108-.957.92-1.7 1.905-1.7h6.608a1.917 1.917 0 110 3.834H6.574c-.78 0-1.452-.466-1.751-1.135H2.275v5.03h2.39a2.032 2.032 0 012.023-1.854h6.38a2.031 2.031 0 110 4.063h-6.38c-.83 0-1.543-.497-1.858-1.21H1.775a.5.5 0 01-.5-.5V3.281a.5.5 0 01.5-.5zm4.799 1.5h6.608a.917.917 0 110 1.834H6.574a.917.917 0 110-1.834zm.114 5.875h6.38a1.031 1.031 0 110 2.063h-6.38a1.032 1.032 0 110-2.063z", fill: "currentColor" }));
    }
    var WB, qq, sxe = R(() => {
      WB = Y(xe()), qq = ixe;
    });
    function oxe(r) {
      return KB.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), KB.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M8 10.5L4 6.654 5.2 5.5 8 8.385 10.8 5.5 12 6.654 8 10.5z", fill: "currentColor" }));
    }
    var KB, Hq, axe = R(() => {
      KB = Y(xe()), Hq = oxe;
    });
    function lxe(r) {
      return YB.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), YB.createElement("path", { d: "M8.339 4.5l-2.055.644 4.451 1.393v2.748l-2.966.928-2.504-.783V6.738l2.42.758 2.055-.644-4.458-1.395L4 5.858v4.463L7.768 11.5 12 10.175V5.646L8.339 4.5z", fill: "currentColor" }));
    }
    var YB, XB, uxe = R(() => {
      YB = Y(xe()), XB = lxe;
    });
    function cxe(r) {
      return QB.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), QB.createElement("path", { d: "M6.8 11.6a.6.6 0 00.6-.6V7.4a.6.6 0 00-1.2 0V11a.6.6 0 00.6.6zm6-7.2h-2.4v-.6A1.8 1.8 0 008.6 2H7.4a1.8 1.8 0 00-1.8 1.8v.6H3.2a.6.6 0 100 1.2h.6v6.6A1.8 1.8 0 005.6 14h4.8a1.8 1.8 0 001.8-1.8V5.6h.6a.6.6 0 100-1.2zm-6-.6a.6.6 0 01.6-.6h1.2a.6.6 0 01.6.6v.6H6.8v-.6zm4.2 8.4a.6.6 0 01-.6.6H5.6a.6.6 0 01-.6-.6V5.6h6v6.6zm-1.8-.6a.6.6 0 00.6-.6V7.4a.6.6 0 00-1.2 0V11a.6.6 0 00.6.6z", fill: "currentColor" }));
    }
    var QB, ZB, dxe = R(() => {
      QB = Y(xe()), ZB = cxe;
    }), Ok = R(() => {
      sxe(), axe(), uxe(), dxe();
    }), Vu, $q, Dk, Wq, Kq, Yq, Xq, Qq, Zq, Jq, eH, tH, nH, rH, iH, sH, oH, aH, JB, lH = R(() => {
      Vu = Y(xe()), it(), k0(), Xn(), Ok(), Dk = ee.li($q || ($q = $([`
  margin: 0;
  padding: 0;
  list-style: none;
  display: flex;
  justify-content: flex-start;
  flex-direction: column;
  align-items: flex-start;
`]))), Kq = ee.div(Wq || (Wq = $([""]))), Xq = ee(Kq)(Yq || (Yq = $([`
  position: relative;
  margin-top: 2px;
  margin-bottom: 2px;
  margin-left: calc(4px + var(--depth) * 16px);
  padding-left: 4px;
  padding-right: 8px;
  gap: 4px;
  height: 21px;
  line-height: 0;
  box-sizing: border-box;
  display: flex;
  flex-wrap: nowrap;
  align-items: center;
  pointer-events: none;
  white-space: nowrap;

  border-radius: 2px;
  box-shadow: 0 3px 4px -1px rgba(0, 0, 0, 0.48);

  color: rgba(255, 255, 255, 0.9);
  background: rgba(40, 43, 47, 0.65);
  backdrop-filter: blur(14px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);

  &.descendant-is-selected {
    background: rgba(29, 53, 59, 0.7);
  }

  `, `;
  &:not(.not-selectable):not(.selected):hover {
    background: rgba(59, 63, 69, 0.9);

    border-bottom: 1px solid rgba(255, 255, 255, 0.24);
  }

  &:not(.not-selectable):not(.selected):active {
    background: rgba(82, 88, 96, 0.9);
    border-bottom: 1px solid rgba(255, 255, 255, 0.24);
  }

  &.selected {
    background: rgba(30, 88, 102, 0.7);
    border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  }

  @supports not (backdrop-filter: blur()) {
    background: rgba(40, 43, 47, 0.95);
  }
`])), Ln), Zq = sa(Qq || (Qq = $([`
  font-weight: 500;
  font-size: 11px;
  & {
  }
`]))), eH = ee.span(Jq || (Jq = $([`
  `, `;

  `, `;
  position: relative;
  // Compensate for border bottom
  top: 0.5px;
  display: flex;
  height: 20px;
  align-items: center;
  box-sizing: border-box;
`])), Zq, Ln), nH = ee.div(tH || (tH = $([`
  font-weight: 500;
  display: flex;
  justify-content: center;
  align-items: center;
  position: relative;
  opacity: 0.99;
`]))), iH = ee.span(rH || (rH = $([`
  font-size: 9px;
  position: relative;
  display: block;
  transition: transform 0.1s ease-out;

  &:hover {
    transform: rotate(-20deg);
  }

  `, `.collapsed & {
    transform: rotate(-90deg);

    &:hover {
      transform: rotate(-70deg);
    }
  }
`])), Dk), oH = ee.ul(sH || (sH = $([`
  margin: 0;
  padding: 0;
  list-style: none;

  `, `.collapsed & {
    display: none;
  }
`])), Dk), aH = ({ label: r, children: s, depth: a, select: d, selectionStatus: m, labelDecoration: y, collapsed: x = !1, setIsCollapsed: w, draggable: T, onDragStart: P, onDragEnd: M }) => {
        let F = s !== void 0;
        return Vu.default.createElement(Dk, { style: { "--depth": a }, className: x ? "collapsed" : "" }, Vu.default.createElement(Xq, { className: m, onClick: d ?? kl, "data-header": !0, draggable: T, onDragStart: P, onDragEnd: M }, Vu.default.createElement(nH, null, F ? Vu.default.createElement(iH, { onClick: (O) => {
          O.stopPropagation(), O.preventDefault(), w?.(!x);
        } }, Vu.default.createElement(Hq, null)) : Vu.default.createElement(XB, null)), Vu.default.createElement(eH, null, Vu.default.createElement("span", null, r)), y), F && Vu.default.createElement(oH, null, s));
      }, JB = aH;
    });
    function hxe(r) {
      return Object.keys(r);
    }
    function pxe(r) {
      return Object.keys((0, Gu.val)(r.sheetTemplatesP));
    }
    function fxe() {
      let r = ar(Va().filter((s) => Ht(s) || an(s)).map((s) => an(s) ? s.sheet : s))[0];
      if (r) return r.getSequence();
    }
    var Gu, Va, uH, M0 = R(() => {
      Gu = ut(), _r(), tn(), st(), Va = () => {
        var r;
        let s = (0, Gu.val)(pe().projectsP), a = ((r = (0, Gu.val)(pe().atomP.historic.panels.outlinePanel.selection)) != null ? r : []).map((d) => {
          let m = s[d.projectId];
          if (!m) return;
          if (d.type === "Project") return m;
          if (!(0, Gu.val)(m.sheetTemplatesP[d.sheetId])) return;
          let y = uH(m, d.sheetId);
          if (!y) return;
          if (d.type === "Sheet") return y;
          let x = (0, Gu.val)(y.objectsP[d.objectKey]);
          if (x) return x;
        });
        return ar(a.filter((d) => typeof d < "u"));
      }, uH = (r, s) => {
        let a = pe().atomP.historic.projects.stateByProjectId[r.address.projectId], d = (0, Gu.val)(a.stateBySheetId[s].selectedInstanceId), m = (0, Gu.val)(r.sheetTemplatesP[s]);
        if (m) {
          if (d) return (0, Gu.val)(m.instancesP[d]);
          {
            let y = (0, Gu.val)(m.instancesP);
            return y[hxe(y)[0]];
          }
        }
      };
    }), I1, cH, mxe = R(() => {
      st(), M0(), zt(), I1 = Y(xe()), lH(), cH = ({ sheet: r, depth: s }) => {
        let a = (0, I1.useCallback)(() => {
          pe().transaction(({ stateEditors: y }) => {
            y.studio.historic.panels.outline.selection.set([r]);
          });
        }, [r]), d = (0, I1.useCallback)((y) => {
          let x = { type: "theatre-sheet", projectId: r.address.projectId, sheetId: r.address.sheetId, sheetInstanceId: r.address.sheetInstanceId };
          y.dataTransfer.setData("application/json", JSON.stringify(x)), y.dataTransfer.effectAllowed = "copy", document.body.classList.add("dragging-sheet");
        }, [r]), m = (0, I1.useCallback)(() => {
          document.body.classList.remove("dragging-sheet");
        }, []);
        return At(() => {
          let y = Va();
          return I1.default.createElement(JB, { depth: s, select: a, selectionStatus: y.some((x) => x === r) ? "selected" : y.some((x) => x.type === "Theatre_SheetObject" && x.sheet === r) ? "descendant-is-selected" : "not-selected", label: "".concat(r.address.sheetId, ": ").concat(r.address.sheetInstanceId), draggable: !0, onDragStart: d, onDragEnd: m });
        }, [s, d, m]);
      };
    }), eL, R0, dH, hH, pH, fH, gxe = R(() => {
      zt(), eL = ut(), R0 = Y(xe()), it(), mxe(), ee.div(dH || (dH = $([`
  display: flex;
`]))), ee.li(hH || (hH = $([`
  color: `, `;
`])), (r) => r.isSelected ? "white" : "hsl(1, 1%, 80%)"), ee.div(pH || (pH = $([""]))), fH = ({ sheetId: r, depth: s, project: a }) => At(() => {
        let d = (0, eL.val)(a.sheetTemplatesP[r]);
        if (!d) return R0.default.createElement(R0.default.Fragment, null);
        let m = (0, eL.val)(d.instancesP);
        return R0.default.createElement(R0.default.Fragment, null, Object.entries(m).map(([y, x]) => R0.default.createElement(cH, { key: x.address.sheetInstanceId, sheet: x, depth: s })));
      }, [s, r, a]);
    }), Fk, mH, gH, yxe = R(() => {
      M0(), zt(), Fk = Y(xe()), gxe(), mH = ({ project: r, depth: s }) => At(() => {
        if (!r) return null;
        let a = pxe(r);
        return Fk.default.createElement(Fk.default.Fragment, null, a.map((d) => Fk.default.createElement(fH, { depth: s, sheetId: d, key: "sheet-".concat(d), project: r })));
      }, [r, s]), gH = mH;
    });
    function vxe(r) {
      var s;
      let a = r.type === "namespace" ? "namespace:".concat(r.sheet.address.sheetId, ":").concat(r.path.join("/")) : r.type === "Theatre_Project" ? "project" : r.type === "Theatre_Sheet" ? "sheetInstance:".concat(r.address.sheetId, ":").concat(r.address.sheetInstanceId) : "unknown", d = r.type === "namespace" ? r.sheet.address.projectId : r.address.projectId, m = (s = nn(pe().atomP.ahistoric.projects.stateByProjectId[d].collapsedItemsInOutline[a])) != null ? s : !1, y = (0, yH.useCallback)((x) => {
        pe().transaction(({ stateEditors: w }) => {
          w.studio.ahistoric.projects.stateByProjectId.collapsedItemsInOutline.set({ projectId: d, isCollapsed: x, itemKey: a });
        });
      }, [a]);
      return { collapsed: m, setCollapsed: y };
    }
    var yH, bxe = R(() => {
      yH = Y(xe()), st(), zt();
    }), N1, vH, bH, xH, _H, SH, xxe = R(() => {
      N1 = Y(xe()), lH(), yxe(), st(), zt(), M0(), vH = ut(), it(), bxe(), xH = ee.div(bH || (bH = $([`
  color: #ff6363;
  margin-left: 11px;
  background: #4c282d;
  padding: 2px 8px;
  border-radius: 2px;
  font-size: 10px;
  box-shadow: 0 2px 8px -4px black;
`]))), _H = ({ depth: r, project: s }) => {
        let a = At(() => Va(), []), d = At(() => {
          let w = s.address.projectId, T = (0, vH.val)(pe().atomP.ephemeral.coreByProject[w].loadingState);
          return T?.type === "browserStateIsNotBasedOnDiskState";
        }, [s]), m = (0, N1.useCallback)(() => {
          pe().transaction(({ stateEditors: w }) => {
            w.studio.historic.panels.outline.selection.set([s]);
          });
        }, [s]), { collapsed: y, setCollapsed: x } = vxe(s);
        return N1.default.createElement(JB, { depth: r, label: s.address.projectId, setIsCollapsed: x, collapsed: y, labelDecoration: d ? N1.default.createElement(xH, null, "Has Conflicts") : null, children: N1.default.createElement(gH, { project: s, depth: r + 1 }), selectionStatus: a.includes(s) ? "selected" : a.some((w) => w.address.projectId === s.address.projectId) ? "descendant-is-selected" : "not-selected", select: m });
      }, SH = _H;
    }), wH, tL, EH, TH, CH, PH, _xe = R(() => {
      wH = ut(), zt(), st(), tL = Y(xe()), it(), xxe(), TH = ee.ul(EH || (EH = $([`
  list-style: none;
  margin: 0;
  padding: 0;
  padding-right: 4px;
`]))), CH = (r) => At(() => {
        let s = (0, wH.val)(pe().projectsP);
        return tL.default.createElement(TH, null, Object.keys(s).map((a) => {
          let d = s[a];
          return tL.default.createElement(SH, { depth: 0, project: d, key: "projectListItem-".concat(a) });
        }));
      }, []), PH = CH;
    });
    function Sxe(r) {
      let [s, a] = (0, nL.useState)(!1);
      return (0, nL.useEffect)(() => {
        let d = (y) => {
          let x = s ? 200 : 50, w = 56, T = y.x < x;
          T && (T = y.y > w), a(!!T);
        };
        document.addEventListener("mousemove", d);
        let m = () => {
          a(!1);
        };
        return document.addEventListener("mouseleave", m), () => {
          document.removeEventListener("mousemove", d), document.removeEventListener("mouseleave", m);
        };
      }, [s]), s;
    }
    var nL, wxe = R(() => {
      nL = Y(xe());
    }), O1, I0, rL, AH, kH, MH, RH, Bk, D1, IH, Exe = R(() => {
      O1 = Y(xe()), it(), qh(), _xe(), zt(), st(), wxe(), I0 = ut(), Xn(), rL = "44px", kH = ee.div(AH || (AH = $([`
  `, `;
  background-color: transparent;
  position: absolute;
  left: 8px;
  z-index: `, `;

  top: calc(`, ` + 8px);
  height: fit-content;
  max-height: calc(100% - `, `);
  overflow-y: scroll;
  overflow-x: hidden;
  padding: 0;
  user-select: none;

  &::-webkit-scrollbar {
    display: none;
  }

  scrollbar-width: none;

  display: `, `;

  &:hover {
    display: block;
  }

  // Create a small buffer on the bottom to aid selecting the bottom item in a long, scrolling list
  &::after {
    content: '';
    display: block;
    height: 20px;
  }
`])), Ln, sm.outlinePanel, rL, rL, ({ pin: r }) => r ? "block" : "none"), MH = () => {
        var r;
        let s = (r = nn(pe().atomP.ahistoric.pinOutline)) != null ? r : !0, a = nn(IH), d = Sxe();
        return (0, O1.useLayoutEffect)(() => {
          Bk.set(d);
        }, [d]), (0, O1.useEffect)(() => () => {
          D1.set(!1), Bk.set(!1);
        }, []), O1.default.createElement(kH, { pin: s || a, onMouseEnter: () => {
          D1.set(!0);
        }, onMouseLeave: () => {
          D1.set(!1);
        } }, O1.default.createElement(PH, null));
      }, RH = MH, Bk = new I0.Atom(!1), D1 = new I0.Atom(!1), IH = (0, I0.prism)(() => {
        let r = (0, I0.val)(D1.prism), s = (0, I0.val)(Bk.prism);
        return r || s;
      });
    });
    function Txe() {
      let [r, s] = (0, iL.useState)(!1), a = (0, iL.useMemo)(() => {
        let d = /* @__PURE__ */ new Set();
        return () => {
          let m = () => {
            d.delete(m), s(d.size > 0);
          };
          return d.add(m), s(!0), m;
        };
      }, []);
      return [r, a];
    }
    var iL, Cxe = R(() => {
      iL = Y(xe());
    }), NH, OH, DH, Pxe = R(() => {
      NH = Y(xe()), OH = function(r) {
        (0, NH.useEffect)(r, []);
      }, DH = OH;
    }), FH, BH, LH, Axe = R(() => {
      FH = Y(xe()), Pxe(), BH = function(r) {
        var s = (0, FH.useRef)(r);
        s.current = r, DH(function() {
          return function() {
            return s.current();
          };
        });
      }, LH = BH;
    }), Lk, jH, UH, kxe = R(() => {
      Lk = Y(xe()), Axe(), jH = function(r) {
        var s = (0, Lk.useRef)(0), a = (0, Lk.useState)(r), d = a[0], m = a[1], y = (0, Lk.useCallback)(function(x) {
          cancelAnimationFrame(s.current), s.current = requestAnimationFrame(function() {
            m(x);
          });
        }, []);
        return LH(function() {
          cancelAnimationFrame(s.current);
        }), [d, y];
      }, UH = jH;
    });
    function Mxe(r) {
      for (var s = [], a = 1; a < arguments.length; a++) s[a - 1] = arguments[a];
      r && r.addEventListener && r.addEventListener.apply(r, s);
    }
    function Rxe(r) {
      for (var s = [], a = 1; a < arguments.length; a++) s[a - 1] = arguments[a];
      r && r.removeEventListener && r.removeEventListener.apply(r, s);
    }
    var jk, Ixe = R(() => {
      jk = typeof window < "u";
    }), zH, VH, Uk, sL = R(() => {
      zH = Y(xe()), kxe(), Ixe(), VH = function(r, s) {
        r === void 0 && (r = 1 / 0), s === void 0 && (s = 1 / 0);
        var a = UH({ width: jk ? window.innerWidth : r, height: jk ? window.innerHeight : s }), d = a[0], m = a[1];
        return (0, zH.useEffect)(function() {
          if (jk) {
            var y = function() {
              m({ width: window.innerWidth, height: window.innerHeight });
            };
            return Mxe(window, "resize", y), function() {
              Rxe(window, "resize", y);
            };
          }
        }, []), d;
      }, Uk = VH;
    }), oL, zk, Vk, aL, N0, GH, lL, O0 = R(() => {
      oL = ut(), zt(), st(), Cxe(), zk = Y(xe()), sL(), Vk = (r, s) => {
        let a = r.left / s.width, d = (r.left + r.width) / s.width, m = r.top / s.height, y = (r.height + r.top) / s.height;
        return { edges: { left: a <= 0.5 ? { from: "screenLeft", distance: a } : { from: "screenRight", distance: 1 - a }, right: d <= 0.5 ? { from: "screenLeft", distance: d } : { from: "screenRight", distance: 1 - d }, top: m <= 0.5 ? { from: "screenTop", distance: m } : { from: "screenBottom", distance: 1 - m }, bottom: y <= 0.5 ? { from: "screenTop", distance: y } : { from: "screenBottom", distance: 1 - y } } };
      }, aL = zk.default.createContext(null), N0 = () => (0, zk.useContext)(aL), GH = ({ panelId: r, children: s, defaultPosition: a, minDims: d }) => {
        let m = Uk(800, 200), [y, x] = Txe(), { stuff: w } = At(() => {
          var T;
          let { edges: P } = (T = (0, oL.val)(pe().atomP.historic.panelPositions[r])) != null ? T : a, M = Math.floor(m.width * (P.left.from === "screenLeft" ? P.left.distance : 1 - P.left.distance)), F = Math.floor(m.width * (P.right.from === "screenLeft" ? P.right.distance : 1 - P.right.distance)), O = Math.floor(m.height * (P.top.from === "screenTop" ? P.top.distance : 1 - P.top.distance)), N = Math.floor(m.height * (P.bottom.from === "screenTop" ? P.bottom.distance : 1 - P.bottom.distance)), B = Math.max(F - M, d.width), U = Math.max(N - O, d.height);
          return { stuff: { dims: oL.prism.memo("dims", () => ({ width: B, left: M, top: O, height: U }), [B, M, O, U]), panelId: r, minDims: d, boundsHighlighted: y, addBoundsHighlightLock: x } };
        }, [r, m, y, x]);
        return zk.default.createElement(aL.Provider, { value: w }, s);
      }, lL = GH;
    }), nd, qH, Ml, HH, $H, WH, KH, uL, YH, Ao, XH, Os = R(() => {
      nd = Y(xe()), it(), qH = "pointer-root", Ml = "--lockedCursor", $H = ee.div(HH || (HH = $([`
  pointer-events: auto;
  &.normal {
    pointer-events: none;
  }
`]))), KH = ee.div(WH || (WH = $([`
  position: absolute;
  inset: 0;
  pointer-events: none;

  #pointer-root:not(.normal) > & {
    pointer-events: auto;
  }
`]))), uL = (0, nd.createContext)({}), YH = (r) => {
        var s, a, d, m;
        let [y, x] = (0, nd.useState)([]), w = (0, nd.useMemo)(() => ({ getLock: (P, M) => {
          let F = { className: P, cursor: M };
          return x((O) => [...O, F]), () => {
            x((O) => O.filter((N) => N !== F));
          };
        } }), []), T = (a = (s = y[0]) == null ? void 0 : s.cursor) != null ? a : "";
        return nd.default.createElement(uL.Provider, { value: w }, nd.default.createElement($H, { id: qH, className: ((m = (d = y[0]) == null ? void 0 : d.className) != null ? m : "normal") + " " + r.className }, nd.default.createElement(KH, { style: { cursor: T, [Ml]: T } }, r.children)));
      }, Ao = (r, s, a) => {
        let d = (0, nd.useContext)(uL);
        (0, nd.useLayoutEffect)(() => {
          if (r) return d.getLock(s, a);
        }, [r, s, a]);
      }, XH = YH;
    });
    function QH(r) {
      return F1.default.createElement(cL.Provider, { value: r.logger }, r.children);
    }
    function D0(r, s) {
      let a = (0, F1.useContext)(cL);
      return (0, F1.useMemo)(() => r ? a.named(r, s) : a, [a, r, s]);
    }
    var F1, cL, om = R(() => {
      F1 = Y(xe()), cL = F1.default.createContext(null);
    });
    function Nxe() {
      let r = D0("PointerCapturing"), s = Rl.default.useRef(null), a = () => s.current != null;
      return (d) => {
        let m, y = (x) => (m = x, s.current = x, x);
        return { capturing: { capturePointer(x) {
          if (r._debug("Capturing pointer", { forDebugName: d, reason: x }), s.current != null) throw new Error('"'.concat(d, '" attempted capturing pointer for "').concat(x, '" while already captured by "').concat(s.current.debugOwnerName, '" for "').concat(s.current.debugReason, '"'));
          let w = y({ debugOwnerName: d, debugReason: x });
          return { isCapturing() {
            return w === s.current;
          }, release() {
            return w === s.current ? (r._debug("Releasing pointer", { forDebugName: d, reason: x }), y(null), !0) : !1;
          } };
        }, isPointerBeingCaptured: a }, forceRelease() {
          m && s.current === m && (r._debug("Force releasing pointer", { localCapture: m }), y(null));
        } };
      };
    }
    function Oxe(r) {
      let s = Nxe();
      return Rl.default.createElement(dL.Provider, { value: s }, Rl.default.createElement(JH, { children: r.children }));
    }
    function ZH(r) {
      let s = (0, Rl.useContext)(dL), a = (0, Rl.useMemo)(() => s(r), [r, s]);
      return (0, Rl.useEffect)(() => () => {
        a.forceRelease();
      }, [a]), a.capturing;
    }
    var Rl, dL, JH, hL = R(() => {
      Rl = Y(xe()), om(), dL = Rl.default.createContext(null), JH = Rl.default.memo(({ children: r }) => Rl.default.createElement(Rl.default.Fragment, null, r));
    }), pL, Dxe = R(() => {
      pL = typeof window < "u" && /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    });
    function Fr(r, s) {
      let a = (0, F0.useRef)(s);
      a.current = s;
      let d = s.shouldPointerLock && !pL, m = (0, F0.useRef)({ domDragStarted: !1 }), { capturePointer: y } = ZH("useDrag for ".concat(s.debugName)), x = (0, F0.useRef)({ onDrag: kl, onDragEnd: kl, onClick: kl }), w = (0, F0.useRef)(), [T, P] = kn(!1);
      return (0, F0.useLayoutEffect)(() => {
        if (!r) return;
        let M = () => {
          let Q = m.current.domDragStarted && m.current.detection.detected;
          T.current !== Q && (T.current = Q);
        }, F = (Q) => {
          if (!m.current.domDragStarted) return;
          let ne = m.current;
          if (!Fxe(Q, ne) && (ne.detection.detected || (ne.detection.totalDistanceMoved += Math.abs(Q.movementY) + Math.abs(Q.movementX), ne.detection.totalDistanceMoved > e$ && (d && r.requestPointerLock(), ne.detection = { detected: !0, dragMovement: { x: 0, y: 0 }, dragEventCount: 0 }, M())), ne.detection.detected)) {
            ne.detection.dragEventCount += 1;
            let { dragMovement: ce } = ne.detection;
            if (d) ce.x += Q.movementX, ce.y += Q.movementY;
            else {
              let { startPos: ue } = ne;
              ce.x = Q.screenX - ue.x, ce.y = Q.screenY - ue.y;
            }
            x.current.onDrag(ce.x, ce.y, Q, Q.movementX, Q.movementY);
          }
        }, O = (Q) => {
          if (B(), !m.current.domDragStarted) return;
          let ne = m.current.detection.detected;
          m.current = { domDragStarted: !1 }, s.shouldPointerLock && !pL && document.exitPointerLock(), x.current.onDragEnd(ne), window.focus(), ne || x.current.onClick(Q), M();
        }, N = () => {
          document.addEventListener("mousemove", F), document.addEventListener("mouseup", O);
        }, B = () => {
          var Q;
          (Q = w.current) == null || Q.release(), document.removeEventListener("mousemove", F), document.removeEventListener("mouseup", O);
        }, U = (Q) => {
          a.current.disabled || m.current.domDragStarted && m.current.detection.detected && (a.current.dontBlockMouseDown || (Q.stopPropagation(), Q.preventDefault()), m.current.detection = { detected: !1, totalDistanceMoved: 0 }, M());
        }, H = (Q) => {
          var ne, ce, ue, se;
          (ne = w.current) == null || ne.release();
          let Oe = a.current;
          if (Oe.disabled === !0 || !((ce = Oe.buttons) != null ? ce : [0]).includes(Q.button)) return;
          let he = Oe.onDragStart(Q);
          he !== !1 && (x.current.onDrag = he.onDrag, x.current.onDragEnd = (ue = he.onDragEnd) != null ? ue : kl, x.current.onClick = (se = he.onClick) != null ? se : kl, w.current = y("Drag start"), Oe.dontBlockMouseDown || (Q.stopPropagation(), Q.preventDefault()), m.current = { domDragStarted: !0, startPos: { x: Q.screenX, y: Q.screenY }, detection: { detected: !1, totalDistanceMoved: 0 } }, M(), N());
        }, W = (Q) => {
          H(Q);
        };
        return r.addEventListener("mousedown", W), r.addEventListener("click", U), () => {
          var Q, ne;
          B(), r.removeEventListener("mousedown", W), r.removeEventListener("click", U), m.current.domDragStarted && ((ne = (Q = x.current).onDragEnd) == null || ne.call(Q, m.current.detection.detected)), m.current = { domDragStarted: !1 }, M();
        };
      }, [r]), Ao(P && !!s.lockCSSCursorTo, "dragging", s.lockCSSCursorTo), [P];
    }
    function Fxe(r, s) {
      return (!s.detection.detected || s.detection.detected && s.detection.dragEventCount < 3) && (Math.abs(r.movementX) > fL || Math.abs(r.movementY) > fL);
    }
    var F0, e$, fL, li = R(() => {
      F0 = Y(xe()), Os(), hL(), k0(), Dxe(), Hn(), e$ = 3, fL = 100;
    }), B1, t$, n$, r$, mL, i$ = R(() => {
      Hn(), st(), li(), B1 = Y(xe()), it(), O0(), Os(), tn(), qh(), n$ = ee.div(t$ || (t$ = $([`
  cursor: move;
`]))), r$ = (r) => {
        let s = N0(), a = (0, B1.useRef)(s);
        a.current = s;
        let [d, m] = kn(null), y = (0, B1.useMemo)(() => ({ debugName: "PanelDragZone", lockCursorTo: "move", onDragStart() {
          let P = a.current, M, F = s.addBoundsHighlightLock(), O = P.panelId;
          if (O.startsWith("pane-")) {
            let N = O.slice(5);
            pe().paneManager.bringPaneToFront(N);
          }
          return { onDrag(N, B) {
            let U = V(L({}, P.dims), { top: ir(P.dims.top + B, 0, window.innerHeight - zu), left: ir(P.dims.left + N, -P.dims.width + zu, window.innerWidth - zu) }), H = Vk(U, { width: window.innerWidth, height: window.innerHeight });
            M?.discard(), M = pe().tempTransaction(({ stateEditors: W }) => {
              W.studio.historic.panelPositions.setPanelPosition({ position: H, panelId: P.panelId });
            });
          }, onDragEnd(N) {
            F(), N ? M?.commit() : M?.discard();
          } };
        } }), []), [x] = Fr(m, y);
        Ao(x, "dragging", "move");
        let [w, T] = (0, B1.useMemo)(() => {
          let P;
          return [function() {
            if (P) {
              let M = P;
              P = void 0, M();
            }
            P = s.addBoundsHighlightLock();
          }, function() {
            if (P) {
              let M = P;
              P = void 0, M();
            }
          }];
        }, []);
        return B1.default.createElement(n$, V(L({}, r), { ref: d, onMouseEnter: w, onMouseLeave: T }));
      }, mL = r$;
    }), L1, gL, s$, yL, o$, vL, a$, bL, l$, u$, c$, d$, h$, xL, p$, f$, m$, g$, y$, j1, v$, b$, x$, _$, S$, w$, E$, T$, C$, _L, P$, rd, Bxe = R(() => {
      Hn(), st(), li(), Al(), L1 = Y(xe()), it(), O0(), Xn(), tn(), qh(), gL = ut(), yL = ee.div(s$ || (s$ = $([`
  position: absolute;
  `, `;
  &:after {
    position: absolute;
    inset: -5px;
    display: block;
    content: ' ';
  }

  opacity: 0;
  background-color: #478698;

  &.isHighlighted {
    opacity: 0.7;
  }

  &.isDragging {
    opacity: 1;
    /* background-color: `, `; */
  }

  &:hover {
    opacity: 1;
  }
`])), Ln, _0(0.2, "#478698")), vL = ee(yL)(o$ || (o$ = $([`
  /**
  The horizintal/vertical resize handles have z-index:-1 and are offset 1px outside of the panel
  to make sure they don't occlude any element that pops out of the panel (like the Playhead in SequenceEditorPanel).

  This means that panels will always need an extra 1px margin for their resize handles to be visible, but that's not a problem
  that we have to deal with right now (if it is at all a problem).
  
   */
  z-index: -1;
`]))), bL = ee(vL)(a$ || (a$ = $([`
  left: 0px;
  right: 0px;
  height: 1px;
`]))), u$ = ee(bL)(l$ || (l$ = $([`
  top: -1px;
`]))), d$ = ee(bL)(c$ || (c$ = $([`
  bottom: -1px;
`]))), xL = ee(vL)(h$ || (h$ = $([`
  z-index: -1;
  top: -1px;
  bottom: -1px;
  width: 1px;
`]))), f$ = ee(xL)(p$ || (p$ = $([`
  left: -1px;
`]))), g$ = ee(xL)(m$ || (m$ = $([`
  right: -1px;
`]))), j1 = ee(yL)(y$ || (y$ = $([`
  // The angles have z-index: 10 to make sure they _do_ occlude other elements in the panel.
  z-index: 10;
  width: 8px;
  height: 8px;
`]))), b$ = ee(j1)(v$ || (v$ = $([`
  top: 0;
  left: 0;
`]))), _$ = ee(j1)(x$ || (x$ = $([`
  top: 0;
  right: 0;
`]))), w$ = ee(j1)(S$ || (S$ = $([`
  bottom: 0;
  left: 0;
`]))), T$ = ee(j1)(E$ || (E$ = $([`
  bottom: 0;
  right: 0;
`]))), C$ = { Top: u$, TopLeft: b$, TopRight: _$, Bottom: d$, BottomLeft: w$, BottomRight: T$, Left: f$, Right: g$ }, _L = { Top: "ns-resize", Bottom: "ns-resize", Left: "ew-resize", Right: "ew-resize", TopLeft: "nw-resize", TopRight: "ne-resize", BottomLeft: "sw-resize", BottomRight: "se-resize" }, P$ = ({ which: r }) => {
        let s = N0(), a = (0, L1.useRef)(s);
        a.current = s;
        let d = (0, L1.useRef)(0), [m, y] = kn(null), x = (0, L1.useMemo)(() => ({ debugName: "PanelResizeHandle", lockCursorTo: _L[r], onDragStart() {
          var M;
          let F, O = a.current, N = s.addBoundsHighlightLock();
          return d.current = (M = (0, gL.val)(pe().atomP.historic.panels.sequenceEditor.dopesheetLeftWidth)) != null ? M : 225, { onDrag(B, U) {
            var H;
            let W = (H = (0, gL.val)(pe().atomP.historic.panels.sequenceEditor.rightPanelOpen)) != null ? H : !0, Q = L({}, O.dims);
            if (r.startsWith("Bottom")) Q.height = Math.max(Q.height + U, O.minDims.height);
            else if (r.startsWith("Top")) {
              let ce = Q.top + Q.height, ue = ir(Q.top + U, 0, Math.min(ce - O.minDims.height, window.innerHeight - zu)), se = ce - ue;
              Q.height = se, Q.top = ue;
            }
            if (r.endsWith("Left")) {
              let ce = Q.left + Q.width, ue = Math.min(Q.left + B, Math.min(ce - O.minDims.width, window.innerWidth - zu)), se = ce - ue;
              Q.width = se, Q.left = ue;
            } else r.endsWith("Right") && (Q.width = Math.max(Q.width + B, Math.max(O.minDims.width, zu - O.dims.left)));
            let ne = Vk(Q, { width: window.innerWidth, height: window.innerHeight });
            F?.discard(), F = pe().tempTransaction(({ stateEditors: ce }) => {
              if (!W && (r === "BottomRight" || r === "TopRight") && O.panelId === "sequenceEditor") {
                let ue = Math.max(225, d.current + B);
                ce.studio.historic.panels.sequenceEditor.setDopesheetLeftWidth(ue);
              }
              ce.studio.historic.panelPositions.setPanelPosition({ position: ne, panelId: O.panelId });
            });
          }, onDragEnd(B) {
            N(), B ? F?.commit() : F?.discard();
          } };
        } }), [r]), [w] = Fr(y, x), T = C$[r], P = r.length <= 6;
        return L1.default.createElement(T, { ref: m, className: [w ? "isDragging" : "", s.boundsHighlighted && P ? "isHighlighted" : ""].join(" "), style: { cursor: _L[r] } });
      }, rd = P$;
    }), Il, A$, k$, Lxe = R(() => {
      Il = Y(xe()), Bxe(), A$ = (r) => Il.default.createElement(Il.default.Fragment, null, Il.default.createElement(rd, { which: "Bottom" }), Il.default.createElement(rd, { which: "Top" }), Il.default.createElement(rd, { which: "Left" }), Il.default.createElement(rd, { which: "Right" }), Il.default.createElement(rd, { which: "TopLeft" }), Il.default.createElement(rd, { which: "TopRight" }), Il.default.createElement(rd, { which: "BottomLeft" }), Il.default.createElement(rd, { which: "BottomRight" })), k$ = A$;
    }), Gk, M$, R$, I$, SL, N$ = R(() => {
      Xn(), Gk = Y(xe()), it(), O0(), Lxe(), R$ = ee.div(M$ || (M$ = $([`
  position: absolute;
  user-select: none;
  box-sizing: border-box;
  `, `;
  /* box-shadow: 1px 2px 10px -5px black; */

  z-index: 1000;
`])), Ln), I$ = Gk.default.forwardRef((r, s) => {
        let a = N0(), d = r, { style: m, children: y } = d, x = re(d, ["style", "children"]);
        return Gk.default.createElement(R$, V(L({ ref: s }, x), { style: L({ width: a.dims.width + "px", height: a.dims.height + "px", top: a.dims.top + "px", left: a.dims.left + "px" }, m ?? {}) }), Gk.default.createElement(k$, null), y);
      }), SL = I$;
    }), jxe = J((r, s) => {
      (function(a, d) {
        typeof r == "object" && typeof s < "u" ? d(r, xe()) : (a = typeof globalThis < "u" ? globalThis : a || self, d(a.ReactErrorBoundary = {}, a.React));
      })(r, function(a, d) {
        function m(N) {
          if (N && N.__esModule) return N;
          var B = /* @__PURE__ */ Object.create(null);
          return N && Object.keys(N).forEach(function(U) {
            if (U !== "default") {
              var H = Object.getOwnPropertyDescriptor(N, U);
              Object.defineProperty(B, U, H.get ? H : { enumerable: !0, get: function() {
                return N[U];
              } });
            }
          }), B.default = N, Object.freeze(B);
        }
        var y = m(d);
        function x(N, B) {
          return x = Object.setPrototypeOf || function(U, H) {
            return U.__proto__ = H, U;
          }, x(N, B);
        }
        function w(N, B) {
          N.prototype = Object.create(B.prototype), N.prototype.constructor = N, x(N, B);
        }
        var T = function(N, B) {
          return N === void 0 && (N = []), B === void 0 && (B = []), N.length !== B.length || N.some(function(U, H) {
            return !Object.is(U, B[H]);
          });
        }, P = { error: null }, M = function(N) {
          w(B, N);
          function B() {
            for (var H, W = arguments.length, Q = new Array(W), ne = 0; ne < W; ne++) Q[ne] = arguments[ne];
            return H = N.call.apply(N, [this].concat(Q)) || this, H.state = P, H.updatedWithError = !1, H.resetErrorBoundary = function() {
              for (var ce, ue = arguments.length, se = new Array(ue), Oe = 0; Oe < ue; Oe++) se[Oe] = arguments[Oe];
              H.props.onReset == null || (ce = H.props).onReset.apply(ce, se), H.reset();
            }, H;
          }
          B.getDerivedStateFromError = function(H) {
            return { error: H };
          };
          var U = B.prototype;
          return U.reset = function() {
            this.updatedWithError = !1, this.setState(P);
          }, U.componentDidCatch = function(H, W) {
            var Q, ne;
            (Q = (ne = this.props).onError) == null || Q.call(ne, H, W);
          }, U.componentDidMount = function() {
            var H = this.state.error;
            H !== null && (this.updatedWithError = !0);
          }, U.componentDidUpdate = function(H) {
            var W = this.state.error, Q = this.props.resetKeys;
            if (W !== null && !this.updatedWithError) {
              this.updatedWithError = !0;
              return;
            }
            if (W !== null && T(H.resetKeys, Q)) {
              var ne, ce;
              (ne = (ce = this.props).onResetKeysChange) == null || ne.call(ce, H.resetKeys, Q), this.reset();
            }
          }, U.render = function() {
            var H = this.state.error, W = this.props, Q = W.fallbackRender, ne = W.FallbackComponent, ce = W.fallback;
            if (H !== null) {
              var ue = { error: H, resetErrorBoundary: this.resetErrorBoundary };
              if (y.isValidElement(ce)) return ce;
              if (typeof Q == "function") return Q(ue);
              if (ne) return y.createElement(ne, ue);
              throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
            }
            return this.props.children;
          }, B;
        }(y.Component);
        function F(N, B) {
          var U = function(W) {
            return y.createElement(M, B, y.createElement(N, W));
          }, H = N.displayName || N.name || "Unknown";
          return U.displayName = "withErrorBoundary(" + H + ")", U;
        }
        function O(N) {
          var B = y.useState(null), U = B[0], H = B[1];
          if (N != null) throw N;
          if (U != null) throw U;
          return H;
        }
        a.ErrorBoundary = M, a.useErrorHandler = O, a.withErrorBoundary = F, Object.defineProperty(a, "__esModule", { value: !0 });
      });
    }), Uxe = R(() => {
    }), wL, EL, TL, O$ = R(() => {
      wL = Y(xe()), EL = { color: void 0, size: void 0, className: void 0, style: void 0, attr: void 0 }, TL = wL.default.createContext && wL.default.createContext(EL);
    });
    function D$(r) {
      return r && r.map(function(s, a) {
        return L0.default.createElement(s.tag, id({ key: a }, s.attr), D$(s.child));
      });
    }
    function B0(r) {
      return function(s) {
        return L0.default.createElement(zxe, id({ attr: id({}, r.attr) }, s), D$(r.child));
      };
    }
    function zxe(r) {
      var s = function(a) {
        var d = r.attr, m = r.size, y = r.title, x = F$(r, ["attr", "size", "title"]), w = m || a.size || "1em", T;
        return a.className && (T = a.className), r.className && (T = (T ? T + " " : "") + r.className), L0.default.createElement("svg", id({ stroke: "currentColor", fill: "currentColor", strokeWidth: "0" }, a.attr, d, x, { className: T, style: id(id({ color: r.color || a.color }, a.style), r.style), height: w, width: w, xmlns: "http://www.w3.org/2000/svg" }), y && L0.default.createElement("title", null, y), r.children);
      };
      return TL !== void 0 ? L0.default.createElement(TL.Consumer, null, function(a) {
        return s(a);
      }) : s(EL);
    }
    var L0, id, F$, Vxe = R(() => {
      L0 = Y(xe()), O$(), id = function() {
        return id = Object.assign || function(r) {
          for (var s, a = 1, d = arguments.length; a < d; a++) {
            s = arguments[a];
            for (var m in s) Object.prototype.hasOwnProperty.call(s, m) && (r[m] = s[m]);
          }
          return r;
        }, id.apply(this, arguments);
      }, F$ = function(r, s) {
        var a = {};
        for (var d in r) Object.prototype.hasOwnProperty.call(r, d) && s.indexOf(d) < 0 && (a[d] = r[d]);
        if (r != null && typeof Object.getOwnPropertySymbols == "function") for (var m = 0, d = Object.getOwnPropertySymbols(r); m < d.length; m++) s.indexOf(d[m]) < 0 && Object.prototype.propertyIsEnumerable.call(r, d[m]) && (a[d[m]] = r[d[m]]);
        return a;
      };
    }), gi = R(() => {
      Uxe(), Vxe(), O$();
    }), Gxe = R(() => {
      gi();
    }), qxe = R(() => {
      gi();
    });
    function Hxe(r) {
      return B0({ attr: { viewBox: "0 0 512 512" }, child: [{ tag: "path", attr: { d: "M289.94 256l95-95A24 24 0 00351 127l-95 95-95-95a24 24 0 00-34 34l95 95-95 95a24 24 0 1034 34l95-95 95 95a24 24 0 0034-34z" } }] })(r);
    }
    var $xe = R(() => {
      gi();
    }), Wxe = R(() => {
      gi();
    }), Kxe = R(() => {
      gi();
    });
    function Yxe(r) {
      return B0({ attr: { viewBox: "0 0 8 16" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M5.5 3L7 4.5 3.25 8 7 11.5 5.5 13l-5-5 5-5z" } }] })(r);
    }
    function Xxe(r) {
      return B0({ attr: { viewBox: "0 0 8 16" }, child: [{ tag: "path", attr: { fillRule: "evenodd", d: "M7.5 8l-5 5L1 11.5 4.75 8 1 4.5 2.5 3l5 5z" } }] })(r);
    }
    var Qxe = R(() => {
      gi();
    }), Zxe = R(() => {
      gi();
    }), Jxe = R(() => {
      gi();
    }), e_e = R(() => {
      gi();
    }), t_e = R(() => {
      gi();
    }), n_e = R(() => {
      gi();
    }), r_e = R(() => {
      gi();
    }), i_e = R(() => {
      gi();
    }), s_e = R(() => {
      gi();
    }), o_e = R(() => {
      gi();
    });
    function a_e(r) {
      return B0({ attr: { fill: "none", viewBox: "0 0 24 24", stroke: "currentColor" }, child: [{ tag: "path", attr: { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: "2", d: "M9 5l7 7-7 7" } }] })(r);
    }
    var l_e = R(() => {
      gi();
    }), u_e = R(() => {
      gi();
    }), c_e = R(() => {
      gi();
    }), d_e = R(() => {
      gi();
    });
    function h_e(r) {
      return B0({ attr: { viewBox: "0 0 24 24", fill: "none" }, child: [{ tag: "path", attr: { d: "M6 9.65685L7.41421 11.0711L11.6569 6.82843L15.8995 11.0711L17.3137 9.65685L11.6569 4L6 9.65685Z", fill: "currentColor" } }, { tag: "path", attr: { d: "M6 14.4433L7.41421 13.0291L11.6569 17.2717L15.8995 13.0291L17.3137 14.4433L11.6569 20.1001L6 14.4433Z", fill: "currentColor" } }] })(r);
    }
    var p_e = R(() => {
      gi();
    });
    function f_e(r) {
      return B0({ attr: { viewBox: "0 0 16 16", fill: "currentColor" }, child: [{ tag: "path", attr: { d: "M14 10.44l-.413.56H2.393L2 10.46 7.627 5h.827L14 10.44z" } }] })(r);
    }
    var m_e = R(() => {
      gi();
    }), U1 = R(() => {
      Gxe(), qxe(), $xe(), Wxe(), Kxe(), Qxe(), Zxe(), Jxe(), e_e(), t_e(), n_e(), r_e(), i_e(), s_e(), o_e(), l_e(), u_e(), c_e(), d_e(), p_e(), m_e();
    }), Zi, B$, L$, j$, U$, z$, V$, G$, q$, H$, $$, W$, K$, Y$, X$, Q$, Z$, J$, e9, t9, g_e = R(() => {
      Zi = Y(xe()), it(), qh(), O0(), i$(), N$(), B$ = Y(jxe()), U1(), st(), qh(), zt(), L$ = { edges: { left: { from: "screenLeft", distance: 0.3 }, right: { from: "screenRight", distance: 0.3 }, top: { from: "screenTop", distance: 0.3 }, bottom: { from: "screenBottom", distance: 0.3 } } }, j$ = { width: 300, height: 300 }, U$ = ({ paneInstance: r }) => Zi.default.createElement(lL, { panelId: "pane-".concat(r.instanceId), defaultPosition: L$, minDims: j$ }, Zi.default.createElement(e9, { paneInstance: r })), V$ = ee(SL)(z$ || (z$ = $([`
  display: flex;
  flex-direction: column;

  box-shadow: 0px 5px 12px -4px rgb(0 0 0 / 22%);
  z-index: `, `;
`])), (r) => r.$zIndex), q$ = ee.div(G$ || (G$ = $([`
  width: 100%;
`]))), $$ = ee.div(H$ || (H$ = $([`
  display: flex;
  align-items: center;
  opacity: 1;
  position: absolute;
  right: 4px;
  top: 0;
  bottom: 0;
`]))), K$ = ee.button(W$ || (W$ = $([`
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 2px;
  font-size: 11px;
  height: 10px;
  width: 18px;
  color: #adadadb3;
  background: transparent;
  border: none;
  cursor: pointer;
  &:hover {
    color: white;
  }
`]))), X$ = ee(Uq)(Y$ || (Y$ = $([`
  position: relative;
  overflow: hidden;

  &:after {
    z-index: 10;
    position: absolute;
    inset: 0;
    display: block;
    content: ' ';
    pointer-events: none;

    #pointer-root:not(.normal) & {
      pointer-events: auto;
    }
  }
`]))), Z$ = ee.div(Q$ || (Q$ = $([`
  padding: 12px;

  & > pre {
    border: 1px solid #ff62624f;
    background-color: rgb(255 0 0 / 5%);
    margin: 8px 0;
    padding: 8px;
    font-family: monospace;
    overflow: scroll;
    color: #ff9896;
  }
`]))), J$ = (r) => Zi.default.createElement(Z$, null, "An Error occurred rendering this pane. Open the console for more info.", Zi.default.createElement("pre", null, JSON.stringify({ message: r.error.message, stack: r.error.stack }, null, 2))), e9 = ({ paneInstance: r }) => {
        var s;
        let [a, d] = (0, Zi.useState)(null), m = r.definition.mount;
        (0, Zi.useLayoutEffect)(() => {
          if (!a) return;
          let P = m({ paneId: r.instanceId, node: a });
          if (typeof P == "function") return P;
        }, [a, m, r.instanceId]);
        let y = (0, Zi.useCallback)(() => {
          pe().paneManager.destroyPane(r.instanceId);
        }, [r]), x = (0, Zi.useCallback)(() => {
          pe().paneManager.bringPaneToFront(r.instanceId);
        }, [r]), w = ((s = nn(pe().atomP.historic.paneFocusOrder)) != null ? s : []).indexOf(r.instanceId), T = w >= 0 ? sm.pluginPanes + w : sm.pluginPanes;
        return Zi.default.createElement(V$, { "data-testid": "theatre-pane-wrapper-".concat(r.instanceId), $zIndex: T, onMouseDown: x }, Zi.default.createElement(mL, null, Zi.default.createElement(Nk, null, Zi.default.createElement($$, null, Zi.default.createElement(K$, { onClick: y, title: "Close Pane" }, Zi.default.createElement(Hxe, null))), Zi.default.createElement(q$, null, r.instanceId))), Zi.default.createElement(B$.ErrorBoundary, { FallbackComponent: J$ }, Zi.default.createElement(X$, { "data-testid": "theatre-pane-content-".concat(r.instanceId), ref: d })));
      }, t9 = U$;
    });
    function j0(r) {
      return JSON.stringify(CL(r));
    }
    function CL(r) {
      return jy(r) ? Object.keys(r).sort().reduce((s, a) => (s[a] = CL(r[a]), s), {}) : Array.isArray(r) ? r.map(CL) : r;
    }
    var y_e = R(() => {
      tn();
    }), n9, U0, r9 = R(() => {
      n9 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", U0 = (r = 21) => {
        let s = "", a = r;
        for (; a--; ) s += n9[Math.random() * 64 | 0];
        return s;
      };
    });
    function i9() {
      return U0(10);
    }
    function v_e() {
      return U0(10);
    }
    function s9() {
      return U0(10);
    }
    function o9() {
      return U0(10);
    }
    var Ji, Nl = R(() => {
      y_e(), r9(), Ji = { forSheet() {
        return "sheet";
      }, forSheetObject(r) {
        return j0({ o: r.address.objectKey });
      }, forSubSequence(r) {
        return j0({ ss: r });
      }, forSheetObjectProp(r, s) {
        return j0({ o: r.address.objectKey, p: s });
      }, forTrackKeyframe(r, s, a) {
        return j0({ o: r.address.objectKey, t: s, k: a });
      }, forSheetObjectAggregateKeyframe(r, s) {
        return Ji.forCompoundPropAggregateKeyframe(r, [], s);
      }, forSheetAggregateKeyframe(r, s) {
        return j0({ o: r.address.sheetId, pos: s });
      }, forCompoundPropAggregateKeyframe(r, s, a) {
        return j0({ o: r.address.objectKey, p: s, pos: a });
      } };
    }), PL, AL, a9 = R(() => {
      PL = ut(), AL = (r, s) => {
        let a = PL.prism.memo(r, () => new PL.Atom(s), []);
        return a.set(s), a;
      };
    }), l9, Ol, sd = R(() => {
      it(), Ol = sa(l9 || (l9 = $([`
  font-weight: 300;
  font-size: 11px;
  color: `, `;
  text-shadow: 0.5px 0.5px 2px rgba(0, 0, 0, 0.3);
`])), (r) => r.isHighlighted === "self" ? "#CCC" : "#919191");
    });
    function z0(r, s) {
      let a = r;
      for (let d of s) a = a[d];
      return a;
    }
    var z1 = R(() => {
    });
    function b_e() {
      let r = 0, s = new d9.Atom({ hasLock: !1 });
      return { replaceLock(a, d) {
        let m = r++, y = s.get();
        return y.hasLock && y.cleanup(), s.set({ hasLock: !0, lockId: m, cleanup: d, deepPath: x_e(u9(a)) }), function() {
          let x = s.get();
          x.hasLock && x.lockId === m && (x.cleanup(), s.set({ hasLock: !1 }));
        };
      }, getIsPropHighlightedD(a) {
        let d = z0(s.pointer.deepPath, u9(a));
        return (0, h9.prism)(() => {
          let m = (0, c9.val)(d);
          return m === !0 ? "self" : m ? "descendent" : null;
        });
      } };
    }
    function u9(r) {
      return [r.projectId, r.sheetId, r.objectKey, ...r.pathToProp];
    }
    function x_e(r) {
      let s = {};
      return fe(s, r, !0), s;
    }
    var c9, d9, h9, p9, __e = R(() => {
      c9 = ut(), d9 = ut(), h9 = ut(), z1(), Re(), p9 = b_e();
    });
    function kL(r, s) {
      (0, f9.useLayoutEffect)(() => {
        if (!r || s.type !== "propWithChildren" && s.type !== "primitiveProp" && s.type !== "sheetObject") return;
        let a = null, d = V(L({}, s.sheetObject.address), { pathToProp: s.type === "sheetObject" ? [] : s.pathToProp });
        function m() {
          a = p9.replaceLock(d, () => {
          });
        }
        function y() {
          a?.();
        }
        return r.addEventListener("mouseenter", m), r.addEventListener("mouseleave", y), () => {
          a?.(), r.removeEventListener("mouseenter", m), r.removeEventListener("mouseleave", y);
        };
      }, [r]);
    }
    var f9, ML = R(() => {
      f9 = Y(xe()), __e();
    });
    function RL(r) {
      let [s, a] = (0, IL.useState)(null);
      return (0, IL.useLayoutEffect)(() => (r && a(r.getBoundingClientRect()), () => {
        a(null);
      }), [r]), s;
    }
    var IL, m9 = R(() => {
      IL = Y(xe());
    }), V1, qk, g9, y9, v9, b9, x9, _9, S9 = R(() => {
      k0(), V1 = Y(xe()), it(), qk = 26, y9 = ee.li(g9 || (g9 = $([`
  height: `, `px;
  padding: 0 12px;
  margin: 0;
  display: flex;
  align-items: center;
  font-size: 11px;
  font-weight: 400;
  position: relative;
  color: `, `;
  cursor: `, `;

  &:after {
    position: absolute;
    inset: 2px 1px;
    display: block;
    content: ' ';
    pointer-events: none;
    z-index: -1;
    border-radius: 3px;
  }

  &:hover:after {
    background-color: `, `;
  }
`])), qk, (r) => r.enabled ? "white" : "#8f8f8f", (r) => r.enabled ? "normal" : "not-allowed", (r) => r.enabled ? "rgba(63, 174, 191, 0.75)" : "initial"), b9 = ee.span(v9 || (v9 = $([""]))), x9 = (r) => V1.default.createElement(y9, { onClick: r.enabled ? r.onClick : kl, enabled: r.enabled, title: r.enabled ? void 0 : "Disabled" }, V1.default.createElement(b9, null, V1.default.createElement(V1.default.Fragment, null, r.label))), _9 = x9;
    });
    function S_e(r) {
      let s = (0, NL.useRef)(r);
      s.current = r, (0, NL.useEffect)(() => {
        let a = (d) => s.current(d);
        return window.addEventListener("keydown", a), () => {
          window.removeEventListener("keydown", a);
        };
      }, []);
    }
    var NL, w_e = R(() => {
      NL = Y(xe());
    }), G1, w9, E9, T9, C9, P9, A9, k9, OL, M9 = R(() => {
      G1 = Y(xe()), S9(), it(), Al(), Xn(), w9 = 190, E9 = !0, C9 = ee.ul(T9 || (T9 = $([`
  position: absolute;
  min-width: `, `px;
  z-index: 10000;
  background: `, `;
  backdrop-filter: blur(2px);
  color: white;
  list-style-type: none;
  padding: 2px 0;
  margin: 0;
  border-radius: 1px;
  cursor: default;
  `, `;
  border-radius: 3px;
`])), w9, Uu(0.2, "#111"), Ln), A9 = ee.div(P9 || (P9 = $([`
  padding: 4px 10px;
  border-bottom: 1px solid #6262626d;
  color: #adadadb3;
  font-size: 11px;
  font-weight: 500;
`]))), k9 = G1.default.forwardRef((r, s) => G1.default.createElement(C9, { ref: s }, E9 && r.displayName ? G1.default.createElement(A9, null, r.displayName) : null, r.items.map((a, d) => G1.default.createElement(_9, { key: "item-".concat(d), label: a.label, enabled: a.enabled !== !1, onClick: (m) => {
        a.callback && a.callback(m), r.onRequestClose();
      } })))), OL = k9;
    }), R9, I9, Hk, N9, q1, O9, D9, E_e = R(() => {
      m9(), R9 = Y(xe()), I9 = Y(xe()), Hk = Y(xe()), N9 = Y(oi()), sL(), S9(), im(), w_e(), M9(), q1 = 20, O9 = (r) => {
        let [s, a] = (0, Hk.useState)(null), d = RL(s), m = Uk();
        (0, Hk.useLayoutEffect)(() => {
          if (!d || !s) return;
          let w = { left: d.width / 2, top: qk / 2 + (r.displayName ? qk : 0) }, T = { left: r.clickPoint.clientX - w.left, top: r.clickPoint.clientY - w.top };
          T.left < 0 ? T.left = 0 : T.left + d.width > m.width && (T.left = m.width - d.width), T.top < 0 ? T.top = 0 : T.top + d.height > m.height && (T.top = m.height - d.height), s.style.left = T.left + "px", s.style.top = T.top + "px";
          let P = (M) => {
            (M.clientX < T.left - q1 || M.clientX > T.left + d.width + q1 || M.clientY < T.top - q1 || M.clientY > T.top + d.height + q1) && r.onRequestClose();
          };
          return window.addEventListener("mousemove", P), () => {
            window.removeEventListener("mousemove", P);
          };
        }, [d, s, r.clickPoint, m, r.onRequestClose]);
        let y = (0, I9.useContext)(P0);
        S_e((w) => {
          w.key === "Escape" && r.onRequestClose();
        });
        let x = (0, R9.useMemo)(() => {
          let w = Array.isArray(r.items) ? r.items : r.items();
          return w.length > 0 ? w : [{ label: r.displayName ? "No actions for ".concat(r.displayName) : "No actions found", enabled: !1 }];
        }, [r.items]);
        return (0, N9.createPortal)(Hk.default.createElement(OL, { items: x, onRequestClose: r.onRequestClose, displayName: r.displayName, ref: a }), y);
      }, D9 = O9;
    }), $k, F9, B9, T_e = R(() => {
      $k = Y(xe()), F9 = (r, s) => {
        let [a, d] = (0, $k.useState)({ isOpen: !1 }), m = (0, $k.useCallback)(() => d({ isOpen: !1 }), []);
        return (0, $k.useEffect)(() => {
          if (!r || s.disabled === !0) {
            d({ isOpen: !1 });
            return;
          }
          let y = (x) => {
            d({ isOpen: !0, event: x }), x.preventDefault(), x.stopPropagation();
          };
          return r.addEventListener("contextmenu", y), () => {
            r.removeEventListener("contextmenu", y);
          };
        }, [r, s.disabled]), [a, m];
      }, B9 = F9;
    }), L9, j9, U9, C_e = R(() => {
      it(), j9 = ee.input.attrs({ type: "checkbox" })(L9 || (L9 = $([`
  outline: none;
`]))), U9 = j9;
    });
    function P_e({ propConfig: r, editingTools: s, value: a, autoFocus: d }) {
      let m = (0, DL.useCallback)((y) => {
        s.permanentlySetValue(!!y.target.checked);
      }, [r, s]);
      return DL.default.createElement(V9, { checked: a, onChange: m, autoFocus: d });
    }
    var DL, z9, V9, G9, A_e = R(() => {
      DL = Y(xe()), it(), C_e(), V9 = ee(U9)(z9 || (z9 = $([`
  margin-left: 6px;

  :focus {
    outline: 1px solid #555;
  }
`]))), G9 = P_e;
    });
    function Wk(r) {
      return (s) => {
        r.forEach((a) => {
          typeof a == "function" ? a(s) : a != null && (a.current = s);
        });
      };
    }
    var Kk = R(() => {
    });
    function FL(r, s, a) {
      (0, q9.useEffect)(() => {
        if (!r || a === !1) return;
        let d = Array.isArray(r) ? r.filter((y) => y) : [r], m = (y) => {
          d.every((x) => !y.composedPath().includes(x)) && s(y);
        };
        return window.addEventListener("mousedown", m, { capture: !0, passive: !1 }), () => {
          window.removeEventListener("mousedown", m, { capture: !0, passive: !1 });
        };
      }, [r, a]);
    }
    var q9, BL = R(() => {
      q9 = Y(xe());
    });
    function k_e(r) {
      return isNaN(r) ? "NaN" : h1(r) ? r.toFixed(0) : z(r, 3).toString();
    }
    var H9, $9, od, W9, Yk, K9, Y9, X9, Q9, Z9, J9, eW, tW, V0, H1 = R(() => {
      tn(), H9 = Y(xe()), $9 = Y(xe()), od = Y(xe()), it(), Kk(), Hn(), BL(), li(), Yk = ee.div(W9 || (W9 = $([`
  height: 100%;
  width: 100%;
  position: relative;
  z-index: 0;
  box-sizing: border-box;
  display: flex;
  align-items: center;

  &:after {
    position: absolute;
    inset: 1px 0 2px;
    display: block;
    content: ' ';
    background-color: transparent;
    border: 1px solid transparent;
    z-index: -2;
    box-sizing: border-box;
    border-radius: 1px;
  }

  &:hover,
  &.dragging,
  &.editingViaKeyboard {
    &:after {
      background-color: #10101042;
      border-color: #00000059;
    }
  }
`]))), Y9 = ee.input(K9 || (K9 = $([`
  background: transparent;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.9);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  cursor: ew-resize;
  text-align: left;
  width: 100%;
  height: calc(100% - 4px);
  border-radius: 2px;

  &:focus {
    cursor: text;
  }
`]))), Q9 = ee.div(X9 || (X9 = $([`
  position: absolute;
  inset: 3px 2px 4px;
  transform: scale(var(--percentage), 1);
  transform-origin: top left;
  background-color: #2d5561;
  z-index: -1;
  border-radius: 2px;
  pointer-events: none;

  `, ".dragging &, ", `.noFocus:hover & {
    background-color: #338198;
  }
`])), Yk, Yk), J9 = ee.div(Z9 || (Z9 = $([`
  display: contents;
`]))), eW = (r) => !0, tW = (r) => {
        var s;
        let [a] = kn({ mode: "noFocus" }), d = (s = r.isValid) != null ? s : eW, m = (0, od.useRef)(r);
        m.current = r;
        let y = (0, od.useRef)(null);
        FL(y.current, () => {
          y.current.blur();
        }, a.current.mode === "editingViaKeyboard");
        let x = (0, od.useRef)(null), w = (0, od.useMemo)(() => {
          let H = (he) => {
            let ie = he.target, { value: ye } = ie, Ee = a.current;
            a.current = V(L({}, Ee), { currentEditedValueInString: ye });
            let ve = parseFloat(ye);
            !isFinite(ve) || !d(ve) || m.current.temporarilySetValue(ve);
          }, W = () => {
            a.current.mode === "editingViaKeyboard" && (Q(), a.current = { mode: "noFocus" }), r.onBlur && r.onBlur();
          }, Q = () => {
            let he = a.current, ie = parseFloat(he.currentEditedValueInString);
            !isFinite(ie) || !d(ie) || he.valueBeforeEditing === ie ? m.current.discardTemporaryValue() : m.current.permanentlySetValue(ie);
          }, ne = (he) => {
            he.key === "Escape" ? (m.current.discardTemporaryValue(), a.current = { mode: "noFocus" }, y.current.blur()) : (he.key === "Enter" || he.key === "Tab") && (Q(), y.current.blur());
          }, ce = (he) => {
            a.current.mode === "noFocus" && (y.current.focus(), he.preventDefault()), he.stopPropagation();
          }, ue = () => {
            a.current.mode === "noFocus" ? se() : a.current.mode;
          }, se = () => {
            let he = m.current.value;
            a.current = { mode: "editingViaKeyboard", currentEditedValueInString: String(he), valueBeforeEditing: he }, setTimeout(() => {
              y.current.focus(), y.current.setSelectionRange(0, 100);
            });
          }, Oe;
          return { inputChange: H, onBlur: W, transitionToDraggingMode: () => {
            var he;
            let ie = m.current.value;
            Oe = (he = y.current) == null ? void 0 : he.getBoundingClientRect().width, a.current = { mode: "dragging" };
            let ye = ie, Ee = ie;
            return x.current = document.body.style.cursor, { onDrag(ve, Xe, Se, nt) {
              let De = Se.altKey ? nt / 10 : nt, Ce = Ee + r.nudge({ deltaX: De, deltaFraction: De / Oe, magnitude: 1 });
              Ee = r.range ? ir(Ce, r.range[0], r.range[1]) : Ce, m.current.temporarilySetValue(Ee);
            }, onDragEnd(ve) {
              ve ? (ye === Ee ? m.current.discardTemporaryValue() : m.current.permanentlySetValue(Ee), a.current = { mode: "noFocus" }) : (m.current.discardTemporaryValue(), a.current = { mode: "noFocus" });
            }, onClick() {
              y.current.focus(), y.current.setSelectionRange(0, 100);
            } };
          }, onInputKeyDown: ne, onClick: ce, onFocus: ue };
        }, []);
        (0, H9.useEffect)(() => () => {
          w.onBlur();
        }, []);
        let T = a.current.mode !== "editingViaKeyboard" ? k_e(r.value) : a.current.currentEditedValueInString;
        typeof T == "number" && isNaN(T) && (T = "NaN");
        let P = [y];
        r.inputRef && P.push(r.inputRef);
        let M = od.default.createElement(Y9, { key: "input", type: "text", onChange: w.inputChange, value: T, onBlur: w.onBlur, onKeyDown: w.onInputKeyDown, onClick: w.onClick, onFocus: w.onFocus, ref: Wk(P), onMouseDown: (H) => {
          H.stopPropagation();
        }, onDoubleClick: (H) => {
          H.preventDefault(), H.stopPropagation();
        }, autoFocus: r.autoFocus }), { range: F } = r, O = parseFloat(T), N = F ? od.default.createElement(Q9, { style: { "--percentage": ir((O - F[0]) / (F[1] - F[0]), 0, 1) } }) : null, [B, U] = (0, $9.useState)(null);
        return Fr(B, { debugName: "form/BasicNumberInput", onDragStart: w.transitionToDraggingMode, lockCSSCursorTo: "ew-resize", shouldPointerLock: !0, disabled: a.current.mode === "editingViaKeyboard" }), od.default.createElement(Yk, { className: r.className + " " + a.current.mode }, od.default.createElement(J9, { ref: U }, M), N);
      }, V0 = tW;
    });
    function M_e({ propConfig: r, editingTools: s, value: a, autoFocus: d }) {
      let m = (0, LL.useCallback)((y) => r.nudgeFn(V(L({}, y), { config: r })), [r]);
      return LL.default.createElement(V0, { value: a, temporarilySetValue: s.temporarilySetValue, discardTemporaryValue: s.discardTemporaryValue, permanentlySetValue: s.permanentlySetValue, range: r.range, nudge: m, autoFocus: d });
    }
    var LL, nW, R_e = R(() => {
      H1(), LL = Y(xe()), nW = M_e;
    });
    function I_e({ value: r, onChange: s, options: a, autoFocus: d }) {
      let m = (0, $1.useCallback)((y) => {
        s(String(y.target.value));
      }, [s]);
      return $1.default.createElement(jL, { role: "radiogroup" }, Object.keys(a).map((y, x) => $1.default.createElement(sW, { key: "label-" + x, "data-checked": r === y }, a[y], $1.default.createElement(aW, { type: "radio", checked: r === y, value: y, onChange: m, name: "switchbox", autoFocus: d }))));
    }
    var $1, rW, jL, iW, sW, oW, aW, lW, N_e = R(() => {
      Al(), $1 = Y(xe()), it(), jL = ee.form(rW || (rW = $([`
  display: flex;
  flex-direction: row;
  align-items: stretch;
  vertical-align: middle;
  justify-content: stretch;
  height: 24px;
  width: 100%;
`]))), sW = ee.label(iW || (iW = $([`
  padding: 0 0.5em;
  background: transparent;
  /* background: #373748; */
  display: flex;
  align-items: center;
  justify-content: center;
  flex-grow: 1;
  color: #a7a7a7;
  border: 1px solid transparent;
  box-sizing: border-box;
  border-right-width: 0px;

  & + &:last-child {
    border-right-width: 1px;
  }

  `, `:hover > & {
    border-color: #1c2123;
    /* background-color: #373748; */
    /* color: `, `; */
  }

  &&:hover {
    background-color: #464654;
  }

  &&[data-checked='true'] {
    color: white;
    background: #3f3f4c;
  }
`])), jL, EB(0.1, "white")), aW = ee.input(oW || (oW = $([`
  position: absolute;
  opacity: 0;
  pointer-events: none;
  width: 0;
  height: 0;
`]))), lW = I_e;
    });
    function O_e({ value: r, onChange: s, options: a, className: d, autoFocus: m }) {
      let y = (0, am.useCallback)((x) => {
        s(String(x.target.value));
      }, [s]);
      return am.default.createElement(cW, null, am.default.createElement(fW, { className: d, value: r, onChange: y, autoFocus: m }, Object.keys(a).map((x, w) => am.default.createElement("option", { key: "option-" + w, value: x }, a[x]))), am.default.createElement(hW, null, am.default.createElement(h_e, null)));
    }
    var am, uW, cW, dW, hW, pW, fW, mW, D_e = R(() => {
      am = Y(xe()), it(), U1(), cW = ee.div(uW || (uW = $([`
  width: 100%;
  position: relative;
`]))), hW = ee.div(dW || (dW = $([`
  position: absolute;
  right: 0px;
  top: 0;
  bottom: 0;
  width: 1.5em;
  font-size: 14px;
  display: flex;
  align-items: center;
  color: #6b7280;
  pointer-events: none;
`]))), fW = ee.select(pW || (pW = $([`
  appearance: none;
  background-color: transparent;
  box-sizing: border-box;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.85);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  text-align: left;
  width: 100%;
  border-radius: 2px;
  /*
  looks like putting percentages in the height of a select box doesn't work in Firefox. Not sure why.
  So we're hard-coding the height to 26px, unlike all other inputs that use a relative height.
  */
  height: 26px /* calc(100% - 4px); */;

  @supports (-moz-appearance: none) {
    /* Ugly hack to remove the extra left padding that shows up only in Firefox */
    text-indent: -2px;
  }

  &:hover,
  &:focus {
    background-color: #10101042;
    border-color: #00000059;
  }
`]))), mW = O_e;
    });
    function F_e({ propConfig: r, editingTools: s, value: a, autoFocus: d }) {
      let m = (0, Xk.useCallback)((y) => {
        s.permanentlySetValue(y);
      }, [r, s]);
      return r.as === "menu" ? Xk.default.createElement(mW, { value: a, onChange: m, options: r.valuesAndLabels, autoFocus: d }) : Xk.default.createElement(lW, { value: a, onChange: m, options: r.valuesAndLabels, autoFocus: d });
    }
    var Xk, gW, B_e = R(() => {
      Xk = Y(xe()), N_e(), D_e(), gW = F_e;
    }), yW, W1, vW, bW, xW, _W, Hh, G0 = R(() => {
      it(), yW = Y(xe()), W1 = Y(xe()), Kk(), Hn(), BL(), bW = ee.input.attrs({ type: "text" })(vW || (vW = $([`
  background: transparent;
  border: 1px solid transparent;
  color: rgba(255, 255, 255, 0.9);
  padding: 1px 6px;
  font: inherit;
  outline: none;
  cursor: text;
  text-align: left;
  width: 100%;
  height: calc(100% - 4px);
  border-radius: 2px;
  border: 1px solid transparent;
  box-sizing: border-box;

  &:hover {
    background-color: #10101042;
    border-color: #00000059;
  }

  &:hover,
  &:focus {
    cursor: text;
    background-color: #10101042;
    border-color: #00000059;
  }

  &.invalid {
    border-color: red;
  }
`]))), xW = (r) => !0, _W = (r) => {
        var s, a;
        let [d] = kn({ mode: "noFocus" }), m = (s = r.isValid) != null ? s : xW, y = (0, W1.useRef)(r);
        y.current = r;
        let x = (0, W1.useRef)(null);
        FL(x.current, () => {
          x.current.blur();
        }, d.current.mode === "editingViaKeyboard");
        let w = (0, W1.useMemo)(() => {
          let M = (W) => {
            let Q = W.target, { value: ne } = Q, ce = d.current;
            d.current = V(L({}, ce), { currentEditedValueInString: ne }), m(ne) && y.current.temporarilySetValue(ne);
          }, F = () => {
            var W, Q;
            d.current.mode === "editingViaKeyboard" && (O(), d.current = { mode: "noFocus" }), (Q = (W = y.current).onBlur) == null || Q.call(W);
          }, O = () => {
            let W = d.current, Q = W.currentEditedValueInString;
            m(Q) ? W.valueBeforeEditing === Q ? y.current.discardTemporaryValue() : y.current.permanentlySetValue(Q) : y.current.discardTemporaryValue();
          }, N = (W) => {
            W.key === "Escape" ? (y.current.discardTemporaryValue(), d.current = { mode: "noFocus" }, x.current.blur()) : (W.key === "Enter" || W.key === "Tab") && (O(), x.current.blur());
          }, B = (W) => {
            d.current.mode === "noFocus" && (x.current.focus(), W.preventDefault()), W.stopPropagation();
          }, U = () => {
            d.current.mode === "noFocus" ? H() : d.current.mode;
          }, H = () => {
            let W = y.current.value;
            d.current = { mode: "editingViaKeyboard", currentEditedValueInString: String(W), valueBeforeEditing: W }, setTimeout(() => {
              x.current.focus();
            });
          };
          return { inputChange: M, onBlur: F, onInputKeyDown: N, onClick: B, onFocus: U };
        }, []);
        (0, yW.useEffect)(() => () => {
          w.onBlur();
        }, []);
        let T = d.current.mode !== "editingViaKeyboard" ? r.value : d.current.currentEditedValueInString, P = [x];
        return r.inputRef && P.push(r.inputRef), W1.default.createElement(bW, { key: "input", type: "text", className: "".concat((a = r.className) != null ? a : "", " ").concat(m(T) ? "" : "invalid"), onChange: w.inputChange, value: T, onBlur: w.onBlur, onKeyDown: w.onInputKeyDown, onClick: w.onClick, onFocus: w.onFocus, ref: Wk(P), onMouseDown: (M) => {
          M.stopPropagation();
        }, onDoubleClick: (M) => {
          M.preventDefault(), M.stopPropagation();
        }, autoFocus: r.autoFocus });
      }, Hh = _W;
    });
    function L_e({ editingTools: r, value: s, autoFocus: a }) {
      return SW.default.createElement(Hh, { value: s, temporarilySetValue: r.temporarilySetValue, discardTemporaryValue: r.discardTemporaryValue, permanentlySetValue: r.permanentlySetValue, autoFocus: a });
    }
    var SW, wW, j_e = R(() => {
      SW = Y(xe()), G0(), wW = L_e;
    });
    function U_e(r) {
      r = r.trim().toLowerCase();
      let s = r.match(VL);
      if (!s) return { r: 0, g: 0, b: 0, a: 1 };
      let a = z_e(s[1]);
      return { r: parseInt(a.substr(0, 2), 16) / 255, g: parseInt(a.substr(2, 2), 16) / 255, b: parseInt(a.substr(4, 2), 16) / 255, a: parseInt(a.substr(6, 2), 16) / 255 };
    }
    function UL(r, { removeAlphaIfOpaque: s = !1 } = {}) {
      let a = (r.a * 255 | 256).toString(16).slice(1), d = (r.r * 255 | 256).toString(16).slice(1) + (r.g * 255 | 256).toString(16).slice(1) + (r.b * 255 | 256).toString(16).slice(1) + (s && a === "ff" ? "" : a);
      return "#".concat(d);
    }
    function zL(r) {
      return V(L({}, r), { toString() {
        return UL(this, { removeAlphaIfOpaque: !0 });
      } });
    }
    function z_e(r) {
      switch (r.length) {
        case 3:
          return "".concat(r.repeat(2), "ff");
        case 4:
          let s = r.substr(0, 3), a = r[3];
          return "".concat(s.repeat(2)).concat(a.repeat(2));
        case 6:
          return "".concat(r, "ff");
      }
      return r;
    }
    var VL, EW = R(() => {
      VL = /^#*([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
    });
    function Qk(r) {
      let s = (0, GL.useRef)(r), a = (0, GL.useRef)((d) => {
        s.current && s.current(d);
      });
      return s.current = r, a.current;
    }
    var GL, TW = R(() => {
      GL = Y(xe());
    }), lm, Zk = R(() => {
      lm = (r, s = 0, a = 1) => r > a ? a : r < s ? s : r;
    }), K1, qL, CW, HL, $L = R(() => {
      K1 = Y(xe()), qL = (0, K1.createContext)(void 0), CW = ({ children: r }) => {
        let [s, a] = (0, K1.useState)(!1);
        return K1.default.createElement(qL.Provider, { value: { editing: s, setEditing: a } }, r);
      }, HL = () => (0, K1.useContext)(qL);
    }), $h, q0, PW, Jk, WL, KL, AW, kW, MW, RW, Y1, eM = R(() => {
      $h = Y(xe()), TW(), Zk(), it(), $L(), q0 = (r) => "touches" in r, PW = (r, s) => {
        for (let a = 0; a < r.length; a++) if (r[a].identifier === s) return r[a];
        return r[0];
      }, Jk = (r) => r && r.ownerDocument.defaultView || self, WL = (r, s, a) => {
        let d = r.getBoundingClientRect(), m = q0(s) ? PW(s.touches, a) : s;
        return { left: lm((m.pageX - (d.left + Jk(r).pageXOffset)) / d.width), top: lm((m.pageY - (d.top + Jk(r).pageYOffset)) / d.height) };
      }, KL = (r) => {
        !q0(r) && r.preventDefault();
      }, AW = (r, s) => s && !q0(r), MW = ee.div(kW || (kW = $([`
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  border-radius: inherit;
  outline: none;
  /* Don't trigger the default scrolling behavior when the event is originating from this element */
  touch-action: none;
`]))), RW = (r) => {
        var s = r, { onMove: a, onKey: d } = s, m = re(s, ["onMove", "onKey"]);
        let y = (0, $h.useRef)(null), x = Qk(a), w = Qk(d), T = (0, $h.useRef)(null), P = (0, $h.useRef)(!1), { setEditing: M } = HL(), [F, O, N] = (0, $h.useMemo)(() => {
          let B = ({ nativeEvent: ne }) => {
            let ce = y.current;
            if (ce && (KL(ne), !(AW(ne, P.current) || !ce))) {
              if (q0(ne)) {
                P.current = !0;
                let ue = ne.changedTouches || [];
                ue.length && (T.current = ue[0].identifier);
              }
              ce.focus(), M(!0), x(WL(ce, ne, T.current)), Q(!0);
            }
          }, U = (ne) => {
            KL(ne), (q0(ne) ? ne.touches.length > 0 : ne.buttons > 0) && y.current ? x(WL(y.current, ne, T.current)) : (M(!1), Q(!1));
          }, H = (ne) => {
            M(!1), Q(!1);
          }, W = (ne) => {
            let ce = ne.which || ne.keyCode;
            ce < 37 || ce > 40 || (ne.preventDefault(), w({ left: ce === 39 ? 0.05 : ce === 37 ? -0.05 : 0, top: ce === 40 ? 0.05 : ce === 38 ? -0.05 : 0 }));
          };
          function Q(ne) {
            let ce = P.current, ue = y.current, se = Jk(ue), Oe = ne ? se.addEventListener : se.removeEventListener;
            Oe(ce ? "touchmove" : "mousemove", U), Oe(ce ? "touchend" : "mouseup", H);
          }
          return [B, W, Q];
        }, [w, x]);
        return (0, $h.useEffect)(() => N, [N]), $h.default.createElement(MW, V(L({}, m), { onTouchStart: F, onMouseDown: F, ref: y, onKeyDown: O, tabIndex: 0, role: "slider" }));
      }, Y1 = $h.default.memo(RW);
    }), YL, IW, NW, OW, DW, FW, BW, tM, XL = R(() => {
      YL = Y(xe()), it(), eM(), NW = ee(Y1)(IW || (IW = $([""]))), DW = ee.div(OW || (OW = $([`
  position: absolute;
  z-index: 1;
  box-sizing: border-box;
  width: 16px;
  height: 16px;
  transform: translate(-50%, -50%);
  background-color: #fff;
  border: 1px solid #ffffff00;
  border-radius: 2px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);

  `, `:focus & {
    transform: translate(-50%, -50%) scale(1.1);
  }
`])), NW), BW = ee.div(FW || (FW = $([`
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  border-radius: inherit;
`]))), tM = ({ className: r, color: s, left: a, top: d = 0.5 }) => {
        let m = { top: "".concat(d * 100, "%"), left: "".concat(a * 100, "%") };
        return YL.default.createElement(DW, { style: m, className: r }, YL.default.createElement(BW, { style: { backgroundColor: s } }));
      };
    }), Ds, nM = R(() => {
      Ds = (r, s = 0, a = Math.pow(10, s)) => Math.round(a * r) / a;
    }), QL, rM, iM, LW, jW, sM = R(() => {
      nM(), QL = ({ h: r, s, v: a, a: d }) => {
        let m = (200 - s) * a / 100;
        return { h: Ds(r), s: Ds(m > 0 && m < 200 ? s * a / 100 / (m <= 100 ? m : 200 - m) * 100 : 0), l: Ds(m / 2), a: Ds(d, 2) };
      }, rM = (r) => {
        let { h: s, s: a, l: d } = QL(r);
        return "hsl(".concat(s, ", ").concat(a, "%, ").concat(d, "%)");
      }, iM = (r) => {
        let { h: s, s: a, l: d, a: m } = QL(r);
        return "hsla(".concat(s, ", ").concat(a, "%, ").concat(d, "%, ").concat(m, ")");
      }, LW = ({ h: r, s, v: a, a: d }) => {
        r = r / 360 * 6, s = s / 100, a = a / 100;
        let m = Math.floor(r), y = a * (1 - s), x = a * (1 - (r - m) * s), w = a * (1 - (1 - r + m) * s), T = m % 6;
        return { r: Ds([a, x, y, y, w, a][T] * 255), g: Ds([w, a, a, x, y, y][T] * 255), b: Ds([y, y, w, a, a, x][T] * 255), a: Ds(d, 2) };
      }, jW = ({ r, g: s, b: a, a: d }) => {
        let m = Math.max(r, s, a), y = m - Math.min(r, s, a), x = y ? m === r ? (s - a) / y : m === s ? 2 + (a - r) / y : 4 + (r - s) / y : 0;
        return { h: Ds(60 * (x < 0 ? x + 6 : x)), s: Ds(m ? y / m * 100 : 0), v: Ds(m / 255 * 100), a: d };
      };
    }), X1, UW, zW, VW, GW, qW, HW, V_e = R(() => {
      X1 = Y(xe()), eM(), XL(), sM(), Zk(), nM(), it(), zW = ee.div(UW || (UW = $([`
  position: relative;
  height: 16px;
  border-radius: 2px;

  background: linear-gradient(
    to right,
    #f00 0%,
    #ff0 17%,
    #0f0 33%,
    #0ff 50%,
    #00f 67%,
    #f0f 83%,
    #f00 100%
  );
`]))), GW = ee(tM)(VW || (VW = $([`
  z-index: 2;
`]))), qW = ({ className: r, hue: s, onChange: a }) => X1.default.createElement(zW, { className: r }, X1.default.createElement(Y1, { onMove: (d) => {
        a({ h: 360 * d.left });
      }, onKey: (d) => {
        a({ h: lm(s + d.left * 360, 0, 360) });
      }, "aria-label": "Hue", "aria-valuetext": Ds(s) }, X1.default.createElement(GW, { left: s / 360, color: rM({ h: s, s: 100, v: 100, a: 1 }) }))), HW = X1.default.memo(qW);
    }), Q1, $W, WW, KW, YW, XW, QW, G_e = R(() => {
      Q1 = Y(xe()), eM(), XL(), sM(), Zk(), nM(), it(), WW = ee.div($W || ($W = $([`
  position: relative;
  flex-grow: 1;
  border-color: transparent; /* Fixes https://github.com/omgovich/react-colorful/issues/139 */
  border-bottom: 12px solid #000;
  border-radius: 2px;
  background-image: linear-gradient(to top, #000, rgba(0, 0, 0, 0)),
    linear-gradient(to right, #fff, rgba(255, 255, 255, 0));

  // Improve elements rendering on light backgrounds
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);
`]))), YW = ee(tM)(KW || (KW = $([`
  z-index: 3;
`]))), XW = ({ hsva: r, onChange: s }) => {
        let a = (y) => {
          s({ s: y.left * 100, v: 100 - y.top * 100 });
        }, d = (y) => {
          s({ s: lm(r.s + y.left * 100, 0, 100), v: lm(r.v - y.top * 100, 0, 100) });
        }, m = { backgroundColor: rM({ h: r.h, s: 100, v: 100, a: 1 }) };
        return Q1.default.createElement(WW, { style: m }, Q1.default.createElement(Y1, { onMove: a, onKey: d, "aria-label": "Color", "aria-valuetext": "Saturation ".concat(Ds(r.s), "%, Brightness ").concat(Ds(r.v), "%") }, Q1.default.createElement(YW, { top: 1 - r.v / 100, left: r.s / 100, color: rM(r) })));
      }, QW = Q1.default.memo(XW);
    }), Z1, ZW, JW, e7, t7, n7, r7, i7, q_e = R(() => {
      Z1 = Y(xe()), eM(), XL(), sM(), Zk(), nM(), it(), JW = ee.div(ZW || (ZW = $([`
  position: relative;
  height: 16px;
  border-radius: 2px;
  // Checkerboard
  background-color: #fff;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>');
`]))), t7 = ee.div.attrs(({ colorFrom: r, colorTo: s }) => ({ style: { backgroundImage: "linear-gradient(90deg, ".concat(r, ", ").concat(s, ")") } }))(e7 || (e7 = $([`
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
  border-radius: inherit;

  // Improve rendering on light backgrounds
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.05);
`]))), r7 = ee(tM)(n7 || (n7 = $([`
  // Checkerboard
  background-color: #fff;
  background-image: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill-opacity=".05"><rect x="8" width="8" height="8"/><rect y="8" width="8" height="8"/></svg>');
`]))), i7 = ({ className: r, hsva: s, onChange: a }) => {
        let d = (w) => {
          a({ a: w.left });
        }, m = (w) => {
          a({ a: lm(s.a + w.left) });
        }, y = iM(Object.assign({}, s, { a: 0 })), x = iM(Object.assign({}, s, { a: 1 }));
        return Z1.default.createElement(JW, { className: r }, Z1.default.createElement(t7, { colorFrom: y, colorTo: x }), Z1.default.createElement(Y1, { onMove: d, onKey: m, "aria-label": "Alpha", "aria-valuetext": "".concat(Ds(s.a * 100), "%") }, Z1.default.createElement(r7, { left: s.a, color: iM(s) })));
      };
    }), oM, s7 = R(() => {
      oM = (r, s) => {
        if (r === s) return !0;
        for (let a in r) if (r[a] !== s[a]) return !1;
        return !0;
      };
    });
    function H_e(r, s, a, d) {
      let { editing: m } = HL(), [y, x] = (0, ad.useState)(s), w = Qk(a), T = Qk(d), P = m ? y : s, [M, F] = (0, ad.useState)(() => r.toHsva(P)), O = (0, ad.useRef)({ color: P, hsva: M }), N = (0, ad.useRef)({ color: P, hsva: M });
      (0, ad.useEffect)(() => {
        m && x(O.current.color);
      }, [m]), (0, ad.useEffect)(() => {
        let U = r.fromHsva(M);
        m ? !oM(M, O.current.hsva) && !r.equal(U, O.current.color) && (O.current = { hsva: M, color: U }, x(U), w(U)) : !oM(M, N.current.hsva) && !r.equal(U, N.current.color) && (N.current = { hsva: M, color: U }, O.current = { hsva: M, color: U }, T(U));
      }, [m, M, r, w, T]), (0, ad.useEffect)(() => {
        if (!m && !r.equal(P, N.current.color)) {
          let U = r.toHsva(P);
          N.current = { hsva: U, color: P }, F(U);
        }
      }, [m, P, r]);
      let B = (0, ad.useCallback)((U) => {
        F((H) => Object.assign({}, H, U));
      }, []);
      return [M, B];
    }
    var ad, $_e = R(() => {
      ad = Y(xe()), s7(), TW(), $L();
    }), H0, o7, a7, l7, W_e = R(() => {
      H0 = Y(xe()), V_e(), G_e(), q_e(), $_e(), it(), a7 = ee.div(o7 || (o7 = $([`
  position: relative;
  display: flex;
  gap: 4px;
  flex-direction: column;
  width: 200px;
  height: 200px;
  user-select: none;
  cursor: default;
`]))), l7 = (r) => {
        var s = r, { className: a, colorModel: d, color: m = d.defaultColor, temporarilySetValue: y, permanentlySetValue: x, discardTemporaryValue: w } = s, T = re(s, ["className", "colorModel", "color", "temporarilySetValue", "permanentlySetValue", "discardTemporaryValue"]);
        let [P, M] = H_e(d, m, y, x);
        return (0, H0.useEffect)(() => () => {
          w();
        }, []), H0.default.createElement(a7, L({}, T), H0.default.createElement(QW, { hsva: P, onChange: M }), H0.default.createElement(HW, { hue: P.h, onChange: M }), H0.default.createElement(i7, { hsva: P, onChange: M }));
      };
    }), ZL, u7, c7, d7, h7, K_e = R(() => {
      ZL = Y(xe()), W_e(), s7(), sM(), $L(), u7 = (r) => ({ r: r.r / 255, g: r.g / 255, b: r.b / 255, a: r.a }), c7 = (r) => ({ r: r.r * 255, g: r.g * 255, b: r.b * 255, a: r.a }), d7 = { defaultColor: { r: 0, g: 0, b: 0, a: 1 }, toHsva: (r) => jW(c7(r)), fromHsva: (r) => u7(LW(r)), equal: oM }, h7 = (r) => ZL.default.createElement(CW, null, ZL.default.createElement(l7, V(L({}, r), { permanentlySetValue: (s) => {
        r.permanentlySetValue(s);
      }, colorModel: d7 })));
    }), Y_e = R(() => {
      K_e();
    }), p7, f7, JL, m7 = R(() => {
      p7 = Y(xe()), f7 = (0, p7.createContext)({}), JL = f7;
    });
    function X_e(r, s, a) {
      let d = (m) => {
        let y = r.getBoundingClientRect();
        (m.clientX < y.left - s || m.clientX > y.left + y.width + s || m.clientY < y.top - s || m.clientY > y.top + y.height + s) && a(m);
      };
      return window.addEventListener("mousemove", d), () => {
        window.removeEventListener("mousemove", d);
      };
    }
    var Q_e = R(() => {
    }), g7, aM, e3, y7, t3, v7 = R(() => {
      g7 = Y(xe()), aM = Y(xe()), sL(), m9(), m7(), Hn(), BL(), Q_e(), k0(), tn(), e3 = 8, y7 = (r) => {
        var s, a;
        let d = r.children(), [m, y] = kn(null), x = d.props.style ? L({}, d.props.style) : {};
        x.position = "absolute";
        let w = RL(y), T = RL(r.target), P = Uk(), [M, F] = (0, aM.useState)({});
        return (0, aM.useLayoutEffect)(() => {
          var O, N, B;
          if (!w || !y || !T) return;
          let U = (O = r.verticalGap) != null ? O : 8, H = {}, W = (N = r.verticalPlacement) != null ? N : "bottom", Q = 0, ne = 0;
          W === "bottom" ? T.bottom + w.height + U < P.height ? (W = "bottom", Q = T.bottom + U, H.top = "0px") : T.top > w.height + U ? (W = "top", Q = T.top - (w.height + U), H.bottom = "0px", H.transform = "rotateZ(180deg)") : W = "overlay" : W === "top" && (T.top > w.height + U ? (W = "top", Q = T.top - (w.height + U), H.bottom = "0px", H.transform = "rotateZ(180deg)") : T.bottom + w.height + U < P.height ? (W = "bottom", Q = T.bottom + U, H.top = "0px") : W = "overlay");
          let ce = 0;
          if (W !== "overlay") {
            let ye = T.left + T.width / 2;
            ye < w.width / 2 ? (ne = U, ce = Math.max(ye - U, e3)) : ye + w.width / 2 > P.width ? (ne = P.width - (U + w.width), ce = Math.min(ye - ne, w.width - e3)) : (ne = ye - w.width / 2, ce = w.width / 2), H.left = ce + "px";
          }
          let { minX: ue = -1 / 0, maxX: se = 1 / 0, minY: Oe = -1 / 0, maxY: he = 1 / 0 } = (B = r.constraints) != null ? B : {}, ie = { left: ir(ne, ue, se - w.width), top: ir(Q, Oe, he + w.height) };
          if (y.style.left = ie.left + "px", y.style.top = ie.top + "px", F(H), r.onPointerOutside) return X_e(y, r.onPointerOutside.threshold, r.onPointerOutside.callback);
        }, [w, y, r.target, T, P, r.onPointerOutside]), FL([y, (s = r.target) != null ? s : null], (a = r.onClickOutside) != null ? a : kl), g7.default.createElement(JL.Provider, { value: M }, (0, aM.cloneElement)(d, { ref: m, style: x }));
      }, t3 = y7;
    });
    function ko(r, s) {
      let { isPointerBeingCaptured: a } = ZH("usePopover"), [d, m] = kn({ isOpen: !1 }), y = (0, Fs.useRef)(r), x = (0, Fs.useCallback)((O) => {
        d.current = { isOpen: !1 };
      }, []), w = (0, Fs.useCallback)((O, N) => {
        var B;
        let U = typeof y.current == "function" ? y.current() : y.current;
        function H() {
          P.childHasFocusRef.current || U.closeOnClickOutside !== !1 && x("clicked outside popover");
        }
        d.current = { isOpen: !0, clickPoint: { clientX: O.clientX, clientY: O.clientY }, target: N, opts: U, onClickOutside: H, onPointerOutside: U.closeWhenPointerIsDistant === !1 ? void 0 : { threshold: (B = U.pointerDistanceThreshold) != null ? B : 100, callback: () => {
          P.childHasFocusRef.current || a() || x("pointer outside");
        } } };
      }, []), T = (0, Fs.useCallback)((...O) => {
        d.current.isOpen ? x("toggled") : w(...O);
      }, []), P = Z_e({ state: m }), [, M] = (0, Fs.useContext)(g3);
      (0, Fs.useEffect)(() => {
        let O;
        return m.isOpen && (O = M()), () => O?.();
      }, [m.isOpen]);
      let F = (0, Fs.useContext)(P0);
      return { node: m.isOpen ? (0, b7.createPortal)(Fs.default.createElement(n3.Provider, { value: P.childPopoverLock }, Fs.default.createElement(t3, { children: s, target: m.target, onClickOutside: m.onClickOutside, onPointerOutside: m.onPointerOutside, constraints: m.opts.constraints, verticalGap: m.opts.verticalGap })), F) : Fs.default.createElement(Fs.default.Fragment, null), open: w, close: x, toggle: T, isOpen: m.isOpen };
    }
    function Z_e(r) {
      let s = (0, Fs.useContext)(n3);
      (0, Fs.useEffect)(() => {
        if (r.state.isOpen) {
          let d = s.takeFocus();
          return () => {
            d.releaseFocus();
          };
        }
      }, [r.state.isOpen]);
      let a = (0, Fs.useRef)(!1);
      return { childHasFocusRef: a, childPopoverLock: { takeFocus() {
        return a.current = !0, { releaseFocus() {
          a.current = !1;
        } };
      } } };
    }
    var Fs, b7, n3, Dl = R(() => {
      hL(), Hn(), Fs = Y(xe()), b7 = Y(oi()), im(), v7(), nY(), n3 = Fs.default.createContext({ takeFocus() {
        return { releaseFocus() {
        } };
      } });
    }), ld, x7, _7, S7, w7, E7, T7, C7, P7, A7, k7, M7, R7, J_e = R(() => {
      ld = Y(xe()), it(), m7(), _7 = ee.div(x7 || (x7 = $([`
  position: absolute;
  width: 0;
  height: 0;
  color: var(--popover-arrow-color);
  pointer-events: none;
`]))), w7 = ee.div(S7 || (S7 = $([`
  width: 12px;
  height: 8px;
  position: absolute;
  left: -7px;
  top: -8px;
  text-align: center;
  line-height: 0;
`]))), T7 = ee.path(E7 || (E7 = $([`
  fill: var(--popover-bg);
`]))), P7 = ee.path(C7 || (C7 = $([`
  fill: var(--popover-inner-stroke);
`]))), k7 = ee.path(A7 || (A7 = $([`
  fill: var(--popover-outer-stroke);
`]))), M7 = (0, ld.forwardRef)(({ className: r }, s) => {
        let a = (0, ld.useContext)(JL);
        return ld.default.createElement(_7, { className: r, ref: s, style: L({}, a) }, ld.default.createElement(w7, null, ld.default.createElement("svg", { width: "12", height: "8", viewBox: "0 0 12 8", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, ld.default.createElement(k7, { d: "M6 0L0 6H12L6 0Z" }), ld.default.createElement(P7, { d: "M6 1.5L0 7.5H12L6 1.5Z" }), ld.default.createElement(T7, { d: "M6 3L0 9H12L6 3Z" }))));
      }), R7 = M7;
    }), lM, r3, I7, N7, O7, Mo, Fl = R(() => {
      Xn(), Al(), lM = Y(xe()), it(), J_e(), r3 = Uu(0.05, "#2a2a31"), N7 = ee.div(I7 || (I7 = $([`
  position: absolute;
  --popover-bg: `, `;
  --popover-inner-stroke: #505159;
  --popover-outer-stroke: #111;

  background: var(--popover-bg);

  color: white;
  padding: 0;
  margin: 0;
  cursor: default;
  `, `;
  border-radius: 3px;
  z-index: 10000;
  border: 1px solid var(--popover-inner-stroke);
  box-shadow: 0 0 0 1px var(--popover-outer-stroke), 0 6px 8px -4px black;
  backdrop-filter: blur(8px);

  & a {
    color: inherit;
  }
`])), r3, Ln), O7 = lM.default.forwardRef(({ children: r, className: s, showPopoverEdgeTriangle: a = !0 }, d) => lM.default.createElement(N7, { className: s, ref: d }, a ? lM.default.createElement(R7, null) : void 0, r)), Mo = O7;
    });
    function e1e({ editingTools: r, value: s, autoFocus: a }) {
      let d = (0, qu.useRef)(null), m = (0, qu.useCallback)((x) => {
        let w = zL(U_e(x));
        r.permanentlySetValue(w);
      }, [r]), y = ko({ debugName: "RgbaPropEditor" }, () => qu.default.createElement(V7, null, qu.default.createElement(h7, { color: { r: s.r, g: s.g, b: s.b, a: s.a }, temporarilySetValue: (x) => {
        let w = zL(x);
        r.temporarilySetValue(w);
      }, permanentlySetValue: (x) => {
        let w = zL(x);
        r.permanentlySetValue(w);
      }, discardTemporaryValue: r.discardTemporaryValue })));
      return qu.default.createElement(qu.default.Fragment, null, qu.default.createElement(F7, null, qu.default.createElement(L7, { rgbaColor: s, ref: d, onClick: (x) => {
        y.toggle(x, d.current);
      } }), qu.default.createElement(U7, { value: UL(s, { removeAlphaIfOpaque: !0 }), temporarilySetValue: i3, discardTemporaryValue: i3, permanentlySetValue: m, isValid: (x) => !!x.match(VL), autoFocus: a })), y.node);
    }
    var qu, D7, F7, B7, L7, j7, U7, i3, z7, V7, G7, t1e = R(() => {
      EW(), EW(), qu = Y(xe()), Y_e(), it(), Dl(), G0(), Fl(), F7 = ee.div(D7 || (D7 = $([`
  display: flex;
  align-items: center;
  height: 100%;
  gap: 4px;
`]))), L7 = ee.div.attrs((r) => ({ style: { background: UL(r.rgbaColor) } }))(B7 || (B7 = $([`
  height: 18px;
  aspect-ratio: 1;
  border-radius: 99999px;
`]))), U7 = ee(Hh)(j7 || (j7 = $([`
  flex: 1;
`]))), i3 = () => {
      }, V7 = ee.div(z7 || (z7 = $([`
  position: absolute;
  background-color: `, `;
  color: white;
  margin: 0;
  cursor: default;
  border-radius: 3px;
  z-index: 10000;
  backdrop-filter: blur(8px);

  padding: 4px;
  pointer-events: all;

  border: none;
  box-shadow: none;
`])), r3), G7 = e1e;
    });
    function n1e({ propConfig: r, editingTools: s, value: a, autoFocus: d }) {
      let [m, y] = Bl.default.useState();
      (0, Bl.useEffect)(() => {
        y(a ? s.getAssetUrl(a) : void 0);
      }, [a]);
      let x = (0, Bl.useCallback)((T) => dt(this, null, function* () {
        let P = T.target.files[0];
        s.permanentlySetValue({ type: "image", id: void 0 });
        let M = yield s.createAsset(P);
        M ? s.permanentlySetValue({ type: "image", id: M }) : s.permanentlySetValue(a), T.target.value = null;
      }), [s, a]), w = !(a != null && a.id);
      return Bl.default.createElement(s3, { empty: w }, Bl.default.createElement(X7, { empty: w, title: w ? "Upload image" : '"'.concat(a.id, '" (Click to upload new image)') }, Bl.default.createElement(Z7, { type: "file", onChange: x, accept: "image/*,.hdr", autoFocus: d }), m ? Bl.default.createElement(eK, { src: m }) : Bl.default.createElement($7, null)), !w && Bl.default.createElement(nK, { title: "Delete image", onClick: () => {
        s.permanentlySetValue({ type: "image", id: void 0 });
      } }, Bl.default.createElement(ZB, null)));
    }
    var Bl, q7, s3, H7, $7, W7, K7, Y7, X7, Q7, Z7, J7, eK, tK, nK, rK, r1e = R(() => {
      Ok(), Bl = Y(xe()), it(), s3 = ee.div(q7 || (q7 = $([`
  display: flex;
  align-items: center;
  height: 100%;
  gap: 4px;
`]))), $7 = ee.div(H7 || (H7 = $([`
  position: absolute;
  inset: -5px;
  // rotate 45deg
  transform: rotate(45deg);
  --checker-color: #ededed36;
  &:hover {
    --checker-color: #ededed77;
  }
  // checkerboard background with 4px squares
  background-image: linear-gradient(
      45deg,
      var(--checker-color) 25%,
      transparent 25%
    ),
    linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),
    linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);
  background-size: 5px 5px;
`]))), X7 = ee.label(Y7 || (Y7 = $([`
  position: relative;
  cursor: default;
  box-sizing: border-box;

  height: 18px;
  aspect-ratio: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 16px;

  overflow: hidden;
  color: #ccc;
  &:hover {
    color: white;
  }

  border-radius: 99999px;
  border: 1px solid hwb(220deg 40% 52%);
  &:hover {
    border-color: hwb(220deg 45% 52%);
  }

  `, `
`])), (r) => r.empty ? sa(W7 || (W7 = $([""]))) : sa(K7 || (K7 = $([""])))), Z7 = ee.input.attrs({ type: "file" })(Q7 || (Q7 = $([`
  display: none;
`]))), eK = ee.img(J7 || (J7 = $([`
  position: absolute;
  inset: 0;
  height: 100%;
  aspect-ratio: 1;

  object-fit: cover;
`]))), nK = ee.button(tK || (tK = $([`
  display: flex;
  align-items: center;
  justify-content: center;
  outline: none;
  background: transparent;
  color: #a8a8a9;

  border: none;
  height: 100%;
  aspect-ratio: 1/1;

  opacity: 0;

  `, `:hover & {
    opacity: 0.8;
  }

  &:hover {
    opacity: 1;
    color: white;
  }
`])), s3), rK = n1e;
    });
    function i1e({ propConfig: r, editingTools: s, value: a, autoFocus: d }) {
      let [m, y] = Ll.default.useState();
      (0, Ll.useEffect)(() => {
        y(a ? s.getAssetUrl(a) : void 0);
      }, [a]);
      let x = (0, Ll.useCallback)((T) => dt(this, null, function* () {
        let P = T.target.files[0];
        s.permanentlySetValue({ type: "file", id: void 0 });
        let M = yield s.createAsset(P);
        M ? s.permanentlySetValue({ type: "file", id: M }) : s.permanentlySetValue(a), T.target.value = null;
      }), [s, a]), w = !(a != null && a.id);
      return Ll.default.createElement(o3, { empty: w }, Ll.default.createElement(cK, { empty: w, title: w ? "Upload file" : '"'.concat(a.id, '" (Click to upload new file)') }, Ll.default.createElement(hK, { type: "file", onChange: x, autoFocus: d }), m ? Ll.default.createElement(XB, null) : Ll.default.createElement(oK, null)), !w && Ll.default.createElement(fK, { title: "Delete file", onClick: () => {
        s.permanentlySetValue({ type: "file", id: void 0 });
      } }, Ll.default.createElement(ZB, null)));
    }
    var Ll, iK, o3, sK, oK, aK, lK, uK, cK, dK, hK, pK, fK, mK, s1e = R(() => {
      Ok(), Ll = Y(xe()), it(), o3 = ee.div(iK || (iK = $([`
  display: flex;
  align-items: center;
  height: 100%;
  gap: 4px;
`]))), oK = ee.div(sK || (sK = $([`
  position: absolute;
  inset: -5px;
  // rotate 45deg
  transform: rotate(45deg);
  --checker-color: #ededed36;
  &:hover {
    --checker-color: #ededed77;
  }
  // checkerboard background with 4px squares
  background-image: linear-gradient(
      45deg,
      var(--checker-color) 25%,
      transparent 25%
    ),
    linear-gradient(-45deg, var(--checker-color) 25%, transparent 25%),
    linear-gradient(45deg, transparent 75%, var(--checker-color) 75%),
    linear-gradient(-45deg, transparent 75%, var(--checker-color) 75%);
  background-size: 5px 5px;
`]))), cK = ee.label(uK || (uK = $([`
  position: relative;
  cursor: default;
  box-sizing: border-box;

  height: 18px;
  aspect-ratio: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 16px;

  overflow: hidden;
  color: #ccc;
  &:hover {
    color: white;
  }

  border-radius: 99999px;
  border: 1px solid hwb(220deg 40% 52%);
  &:hover {
    border-color: hwb(220deg 45% 52%);
  }

  `, `
`])), (r) => r.empty ? sa(aK || (aK = $([""]))) : sa(lK || (lK = $([""])))), hK = ee.input.attrs({ type: "file" })(dK || (dK = $([`
  display: none;
`]))), fK = ee.button(pK || (pK = $([`
  display: flex;
  align-items: center;
  justify-content: center;
  outline: none;
  background: transparent;
  color: #a8a8a9;

  border: none;
  height: 100%;
  aspect-ratio: 1/1;

  opacity: 0;

  `, `:hover & {
    opacity: 0.8;
  }

  &:hover {
    opacity: 1;
    color: white;
  }
`])), o3), mK = i1e;
    }), a3, gK = R(() => {
      A_e(), R_e(), B_e(), j_e(), t1e(), r1e(), s1e(), a3 = { number: nW, string: wW, boolean: G9, stringLiteral: gW, rgba: G7, image: rK, file: mK };
    });
    function uM(r) {
      let s = /* @__PURE__ */ new WeakMap();
      return (a) => (s.has(a) || s.set(a, r(a)), s.get(a));
    }
    var l3 = R(() => {
    });
    function Hu(r) {
      return r.type === "compound" || r.type === "enum";
    }
    function $0(r, s) {
      if (!r) return;
      let [a, ...d] = s;
      if (a === void 0) return r;
      if (!Hu(r)) return;
      let m = r.type === "enum" ? r.cases[a] : r.props[a];
      return $0(m, d);
    }
    function cM(r, s) {
      let a = s.deserializeAndSanitize(r);
      return a === void 0 ? s.default : a;
    }
    function o1e(r) {
      return !Hu(r);
    }
    function* W0(r, s) {
      if (r.type === "compound") for (let a in r.props) yield* St(W0(r.props[a], [...s, a]));
      else {
        if (r.type === "enum") throw new Error("Not implemented yet");
        return yield { path: s, conf: r };
      }
    }
    var u3, Wh = R(() => {
      l3(), u3 = uM((r) => {
        if (r.type === "enum") throw new Error("Not implemented yet for enums");
        for (let s in r.props) {
          let a = r.props[s];
          if (Hu(a)) {
            if (u3(a)) return !0;
          } else return !0;
        }
        return !1;
      });
    });
    function Kh(r, s) {
      return s.length === 0 ? r : qc(r, s);
    }
    var dM = R(() => {
      Nf();
    });
    function yK(r, s) {
      return r == null ? null : r instanceof Element && r.matches(s) ? r : yK(r.parentElement, s);
    }
    var a1e = R(() => {
    });
    function l1e(r) {
      let s = new pM.Atom(void 0), a = new pM.Atom({}), d = new pM.Atom({}), m = 0;
      return { addRelatedFlags(y, x) {
        let w = String(++m), T = x.map((P) => {
          let M = { flag: P.flag }, F = [P.affects, y, w];
          return d.setByPointer((O) => z0(O, F), M), F;
        });
        return () => {
          for (let P of T) d.setByPointer((M) => z0(M, P), void 0);
        };
      }, usePresenceFlag(y) {
      }, setUserHover(y) {
        let x = s.get();
        x !== y && (x && a.setByPointer((w) => w[x], !1), s.set(y), y && a.setByPointer((w) => w[y], !0));
      } };
    }
    function K0(r) {
      let s = hM.default.useContext(d3), a = s.usePresenceFlag(r);
      return { attrs: { [fM]: r }, flag: a, useRelations(d, m) {
        (0, c3.useEffect)(() => r && s.addRelatedFlags(r, d()), [r, ...m]);
      } };
    }
    function u1e(r) {
      let s = hM.default.useContext(d3), a = D0("PresenceListeners");
      (0, c3.useEffect)(() => {
        let d;
        if (!r) return;
        let m = (y) => {
          if (y.target instanceof Node) {
            let x = yK(y.target, "[".concat(fM, "]"));
            if (x) {
              let w = x.getAttribute(fM);
              d !== w && (d = w, s.setUserHover(w || void 0), a._debug("Updated current hover", { itemKey: w }));
              return;
            }
            d != null && (d = null, s.setUserHover(void 0), a._debug("Cleared current hover"));
          }
        };
        return r.addEventListener("mouseover", m), () => {
          r.removeEventListener("mouseover", m), d != null && (d = null, a._debug("Cleared current hover as part of cleanup"));
        };
      }, [r, s]);
    }
    var hM, c3, vK, pM, bK, d3, fM, J1 = R(() => {
      hM = Y(xe()), c3 = Y(xe()), om(), vK = ut(), pM = ut(), zt(), a1e(), z1(), bK = (0, vK.prism)(() => {
      }), bK.keepHot(), d3 = hM.default.createContext(l1e()), fM = "data-pi-key";
    }), ys, xK, eS, _K, h3, Yh, SK, p3, wK, EK, TK, mM, CK, PK, AK, kK, MK, RK, tS, IK, f3, gM = R(() => {
      Xn(), Al(), ys = Y(xe()), it(), J1(), eS = ee.div(xK || (xK = $([`
  display: flex;
  justify-content: center;
  align-items: center;
  width: 16px;
  margin: 0 0px 0 2px;
  position: relative;
  z-index: 0;
  opacity: 0.7;

  &:after {
    position: absolute;
    left: -14px;
    right: -14px;
    top: -2px;
    bottom: -2px;
    content: ' ';
    display: none;
    z-index: -1;
    background: `, `;
  }

  &:hover {
    opacity: 1;
    &:after {
      display: block;
    }
  }
`])), Uu(0.2, "black")), h3 = ee.div(_K || (_K = $([`
  background: none;
  position: relative;
  border: 0;
  transition: transform 0.1s ease-out;
  z-index: 0;
  outline: none;
  cursor: pointer;

  &:after {
    display: none;
    `, `:hover & {
      display: block;
    }
    position: absolute;
    left: -4px;
    right: -4px;
    top: -4px;
    bottom: -4px;
    content: ' ';
    z-index: -1;
  }
`])), eS), Yh = { offColor: "#555", onColor: "#e0c917" }, p3 = ee(h3)(SK || (SK = $([`
  &:hover {
    color: #e0c917;
  }

  color: `, `;
`])), (r) => r.presence === 2 ? "white" : r.isOn ? Yh.onColor : Yh.offColor), EK = sa(wK || (wK = $([`
  pointer-events: none !important;
`]))), mM = ee(h3)(TK || (TK = $([`
  color: `, `;

  `, `;
`])), (r) => r.flag === 2 ? "white" : r.available ? Yh.onColor : Yh.offColor, (r) => r.available ? Ln : EK), PK = ee(mM)(CK || (CK = $([`
  transform: translateX(2px);
  `, `:hover & {
    transform: translateX(-7px);
  }
`])), eS), kK = ee(mM)(AK || (AK = $([`
  transform: translateX(-2px);
  `, `:hover & {
    transform: translateX(7px);
  }
`])), eS), ((r) => {
        let s = ee.g(MK || (MK = $([`
    stroke-width: 1;
    `, `:hover & path {
      stroke-width: 3;
    }
  `])), mM);
        r.Prev = () => ys.default.createElement("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, ys.default.createElement(s, { transform: "translate(6 3)" }, ys.default.createElement("path", { d: "M4 1L1 4L4 7", stroke: "currentColor" }))), r.Next = () => ys.default.createElement("svg", { width: "12", height: "12", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, ys.default.createElement(s, { transform: "translate(1 3)" }, ys.default.createElement("path", { d: "M1 1L4 4L1 7", stroke: "currentColor" })));
        let a = ee.g(RK || (RK = $([`
    stroke-width: 0;
    `, `:hover & path {
      stroke: currentColor;
      stroke-width: 2;
    }
  `])), p3);
        r.Cur = () => ys.default.createElement("svg", { width: "8", height: "12", viewBox: "0 0 8 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, ys.default.createElement(a, { transform: "translate(1 4)" }, ys.default.createElement("path", { d: "M3 0L6 3L3 6L0 3L3 0Z", fill: "currentColor" })));
      })(tS || (tS = {})), IK = (r) => {
        var s, a, d, m, y;
        let x = K0((s = r.prev) == null ? void 0 : s.itemKey), w = K0(((a = r.cur) == null ? void 0 : a.type) === "on" ? r.cur.itemKey : void 0), T = K0((d = r.next) == null ? void 0 : d.itemKey);
        return ys.default.createElement(eS, null, ys.default.createElement(PK, L({ available: !!r.prev, onClick: (m = r.prev) == null ? void 0 : m.jump, flag: x.flag }, x.attrs), ys.default.createElement(tS.Prev, null)), ys.default.createElement(p3, L({ isOn: r.cur.type === "on", onClick: r.cur.toggle, presence: w.flag }, w.attrs), ys.default.createElement(tS.Cur, null)), ys.default.createElement(kK, L({ available: !!r.next, onClick: (y = r.next) == null ? void 0 : y.jump, flag: T.flag }, T.attrs), ys.default.createElement(tS.Next, null)));
      }, f3 = IK;
    }), yM, nS, NK, OK, DK, FK, BK, LK, jK, rS, UK = R(() => {
      Al(), yM = Y(xe()), it(), st(), gM(), Wh(), nS = { defaultState: { color: Uu(0.95, "#C4C4C4"), hoverColor: Uu(0.15, Yh.onColor) }, withStaticOverride: { color: Uu(0.85, "#C4C4C4"), hoverColor: Uu(0.15, Yh.onColor) } }, OK = ee.div(NK || (NK = $([`
  width: 16px;
  margin: 0 0px 0 2px;
  display: flex;
  justify-content: center;
  align-items: center;
  cursor: pointer;

  color: `, `;

  &:hover {
    color: `, `;
  }
`])), (r) => r.hasStaticOverride ? nS.withStaticOverride.color : nS.defaultState.color, (r) => r.hasStaticOverride ? nS.withStaticOverride.hoverColor : nS.defaultState.hoverColor), FK = ee.div(DK || (DK = $([`
  width: 5px;
  height: 5px;
  border-radius: 1px;
  transform: rotate(45deg);
  /* border: 1px solid currentColor; */
  background-color: currentColor;
`]))), LK = ee.div(BK || (BK = $([`
  width: 5px;
  height: 5px;
  background-color: currentColor;
  border-radius: 1px;
  transform: rotate(45deg);
`]))), jK = (r) => {
        let { hasStaticOverride: s, obj: a, propConfig: d, pathToProp: m } = r;
        return yM.default.createElement(OK, { hasStaticOverride: s, onClick: () => {
          pe().transaction(({ stateEditors: y }) => {
            for (let { path: x, conf: w } of W0(d, m)) {
              if (Hu(w)) continue;
              let T = V(L({}, a.address), { pathToProp: x });
              y.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(T, d);
            }
          });
        }, title: "Sequence this prop" }, s ? yM.default.createElement(LK, { title: "The default value is overridden" }) : yM.default.createElement(FK, { title: "This is the default value for this prop" }));
      }, rS = jK;
    });
    function zK(r, s, a) {
      if (!s || s.data.keyframes.length === 0) return VK;
      let d = m3.get(s.data);
      if (d && d[0] === a) return d[1];
      function m(x) {
        if (!s) return;
        let w = s.data.keyframes[x];
        return w && { kf: w, track: s, itemKey: Ji.forTrackKeyframe(r, s.id, w.id) };
      }
      let y = (() => {
        let x = s.data.keyframes.findIndex((T) => T.position >= a);
        if (x === -1) return { prev: m(s.data.keyframes.length - 1) };
        let w = m(x);
        return w.kf.position === a ? { prev: m(x - 1), cur: w, next: m(x + 1) } : { next: w, prev: m(x - 1) };
      })();
      return m3.set(s.data, [a, y]), y;
    }
    var m3, VK, GK = R(() => {
      Nl(), m3 = /* @__PURE__ */ new WeakMap(), VK = {};
    }), qK, c1e = R(() => {
      qK = {};
    });
    function HK(r, s, a) {
      let d = (0, Ga.getPointerParts)(r).path;
      return At(() => {
        if (!u3(a)) return { type: "AllStatic", beingScrubbed: !1, contextMenuItems: [], controlIndicators: um.default.createElement(rS, { hasStaticOverride: !1, obj: s, pathToProp: d, propConfig: a }) };
        let m = !!(0, Ga.val)(qc(pe().atomP.ephemeral.projects.stateByProjectId[s.address.projectId].stateBySheetId[s.address.sheetId].stateByObjectKey[s.address.objectKey].valuesBeingScrubbed, (0, Ga.getPointerParts)(r).path)), y = [], x = { beingScrubbed: m, contextMenuItems: y, controlIndicators: um.default.createElement(um.default.Fragment, null) }, w = (0, Ga.val)(s.template.getMapOfValidSequenceTracks_forStudio()), T = Kh(w, d), P = T !== void 0 && Object.keys(T).length !== 0, M = [], F = (0, Ga.val)(s.template.getStaticButNotSequencedOverrides()), O = Kh(F ?? qK, d) !== void 0;
        if (P) for (let N of W0(a, [])) {
          if (Hu(N.conf)) continue;
          let B = Kh(T, N.path);
          typeof B != "string" ? O = !0 : M.push(B);
        }
        if ((O || P) && y.push({ label: "Reset all to default", callback: () => {
          pe().transaction(({ unset: N }) => {
            N(r);
          });
        } }), P && y.push({ label: "Make all static", callback: () => {
          pe().transaction(({ stateEditors: N }) => {
            for (let { path: B, conf: U } of W0(a, [])) {
              if (Hu(U)) continue;
              let H = V(L({}, s.address), { pathToProp: [...d, ...B] }), W = z0(r, B);
              N.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsStatic(V(L({}, H), { value: s.getValueByPointer(W) }));
            }
          });
        } }), (!P || P && O) && y.push({ label: "Sequence all", callback: () => {
          pe().transaction(({ stateEditors: N }) => {
            for (let { path: B, conf: U } of W0(a, d)) {
              if (Hu(U)) continue;
              let H = V(L({}, s.address), { pathToProp: B });
              N.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(H, a);
            }
          });
        } }), P) {
          let N = Ga.prism.memo("controlIndicators", () => um.default.createElement(d1e, { pointerToProp: r, obj: s, possibleSequenceTrackIds: T, listOfDescendantTrackIds: M }), [T, M]);
          return V(L({}, x), { type: "HasSequences", controlIndicators: N });
        } else return V(L({}, x), { type: "AllStatic", controlIndicators: um.default.createElement(rS, { hasStaticOverride: O, obj: s, pathToProp: d, propConfig: a }) });
      }, []);
    }
    function d1e({ pointerToProp: r, obj: s, possibleSequenceTrackIds: a, listOfDescendantTrackIds: d }) {
      return At(() => {
        let m = (0, Ga.getPointerParts)(r).path, y = (0, Ga.val)(s.sheet.getSequence().positionPrism), x = d.map((N) => ({ trackId: N, track: (0, Ga.val)(s.template.project.pointers.historic.sheetsById[s.address.sheetId].sequence.tracksByObject[s.address.objectKey].trackData[N]) })).filter(({ track: N }) => !!N).map((N) => V(L({}, N), { nearbies: zK(s, { id: N.trackId, data: N.track, sheetObject: s }, y) })), w = x.find(({ nearbies: N }) => !!N.cur), T = x.every(({ nearbies: N }) => !!N.cur), P = x.reduce((N, B) => B.nearbies.prev && (N === void 0 || B.nearbies.prev.kf.position > N.kf.position) ? B.nearbies.prev : N, void 0), M = x.reduce((N, B) => B.nearbies.next && (N === void 0 || B.nearbies.next.kf.position < N.kf.position) ? B.nearbies.next : N, void 0), F = () => {
          T ? pe().transaction((N) => {
            N.unset(r);
          }) : w ? pe().transaction((N) => {
            N.set(r, (0, Ga.val)(r));
          }) : pe().transaction((N) => {
            N.set(r, (0, Ga.val)(r));
          });
        }, O = { cur: w ? { type: "on", itemKey: Ji.forCompoundPropAggregateKeyframe(s, m, y), toggle: F } : { toggle: F, type: "off" }, prev: P !== void 0 ? { position: P.kf.position, itemKey: Ji.forCompoundPropAggregateKeyframe(s, m, P.kf.position), jump: () => {
          s.sheet.getSequence().position = P.kf.position;
        } } : void 0, next: M !== void 0 ? { position: M.kf.position, itemKey: Ji.forCompoundPropAggregateKeyframe(s, m, M.kf.position), jump: () => {
          s.sheet.getSequence().position = M.kf.position;
        } } : void 0 };
        return um.default.createElement(f3, L({}, O));
      }, [r, s, a, d]);
    }
    var Ga, um, $K = R(() => {
      st(), dM(), zt(), Ga = ut(), Nf(), um = Y(xe()), UK(), Wh(), Nl(), z1(), gM(), GK(), c1e();
    });
    function h1e(r, s, a) {
      return (0, jl.prism)(() => {
        var d;
        let m = (0, jl.getPointerParts)(r).path, y = s.getValueByPointer(r), x = jl.prism.memo("editPropValue", () => {
          let B = null;
          return { temporarilySetValue(U) {
            B || (B = pe().scrub()), B.capture((H) => {
              H.set(r, U);
            });
          }, discardTemporaryValue() {
            B && (B.discard(), B = null);
          }, permanentlySetValue(U) {
            B ? (B.capture((H) => {
              H.set(r, U);
            }), B.commit(), B = null) : pe().transaction((H) => {
              H.set(r, U);
            });
          } };
        }, []), w = { createAsset: (B) => s.sheet.project.assetStorage.createAsset(B), getAssetUrl: (B) => B.id ? s.sheet.project.assetStorage.getAssetUrl(B.id) : void 0 }, T = (0, jl.val)(qc(pe().atomP.ephemeral.projects.stateByProjectId[s.address.projectId].stateBySheetId[s.address.sheetId].stateByObjectKey[s.address.objectKey].valuesBeingScrubbed, (0, jl.getPointerParts)(r).path)) === !0, P = [], M = V(L(L({}, x), w), { value: y, beingScrubbed: T, contextMenuItems: P, controlIndicators: Y0.default.createElement(Y0.default.Fragment, null) }), F = o1e(a);
        if (F) {
          let B = (0, jl.val)(s.template.getMapOfValidSequenceTracks_forStudio()), U = Kh(B, m);
          if (typeof U == "string") {
            P.push({ label: "Make static", callback: () => {
              pe().transaction(({ stateEditors: se }) => {
                let Oe = V(L({}, s.address), { pathToProp: m });
                se.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsStatic(V(L({}, Oe), { value: s.getValueByPointer(r) }));
              });
            } });
            let H = U, W = jl.prism.sub("lcr", () => {
              let se = (0, jl.val)(s.template.project.pointers.historic.sheetsById[s.address.sheetId].sequence.tracksByObject[s.address.objectKey].trackData[H]), Oe = (0, jl.val)(s.sheet.getSequence().positionPrism);
              return zK(s, se && { data: se, id: H, sheetObject: s }, Oe);
            }, [H]), Q;
            M.beingScrubbed ? Q = "Sequenced_OnKeyframe_BeingScrubbed" : W.cur ? Q = "Sequenced_OnKeyframe" : ((d = W.prev) == null ? void 0 : d.kf.connectedRight) === !0 ? Q = "Sequenced_BeingInterpolated" : Q = "Sequened_NotBeingInterpolated";
            let ne = () => {
              W.cur ? pe().transaction((se) => {
                se.unset(r);
              }) : pe().transaction((se) => {
                se.set(r, M.value);
              });
            }, ce = { cur: W.cur ? { type: "on", itemKey: W.cur.itemKey, toggle: ne } : { type: "off", toggle: ne }, prev: W.prev !== void 0 ? { itemKey: W.prev.itemKey, position: W.prev.kf.position, jump: () => {
              s.sheet.getSequence().position = W.prev.kf.position;
            } } : void 0, next: W.next !== void 0 ? { itemKey: W.next.itemKey, position: W.next.kf.position, jump: () => {
              s.sheet.getSequence().position = W.next.kf.position;
            } } : void 0 }, ue = Y0.default.createElement(f3, L({}, ce));
            return V(L({}, M), { type: "Sequenced", shade: Q, nearbyKeyframes: W, controlIndicators: ue });
          }
        }
        let O = (0, jl.val)(s.template.getStaticValues()), N = Kh(O, m);
        return typeof N < "u" && P.push({ label: "Reset to default", callback: () => {
          pe().transaction(({ unset: B }) => {
            B(r);
          });
        } }), F && P.push({ label: "Sequence", callback: () => {
          pe().transaction(({ stateEditors: B }) => {
            let U = V(L({}, s.address), { pathToProp: m });
            B.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(U, a);
          });
        } }), typeof N < "u" ? V(L({}, M), { type: "Static", shade: M.beingScrubbed ? "Static_BeingScrubbed" : "Static", controlIndicators: Y0.default.createElement(rS, { hasStaticOverride: !0, obj: s, pathToProp: m, propConfig: a }) }) : V(L({}, M), { type: "Default", shade: "Default", controlIndicators: Y0.default.createElement(rS, { hasStaticOverride: !0, obj: s, pathToProp: m, propConfig: a }) });
      });
    }
    function p1e(r, s, a) {
      if (vM.has(r)) return vM.get(r);
      {
        let d = h1e(r, s, a);
        return vM.set(r, d), d;
      }
    }
    function f1e(r, s, a) {
      let d = p1e(r, s, a);
      return Yn(d);
    }
    var Y0, jl, vM, m1e = R(() => {
      Nf(), Y0 = Y(xe()), jl = ut(), st(), dM(), zt(), Wh(), UK(), GK(), gM(), vM = /* @__PURE__ */ new WeakMap();
    });
    function g1e(r) {
      return bM.has(r) || bM.set(r, (WK++).toString()), bM.get(r);
    }
    var bM, WK, y1e = R(() => {
      bM = /* @__PURE__ */ new WeakMap(), WK = 0;
    }), KK, X0, YK, XK, QK, ZK, JK, g3, eY, tY, nY = R(() => {
      zt(), KK = Y(xe()), it(), _r(), qh(), Xn(), X0 = ut(), YK = "32px", ee.div(XK || (XK = $([`
  `, `;
  background-color: rgba(40, 43, 47, 0.8);
  position: fixed;
  right: 8px;
  top: 50px;
  // Temporary, see comment about CSS grid in SingleRowPropEditor.
  width: 280px;
  height: fit-content;
  z-index: `, `;

  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(14px);
  border-radius: 2px;

  display: `, `;

  &:hover {
    display: block;
  }

  @supports not (backdrop-filter: blur()) {
    background: rgba(40, 43, 47, 0.95);
  }
`])), Ln, sm.propsPanel, ({ pin: r }) => r ? "block" : "none"), ee.div(QK || (QK = $([`
  margin: 0 10px;
  color: #919191;
  font-weight: 500;
  font-size: 10px;
  user-select: none;
  `, `;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
`])), Ln), ee.div(ZK || (ZK = $([`
  height: `, `;
  display: flex;
  align-items: center;
`])), YK), ee.div(JK || (JK = $([`
  `, `;
  max-height: calc(100vh - 100px);
  overflow-y: scroll;
  &::-webkit-scrollbar {
    display: none;
  }

  scrollbar-width: none;
  padding: 0;
  user-select: none;

  /* Set the font-size for input values in the detail panel */
  font-size: 12px;
`])), Ln), g3 = (0, KK.createContext)([!1, () => () => {
      }]), eY = new X0.Atom(!1), tY = new X0.Atom(!1), (0, X0.prism)(() => {
        let r = (0, X0.val)(tY.prism), s = (0, X0.val)(eY.prism);
        return r || s;
      });
    });
    function Bs(r, s) {
      let [a, d] = B9(r, s), [, m] = (0, Q0.useContext)(g3);
      return (0, Q0.useEffect)(() => {
        var y;
        let x;
        return a.isOpen && ((y = s.onOpen) == null || y.call(s), x = m()), () => x?.();
      }, [a.isOpen, s.onOpen]), [a.isOpen ? Q0.default.createElement(D9, { items: s.menuItems, displayName: s.displayName, clickPoint: a.event, onRequestClose: d }) : rY, d, a.isOpen];
    }
    var Q0, rY, Ls = R(() => {
      Q0 = Y(xe()), E_e(), T_e(), nY(), rY = Q0.default.createElement(Q0.default.Fragment, null);
    }), ud, iY, y3, sY, xM, oY, v3, aY, lY, uY, cY, dY, hY, pY, fY, mY, b3, _M = R(() => {
      Xn(), ud = Y(xe()), U1(), it(), sd(), ML(), Ls(), y3 = ee.li(iY || (iY = $([`
  --depth: `, `;
  margin: 0;
  padding: 0;
  list-style: none;
`])), (r) => r.depth - 1), xM = ee.div(sY || (sY = $([`
  border-bottom: 1px solid #7695b705;
`]))), v3 = ee(xM)(oY || (oY = $([`
  padding-left: calc(var(--depth) * 10px);

  display: flex;
  align-items: stretch;
  color: `, `;

  box-sizing: border-box;

  `, `;
`])), A0.panel.body.compoudThing.label.color, (r) => r.isSelected && "background: blue"), lY = ee.span(aY || (aY = $([`
  `, `;
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding-right: 4px;
  line-height: 26px;
  flex-wrap: nowrap;
  width: 100%;

  `, `:hover & {
    color: #ccc;
  }
`])), Ol, v3), cY = ee.span(uY || (uY = $([`
  color: #6a9955;
  font-size: 12px;
  margin-right: auto;
  margin-left: 8px;
  opacity: 0.8;
  font-weight: normal;
  max-width: 150px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
`]))), hY = ee.span(dY || (dY = $([`
  width: 12px;
  padding: 8px;
  font-size: 9px;
  display: flex;
  align-items: center;

  transition: transform 0.05s ease-out, color 0.1s ease-out;
  transform: rotateZ(`, `deg);
  color: #66686a;

  &:hover {
    transform: rotateZ(`, `deg);
    color: #c0c4c9;
  }
`])), (r) => r.isCollapsed ? 0 : 90, (r) => r.isCollapsed ? 15 : 75), fY = ee.ul(pY || (pY = $([`
  margin: 0;
  padding: 0;
  list-style: none;
`]))), mY = ({ leaf: r, label: s, children: a, isSelectable: d, isSelected: m, toggleSelect: y, toggleCollapsed: x, isCollapsed: w, valueDisplay: T, contextMenuItems: P }) => {
        let M = Array.isArray(a) && a.length > 0, F = (0, ud.useRef)(null);
        kL(F.current, r);
        let [O] = Bs(F.current, { menuItems: P ?? [] });
        return r.shouldRender ? ud.default.createElement(y3, { depth: r.depth }, O, ud.default.createElement(v3, { ref: F, style: { height: r.nodeHeight + "px" }, isSelectable: d === !0, isSelected: m === !0, onClick: y, isEven: r.n % 2 === 0 }, ud.default.createElement(hY, { isCollapsed: w, onClick: x }, ud.default.createElement(a_e, null)), ud.default.createElement(lY, { onClick: x }, s), T && ud.default.createElement(cY, null, T)), M && ud.default.createElement(fY, null, a)) : null;
      }, b3 = mY;
    });
    function v1e(r, s) {
      if (r.length !== s.length) return !1;
      for (let a = 0; a < r.length; a++) if (r[a] !== s[a]) return !1;
      return !0;
    }
    function x3(r) {
      var s;
      let a = [];
      for (; ; ) {
        let d = a.length, m = (s = r[0]) == null ? void 0 : s[d];
        if (m === void 0) return a;
        for (let y of r) if (m !== y[d]) return a;
        a.push(m);
      }
    }
    var Ul, _3, Xh = R(() => {
      l3(), Ul = uM((r) => JSON.stringify(r)), _3 = (r) => JSON.parse(r);
    });
    function b1e(r, s) {
      let a = (0, S3.useRef)({ combo: r, listener: s });
      a.current = { combo: r, listener: s }, (0, S3.useEffect)(() => {
        function d(x) {
          x.key === a.current.combo && a.current.listener({ down: !0, event: x });
        }
        function m(x) {
          x.key === a.current.combo && a.current.listener({ down: !1, event: x });
        }
        function y(x) {
          a.current.listener({ down: !1, event: void 0 });
        }
        return document.addEventListener("keydown", d), document.addEventListener("keyup", m), window.addEventListener("blur", y), () => {
          document.removeEventListener("keydown", d), document.removeEventListener("keyup", m), window.removeEventListener("blur", y);
        };
      }, []);
    }
    var S3, x1e = R(() => {
      S3 = Y(xe());
    });
    function gY(r) {
      let [s, a] = (0, yY.useState)(!1);
      return b1e(r, ({ down: d }) => {
        a(d);
      }), s;
    }
    var yY, vY = R(() => {
      yY = Y(xe()), x1e();
    });
    function _1e(r) {
      let s = (0, w3.useMemo)(() => new bY.Atom(r), []);
      return (0, w3.useLayoutEffect)(() => {
        s.set(r);
      }, [r]), s;
    }
    var bY, w3, S1e = R(() => {
      bY = ut(), w3 = Y(xe());
    });
    function xY(r, s, a) {
      let d = (0, E3.pointer)({ root: {}, path: [] }), m = s(d);
      fe(r, (0, E3.getPointerParts)(m).path, a);
    }
    var E3, w1e = R(() => {
      E3 = ut(), Re();
    }), SM, _Y, js, zl = R(() => {
      SM = "data-pos", _Y = { checkIfMouseEventSnapToPos(r, s) {
        let a = r.composedPath().find((d) => d instanceof Element && d !== s?.ignore && d.hasAttribute(SM));
        if (a) {
          let d = parseFloat(a.getAttribute(SM));
          if (isFinite(d)) return d;
        }
        return null;
      }, includePositionSnapAttrs(r) {
        return { [SM]: r };
      } }, js = _Y;
    });
    function wM(r) {
      let s = r.type === "sheet" ? T1e(r) : T3(r);
      return { byPosition: E1e(s), tracks: s };
    }
    function E1e(r) {
      let s = /* @__PURE__ */ new Map();
      for (let a of r) for (let d of a.data.keyframes) {
        let m = s.get(d.position);
        m || (m = [], s.set(d.position, m)), m.push({ kf: d, track: a, itemKey: Ji.forTrackKeyframe(a.sheetObject, a.id, d.id) });
      }
      return s;
    }
    function T1e(r) {
      return r.children.filter((s) => s.type === "sheetObject").flatMap(T3);
    }
    function T3(r) {
      return r.children.flatMap((s) => s.type === "propWithChildren" ? T3(s) : C1e(s));
    }
    function C1e(r) {
      let s = r.sheetObject, a = s.address.projectId, d = pe().atomP.historic.coreByProject[a].sheetsById[s.address.sheetId].sequence.tracksByObject[s.address.objectKey], m = (0, C3.val)(d.trackIdByPropPath[Ul(r.pathToProp)]);
      if (!m) return [];
      let y = (0, C3.val)(d.trackData[m]);
      return y ? [{ id: m, data: y, sheetObject: s }] : [];
    }
    var C3, EM = R(() => {
      st(), C3 = ut(), Nl(), Xh();
    });
    function P1e(r, s) {
      let [a, d] = kn(null), m = D0("useCaptureSelection");
      return Fr(s, (0, Z0.useMemo)(() => ({ debugName: "DopeSheetSelectionView/useCaptureSelection", dontBlockMouseDown: !0, lockCSSCursorTo: "cell", onDragStart(y) {
        if (!y.shiftKey || y.target instanceof HTMLInputElement) return !1;
        let x = s.getBoundingClientRect(), w = y.clientX - x.left - (0, qa.val)(r.scaledSpace.leftPadding), T = (0, qa.val)(r.scaledSpace.toUnitSpace)(w);
        return a.current = { h: [T, T], v: [y.clientY - x.top, y.clientY - x.top] }, (0, qa.val)(r.selectionAtom).set({ current: void 0 }), { onDrag(P, M, F) {
          let O = s.getBoundingClientRect(), N = F.clientX - O.left - (0, qa.val)(r.scaledSpace.leftPadding), B = (0, qa.val)(r.scaledSpace.toUnitSpace)(N);
          a.current = { h: [a.current.h[0], B], v: [a.current.v[0], F.clientY - O.top] };
          let U = P3.boundsToSelection(m, (0, qa.val)(r), a.current);
          (0, qa.val)(r.selectionAtom).set({ current: U });
        }, onDragEnd(P) {
          a.current = null;
        } };
      } }), [r, s, a])), d;
    }
    var qa, Z0, cm, SY, wY, EY, P3, TY, CY, A3, PY, AY, A1e = R(() => {
      st(), li(), vY(), S1e(), w1e(), Hn(), zt(), qa = ut(), Z0 = Y(xe()), it(), zl(), EM(), om(), cm = 5, wY = ee.div(SY || (SY = $([`
  cursor: `, `;
`])), (r) => r.isShiftDown ? "cell" : "default"), EY = ({ layoutP: r, children: s, height: a }) => {
        let [d, m] = kn(null), y = gY("Shift"), x = P1e(r, m), w = (0, Z0.useRef)(x);
        return w.current = x, Z0.default.createElement(wY, { style: { height: a + "px" }, ref: d, isShiftDown: y, className: "selectionview" }, x && Z0.default.createElement(PY, { state: x, layoutP: r }), s);
      }, ((r) => {
        let s = (x, w, T, P, M) => {
          let F = wM(T);
          if (T.top + T.nodeHeight / 2 + cm > P.v[0] && T.top + T.nodeHeight / 2 - cm < P.v[1]) for (let [O, N] of F.byPosition) {
            let B = w.scaledSpace.toUnitSpace(cm);
            if (!(O + B <= P.h[0] || O - B >= P.h[1])) for (let U of N) xY(M, (H) => H[U.track.sheetObject.address.objectKey].byTrackId[U.track.id].byKeyframeId[U.kf.id], !0);
          }
          d(x, w, T, P, M);
        }, a = { sheet(x, w, T, P, M) {
          s(x, w, T, P, M);
        }, propWithChildren(x, w, T, P, M) {
          s(x, w, T, P, M);
        }, sheetObject(x, w, T, P, M) {
          s(x, w, T, P, M);
        }, primitiveProp(x, w, T, P, M) {
          let { sheetObject: F, trackId: O } = T;
          if (!O) return;
          let N = (0, qa.val)(pe().atomP.historic.coreByProject[F.address.projectId].sheetsById[F.address.sheetId].sequence.tracksByObject[F.address.objectKey].trackData[O]);
          if (!(P.v[0] > T.top + T.nodeHeight / 2 + cm || T.top + T.nodeHeight / 2 - cm > P.v[1])) for (let B of N.keyframes) {
            let U = w.scaledSpace.toUnitSpace(cm);
            if (!(B.position + U <= P.h[0])) {
              if (B.position - U >= P.h[1]) break;
              xY(M, (H) => H[F.address.objectKey].byTrackId[O].byKeyframeId[B.id], !0);
            }
          }
        } }, d = (x, w, T, P, M) => {
          if ("children" in T) for (let F of T.children) m(x, w, F, P, M);
        };
        function m(x, w, T, P, M) {
          if (!T.shouldRender) {
            d(x, w, T, P, M);
            return;
          }
          if (P.v[0] > T.top + T.heightIncludingChildren || T.top > P.v[1]) return;
          let F = a[T.type];
          F ? F(x, w, T, P, M) : d(x, w, T, P, M);
        }
        function y(x, w, T) {
          let P = {};
          T = A3(T);
          let M = w.tree;
          m(x.utilFor.internal(), w, M, T, P);
          let F = w.tree.sheet;
          return { type: "DopeSheetSelection", byObjectKey: P, getDragHandlers(O) {
            return { debugName: "DopeSheetSelectionView/boundsToSelection", onDragStart() {
              let N, B = w.scaledSpace.toUnitSpace;
              return { onDrag(U, H, W) {
                N && (N.discard(), N = void 0);
                let Q = js.checkIfMouseEventSnapToPos(W, { ignore: O.domNode }), ne = Q != null ? Q - O.positionAtStartOfDrag : B(U);
                N = pe().tempTransaction(({ stateEditors: ce }) => {
                  let ue = ce.coreByProject.historic.sheetsById.sequence.transformKeyframes;
                  for (let se of Object.keys(P)) {
                    let { byTrackId: Oe } = P[se];
                    for (let he of Object.keys(Oe)) {
                      let { byKeyframeId: ie } = Oe[he];
                      ue({ trackId: he, keyframeIds: Object.keys(ie), translate: ne, scale: 1, origin: 0, snappingFunction: F.getSequence().closestGridPosition, objectKey: se, projectId: O.projectId, sheetId: O.sheetId });
                    }
                  }
                });
              }, onDragEnd(U) {
                U ? N?.commit() : N?.discard();
              } };
            } };
          }, delete() {
            pe().transaction(({ stateEditors: O }) => {
              let N = O.coreByProject.historic.sheetsById.sequence.deleteKeyframes;
              for (let B of Object.keys(P)) {
                let { byTrackId: U } = P[B];
                for (let H of Object.keys(U)) {
                  let { byKeyframeId: W } = U[H];
                  N(V(L({}, F.address), { objectKey: B, trackId: H, keyframeIds: Object.keys(W) }));
                }
              }
            });
          } };
        }
        r.boundsToSelection = y;
      })(P3 || (P3 = {})), CY = ee.div(TY || (TY = $([`
  position: absolute;
  background: rgba(255, 255, 255, 0.1);
  border: 1px dashed rgba(255, 255, 255, 0.4);
  box-sizing: border-box;
`]))), A3 = (r) => ({ h: [...r.h].sort((s, a) => s - a), v: [...r.v].sort((s, a) => s - a) }), PY = ({ state: r, layoutP: s }) => {
        let a = _1e(r);
        return At(() => {
          let d = (0, qa.val)(a.pointer), m = A3(d), y = (0, qa.val)(s.scaledSpace.fromUnitSpace), x = (0, qa.val)(s.scaledSpace.leftPadding), w = m.h.map(y).map((O) => O + x), T = m.v[0], P = m.v[1] - m.v[0], M = w[0], F = w[1] - w[0];
          return Z0.default.createElement(CY, { style: { top: T + "px", height: P + "px", left: M + "px", width: F + "px" } });
        }, [s, a]);
      }, AY = EY;
    }), oa, kY, MY, RY, k3, M3, R3, IY, NY, OY, TM = R(() => {
      k0(), oa = Y(xe()), it(), ec(), kY = ut(), RY = ee.div(MY || (MY = $([`
  position: absolute;
  top: 30px;
  right: 0;
  left: 0;
  bottom: 0;
  overflow-x: hidden;
  overflow-y: scroll;
  z-index: `, `;

  &::-webkit-scrollbar {
    display: none;
  }

  scrollbar-width: none;
`])), () => Hl.scrollableArea), k3 = (0, oa.createContext)(kl), M3 = (0, oa.createContext)(null), R3 = () => (0, oa.useContext)(M3), IY = () => (0, oa.useContext)(k3), NY = (r) => {
        let s = (0, oa.useRef)(null), a = (0, oa.useCallback)((y) => {
          s.current.scrollBy(0, y.deltaY);
        }, []), d = (0, oa.useMemo)(() => new kY.Atom({ scrollTop: 0, clientHeight: 0 }), []), m = (0, oa.useCallback)(() => {
          s.current && d.set({ scrollTop: s.current.scrollTop, clientHeight: s.current.clientHeight });
        }, [d]);
        return (0, oa.useLayoutEffect)(() => {
          s.current && d.set({ scrollTop: s.current.scrollTop, clientHeight: s.current.clientHeight });
          let y = s.current;
          if (!y) return;
          let x = new ResizeObserver(() => {
            d.set({ scrollTop: y.scrollTop, clientHeight: y.clientHeight });
          });
          return x.observe(y), () => x.disconnect();
        }, [d]), oa.default.createElement(M3.Provider, { value: d.pointer }, oa.default.createElement(k3.Provider, { value: a }, oa.default.createElement(RY, { ref: s, onScroll: m, id: "VerticalScrollContainer" }, r.children)));
      }, OY = NY;
    }), I3, DY = R(() => {
      I3 = 'data:image/svg+xml,<svg width="34" height="34" viewBox="0 0 34 34" fill="none" xmlns="http://www.w3.org/2000/svg">%0D%0A  <path d="M1 7V1H7" stroke="%2374FFDE" stroke-width="0.25" />%0D%0A  <path d="M7 33H1L1 27" stroke="%2374FFDE" stroke-width="0.25" />%0D%0A  <path d="M33 27V33H27" stroke="%2374FFDE" stroke-width="0.25" />%0D%0A  <path d="M27 1L33 1V7" stroke="%2374FFDE" stroke-width="0.25" />%0D%0A</svg>';
    }), Vl, CM = R(() => {
      Vl = (r, s = r) => `
  left: `.concat(r * -0.5, `px;
  top: `).concat(s * -0.5, `px;
  width: `).concat(r, `px;
  height: `).concat(s, `px;
`);
    }), PM, FY, BY, k1e = R(() => {
      PM = ut(), FY = (0, PM.prism)(() => {
        let [r, s] = PM.prism.state("pos", null);
        return PM.prism.effect("setupListeners", () => {
          let a = (d) => {
            s(d);
          };
          return document.addEventListener("mousemove", a), () => {
            document.removeEventListener("mousemove", a);
          };
        }, []), r;
      }), BY = FY;
    }), cd, io, iS, LY, jY, UY, N3, $u, Wu, AM, zY, VY, Ui = R(() => {
      cd = ut(), k1e(), tn(), io = Y(xe()), iS = (0, io.createContext)(null), LY = 0, jY = ({ children: r, layoutP: s }) => {
        let a = (0, io.useMemo)(() => new cd.Atom([]), []), d = (0, io.useMemo)(() => (0, cd.prism)(() => {
          let x = cd.prism.memo("p", () => zY(s), [s]).getValue(), w = (0, cd.val)(a.pointer);
          return w.length > 0 ? Qc(w).position : x;
        }), [s]), m = (0, io.useCallback)(() => {
          let x = LY++;
          return a.reduce((w) => [...w, { id: x, position: [-1, 0] }]), { set: (w) => {
            a.reduce((T) => {
              let P = T.findIndex((F) => F.id === x);
              if (P === -1) return console.warn("Lock is already freed. This is a bug."), T;
              let M = [...T];
              return M.splice(P, 1, { id: x, position: [w, w === -1 ? 0 : 1] }), M;
            });
          }, unlock: () => {
            a.reduce((w) => w.filter((T) => T.id !== x));
          } };
        }, []), y = { currentD: d, getLock: m };
        return io.default.createElement(iS.Provider, { value: y }, r);
      }, UY = () => (0, io.useContext)(iS).currentD, N3 = () => {
        let { getLock: r } = (0, io.useContext)(iS), s = (0, io.useRef)();
        return (0, io.useLayoutEffect)(() => () => {
          var a;
          (a = s.current) == null || a.unlock();
        }, []), (0, io.useMemo)(() => {
          let a;
          return (d, m) => {
            var y, x;
            a?.shouldLock !== d && (d ? s.current = r() : (y = s.current) == null || y.unlock()), a?.pos !== m && d && ((x = s.current) == null || x.set(m)), a = { shouldLock: d, pos: m };
          };
        }, [r]);
      }, $u = (r, s) => {
        let { getLock: a } = (0, io.useContext)(iS), d = (0, io.useRef)();
        (0, io.useLayoutEffect)(() => {
          if (r) return d.current = a(), () => {
            d.current.unlock();
          };
        }, [r, a]), (0, io.useLayoutEffect)(() => {
          r && d.current.set(s);
        }, [s, r]);
      }, Wu = (r) => ({ [AM]: r === "hide" ? r : r.toFixed(3) }), AM = "data-theatre-lock-framestamp-to", zY = (r) => (0, cd.prism)(() => {
        let s = (0, cd.val)(r.rightDims), a = (0, cd.val)(r.clippedSpace.toUnitSpace), d = (0, cd.val)(BY);
        if (!d) return [-1, 0];
        for (let M of d.composedPath()) {
          if (!(M instanceof HTMLElement || M instanceof SVGElement)) break;
          if (M.hasAttribute(AM)) {
            let F = M.getAttribute(AM);
            if (typeof F != "string") continue;
            if (F === "hide") return [-1, 0];
            let O = parseFloat(F);
            if (isFinite(O) && O >= 0) return [O, 2];
          }
        }
        let { clientX: m, clientY: y } = d, { screenX: x, screenY: w, width: T, height: P } = s;
        if (ju(m, x, x + T) && ju(y, w + 16, w + P)) {
          let M = m - x;
          return [a(M), 3];
        } else return [-1, 0];
      }), VY = jY;
    }), GY, sS, O3, qY, HY, so, D3 = R(() => {
      Xn(), Os(), it(), DY(), CM(), zl(), Ui(), GY = 12, sS = 34, O3 = "beingDragged", so = { BEING_DRAGGED_CLASS: O3, CSS: sa(qY || (qY = $([`
    position: absolute;
    `, `;
    `, `;

    &.`, ` {
      pointer-events: none !important;
    }
  `])), Vl(GY), Ln, O3), CSS_WHEN_SOMETHING_DRAGGING: sa(HY || (HY = $([`
    pointer-events: auto;
    cursor: var(`, `);

    //  thing
    // This box extends the hitzone so the user does not
    // accidentally leave the hitzone
    &:hover:after {
      position: absolute;
      top: calc(50% - `, `px);
      left: calc(50% - `, `px);
      width: `, `px;
      height: `, `px;
      display: block;
      content: ' ';
      background: url(`, `) no-repeat 100% 100%;
      // This icon might also fit: GiConvergenceTarget
    }
  `])), Ml, sS / 2, sS / 2, sS, sS, I3), reactProps(r) {
        return V(L(L({}, Wu(r.position)), js.includePositionSnapAttrs(r.position)), { className: r.isDragging ? so.BEING_DRAGGED_CLASS : "" });
      } };
    });
    function kM() {
      oS.set({ mode: "snapToAll" });
    }
    function J0() {
      oS.set({ mode: "snapToNone" });
    }
    function M1e(r) {
      oS.set({ mode: "snapToSome", positions: r });
    }
    function R1e(r, s) {
      return Object.fromEntries(Object.entries(r).map(([a, d]) => [a, Object.fromEntries(Object.entries(d.trackData).map(([m, y]) => [m, y.keyframes.filter((x) => s(x, { trackId: m, trackData: y, objectKey: a })).map((x) => x.position)]))]));
    }
    var $Y, WY, F3, KY, YY, XY, QY, ZY, B3, oS, JY, ev = R(() => {
      $Y = ut(), WY = ut(), F3 = Y(xe()), it(), D3(), YY = ee.div(KY || (KY = $([`
  z-index: 1;
  cursor: ew-resize;

  `, `

  #pointer-root.draggingPositionInSequenceEditor & {
    `, `
  }
`])), so.CSS, so.CSS_WHEN_SOMETHING_DRAGGING), QY = ee.div(XY || (XY = $([`
  position: absolute;
`]))), ZY = (r) => F3.default.createElement(QY, { style: { top: "".concat(r.leaf.nodeHeight / 2, "px"), left: "calc(".concat((0, WY.val)(r.layoutP.scaledSpace.leftPadding), "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(r.position, "px))") } }, F3.default.createElement(YY, L({}, so.reactProps({ isDragging: !1, position: r.position })))), B3 = ZY, oS = new $Y.Atom({ mode: "snapToNone" }), JY = oS.prism;
    });
    function I1e(r, s) {
      let a = (0, dm.useMemo)(() => ({ debugName: "HorizontallyScrollableArea", onDragStart(m) {
        if (m.target instanceof HTMLInputElement || m.shiftKey || m.altKey || m.ctrlKey || m.metaKey || m.composedPath().some((F) => F instanceof HTMLElement && F.draggable === !0)) return !1;
        let y = m.clientX - s.getBoundingClientRect().left, x = ir((0, Zr.val)(r.clippedSpace.toUnitSpace)(y), 0, 1 / 0), w = (0, Zr.val)(r.seeker.setIsSeeking), T = (0, Zr.val)(r.sheet).getSequence();
        T.position = x;
        let P = x, M = (0, Zr.val)(r.scaledSpace.toUnitSpace);
        return w(!0), kM(), { onDrag(F, O, N) {
          let B = M(F), U = ir(P + B, 0, T.length), H = js.checkIfMouseEventSnapToPos(N, {});
          H != null && (U = H), T.position = U;
        }, onDragEnd() {
          w(!1), J0();
        } };
      } }), [r, s]), [d] = Fr(s, a);
      Ao(d, "draggingPositionInSequenceEditor", "ew-resize");
    }
    function N1e(r, s) {
      let a = IY();
      (0, dm.useLayoutEffect)(() => {
        if (!s) return;
        let d = (y) => {
          if (y.ctrlKey) {
            y.preventDefault(), y.stopPropagation();
            let x = y.clientX - s.getBoundingClientRect().left, w = (0, Zr.val)(r.clippedSpace.toUnitSpace)(x), T = (0, Zr.val)(r.clippedSpace.range), P = 1 + L3(y.deltaY, [-50, 50]) * 0.03, M = Zc(T, (N) => (N - w) * P + w), F = (0, Zr.val)(r.sheet).getSequence().length, O = F + F * 0.25;
            (0, Zr.val)(r.clippedSpace.setRange)(O1e(M, [0, O]));
            return;
          } else if (y.shiftKey) {
            y.preventDefault(), y.stopPropagation();
            let x = (0, Zr.val)(r.sheet).getSequence().length, w = (0, Zr.val)(r.clippedSpace.range), T = (w.end - w.start) / x, P = L3(y.deltaY || y.deltaX, [-50, 50]) * 0.05 * T, M = Zc(w, (F) => F + P);
            (0, Zr.val)(r.clippedSpace.setRange)(M);
            return;
          } else {
            a(y), y.preventDefault(), y.stopPropagation();
            let x = (0, Zr.val)(r.scaledSpace.toUnitSpace)(y.deltaX * 1), w = (0, Zr.val)(r.clippedSpace.range), T = Zc(w, (P) => P + x);
            (0, Zr.val)(r.clippedSpace.setRange)(T);
            return;
          }
        }, m = { capture: !0, passive: !1 };
        return s.addEventListener("wheel", d, m), () => {
          s.removeEventListener("wheel", d, m);
        };
      }, [s, r]), Fr(s, (0, dm.useMemo)(() => ({ onDragStart(d) {
        let m = (0, Zr.val)(r.clippedSpace.range), y = (0, Zr.val)(r.clippedSpace.setRange), x = (0, Zr.val)(r.scaledSpace.toUnitSpace);
        return d.preventDefault(), d.stopPropagation(), { onDrag(w, T, P, M, F) {
          a({ deltaY: -F });
          let O = -x(w), N = Zc(m, (B) => B + O);
          y(N);
        } };
      }, debugName: "HorizontallyScrollableArea Middle Button Drag", buttons: [1], lockCSSCursorTo: "grabbing" }), [r]));
    }
    function L3(r, [s, a]) {
      return Math.max(Math.min(r, a), s);
    }
    function O1e(r, s) {
      return Zc(r, (a) => L3(a, s));
    }
    function D1e(r, s) {
      (0, dm.useLayoutEffect)(() => {
        if (!s) return;
        let a = (0, Zr.prism)(() => {
          let x = (0, Zr.val)(r.clippedSpace.range);
          return (0, Zr.val)(r.scaledSpace.fromUnitSpace)(x.start);
        }), d = () => {
          let x = a.getValue();
          s.scrollLeft = x;
        }, m = a.onStale(d);
        d();
        let y = setTimeout(d, 100);
        return () => {
          clearTimeout(y), m();
        };
      }, [r, s]);
    }
    var Zr, dm, eX, tX, nX, MM, j3 = R(() => {
      li(), Hn(), zt(), Zr = ut(), tn(), dm = Y(xe()), it(), TM(), Xn(), Os(), zl(), ev(), tX = ee.div(eX || (eX = $([`
  position: absolute;
  right: 0;
  overflow-x: scroll;
  overflow-y: hidden;
  `, `;

  // hide the scrollbar on Gecko
  scrollbar-width: none;

  // hide the scrollbar on Webkit/Blink
  &::-webkit-scrollbar {
    display: none;
  }
`])), Ln), nX = dm.default.memo(({ layoutP: r, children: s, height: a }) => {
        let { width: d, unitSpaceToScaledSpaceMultiplier: m } = At(() => ({ width: (0, Zr.val)(r.rightDims.width), unitSpaceToScaledSpaceMultiplier: (0, Zr.val)(r.scaledSpace.fromUnitSpace)(1) }), [r]), [y, x] = kn(null);
        return N1e(r, x), I1e(r, x), D1e(r, x), dm.default.createElement(tX, { ref: y, style: { width: d + "px", height: a + "px", "--unitSpaceToScaledSpaceMultiplier": m } }, s);
      }), MM = nX;
    }), RM, rX, iX, sX, oX, aX, lX, uX, hm, IM = R(() => {
      RM = Y(xe()), it(), iX = ee.li(rX || (rX = $([`
  margin: 0;
  padding: 0;
  list-style: none;
  box-sizing: border-box;
  position: relative;
`]))), oX = ee.div(sX || (sX = $([`
  box-sizing: border-box;
  width: 100%;
  position: relative;

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    left: -40px;
    top: 0;
    bottom: 0;
    right: 0;
    box-sizing: border-box;
    border-bottom: 1px solid #252b3869;
    background: `, `;
  }
`])), (r) => r.isEven ? "transparent" : "#6b8fb505"), lX = ee.ul(aX || (aX = $([`
  margin: 0;
  padding: 0;
  list-style: none;
`]))), uX = ({ leaf: r, children: s, node: a, isCollapsed: d }) => {
        let m = Array.isArray(s) && s.length > 0;
        return r.shouldRender ? RM.default.createElement(iX, null, RM.default.createElement(oX, { style: { height: r.nodeHeight + "px" }, isEven: r.n % 2 === 0 }, a), m && RM.default.createElement(lX, null, s)) : null;
      }, hm = uX;
    }), F1e = J((r, s) => {
      (function() {
        var a = this, d = {};
        typeof r < "u" ? s.exports = d : a.fuzzy = d, d.simpleFilter = function(m, y) {
          return y.filter(function(x) {
            return d.test(m, x);
          });
        }, d.test = function(m, y) {
          return d.match(m, y) !== null;
        }, d.match = function(m, y, x) {
          x = x || {};
          var w = 0, T = [], P = y.length, M = 0, F = 0, O = x.pre || "", N = x.post || "", B = x.caseSensitive && y || y.toLowerCase(), U;
          m = x.caseSensitive && m || m.toLowerCase();
          for (var H = 0; H < P; H++) U = y[H], B[H] === m[w] ? (U = O + U + N, w += 1, F += 1 + F) : F = 0, M += F, T[T.length] = U;
          return w === m.length ? (M = B === m ? 1 / 0 : M, { rendered: T.join(""), score: M }) : null;
        }, d.filter = function(m, y, x) {
          return !y || y.length === 0 ? [] : typeof m != "string" ? y : (x = x || {}, y.reduce(function(w, T, P, M) {
            var F = T;
            x.extract && (F = x.extract(T));
            var O = d.match(m, F, x);
            return O != null && (w[w.length] = { string: O.rendered, score: O.score, index: P, original: T }), w;
          }, []).sort(function(w, T) {
            var P = T.score - w.score;
            return P || w.index - T.index;
          }));
        };
      })();
    });
    function B1e(r, s) {
      let [a, d] = (0, NM.useState)(!1), m = (0, NM.useRef)(s);
      return a || (m.current = s), (0, NM.useMemo)(() => r(d), m.current);
    }
    var NM, L1e = R(() => {
      NM = Y(xe());
    }), U3, Qh, OM = R(() => {
      U3 = "rgba(26, 28, 30, 0.97);", Qh = "#272B2F";
    });
    function cX(r, s, a, d) {
      let m = B1e((y) => ({ debugName: "CurveSegmentEditor/useKeyframeDrag", lockCSSCursorTo: "move", onDragStart() {
        return y(!0), { onDrag(x, w) {
          r && a.onCurveChange(d(x, w));
        }, onDragEnd(x) {
          y(!1), a.onCancelCurveChange();
        } };
      } }), [r, a.onCurveChange, a.onCancelCurveChange]);
      Fr(s, m);
    }
    var jn, DM, aS, tv, dX, lS, hX, FM, pX, fX, mX, nv, gX, pm, yX, vX, z3, bX, BM, xX, V3, _X, SX, j1e = R(() => {
      jn = Y(xe()), li(), Hn(), Df(), it(), Xn(), L1e(), OM(), DM = 0.12, aS = 1 + DM * 2, tv = 0.01, dX = 8, lS = (1 - tv) / (dX - 1), hX = "#3EAAA4", FM = "#3EAAA4", pX = "#3EAAA4", fX = "#3EAAA4", mX = "#3EAAA4", nv = "#3EAAA4", gX = "#3EAAA4", pm = "#B3B3B3", yX = "#3eaaa4", vX = "#67dfd8", z3 = ["goldenrod", "cornflowerblue", "dodgerblue", "lawngreen"], BM = ee.circle(bX || (bX = $([`
  stroke-width: 0.1px;
  vector-effect: non-scaling-stroke;
  r: 0.04px;
  pointer-events: none;
  transition: r 0.15s;
  fill: `, `;
`])), yX), V3 = ee.circle(xX || (xX = $([`
  stroke-width: 0.1px;
  vector-effect: non-scaling-stroke;
  r: 0.09px;
  cursor: move;
  `, `;
  &:hover {
    opacity: 0.4;
  }
  &:hover + `, ` {
    fill: `, `;
  }
`])), Ln, BM, vX), _X = (r) => {
        let { curveConnection: { left: s, right: a }, backgroundConnections: d } = r, m = Math.min(0, 1 - a.handles[1], 1 - s.handles[3]), y = Math.max(1, 1 - a.handles[1], 1 - s.handles[3]), x = Math.max(1, y - m), w = (W) => (W - m) / x, [T, P] = kn(null), M = aS / (P?.clientWidth || 1), F = aS / (P?.clientHeight || 1), [O, N] = kn(null);
        cX(P, N, r, (W, Q) => {
          let ne = ir(s.handles[2] + W * M, 0, 1), ce = s.handles[3] - Q * F;
          return [ne, ce, a.handles[0], a.handles[1]];
        });
        let [B, U] = kn(null);
        cX(P, U, r, (W, Q) => {
          let ne = ir(a.handles[0] + W * M, 0, 1), ce = a.handles[1] - Q * F;
          return [s.handles[2], s.handles[3], ne, ce];
        });
        let H = (W) => "M0 ".concat(w(1), " C").concat(W.left.handles[2], " ").concat(w(1 - W.left.handles[3]), " ").concat(W.right.handles[0], " ").concat(w(1 - W.right.handles[1]), " 1 ").concat(w(0));
        return jn.default.createElement("svg", { height: "100%", width: "100%", ref: T, viewBox: "".concat(-DM, " ").concat(-DM, " ").concat(aS, " ").concat(aS), xmlns: "http://www.w3.org/2000/svg", preserveAspectRatio: "none", fill: "none" }, jn.default.createElement("linearGradient", { id: "myGradient", gradientTransform: "rotate(90)" }, jn.default.createElement("stop", { offset: w(-1), stopColor: gX }), jn.default.createElement("stop", { offset: w(0), stopColor: nv }), jn.default.createElement("stop", { offset: w(0.3), stopColor: mX }), jn.default.createElement("stop", { offset: w(0.5), stopColor: fX }), jn.default.createElement("stop", { offset: w(0.7), stopColor: pX }), jn.default.createElement("stop", { offset: w(1), stopColor: FM }), jn.default.createElement("stop", { offset: w(2), stopColor: hX })), jn.default.createElement("pattern", { id: "dot-background-pattern-1", width: lS, height: lS / x, y: -m / x }, jn.default.createElement("rect", { width: tv, height: tv, fill: pm, opacity: 0.3 })), jn.default.createElement("rect", { x: 0, y: 0, width: "1", height: 1, fill: "url(#dot-background-pattern-1)" }), jn.default.createElement("pattern", { id: "dot-background-pattern-2", width: lS, height: lS }, jn.default.createElement("rect", { width: tv, height: tv, fill: pm })), jn.default.createElement("rect", { x: 0, y: w(0), width: "1", height: w(1) - w(0), fill: "url(#dot-background-pattern-2)" }), !s.type || s.type === "bezier" ? jn.default.createElement(jn.default.Fragment, null, jn.default.createElement("line", { x1: 0, y1: w(1), x2: s.handles[2], y2: w(1 - s.handles[3]), stroke: pm, strokeWidth: "0.01" }), jn.default.createElement("line", { x1: 1, y1: w(0), x2: a.handles[0], y2: w(1 - a.handles[1]), stroke: pm, strokeWidth: "0.01" }), jn.default.createElement("path", { d: H(r.curveConnection), stroke: "none", fill: "url('#myGradient')", opacity: "0.1" }), d.map((W, Q) => jn.default.createElement("path", { key: W.objectKey + "/" + W.left.id, d: H(W), stroke: z3[Q % z3.length], opacity: 0.6, strokeWidth: "0.01" })), jn.default.createElement("path", { d: H(r.curveConnection), stroke: "url('#myGradient')", strokeWidth: "0.02" }), jn.default.createElement("circle", { cx: 0, cy: w(1), r: "0.025", stroke: FM, strokeWidth: "0.02", fill: Qh }), jn.default.createElement("circle", { cx: 1, cy: w(0), r: "0.025", stroke: nv, strokeWidth: "0.02", fill: Qh }), jn.default.createElement(V3, { ref: O, cx: s.handles[2], cy: w(1 - s.handles[3]), fill: FM, opacity: 0.2 }), jn.default.createElement(BM, { cx: s.handles[2], cy: w(1 - s.handles[3]) }), jn.default.createElement(V3, { ref: B, cx: a.handles[0], cy: w(1 - a.handles[1]), fill: nv, opacity: 0.2 }), jn.default.createElement(BM, { cx: a.handles[0], cy: w(1 - a.handles[1]) })) : jn.default.createElement(jn.default.Fragment, null, jn.default.createElement("line", { x1: 0, y1: w(1), x2: 1, y2: w(1), stroke: pm, strokeWidth: "0.01" }), jn.default.createElement("line", { x1: 1, y1: w(1), x2: 1, y2: 0, stroke: pm, strokeWidth: "0.01" }), jn.default.createElement("circle", { cx: 0, cy: 1, r: "0.025", stroke: nv, strokeWidth: "0.02", fill: Qh }), jn.default.createElement("circle", { cx: 1, cy: 0, r: "0.025", stroke: nv, strokeWidth: "0.02", fill: Qh })));
      }, SX = _X;
    }), wX, dd, G3, EX, TX, CX, PX, AX = R(() => {
      wX = ut(), Hn(), dd = Y(xe()), G3 = (0, dd.createContext)(null), EX = 0, TX = () => {
        let r = (0, dd.useMemo)(() => EX++, []), { cur: s, set: a } = (0, dd.useContext)(G3), [d, m] = kn(!1), y = (0, dd.useCallback)((x, w) => {
          a(x ? r : -1, w);
        }, []);
        return (0, dd.useEffect)(() => s.onStale(() => {
          let x = s.getValue() === r;
          d.current !== x && (d.current = x);
        }), [s, r]), [m, y];
      }, CX = ({ children: r }) => {
        let s = (0, dd.useMemo)(() => new wX.Atom(-1), []), a = s.prism, d = (0, dd.useMemo)(() => {
          let m;
          return (y, x) => {
            let w = m !== void 0;
            m !== void 0 && (clearTimeout(m), m = void 0), x === 0 || w ? s.set(y) : m = setTimeout(() => {
              s.set(y), m = void 0;
            }, x);
          };
        }, []);
        return dd.default.createElement(G3.Provider, { value: { cur: a, set: d } }, r);
      }, PX = CX;
    });
    function LM(r, s) {
      let a = r.enabled !== !1, [d, m] = TX(), [y, x] = kn(null);
      (0, MX.useEffect)(() => {
        if (!a) return;
        let T = y.current;
        if (!T) return;
        let P = () => {
          var F;
          return m(!0, (F = r.enterDelay) != null ? F : 400);
        }, M = () => {
          var F;
          return m(!1, (F = r.exitDelay) != null ? F : 200);
        };
        return T.addEventListener("mouseenter", P), T.addEventListener("mouseleave", M), () => {
          T.removeEventListener("mouseenter", P), T.removeEventListener("mouseleave", M);
        };
      }, [y, a, r.enterDelay, r.exitDelay]);
      let w = (0, kX.useContext)(P0);
      return [a && d && x ? (0, RX.createPortal)(jM.default.createElement(t3, { children: s, target: x, onClickOutside: kl, verticalPlacement: r.verticalPlacement, verticalGap: r.verticalGap }), w) : jM.default.createElement(jM.default.Fragment, null), y, d];
    }
    var kX, MX, jM, RX, UM = R(() => {
      Hn(), kX = Y(xe()), MX = Y(xe()), jM = Y(xe()), v7(), RX = Y(oi()), AX(), im(), k0();
    });
    function zM(r) {
      return r.map((s) => s.toFixed(3)).join(", ");
    }
    function VM(r) {
      if (!r || r?.length > IX) return null;
      let s = r.split(",");
      if (s.length !== 4) return null;
      let a = s.map((d) => Number(d.trim()));
      return !a.every((d) => isFinite(d)) || a[0] < 0 || a[0] > 1 || a[2] < 0 || a[2] > 1 ? null : a;
    }
    function U1e(r, s, a = { threshold: 0.02 }) {
      if (!r || !s) return !1;
      let d = 0;
      for (let m = 0; m < 4; m++) d += Math.abs(r[m] - s[m]);
      return d < a.threshold;
    }
    var IX, GM, NX = R(() => {
      IX = 128, GM = [{ label: "Quad Out", value: "0.250, 0.460, 0.450, 0.940" }, { label: "Quad In Out", value: "0.455, 0.030, 0.515, 0.955" }, { label: "Quad In", value: "0.550, 0.085, 0.680, 0.530" }, { label: "Cubic Out", value: "0.215, 0.610, 0.355, 1.000" }, { label: "Cubic In Out", value: "0.645, 0.045, 0.355, 1.000" }, { label: "Cubic In", value: "0.550, 0.055, 0.675, 0.190" }, { label: "Quart Out", value: "0.165, 0.840, 0.440, 1.000" }, { label: "Quart In Out", value: "0.770, 0.000, 0.175, 1.000" }, { label: "Quart In", value: "0.895, 0.030, 0.685, 0.220" }, { label: "Quint Out", value: "0.230, 1.000, 0.320, 1.000" }, { label: "Quint In Out", value: "0.860, 0.000, 0.070, 1.000" }, { label: "Quint In", value: "0.755, 0.050, 0.855, 0.060" }, { label: "Sine Out", value: "0.390, 0.575, 0.565, 1.000" }, { label: "Sine In Out", value: "0.445, 0.050, 0.550, 0.950" }, { label: "Sine In", value: "0.470, 0.000, 0.745, 0.715" }, { label: "Expo Out", value: "0.190, 1.000, 0.220, 1.000" }, { label: "Expo In Out", value: "1.000, 0.000, 0.000, 1.000" }, { label: "Expo In", value: "0.780, 0.000, 0.810, 0.00" }, { label: "Circ Out", value: "0.075, 0.820, 0.165, 1.000" }, { label: "Circ In Out", value: "0.785, 0.135, 0.150, 0.860" }, { label: "Circ In", value: "0.600, 0.040, 0.980, 0.335" }, { label: "Back Out", value: "0.175, 0.885, 0.320, 1.275" }, { label: "Back In Out", value: "0.680, -0.550, 0.265, 1.550" }, { label: "Back In", value: "0.600, -0.280, 0.735, 0.045" }, { label: "linear", value: "0.5, 0.5, 0.5, 0.5" }, { label: "In Out", value: "0.42,0,0.58,1" }, { label: "Hold", value: "0, 0, Infinity, Infinity" }];
    }), Us, qM, fm, q3, OX, DX, uS, H3, $3, FX, BX, z1e = R(() => {
      Us = Y(xe()), qM = 0.75, fm = 0.1, q3 = 1 + qM * 2, OX = "#F5F5F5", DX = "#888888", uS = "#4f4f4f", H3 = "rgba(255, 255, 255, 0.1)", $3 = (r) => 1 - r, FX = (r) => {
        let { easing: s, isSelected: a } = r, d = a ? OX : DX, m = "".concat(-qM, " ").concat(-qM, " ").concat(q3, " ").concat(q3);
        if (s) {
          let y = [s[0], $3(s[1])], x = [s[2], $3(s[3])];
          return Us.default.createElement("svg", { height: "100%", width: "100%", viewBox: m, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Us.default.createElement("line", { x1: "0", y1: "1", x2: y[0], y2: y[1], stroke: uS, strokeWidth: "0.1" }), Us.default.createElement("line", { x1: "1", y1: "0", x2: x[0], y2: x[1], stroke: uS, strokeWidth: "0.1" }), Us.default.createElement("circle", { cx: y[0], cy: y[1], r: 0.1, fill: H3 }), Us.default.createElement("circle", { cx: x[0], cy: x[1], r: 0.1, fill: H3 }), Us.default.createElement("circle", { cx: y[0], cy: y[1], r: fm, fill: uS }), Us.default.createElement("circle", { cx: x[0], cy: x[1], r: fm, fill: uS }), Us.default.createElement("path", { d: "M0 1 C".concat(y[0], " ").concat(y[1], " ").concat(x[0], ` 
        `).concat(x[1], " 1 0"), stroke: d, strokeWidth: "0.08" }), Us.default.createElement("circle", { cx: 0, cy: 1, r: fm, fill: d }), Us.default.createElement("circle", { cx: 1, cy: 0, r: fm, fill: d }));
        }
        return Us.default.createElement("svg", { height: "100%", width: "100%", viewBox: m, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, Us.default.createElement("line", { x1: "0", y1: "1", x2: 1, y2: 1, stroke: d, strokeWidth: "0.08" }), Us.default.createElement("line", { x1: "1", y1: "0", x2: 1, y2: 1, stroke: d, strokeWidth: "0.08" }), Us.default.createElement("circle", { cx: 0, cy: 1, r: fm, fill: d }), Us.default.createElement("circle", { cx: 1, cy: 0, r: fm, fill: d }));
      }, BX = FX;
    }), cS, LX, jX, UX, zX, VX, GX, qX, V1e = R(() => {
      UM(), cS = Y(xe()), it(), NX(), z1e(), Kk(), OM(), Fl(), UX = ee.div(jX || (jX = $([`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  aspect-ratio: 1;

  transition: background-color 0.15s;
  background-color: `, `;
  border-radius: 2px;
  cursor: pointer;
  outline: none;

  `, `

  &:hover {
    background-color: #31353a;
  }

  &:focus {
    background-color: #383d42;
  }
`])), Qh, ({ isSelected: r }) => r && sa(LX || (LX = $([`
      background-color: #383d42;
    `])))), VX = ee(Mo)(zX || (zX = $([`
  padding: 0.5em;
  color: white;
  max-width: 240px;
  pointer-events: none !important;
  --popover-bg: black;
  --popover-outer-stroke: transparent;
  --popover-inner-stroke: transparent;
  box-shadow: none;
`]))), GX = cS.default.forwardRef((r, s) => {
        let [a, d] = LM({ enabled: !0, verticalPlacement: r.tooltipPlacement, verticalGap: 0 }, () => cS.default.createElement(VX, { showPopoverEdgeTriangle: !1 }, r.easing.label));
        return cS.default.createElement(UX, L({ ref: Wk([d, s]) }, r), a, cS.default.createElement(BX, { easing: VM(r.easing.value), isSelected: r.isSelected }));
      }), qX = GX;
    });
    function G1e(r) {
      var s;
      let [a, d] = (0, HX.useState)(null), m = (x) => {
        if (a === null) {
          r.items.length > 0 && d(0);
          return;
        }
        let w = a + x * r.uiColumns, T = w < 0, P = w > r.items.length - 1;
        if (T || P) {
          if (r.canVerticleExit && r.canVerticleExit(T ? "top" : "bottom")) {
            d(null);
            return;
          }
          return;
        }
        d(w);
      }, y = (x) => {
        a === null ? d(W1e(x, r.items.length)) : a + x < 0 ? d(null) : d(Math.min(a + x, r.items.length - 1));
      };
      return { focusFirstItem() {
        d(0);
      }, onParentEltKeyDown: (x) => {
        if (x.key === "ArrowRight") y(1);
        else if (x.key === "ArrowLeft") y(-1);
        else if (x.key === "ArrowUp") m(-1);
        else if (x.key === "ArrowDown") m(1);
        else return 0;
        return 1;
      }, gridItems: r.items.map((x, w) => r.renderItem({ isSelected: w === a, item: x, select(T) {
        d(w), r.onSelectItem(x) === 1 && (T?.preventDefault(), T?.stopPropagation());
      } })), currentSelection: (s = r.items[a ?? -1]) != null ? s : null };
    }
    var HX, q1e = R(() => {
      HX = Y(xe()), cQ();
    });
    function $X(r, s, a) {
      var d;
      (d = r.current) == null || d.discard(), r.current = null;
      let m = VM(a);
      m === null ? r.current = $1e(s) : r.current = H1e(s, m);
    }
    function WX(r) {
      var s;
      (s = r.current) == null || s.discard(), r.current = null;
    }
    function H1e(r, s) {
      return pe().tempTransaction(({ stateEditors: a }) => {
        let { setHandlesForKeyframe: d, setKeyframeType: m } = a.coreByProject.historic.sheetsById.sequence;
        for (let { projectId: y, sheetId: x, objectKey: w, trackId: T, left: P, right: M } of r) d({ projectId: y, sheetId: x, objectKey: w, trackId: T, keyframeId: P.id, start: [s[0], s[1]] }), d({ projectId: y, sheetId: x, objectKey: w, trackId: T, keyframeId: M.id, end: [s[2], s[3]] }), m({ projectId: y, sheetId: x, objectKey: w, trackId: T, keyframeId: P.id, keyframeType: "bezier" });
      });
    }
    function $1e(r) {
      return pe().tempTransaction(({ stateEditors: s }) => {
        let { setKeyframeType: a } = s.coreByProject.historic.sheetsById.sequence;
        for (let { projectId: d, sheetId: m, objectKey: y, trackId: x, left: w } of r) a({ projectId: d, sheetId: m, objectKey: y, trackId: x, keyframeId: w.id, keyframeType: "hold" });
      });
    }
    function W1e(r, s) {
      return (r % s + s) % s;
    }
    function K1e(r, s) {
      return () => setTimeout(r, s);
    }
    function Y1e({ left: r, right: s }) {
      return ({ left: a, right: d }) => r.handles[2] !== a.handles[2] || r.handles[3] !== a.handles[3] || s.handles[0] !== d.handles[0] || s.handles[1] !== d.handles[1];
    }
    var HM, Br, KX, W3, K3, YX, XX, QX, ZX, JX, eQ, tQ, nQ, rQ, iQ, sQ, oQ, aQ, X1e, lQ, uQ, cQ = R(() => {
      HM = ut(), Br = Y(xe()), it(), KX = Y(F1e()), st(), j1e(), V1e(), NX(), OM(), Hn(), q1e(), W3 = 3, K3 = 53, YX = 25, QX = ee.div(XX || (XX = $([`
  background: `, `;
  display: grid;
  grid-template-areas:
    'search  tween'
    'presets tween';
  grid-template-rows: 32px 1fr;
  grid-template-columns: `, `px 120px;
  gap: 1px;
  height: 120px;
`])), U3, W3 * K3), JX = ee.div(ZX || (ZX = $([`
  overflow: auto;
  grid-area: presets;

  display: grid;
  grid-template-columns: repeat(`, `, 1fr);
  grid-auto-rows: min-content;
  gap: 1px;

  overflow-y: scroll;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* Internet Explorer 10+ */
  &::-webkit-scrollbar {
    /* WebKit */
    width: 0;
    height: 0;
  }
`])), W3), tQ = ee.input.attrs({ type: "text" })(eQ || (eQ = $([`
  background-color: `, `;
  border: none;
  border-radius: 2px;
  color: rgba(255, 255, 255, 0.8);
  padding: 6px;
  font-size: 12px;
  outline: none;
  cursor: text;
  text-align: left;
  width: 100%;
  height: 100%;
  box-sizing: border-box;

  grid-area: search;

  &:hover {
    background-color: #212121;
  }

  &:focus {
    background-color: rgba(16, 16, 16, 0.26);
    outline: 1px solid rgba(0, 0, 0, 0.35);
  }
`])), Qh), rQ = ee.div(nQ || (nQ = $([`
  grid-area: tween;
  background: `, `;
`])), Qh), sQ = ee.div(iQ || (iQ = $([`
  grid-column: 1 / 4;
  padding: 6px;
  color: #888888;
`]))), oQ = (r) => {
        let s = (0, Br.useMemo)(() => [r.curveConnection, ...r.additionalConnections], [r.curveConnection, ...r.additionalConnections]), a = (0, Br.useRef)(null);
        (0, Br.useEffect)(() => {
          let ve = uQ(s);
          return () => {
            var Xe;
            ve(), (Xe = a.current) == null || Xe.commit();
          };
        }, [a]);
        let d = [r.curveConnection.left.handles[2], r.curveConnection.left.handles[3], r.curveConnection.right.handles[0], r.curveConnection.right.handles[1]], m = (0, Br.useRef)(null);
        (0, Br.useLayoutEffect)(() => {
          var ve, Xe;
          (ve = m.current) == null || ve.select(), (Xe = m.current) == null || Xe.focus();
        }, [m.current]);
        let [y, x] = (0, Br.useState)(zM(d)), w = (ve) => {
          ve !== void 0 && (M(1), x(ve.target.value), VM(ve.target.value) && O(ve.target.value));
        }, T = (ve) => {
          var Xe, Se;
          M(1), (ve.key === "ArrowDown" || ve.key === "ArrowUp") && ve.preventDefault(), ve.key === "ArrowDown" ? (Ee.focusFirstItem(), (Se = (Xe = se.current[W[0].label]) == null ? void 0 : Xe.current) == null || Se.focus()) : ve.key === "Escape" ? (WX(a), r.onRequestClose("key Escape")) : ve.key === "Enter" && r.onRequestClose("key Enter");
        }, [P, M] = (0, Br.useState)(0);
        (0, Br.useEffect)(() => {
          P === 2 ? x(zM(d)) : P === 3 && y !== "" && x("");
        }, s);
        let [F, O] = (0, Br.useState)(zM(d)), [N, B] = (0, Br.useState)(null);
        (0, Br.useEffect)(() => {
          var ve;
          P !== 0 && P !== 3 && $X(a, s, (ve = N ?? F) != null ? ve : "");
        }, [N, F, P]), s.some(Y1e(r.curveConnection)) && P === 0 && M(3);
        let U = (ve) => {
          var Xe, Se;
          M(2);
          let nt = zM(ve);
          x(nt), O(nt), (Xe = m.current) == null || Xe.select(), (Se = m.current) == null || Se.focus();
        }, H = () => {
        }, W = (0, Br.useMemo)(() => /^[A-Za-z]/.test(y) ? KX.default.filter(y, GM, { extract: (ve) => ve.label }).map((ve) => ve.original) : GM, [y]);
        (0, Br.useEffect)(() => {
          P === 1 && W[0] && O(W[0].value);
        }, [W]);
        let Q = (ve) => {
          ve.key === "Escape" ? (WX(a), r.onRequestClose("key Escape"), ve.stopPropagation()) : ve.key === "Enter" && (r.onRequestClose("key Enter"), ve.stopPropagation());
        }, ne = (ve) => {
          P === 0 && M(2), B(ve.value);
        }, ce = () => B(null), ue = (ve) => ($X(a, s, ve.value), r.onRequestClose("selected easing option"), 1), se = (0, Br.useRef)(GM.reduce((ve, Xe) => (ve[Xe.label] = { current: null }, ve), {})), [Oe, he] = kn(null), [ie, ye] = (0, Br.useState)(0);
        (0, Br.useEffect)(() => {
          let ve = () => {
            var Xe;
            ye((Xe = he?.scrollTop) != null ? Xe : 0);
          };
          return he?.addEventListener("scroll", ve), () => he?.removeEventListener("scroll", ve);
        }, [he]);
        let Ee = G1e({ items: W, uiColumns: 3, onSelectItem: ue, canVerticleExit(ve) {
          var Xe, Se;
          return ve === "top" ? ((Xe = m.current) == null || Xe.select(), (Se = m.current) == null || Se.focus(), 1) : 0;
        }, renderItem: ({ item: ve, select: Xe }) => {
          var Se, nt;
          return Br.default.createElement(qX, { key: ve.label, easing: ve, tabIndex: 0, onKeyDown: Q, ref: se.current[ve.label], onMouseOver: () => ne(ve), onMouseOut: ce, onClick: Xe, tooltipPlacement: ((nt = (Se = se.current[ve.label].current) == null ? void 0 : Se.offsetTop) != null ? nt : 0) - (ie ?? 0) < K3 + YX ? "bottom" : "top", isSelected: U1e(d, VM(ve.value)) });
        } });
        return (0, Br.useLayoutEffect)(() => {
          var ve, Xe;
          if (Ee.currentSelection !== null && document.activeElement !== m.current) {
            let Se = (Xe = (ve = se.current) == null ? void 0 : ve[Ee.currentSelection.label]) == null ? void 0 : Xe.current;
            Se?.focus(), O(Ee.currentSelection.value), /^[A-Za-z]/.test(y) || x(Ee.currentSelection.value);
          }
        }, [Ee.currentSelection]), Br.default.createElement(QX, null, Br.default.createElement(tQ, { value: y, placeholder: P === 3 ? "Multiple easings selected" : "Search presets...", onPaste: K1e(w), onChange: w, ref: m, onKeyDown: T }), Br.default.createElement(JX, { ref: Oe, onKeyDown: (ve) => Ee.onParentEltKeyDown(ve) }, Ee.gridItems, Ee.gridItems.length === 0 ? Br.default.createElement(sQ, null, "No results found") : void 0), Br.default.createElement(rQ, { onClick: () => {
          var ve;
          return (ve = m.current) == null ? void 0 : ve.focus();
        } }, Br.default.createElement(SX, { curveConnection: r.curveConnection, backgroundConnections: r.additionalConnections, onCurveChange: U, onCancelCurveChange: H })));
      }, aQ = oQ, { isCurveEditorOpenD: X1e, isConnectionEditingInCurvePopover: lQ, getLock: uQ } = (() => {
        let r = new HM.Atom([]);
        return { getLock(s) {
          return r.set(s), function() {
            r.set([]);
          };
        }, isCurveEditorOpenD: (0, HM.prism)(() => r.prism.getValue().length > 0), isConnectionEditingInCurvePopover(s) {
          return HM.prism.ensurePrism(), r.prism.getValue().some(({ left: a, right: d }) => s.left.id === a.id && s.right.id === d.id);
        } };
      })();
    });
    function Q1e(r, s) {
      for (let { keyframeId: a } of tSe(s)) if (r.left.id === a) return !0;
      return !1;
    }
    function Z1e(r, s, a) {
      return (0, $M.prism)(() => {
        if (a === void 0) return [];
        let d = [];
        for (let { objectKey: m, trackId: y } of pQ(a)) {
          let x = (0, $M.val)(pe().atomP.historic.coreByProject[r].sheetsById[s].sequence.tracksByObject[m].trackData[y]);
          x && (d = d.concat(eSe(x.keyframes).filter((w) => Q1e(w, a)).map(({ left: w, right: T }) => ({ left: w, right: T, trackId: y, objectKey: m, sheetId: s, projectId: r }))));
        }
        return d;
      });
    }
    function dQ(r, s, a) {
      var d;
      if (a === void 0) return [];
      let m = [];
      for (let { objectKey: x, trackId: w, keyframeIds: T } of pQ(a)) m = m.concat((d = hQ({ projectId: r, sheetId: s, objectKey: x, trackId: w, keyframeIds: T })) != null ? d : []);
      let y = x3(m.map((x) => x.pathToProp));
      return m.map(({ keyframe: x, pathToProp: w }) => ({ keyframe: x, pathToProp: w.slice(y.length) }));
    }
    function hQ({ projectId: r, sheetId: s, objectKey: a, trackId: d, keyframeIds: m }) {
      let y = (0, $M.val)(pe().atomP.historic.coreByProject[r].sheetsById[s].sequence.tracksByObject[a]), x = y?.trackData[d];
      if (!x) return null;
      let w = J1e(y?.trackIdByPropPath || {})[d];
      if (!w) return null;
      let T = [a, ..._3(w)];
      return m.map((P) => ({ keyframe: x.keyframes.find((M) => M.id === P), pathToProp: T })).filter(({ keyframe: P }) => P !== void 0);
    }
    function J1e(r) {
      let s = {};
      for (let [a, d] of Object.entries(r)) s[d] = a;
      return s;
    }
    function eSe(r) {
      return r.map((s, a) => ({ left: s, right: r[a + 1] })).slice(0, -1);
    }
    function tSe(r) {
      var s, a, d;
      let m = [];
      for (let [y, x] of Object.entries((s = r?.byObjectKey) != null ? s : {})) for (let [w, T] of Object.entries((a = x?.byTrackId) != null ? a : {})) for (let P of Object.keys((d = T?.byKeyframeId) != null ? d : {})) m.push({ objectKey: y, trackId: w, keyframeId: P });
      return m;
    }
    function pQ(r) {
      var s, a, d;
      let m = [];
      for (let [y, x] of Object.entries((s = r?.byObjectKey) != null ? s : {})) for (let [w, T] of Object.entries((a = x?.byTrackId) != null ? a : {})) m.push({ objectKey: y, trackId: w, keyframeIds: Object.keys((d = T?.byKeyframeId) != null ? d : {}) });
      return m;
    }
    var $M, WM = R(() => {
      $M = ut(), st(), Xh();
    });
    function nSe(r, s) {
      return (0, fQ.useMemo)(() => rSe(r, s), []);
    }
    function rSe(r, s) {
      let a = null, d = (x) => pe().tempTransaction((w) => r(w, x));
      function m() {
        a?.discard(), a = null;
      }
      let y = { createAsset: s.sheet.project.assetStorage.createAsset, getAssetUrl: (x) => x.id ? s.sheet.project.assetStorage.getAssetUrl(x.id) : void 0 };
      return L({ temporarilySetValue(x) {
        m(), a = d(x);
      }, discardTemporaryValue: m, permanentlySetValue(x) {
        m(), d(x).commit();
      } }, y);
    }
    var fQ, iSe = R(() => {
      st(), fQ = Y(xe());
    });
    function Y3(r) {
      var s;
      if (r.type === "sheetObject") return vs.default.createElement(vs.default.Fragment, null, vs.default.createElement(KM, { style: { paddingLeft: "".concat(r.indent * YM, "px") } }, r.sheetObject.address.objectKey), r.children.map((a, d) => vs.default.createElement(Y3, V(L({ key: d }, a), { autoFocusInput: r.autoFocusInput && d === 0, indent: r.indent + 1 }))));
      if (r.type === "propWithChildren") {
        let a = (s = r.propConfig.label) != null ? s : Qc(r.pathToProp);
        return vs.default.createElement(vs.default.Fragment, null, vs.default.createElement(KM, { style: { paddingLeft: "".concat(r.indent * YM, "px") } }, a), r.children.map((d, m) => vs.default.createElement(Y3, V(L({ key: m }, d), { autoFocusInput: r.autoFocusInput && m === 0, indent: r.indent + 1 }))));
      } else return vs.default.createElement(sSe, V(L({}, r), { autoFocusInput: r.autoFocusInput, indent: r.indent }));
    }
    function sSe(r) {
      var s;
      let a = (s = r.propConfig.label) != null ? s : Qc(r.pathToProp), d = oSe(r);
      if (r.propConfig.type === "enum") return vs.default.createElement(vs.default.Fragment, null);
      {
        let m = a3[r.propConfig.type];
        return vs.default.createElement(gQ, null, vs.default.createElement(KM, null, vs.default.createElement("span", { style: { paddingLeft: "".concat(r.indent * YM, "px") } }, a)), vs.default.createElement(bQ, null, vs.default.createElement(m, { editingTools: d, propConfig: r.propConfig, value: cM(r.keyframe.value, r.propConfig), autoFocus: r.autoFocusInput })));
      }
    }
    function oSe(r) {
      let s = r.sheetObject;
      return nSe(({ stateEditors: a }, d) => {
        let m = V(L({}, r.keyframe), { value: d });
        a.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, s.address), { trackId: r.trackId, keyframes: [m], snappingFunction: s.sheet.getSequence().closestGridPosition }));
      }, s);
    }
    var vs, mQ, gQ, yQ, KM, YM, vQ, bQ, aSe = R(() => {
      vs = Y(xe()), it(), gK(), ia(), iSe(), Wh(), gQ = ee.div(mQ || (mQ = $([`
  display: flex;
  align-items: stretch;
  min-width: 200px;

  select {
    min-width: 100px;
  }
`]))), KM = ee.div(yQ || (yQ = $([`
  font-style: normal;
  font-weight: 400;
  font-size: 11px;
  line-height: 13px;
  letter-spacing: 0.01em;
  padding: 6px 6px 6px 0;

  width: 40%;

  color: #919191;

  overflow: hidden;
`]))), YM = 10, bQ = ee.div(vQ || (vQ = $([`
  display: flex;
  align-items: center;
  width: 60%;
`])));
    });
    function X3(r) {
      return ko({ debugName: "useKeyframeInlineEditorPopover" }, () => XM.default.createElement(Mo, { showPopoverEdgeTriangle: !0 }, XM.default.createElement("div", { style: { margin: "1px 2px 1px 10px" } }, Array.isArray(r) ? r.map((s, a) => XM.default.createElement(Y3, V(L({ key: a }, s), { autoFocusInput: a === 0, indent: 0 }))) : void 0)));
    }
    var XM, Q3 = R(() => {
      XM = Y(xe()), Dl(), Fl(), aSe();
    });
    function lSe(r, s, a) {
      return Bs(r, { displayName: "Keyframe", menuItems: () => {
        let d = dQ(a.leaf.sheetObject.address.projectId, a.leaf.sheetObject.address.sheetId, a.selection);
        return [{ label: d.length > 0 ? "Copy (selection)" : "Copy", callback: () => {
          d.length > 0 ? pe().transaction((m) => {
            m.stateEditors.studio.ahistoric.setClipboardKeyframes(d);
          }) : pe().transaction((m) => {
            m.stateEditors.studio.ahistoric.setClipboardKeyframes([{ keyframe: a.keyframe, pathToProp: a.leaf.pathToProp }]);
          });
        } }, { label: a.selection !== void 0 ? "Delete (selection)" : "Delete", callback: () => {
          a.selection ? a.selection.delete() : pe().transaction(({ stateEditors: m }) => {
            m.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, a.leaf.sheetObject.address), { keyframeIds: [a.keyframe.id], trackId: a.leaf.trackId }));
          });
        } }];
      }, onOpen() {
        s._debug("Show keyframe", a);
      } });
    }
    function uSe(r, s, a) {
      let d = (0, Zh.useRef)(s);
      d.current = s;
      let { onClickFromDrag: m } = a, y = (0, Zh.useMemo)(() => ({ debugName: "KeyframeDot/useDragKeyframe", onDragStart(w) {
        let T = d.current, P = (0, QM.val)(pe().atomP.historic.coreByProject[T.leaf.sheetObject.address.projectId].sheetsById[T.leaf.sheetObject.address.sheetId].sequence.tracksByObject), M = R1e(P, function(B, { trackId: U, objectKey: H }) {
          var W, Q;
          return B.id !== T.keyframe.id && !(T.selection && (Q = (W = T.selection.byObjectKey[H]) == null ? void 0 : W.byTrackId[U]) != null && Q.byKeyframeId[B.id]);
        });
        if (M1e(M), T.selection) {
          let { selection: B, leaf: U } = T, { sheetObject: H } = U, W = B.getDragHandlers(V(L({}, H.address), { domNode: r, positionAtStartOfDrag: T.track.data.keyframes[T.index].position })).onDragStart(w);
          return W && V(L({}, W), { onClick: m, onDragEnd: (...Q) => {
            var ne;
            (ne = W.onDragEnd) == null || ne.call(W, ...Q), J0();
          } });
        }
        let F = T, O = (0, QM.val)(F.layoutP.scaledSpace.toUnitSpace), N;
        return { onDrag(B, U, H) {
          var W;
          let Q = F.track.data.keyframes[F.index], ne = Math.max((W = js.checkIfMouseEventSnapToPos(H, { ignore: r })) != null ? W : Q.position + O(B), 0);
          N?.discard(), N = void 0, N = pe().tempTransaction(({ stateEditors: ce }) => {
            ce.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, F.leaf.sheetObject.address), { trackId: F.leaf.trackId, keyframes: [V(L({}, Q), { position: ne })], snappingFunction: (0, QM.val)(F.layoutP.sheet).getSequence().closestGridPosition }));
          });
        }, onDragEnd(B) {
          B ? N?.commit() : N?.discard(), J0();
        }, onClick(B) {
          m(B);
        } };
      } }), [m]), [x] = Fr(r, y);
      return $u(x, s.keyframe.position), Ao(x, "draggingPositionInSequenceEditor", "ew-resize"), [x];
    }
    var Zh, QM, dS, Z3, hS, J3, xQ, ZM, _Q, SQ, wQ, EQ, TQ, CQ, PQ = R(() => {
      Zh = Y(xe()), it(), st(), Ls(), li(), Hn(), QM = ut(), Ui(), Os(), zl(), CM(), om(), WM(), Xn(), ev(), Q3(), J1(), dS = 6, Z3 = dS + 2, hS = { normalColor: "#40AAA4", selectedColor: "#F2C95C", inlineEditorOpenColor: "#FCF3DC", selectedAndInlineEditorOpenColor: "#CBEBEA" }, J3 = ({ isSelected: r, isInlineEditorPopoverOpen: s }) => r && s ? hS.inlineEditorOpenColor : r ? hS.selectedColor : s ? hS.selectedAndInlineEditorOpenColor : hS.normalColor, ZM = ee.div(xQ || (xQ = $([`
  position: absolute;
  `, `

  background: `, `;
  transform: rotateZ(45deg);

  `, `;

  z-index: 1;
  pointer-events: none;
`])), Vl(dS), (r) => J3(r), (r) => r.flag === 2 ? "outline: 2px solid white;" : ""), SQ = ee.div(_Q || (_Q = $([`
  position: absolute;
  `, `

  background: `, `;

  `, `;

  z-index: 1;
  pointer-events: none;
`])), Vl(dS * 1.5), (r) => J3(r), (r) => r.flag === 2 ? "outline: 2px solid white;" : ""), EQ = ee.div(wQ || (wQ = $([`
  z-index: 1;
  cursor: ew-resize;

  position: absolute;
  `, `;
  `, `;

  & + `, ` {
    `, `
  }

  &:hover + `, ` {
    `, `
  }
`])), Vl(12), Ln, ZM, (r) => r.isInlineEditorPopoverOpen ? Vl(Z3) : "", ZM, Vl(Z3)), TQ = (r) => {
        let s = D0("SingleKeyframeDot", r.keyframe.id), a = K0(r.itemKey), [d, m] = kn(null), [y] = lSe(m, s, r), { node: x, toggle: w, isOpen: T } = X3([{ type: "primitiveProp", keyframe: r.keyframe, pathToProp: r.leaf.pathToProp, propConfig: r.leaf.propConf, sheetObject: r.leaf.sheetObject, trackId: r.leaf.trackId }]);
        uSe(m, r, { onClickFromDrag(M) {
          w(M, d.current);
        } });
        let P = !r.keyframe.type || r.keyframe.type === "bezier";
        return Zh.default.createElement(Zh.default.Fragment, null, Zh.default.createElement(EQ, L({ ref: d, isInlineEditorPopoverOpen: T }, a.attrs)), P ? Zh.default.createElement(ZM, { isSelected: !!r.selection, isInlineEditorPopoverOpen: T, flag: a.flag }) : Zh.default.createElement(SQ, { isSelected: !!r.selection, isInlineEditorPopoverOpen: T, flag: a.flag }), x, y);
      }, CQ = TQ;
    }), ej, tj, nj, mm, AQ, kQ, MQ, cSe = R(() => {
      Al(), ej = Y(xe()), it(), PQ(), tj = dS / 2 + 1, nj = 1e3, mm = { normalColor: "#365b59", selectedColor: "#8A7842", barColor: (r) => {
        let s = r.isSelected ? mm.selectedColor : mm.normalColor;
        return r.isPopoverOpen ? Ek(0.2, _0(0.2, s)) : s;
      }, hoverColor: (r) => {
        let s = r.isSelected ? mm.selectedColor : mm.normalColor;
        return r.isPopoverOpen ? Ek(0.2, _0(0.2, s)) : Ek(0.1, _0(0.1, s));
      } }, kQ = ee.div(AQ || (AQ = $([`
  position: absolute;
  background: `, `;
  height: `, `px;
  width: `, `px;

  left: 0;
  top: -`, `px;
  transform-origin: top left;
  z-index: 0;
  cursor: ew-resize;

  &:after {
    display: block;
    position: absolute;
    content: ' ';
    top: -4px;
    bottom: -4px;
    left: 0;
    right: 0;
  }

  &:hover {
    background: `, `;
  }
`])), mm.barColor, tj, nj, tj / 2, mm.hoverColor), MQ = ej.default.forwardRef((r, s) => {
        let a = { isPopoverOpen: r.isPopoverOpen, isSelected: r.isSelected };
        return ej.default.createElement(kQ, V(L({}, a), { ref: s, style: { transform: "scaleX(calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(r.connectorLengthInUnitSpace / nj, "))") }, onClick: (d) => {
          var m;
          (m = r.openPopover) == null || m.call(r, d);
        } }), r.children);
      });
    });
    function dSe(r, s) {
      let a = (0, rj.useRef)(s);
      a.current = s;
      let d = (0, rj.useMemo)(() => ({ debugName: "useDragKeyframe", lockCSSCursorTo: "ew-resize", onDragStart(m) {
        let y = a.current, x;
        if (y.selection) {
          let { selection: M, leaf: F } = y, { sheetObject: O } = F;
          return M.getDragHandlers(V(L({}, O.address), { domNode: r, positionAtStartOfDrag: y.track.data.keyframes[y.index].position })).onDragStart(m);
        }
        let w = y, T = (0, JM.val)(w.layoutP.sheet).getSequence(), P = (0, JM.val)(w.layoutP.scaledSpace.toUnitSpace);
        return { onDrag(M, F, O) {
          let N = P(M);
          x && (x.discard(), x = void 0), x = pe().tempTransaction(({ stateEditors: B }) => {
            B.coreByProject.historic.sheetsById.sequence.transformKeyframes(V(L({}, w.leaf.sheetObject.address), { trackId: w.leaf.trackId, keyframeIds: [w.keyframe.id, w.track.data.keyframes[w.index + 1].id], translate: N, scale: 1, origin: 0, snappingFunction: T.closestGridPosition }));
          });
        }, onDragEnd(M) {
          M ? x && x.commit() : x && x.discard();
        } };
      } }), []);
      Fr(r, d);
    }
    function hSe(r, s, a, d) {
      return Bs(s, { displayName: "Tween", menuItems: () => {
        let m = dQ(r.leaf.sheetObject.address.projectId, r.leaf.sheetObject.address.sheetId, r.selection);
        return [{ label: m.length > 0 ? "Copy (selection)" : "Copy", callback: () => {
          m.length > 0 ? pe().transaction((y) => {
            y.stateEditors.studio.ahistoric.setClipboardKeyframes(m);
          }) : pe().transaction((y) => {
            y.stateEditors.studio.ahistoric.setClipboardKeyframes([{ keyframe: a, pathToProp: r.leaf.pathToProp }, { keyframe: d, pathToProp: r.leaf.pathToProp }]);
          });
        } }, { label: r.selection ? "Delete (selection)" : "Delete", callback: () => {
          r.selection ? r.selection.delete() : pe().transaction(({ stateEditors: y }) => {
            y.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, r.leaf.sheetObject.address), { keyframeIds: [a.id, d.id], trackId: r.leaf.trackId }));
          });
        } }];
      } });
    }
    var JM, Jh, rj, ij, RQ, IQ, NQ, OQ, DQ, pSe = R(() => {
      st(), Ls(), li(), Hn(), JM = ut(), Jh = Y(xe()), rj = Y(xe()), Dl(), Fl(), cQ(), cSe(), OM(), zt(), WM(), WM(), it(), ij = 5, IQ = ee(Mo)(RQ || (RQ = $([`
  --popover-outer-stroke: transparent;
  --popover-inner-stroke: `, `;
`])), U3), NQ = (r) => {
        let { index: s, track: a } = r, d = a.data.keyframes[s], m = a.data.keyframes[s + 1], [y, x] = kn(null), { node: w, toggle: T, close: P } = ko(() => {
          let N = (0, JM.val)(r.layoutP.rightDims);
          return { debugName: "Connector", constraints: { minX: N.screenX + ij, maxX: N.screenX + N.width - ij } };
        }, () => Jh.default.createElement(DQ, V(L({}, r), { closePopover: P }))), [M] = hSe(r, x, d, m);
        dSe(x, r);
        let F = m.position - d.position, O = { isPopoverOpen: At(() => lQ(V(L({}, r.leaf.sheetObject.address), { trackId: r.leaf.trackId, left: d, right: m })), [r.leaf.sheetObject.address, r.leaf.trackId, d, m]), isSelected: r.selection !== void 0 };
        return Jh.default.createElement(Jh.default.Fragment, null, Jh.default.createElement(MQ, V(L({ ref: y, connectorLengthInUnitSpace: F }, O), { openPopover: (N) => {
          x && T(N, x);
        } }), w), M);
      }, OQ = NQ, DQ = Jh.default.forwardRef((r, s) => {
        let { index: a, track: { data: d }, selection: m } = r, y = d.keyframes[a], x = d.keyframes[a + 1], w = r.leaf.trackId, T = r.leaf.sheetObject.address;
        if (!w) return null;
        let P = At(() => Z1e(T.projectId, T.sheetId, m).getValue(), [T, m]), M = L({ left: y, right: x, trackId: w }, T);
        return Jh.default.createElement(IQ, { showPopoverEdgeTriangle: !1, ref: s }, Jh.default.createElement(aQ, { curveConnection: M, additionalConnections: P, onRequestClose: r.closePopover }));
      });
    }), FQ, gm, BQ, LQ, jQ, UQ, zQ, fSe = R(() => {
      FQ = ut(), gm = Y(xe()), it(), pSe(), PQ(), LQ = ee.div(BQ || (BQ = $([`
  position: absolute;
`]))), jQ = gm.default.createElement(gm.default.Fragment, null), UQ = gm.default.memo((r) => {
        let { index: s, track: { data: a } } = r, d = a.keyframes[s], m = a.keyframes[s + 1], y = d.connectedRight && !!m;
        return gm.default.createElement(LQ, { style: { top: "".concat(r.leaf.nodeHeight / 2, "px"), left: "calc(".concat((0, FQ.val)(r.layoutP.scaledSpace.leftPadding), "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(d.position, "px))") } }, gm.default.createElement(CQ, V(L({}, r), { itemKey: r.itemKey })), y ? gm.default.createElement(OQ, L({}, r)) : jQ);
      }), zQ = UQ;
    });
    function mSe(r, s) {
      return Bs(r, { displayName: "Keyframe Track", menuItems: () => {
        var a;
        let d = (a = (0, rv.val)(pe().atomP.ahistoric.clipboard.keyframesWithRelativePaths)) != null ? a : [];
        return [gSe(s, d)];
      } });
    }
    function gSe(r, s) {
      return { label: "Paste Keyframes", enabled: s.length > 0, callback: () => {
        var a;
        let d = (0, rv.val)(r.layoutP.sheet).getSequence(), m = (a = s[0]) == null ? void 0 : a.pathToProp, y = s.filter(({ keyframe: x, pathToProp: w }) => v1e(m, w)).map(({ keyframe: x, pathToProp: w }) => x);
        pe().transaction(({ stateEditors: x }) => {
          var w;
          d.position = d.closestGridPosition(d.position);
          let T = (w = ySe(y)) == null ? void 0 : w.position;
          for (let P of y) r.leaf.trackId && x.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(V(L({}, r.leaf.sheetObject.address), { trackId: r.leaf.trackId, position: d.position + P.position - T, handles: P.handles, value: P.value, snappingFunction: d.closestGridPosition, type: P.type }));
        });
      } };
    }
    function ySe(r) {
      let s = null;
      for (let a of r) (s === null || a.position < s.position) && (s = a);
      return s;
    }
    var rv, hd, VQ, GQ, sj, qQ, vSe = R(() => {
      zt(), rv = ut(), hd = Y(xe()), it(), fSe(), Ls(), Hn(), st(), Xh(), ev(), Nl(), GQ = ee.div(VQ || (VQ = $([`
  position: relative;
  height: 100%;
  width: 100%;
`]))), sj = hd.default.memo((r) => {
        var s;
        let { layoutP: a, trackData: d, leaf: m } = r, [y, x] = kn(null), { selectedKeyframeIds: w, selection: T } = At(() => {
          if (!m.trackId) return { selectedKeyframeIds: void 0, selection: void 0 };
          let ne = (0, rv.val)(a.selectionAtom), ce = (0, rv.val)(ne.pointer.current);
          if (!ce) return { selectedKeyframeIds: void 0, selection: void 0 };
          let ue = (0, rv.val)(ne.pointer.current.byObjectKey[m.sheetObject.address.objectKey].byTrackId[m.trackId].byKeyframeId);
          return ue ? { selectedKeyframeIds: ue, selection: ce } : { selectedKeyframeIds: void 0, selection: void 0 };
        }, [a, m.trackId]), [P, M, F] = mSe(x, r), O = nn(JY), N = O.mode === "snapToSome" && m.trackId ? (s = O.positions[m.sheetObject.address.objectKey]) == null ? void 0 : s[m.trackId] : [], B = O.mode === "snapToAll";
        if (!m.trackId) return null;
        let U = (0, hd.useMemo)(() => ({ data: d, id: m.trackId, sheetObject: r.leaf.sheetObject }), [d, m.trackId]), H = d.keyframes.map((ne, ce) => hd.default.createElement(zQ, { key: "keyframe-" + ne.id, itemKey: Ji.forTrackKeyframe(m.sheetObject, m.trackId, ne.id), keyframe: ne, index: ce, track: U, layoutP: a, leaf: m, selection: w?.[ne.id] === !0 ? T : void 0 })), W = N.map((ne) => hd.default.createElement(B3, { key: "snap-target-" + ne, layoutP: a, leaf: m, position: ne })), Q = B ? d.keyframes.map((ne) => hd.default.createElement(B3, { key: "additionalSnapTarget-".concat(ne.id), layoutP: a, leaf: m, position: ne.position })) : null;
        return hd.default.createElement(GQ, { ref: y, style: { background: F ? "#444850 " : "unset" } }, H, W, hd.default.createElement(hd.default.Fragment, null, Q), P);
      }), sj.displayName = "BasicKeyframedTrack", qQ = sj;
    }), HQ, ym, $Q, WQ, bSe = R(() => {
      st(), zt(), HQ = ut(), ym = Y(xe()), IM(), vSe(), om(), $Q = ({ leaf: r, layoutP: s }) => {
        let a = D0("PrimitivePropRow", r.pathToProp.join());
        return At(() => {
          let { sheetObject: d } = r, { trackId: m } = r;
          if (!m) return ym.default.createElement(hm, { leaf: r, isCollapsed: !1, node: ym.default.createElement("div", null) });
          let y = (0, HQ.val)(pe().atomP.historic.coreByProject[d.address.projectId].sheetsById[d.address.sheetId].sequence.tracksByObject[d.address.objectKey].trackData[m]);
          return y?.type !== "BasicKeyframedTrack" ? (a.errorDev("trackData type ".concat(y?.type, " is not yet supported on the sequence editor")), ym.default.createElement(hm, { leaf: r, isCollapsed: !1, node: ym.default.createElement("div", null) })) : ym.default.createElement(hm, { leaf: r, isCollapsed: !1, node: ym.default.createElement(qQ, { layoutP: s, trackData: y, leaf: r }) });
        }, [r, s]);
      }, WQ = $Q;
    });
    function KQ() {
      let r = Math.random() * 360, s = 0.7 + Math.random() * 0.3, a = 0.55 + Math.random() * 0.2, d = s * Math.min(a, 1 - a), m = (y) => {
        let x = (y + r / 30) % 12, w = a - d * Math.max(Math.min(x - 3, 9 - x, 1), -1);
        return Math.round(255 * w).toString(16).padStart(2, "0");
      };
      return "#".concat(m(0)).concat(m(8)).concat(m(4));
    }
    var YQ = R(() => {
    });
    function XQ(r, s, a) {
      let d = (0, pS.val)(s.sheet).getSequence();
      r.type === "sheet" ? xSe(r, a, d) : _Se(r, a, d);
    }
    function xSe(r, s, a) {
      var d, m;
      let { projectId: y, sheetId: x } = r.sheet.address, w = s.every(({ pathToProp: M }) => M.length === 0), T = [], P = /* @__PURE__ */ new Map();
      for (let M of r.children) M.type === "sheetObject" && P.set(M.sheetObject.address.objectKey, M.sheetObject);
      if (w) for (let M of r.children.filter((F) => F.type === "sheetObject").map((F) => F.sheetObject)) {
        let F = (0, pS.pointerToPrism)(pe().atomP.historic.coreByProject[y].sheetsById[x].sequence.tracksByObject[M.address.objectKey]).getValue(), O = Object.keys((d = F?.trackData) != null ? d : {});
        for (let N of O) for (let { keyframe: B } of s) T.push({ keyframe: B, trackId: N, address: V(L({}, M.address), { pathToProp: [] }), sheetObject: M });
      }
      else {
        let M = (0, pS.pointerToPrism)(pe().atomP.historic.coreByProject[y].sheetsById[x].sequence.tracksByObject).getValue();
        for (let { keyframe: F, pathToProp: O } of s) {
          if (O.length === 0) continue;
          let N = O[0], B = O.slice(1), U = P.get(N);
          if (!U) continue;
          let H = M?.[N], W = Ul(B), Q = (m = H?.trackIdByPropPath) == null ? void 0 : m[W];
          T.push({ keyframe: F, trackId: Q, address: V(L({}, U.address), { pathToProp: B }), sheetObject: U });
        }
      }
      QQ(T, a);
    }
    function _Se(r, s, a) {
      var d, m;
      let { projectId: y, sheetId: x, objectKey: w } = r.sheetObject.address, T = r.sheetObject, P = (0, pS.pointerToPrism)(pe().atomP.historic.coreByProject[y].sheetsById[x].sequence.tracksByObject[w]).getValue(), M = s.every(({ pathToProp: O }) => O.length === 0), F = [];
      if (M) if (r.type === "sheetObject") {
        let O = Object.keys((d = P?.trackData) != null ? d : {});
        for (let N of O) for (let { keyframe: B } of s) F.push({ keyframe: B, trackId: N, address: V(L({}, T.address), { pathToProp: [] }), sheetObject: T });
      } else {
        let O = r.pathToProp, N = $0(T.template.staticConfig, O);
        if (N) for (let { path: B, conf: U } of W0(N, O)) {
          if (Hu(U)) continue;
          let H = B, W = Ul(H), Q = (m = P?.trackIdByPropPath) == null ? void 0 : m[W];
          for (let { keyframe: ne } of s) F.push({ keyframe: ne, trackId: Q, address: V(L({}, T.address), { pathToProp: H }), sheetObject: T });
        }
      }
      else {
        let O = P?.trackIdByPropPath || {}, N = r.type === "propWithChildren" ? r.pathToProp : [];
        for (let { keyframe: B, pathToProp: U } of s) {
          let H = [...N, ...U], W = Ul(H), Q = O[W];
          F.push({ keyframe: B, trackId: Q, address: V(L({}, T.address), { pathToProp: H }), sheetObject: T });
        }
      }
      QQ(F, a);
    }
    function QQ(r, s) {
      var a;
      if (r.length === 0) return;
      s.position = s.closestGridPosition(s.position);
      let d = (a = SSe(r.map(({ keyframe: m }) => m))) == null ? void 0 : a.position;
      pe().transaction(({ stateEditors: m, drafts: y }) => {
        var x, w, T;
        for (let P of r) {
          let { keyframe: M, address: F, sheetObject: O } = P, N = P.trackId;
          if (!N) {
            let B = $0(O.template.staticConfig, F.pathToProp);
            if (B && !Hu(B)) {
              m.coreByProject.historic.sheetsById.sequence.setPrimitivePropAsSequenced(F, B);
              let U = (T = (w = (x = y.historic.coreByProject[F.projectId]) == null ? void 0 : x.sheetsById[F.sheetId]) == null ? void 0 : w.sequence) == null ? void 0 : T.tracksByObject[F.objectKey];
              if (U) {
                let H = Ul(F.pathToProp);
                N = U.trackIdByPropPath[H];
              }
            }
          }
          N && m.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(V(L({}, F), { trackId: N, position: s.position + M.position - d, handles: M.handles, value: M.value, snappingFunction: s.closestGridPosition, type: M.type }));
        }
      });
    }
    function SSe(r) {
      let s = null;
      for (let a of r) (s === null || a.position < s.position) && (s = a);
      return s;
    }
    function ZQ(r, s) {
      let a = Array.from(s.byPosition.keys());
      if (a.length === 0) return;
      let d = { first: Math.min(...a), last: Math.max(...a) }, m = s.tracks.flatMap((T) => {
        var P;
        return (P = hQ(V(L({}, T.sheetObject.address), { trackId: T.id, keyframeIds: T.data.keyframes.filter((M) => M.position >= d.first && M.position <= d.last).map((M) => M.id) }))) != null ? P : [];
      }), y = r.type === "sheet" ? [] : r.type === "sheetObject" ? [r.sheetObject.address.objectKey] : r.type === "propWithChildren" ? [r.sheetObject.address.objectKey, ...r.pathToProp] : [], x = x3([y, ...m.map((T) => T.pathToProp)]), w = m.map(({ keyframe: T, pathToProp: P }) => ({ keyframe: T, pathToProp: P.slice(x.length) }));
      pe().transaction((T) => {
        T.stateEditors.studio.ahistoric.setClipboardKeyframes(w);
      });
    }
    var pS, JQ = R(() => {
      pS = ut(), st(), WM(), Xh(), Wh();
    });
    function wSe(r) {
      if (!r) return null;
      let s = r.closest("[data-handle]");
      return s && s.getAttribute("data-handle") || null;
    }
    function eZ(r) {
      if (r.type === "sheet") return "theatre-agg-keyframe-color-sheet-".concat(r.sheet.address.sheetId);
      if (r.type === "sheetObject") return "theatre-agg-keyframe-color-object-".concat(r.sheetObject.address.objectKey);
      {
        let s = r.pathToProp.join(".");
        return "theatre-agg-keyframe-color-prop-".concat(r.sheetObject.address.objectKey, "-").concat(s);
      }
    }
    function ESe(r) {
      let s = eZ(r), a = localStorage.getItem(s);
      if (a) return a;
      let d = KQ();
      return localStorage.setItem(s, d), d;
    }
    function tZ(r, s) {
      let a = eZ(r);
      localStorage.setItem(a, s);
    }
    function TSe(r) {
      let { layoutP: s, aggregatedKeyframes: a, viewModel: d } = r, [m, y] = kn(null), x = bs.default.useRef(null), [w, T] = bs.default.useState(() => ESe(d)), [P, M] = bs.default.useState(!1), [F, O] = bs.default.useState({ top: 0, left: 0 }), N = (0, bs.useMemo)(() => {
        let ue = Array.from(a.byPosition.keys());
        return ue.length === 0 ? null : { first: Math.min(...ue), last: Math.max(...ue) };
      }, [a]), [B] = Bs(y, { displayName: "Aggregate Keyframe", menuItems: () => {
        var ue;
        let se = (ue = (0, iv.pointerToPrism)(pe().atomP.ahistoric.clipboard.keyframesWithRelativePaths).getValue()) != null ? ue : [];
        return [{ label: "Copy Keyframes", callback: () => {
          ZQ(d, a);
        } }, { label: "Paste Keyframes", enabled: se.length > 0, callback: () => {
          XQ(d, s, se);
        } }, { label: "Custom Color", callback: () => {
          if (M(!0), y) {
            let Oe = y.getBoundingClientRect();
            O({ top: Math.max(10, Oe.top), left: Math.max(10, Oe.left) });
          }
        } }, { label: "Delete", callback: () => {
          pe().transaction(({ stateEditors: Oe }) => {
            for (let he of a.tracks) {
              let ie = he.data.keyframes.filter((ye) => ye.position >= N.first && ye.position <= N.last).map((ye) => ye.id);
              ie.length > 0 && Oe.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, he.sheetObject.address), { keyframeIds: ie, trackId: he.id }));
            }
          });
        } }];
      } }), U = N3(), H = (0, bs.useMemo)(() => ({ debugName: "AggregateKeyframeBar/useDrag", onDragStart: (ue) => {
        if (!N) return !1;
        let se = ue.target, Oe = wSe(se), he = Oe !== null;
        U(!0, N.first), d.type === "sheet" ? d.sheet.address : d.sheetObject.address;
        let ie = (0, iv.val)(s.scaledSpace.toUnitSpace), ye;
        return { onDrag(Ee, ve, Xe) {
          let Se = ie(Ee), nt = Math.max(0, N.first + Se);
          if (he) {
            let De = Oe === "left", Ce = N.first, le = N.last, Ie = De ? N.first : N.last, $e = Math.max(0, Ie + Se);
            if (De && $e >= le || !De && $e <= Ce) return;
            let de = le - Ce, Ae = Math.abs($e - (De ? le : Ce));
            if (de === 0 || Ae === 0) return;
            ye?.discard(), ye = pe().tempTransaction(({ stateEditors: Je }) => {
              for (let rt of a.tracks) {
                let Ve = [];
                for (let oe of rt.data.keyframes) if (oe.position >= Math.min(Ce, le) && oe.position <= Math.max(Ce, le)) {
                  let je = (oe.position - Ce) / de, Ge = De ? $e + je * Ae : Ce + je * Ae;
                  Ve.push(V(L({}, oe), { position: Ge }));
                }
                Ve.length > 0 && Je.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, rt.sheetObject.address), { trackId: rt.id, keyframes: Ve, snappingFunction: (0, iv.val)(s.sheet).getSequence().closestGridPosition }));
              }
            });
          } else ye?.discard(), ye = pe().tempTransaction(({ stateEditors: De }) => {
            for (let Ce of a.tracks) {
              let le = [];
              for (let Ie of Ce.data.keyframes) Ie.position >= N.first && Ie.position <= N.last && le.push(V(L({}, Ie), { position: Math.max(0, Ie.position + Se) }));
              le.length > 0 && De.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, Ce.sheetObject.address), { trackId: Ce.id, keyframes: le, snappingFunction: (0, iv.val)(s.sheet).getSequence().closestGridPosition }));
            }
          });
          U(!0, nt);
        }, onDragEnd(Ee) {
          U(!1, -1), Ee ? ye?.commit() : ye?.discard();
        } };
      } }), [N, a, s, d, U]), [W] = Fr(y, H);
      if (Ao(W, "draggingPositionInSequenceEditor", "ew-resize"), !N) return bs.default.createElement(oj, { ref: m });
      let Q = (0, iv.val)(s.scaledSpace.leftPadding), ne = "calc(".concat(Q, "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(N.first, "px))"), ce = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(N.last - N.first, "px)");
      return bs.default.createElement(oj, { ref: m }, bs.default.createElement(iZ, { $color: w, style: { left: ne, width: ce } }, bs.default.createElement(aZ, { $position: "left", "data-handle": "left" }), bs.default.createElement(uZ, { $position: "right", style: { left: "calc(100% - 7px)" }, "data-handle": "right" })), P && bs.default.createElement(dZ, { style: { position: "fixed", top: "".concat(F.top, "px"), left: "".concat(F.left, "px") } }, bs.default.createElement(pZ, { ref: x, type: "color", value: w, onChange: (ue) => {
        let se = ue.currentTarget.value;
        T(se), tZ(d, se);
      }, autoFocus: !0 }), bs.default.createElement(mZ, { type: "text", placeholder: "#000000", value: w, onChange: (ue) => {
        let se = ue.currentTarget.value;
        se.startsWith("#") || (se = "#" + se), /^#[0-9A-F]{6}$/i.test(se) && (T(se), tZ(d, se));
      } }), bs.default.createElement("button", { onClick: () => M(!1), style: { padding: "4px 8px", fontSize: "12px", cursor: "pointer", border: "1px solid #666", borderRadius: "2px", background: "#222", color: "#FFF", height: "28px" } }, "Done")), B);
    }
    var iv, bs, nZ, oj, rZ, iZ, sZ, aj, oZ, aZ, lZ, uZ, cZ, dZ, hZ, pZ, fZ, mZ, gZ, yZ, CSe = R(() => {
      iv = ut(), bs = Y(xe()), it(), Hn(), li(), Os(), st(), Ui(), Ls(), Xn(), YQ(), JQ(), oj = ee.div(nZ || (nZ = $([`
  position: absolute;
  height: 100%;
  width: 100%;
`]))), iZ = ee.div(rZ || (rZ = $([`
  position: absolute;
  height: 20px;
  background: `, `;
  cursor: ew-resize;
  top: 50%;
  transform: translateY(-50%);
  border-radius: 2px;
  z-index: 2;
  `, `

  &:hover {
    opacity: 0.8;
  }
`])), (r) => r.$color, Ln), aj = ee.div(sZ || (sZ = $([`
  position: absolute;
  height: 20px;
  width: 7px;
  top: 50%;
  transform: translateY(-50%);
  display: block;
  z-index: 3;
  `, `

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    background: inherit;
    border-radius: `, `;
    width: 7px;
    height: 20px;
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    width: 15px;
    height: 28px;
    top: 50%;
    transform: translateY(-50%);
    `, `
  }

  &:hover:before {
    opacity: 0.8;
  }
`])), Ln, (r) => r.$position === "left" ? "2px 0 0 2px" : "0 2px 2px 0", (r) => r.$position === "left" ? "left: -8px; cursor: w-resize;" : "right: -8px; cursor: e-resize;"), aZ = ee(aj)(oZ || (oZ = $([`
  left: calc(-1 * 7px);
`]))), uZ = ee(aj)(lZ || (lZ = $([`
  right: 0px;
`]))), dZ = ee.div(cZ || (cZ = $([`
  position: absolute;
  background: #333;
  border-radius: 4px;
  padding: 4px;
  z-index: 1000;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
`]))), pZ = ee.input(hZ || (hZ = $([`
  background: #222;
  width: 50px;
  height: 30px;
  border: 1px solid #666;
  border-radius: 2px;
  cursor: pointer;

  &::-webkit-color-swatch-wrapper {
    padding: 2px;
  }

  &::-webkit-color-swatch {
    border: 1px solid #999;
    border-radius: 2px;
  }
`]))), mZ = ee.input(fZ || (fZ = $([`
  background: #222;
  border: 1px solid #666;
  color: #fff;
  width: 70px;
  height: 28px;
  padding: 4px;
  border-radius: 2px;
  font-family: monospace;
  font-size: 12px;

  &:focus {
    outline: none;
    border-color: #40aaa4;
  }
`]))), gZ = bs.default.memo(TSe), yZ = gZ;
    });
    function PSe(r) {
      let { layoutP: s, aggregatedKeyframes: a, viewModel: d } = r, [m, y] = kn(null);
      return eR.default.createElement(bZ, { ref: m }, eR.default.createElement(yZ, { viewModel: d, aggregatedKeyframes: a, layoutP: s }));
    }
    var eR, vZ, bZ, xZ, lj, _Z = R(() => {
      eR = Y(xe()), it(), Hn(), CSe(), bZ = ee.div(vZ || (vZ = $([`
  position: relative;
  height: 100%;
  width: 100%;
`]))), xZ = eR.default.memo(PSe), lj = xZ;
    }), sv, tR, SZ, wZ = R(() => {
      zt(), sv = Y(xe()), bSe(), IM(), _Z(), EM(), om(), tR = (r, s, a = !0) => r.type === "propWithChildren" ? sv.default.createElement(SZ, { layoutP: s, viewModel: r, key: "prop" + r.pathToProp[r.pathToProp.length - 1], renderChildren: a }) : sv.default.createElement(WQ, { layoutP: s, leaf: r, key: "prop" + r.pathToProp[r.pathToProp.length - 1] }), SZ = ({ viewModel: r, layoutP: s, renderChildren: a = !0 }) => {
        let d = D0("RightPropWithChildrenRow", r.pathToProp.join());
        return At(() => {
          let m = wM(r);
          return sv.default.createElement(QH, { logger: d }, sv.default.createElement(hm, { leaf: r, node: sv.default.createElement(lj, { layoutP: s, aggregatedKeyframes: m, viewModel: r }), isCollapsed: r.isCollapsed }, a && r.children.map((y) => tR(y, s))));
        }, [r, s]);
      };
    }), uj, EZ, TZ, ASe = R(() => {
      zt(), uj = Y(xe()), wZ(), IM(), EM(), _Z(), EZ = ({ leaf: r, layoutP: s, renderChildren: a = !0 }) => At(() => {
        let d = wM(r);
        return uj.default.createElement(hm, { leaf: r, node: uj.default.createElement(lj, { layoutP: s, aggregatedKeyframes: d, viewModel: r }), isCollapsed: r.isCollapsed }, a && r.children.map((m) => tR(m, s)));
      }, [r, s]), TZ = EZ;
    });
    function CZ(r) {
      return "theatre-subsequence-color-".concat(r.sheet.address.projectId, "-").concat(r.sheet.address.sheetId, "-").concat(r.subSequence.id);
    }
    function kSe(r) {
      let s = CZ(r), a = localStorage.getItem(s);
      if (a) return a;
      let d = KQ();
      return localStorage.setItem(s, d), d;
    }
    function PZ(r, s) {
      let a = CZ(r);
      localStorage.setItem(a, s);
    }
    var aa, Mn, AZ, kZ, MZ, RZ, IZ, cj, NZ, OZ, DZ, FZ, BZ, LZ, jZ, UZ, zZ, VZ, GZ, qZ, HZ, MSe = R(() => {
      aa = ut(), Mn = Y(xe()), it(), Ui(), Os(), st(), Ls(), Dl(), Fl(), li(), Hn(), Xn(), zl(), Os(), DY(), YQ(), kZ = ee.div(AZ || (AZ = $([`
  position: absolute;
  height: 100%;
  width: 100%;
  min-width: 20px;
`]))), RZ = ee.div.attrs((r) => ({ style: { background: r.$color } }))(MZ || (MZ = $([`
  position: absolute;
  height: 20px;
  line-height: 20px;
  cursor: ew-resize;
  top: 50%;
  transform: translateY(-50%);
  border-radius: 2px;
  text-align: center;
  width: 100%;
  z-index: 2;
  `, `

  &:hover {
    opacity: 0.8;
  }

  span {
    color: white;
    font-weight: bold;
    text-shadow: 0 1px rgba(0, 0, 0, 0.67);
  }
`])), Ln), cj = ee.div(IZ || (IZ = $([`
  background: #555;
  position: absolute;
  height: 20px;
  width: 7px;
  top: 50%;
  transform: translateY(-50%);
  display: block;
  z-index: 3;
  `, `

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    background: inherit;
    border-radius: `, `;
    width: 7px;
    height: 20px;
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    width: 15px;
    height: 28px;
    top: 50%;
    transform: translateY(-50%);
    `, `
  }

  &:hover:before {
    background: rgba(170, 64, 64, 0.6);
  }

  // Snap cursor when dragging playhead
  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
    cursor: var(`, `);

    // Show snap cursor () on hover
    &:hover:after {
      background: url(`, `) no-repeat center center;
      background-size: 34px 34px;
    }
  }
`])), Ln, (r) => r.$position === "left" ? "2px 0 0 2px" : "0 2px 2px 0", (r) => r.$position === "left" ? "left: -8px; cursor: w-resize;" : "right: -8px; cursor: e-resize;", Ml, I3), OZ = ee(cj).attrs((r) => ({ style: { background: r.$color } }))(NZ || (NZ = $([`
  border-right: 1px solid rgba(0, 0, 0, 0.25);
  left: -7px;
`]))), FZ = ee(cj).attrs((r) => ({ style: { background: r.$color } }))(DZ || (DZ = $([`
  border-left: 1px solid rgba(0, 0, 0, 0.25);
  right: -7px;
`]))), ee.div(BZ || (BZ = $([`
  position: absolute;
  left: 8px;
  top: 50%;
  transform: translateY(-50%);
  color: rgba(255, 255, 255, 0.9);
  font-size: 11px;
  font-weight: 500;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  pointer-events: none;
  user-select: none;
`]))), jZ = ee.div(LZ || (LZ = $([`
  position: absolute;
  background: #333;
  border-radius: 4px;
  padding: 4px;
  z-index: 1000;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
`]))), zZ = ee.input(UZ || (UZ = $([`
  background: #222;
  width: 50px;
  height: 30px;
  border: 1px solid #666;
  border-radius: 2px;
  cursor: pointer;

  &::-webkit-color-swatch-wrapper {
    padding: 2px;
  }

  &::-webkit-color-swatch {
    border: 1px solid #999;
    border-radius: 2px;
  }
`]))), GZ = ee.input(VZ || (VZ = $([`
  background: #222;
  border: 1px solid #666;
  color: #fff;
  width: 70px;
  height: 28px;
  padding: 4px;
  border-radius: 2px;
  font-family: monospace;
  font-size: 12px;

  &:focus {
    outline: none;
    border-color: #40aaa4;
  }
`]))), qZ = ({ leaf: r, layoutP: s }) => {
        var a;
        let [d, m] = kn(null), [y, x] = kn(null), [w, T] = kn(null), [P, M] = kn(null), F = Mn.default.useRef(null), [O, N] = (0, Mn.useState)(() => kSe(r)), [B, U] = (0, Mn.useState)(!1), [H, W] = (0, Mn.useState)({ top: 0, left: 0 }), Q = ko({ debugName: "SubSequenceBar/editLabel" }, () => {
          let Ie = r.subSequence.label, $e = Ie;
          return Mn.default.createElement(Mo, null, Mn.default.createElement("div", { style: { padding: "8px" } }, Mn.default.createElement("div", { style: { marginBottom: "8px", fontWeight: "bold" } }, "Edit Sub-sequence Label"), Mn.default.createElement("input", { type: "text", defaultValue: Ie, onChange: (de) => {
            $e = de.target.value;
          }, style: { width: "200px", padding: "4px", marginBottom: "8px" }, autoFocus: !0 }), Mn.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "4px" } }, Mn.default.createElement("button", { onClick: () => {
            pe().transaction(({ stateEditors: de }) => {
              de.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), de.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { label: $e } });
            }), Q.close("user action");
          }, style: { padding: "4px 12px", background: "#40AAA4", color: "white", border: "none", borderRadius: "2px", cursor: "pointer" } }, "Done"))));
        }), ne = ko({ debugName: "SubSequenceBar/editDuration" }, () => {
          let Ie = r.subSequence.duration, $e = Ie;
          return Mn.default.createElement(Mo, null, Mn.default.createElement("div", { style: { padding: "8px" } }, Mn.default.createElement("div", { style: { marginBottom: "8px", fontWeight: "bold" } }, "Edit Sub-sequence Duration"), Mn.default.createElement("input", { type: "number", defaultValue: Ie, step: 0.1, min: 0.1, onChange: (de) => {
            $e = parseFloat(de.target.value);
          }, style: { width: "200px", padding: "4px", marginBottom: "8px" }, autoFocus: !0 }), Mn.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "4px" } }, Mn.default.createElement("button", { onClick: () => {
            $e > 0 && pe().transaction(({ stateEditors: de }) => {
              de.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), de.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { duration: $e } });
            }), ne.close("user action");
          }, style: { padding: "4px 12px", background: "#40AAA4", color: "white", border: "none", borderRadius: "2px", cursor: "pointer" } }, "Done"))));
        }), ce = ko({ debugName: "SubSequenceBar/editTimeScale" }, () => {
          let Ie = r.subSequence.timeScale, $e = Ie;
          return Mn.default.createElement(Mo, null, Mn.default.createElement("div", { style: { padding: "8px" } }, Mn.default.createElement("div", { style: { marginBottom: "8px", fontWeight: "bold" } }, "Edit Sub-sequence Time Scale"), Mn.default.createElement("input", { type: "number", defaultValue: Ie, step: 0.1, min: 0.1, onChange: (de) => {
            $e = parseFloat(de.target.value);
          }, style: { width: "200px", padding: "4px", marginBottom: "8px" }, autoFocus: !0 }), Mn.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "4px" } }, Mn.default.createElement("button", { onClick: () => {
            $e > 0 && pe().transaction(({ stateEditors: de }) => {
              de.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), de.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { timeScale: $e } });
            }), ce.close("user action");
          }, style: { padding: "4px 12px", background: "#40AAA4", color: "white", border: "none", borderRadius: "2px", cursor: "pointer" } }, "Done"))));
        }), ue = ko({ debugName: "SubSequenceBar/editStart" }, () => {
          let Ie = r.subSequence.position, $e = Ie;
          return Mn.default.createElement(Mo, null, Mn.default.createElement("div", { style: { padding: "8px" } }, Mn.default.createElement("div", { style: { marginBottom: "8px", fontWeight: "bold" } }, "Edit Sub-sequence Start Position"), Mn.default.createElement("input", { type: "number", defaultValue: Ie, step: 0.1, min: 0, onChange: (de) => {
            $e = parseFloat(de.target.value);
          }, style: { width: "200px", padding: "4px", marginBottom: "8px" }, autoFocus: !0 }), Mn.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "4px" } }, Mn.default.createElement("button", { onClick: () => {
            $e >= 0 && pe().transaction(({ stateEditors: de }) => {
              de.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), de.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { position: $e } });
            }), ue.close("user action");
          }, style: { padding: "4px 12px", background: "#40AAA4", color: "white", border: "none", borderRadius: "2px", cursor: "pointer" } }, "Ok"))));
        }), [se] = Bs(m, { menuItems: () => [{ label: "Edit Label", callback: () => {
          if (m) {
            let Ie = m.getBoundingClientRect();
            Q.open({ clientX: Ie.left, clientY: Ie.top }, m);
          }
        } }, { label: "Edit Start", callback: () => {
          if (m) {
            let Ie = m.getBoundingClientRect();
            ue.open({ clientX: Ie.left, clientY: Ie.top }, m);
          }
        } }, { label: "Edit Duration", callback: () => {
          if (m) {
            let Ie = m.getBoundingClientRect();
            ne.open({ clientX: Ie.left, clientY: Ie.top }, m);
          }
        } }, { label: "Edit Time Scale", callback: () => {
          if (m) {
            let Ie = m.getBoundingClientRect();
            ce.open({ clientX: Ie.left, clientY: Ie.top }, m);
          }
        } }, { label: "Delete Sub-sequence", callback: () => {
          pe().transaction(({ stateEditors: Ie }) => {
            Ie.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), Ie.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id });
          });
        } }, { label: "Custom Color", callback: () => {
          if (U(!0), m) {
            let Ie = m.getBoundingClientRect();
            W({ top: Math.max(10, Ie.top), left: Math.max(10, Ie.left) });
          }
        } }] }), Oe = N3(), he = (Ie) => {
          let $e = Ie.composedPath();
          for (let de of $e) {
            if (de === T) return "left";
            if (de === M) return "right";
            if (de === x) return "bar";
            if (de === m) break;
          }
          return null;
        }, ie = (0, Mn.useMemo)(() => {
          let Ie = null, $e = null, de = 0, Ae = 0, Je = 1, rt = () => {
            var Ve;
            let oe = r.subSequence.duration;
            if (!oe || oe === 0) try {
              let je = pe(), Ge = (0, aa.val)(je.projectsP)[r.sheet.address.projectId];
              oe = (Ve = (0, aa.val)(Ge.pointers.historic.sheetsById[r.subSequence.sheetId].sequence.length)) != null ? Ve : (0, aa.val)(s.sheet).getSequence().length;
            } catch {
              oe = (0, aa.val)(s.sheet).getSequence().length;
            }
            return oe ?? 1;
          };
          return { debugName: "SubSequenceBar/drag", lockCSSCursorTo: "ew-resize", onDragStart(Ve) {
            return $e = he(Ve), $e ? (de = r.subSequence.position, Ae = rt(), Je = r.subSequence.timeScale, Oe(!0, r.subSequence.position), { onDrag(oe) {
              Ie && Ie.discard(), Ie = pe().tempTransaction(({ stateEditors: je }) => {
                let Ge = (0, aa.val)(s.clippedSpace.range), yt = (0, aa.val)(s.clippedSpace.width), Nt = (Ge.end - Ge.start) / yt, Lt = oe * Nt, qt = (0, aa.val)(s.sheet).getSequence().closestGridPosition;
                if ($e === "bar") {
                  let Tn = de + Lt, dr = Math.max(0, qt(Tn));
                  je.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), je.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { position: dr } });
                } else if ($e === "left") {
                  let Tn = de + Ae / Je, dr = de + Lt, dn = Math.max(0, qt(dr)), jr = Tn - dn, Sn = Math.max(0.01, Ae / jr);
                  je.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), je.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { position: dn, timeScale: Sn } });
                } else if ($e === "right") {
                  let Tn = de + Ae / Je + Lt, dr = Math.max(de + 0.01, qt(Tn)) - de, dn = Math.max(0.01, Ae / dr);
                  je.studio.historic.projects.stateByProjectId.stateBySheetId._ensure({ projectId: r.sheet.address.projectId, sheetId: r.sheet.address.sheetId }), je.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { timeScale: dn } });
                }
              });
            }, onDragEnd(oe) {
              Oe(!1, 0), oe && Ie ? Ie.commit() : Ie && Ie.discard(), Ie = null;
            } }) : !1;
          } };
        }, [r, s, Oe, T, M, x, m]), [ye] = Fr(m, ie);
        Ao(ye, "draggingPositionInSequenceEditor", "ew-resize");
        let Ee = (0, aa.val)(s.scaledSpace.leftPadding), ve = r.subSequence.position, Xe = r.subSequence.timeScale, Se = r.subSequence.duration;
        if (!Se || Se === 0) try {
          let Ie = pe(), $e = (0, aa.val)(Ie.projectsP)[r.sheet.address.projectId];
          Se = (a = (0, aa.val)($e.pointers.historic.sheetsById[r.subSequence.sheetId].sequence.length)) != null ? a : (0, aa.val)(s.sheet).getSequence().length;
        } catch {
          Se = (0, aa.val)(s.sheet).getSequence().length;
        }
        Se || (Se = 1);
        let nt = "calc(".concat(Ee, "px + calc(var(--unitSpaceToScaledSpaceMultiplier) * ").concat(ve, "px))"), De = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(Se / Xe, "px)"), Ce = ve, le = ve + Se / Xe;
        return Mn.default.createElement(kZ, { ref: d, style: { left: nt, width: De } }, Q.node, ue.node, ne.node, ce.node, B && Mn.default.createElement(jZ, { style: { position: "fixed", top: "".concat(H.top, "px"), left: "".concat(H.left, "px") } }, Mn.default.createElement(zZ, { ref: F, type: "color", value: O, onChange: (Ie) => {
          let $e = Ie.currentTarget.value;
          N($e), PZ(r, $e);
        }, autoFocus: !0 }), Mn.default.createElement(GZ, { type: "text", placeholder: "#000000", value: O, onChange: (Ie) => {
          let $e = Ie.currentTarget.value;
          $e.startsWith("#") || ($e = "#" + $e), /^#[0-9A-F]{6}$/i.test($e) && (N($e), PZ(r, $e));
        } }), Mn.default.createElement("button", { onClick: () => U(!1), style: { padding: "4px 8px", fontSize: "12px", cursor: "pointer", border: "1px solid #666", borderRadius: "2px", background: "#222", color: "#FFF", height: "28px" } }, "Done")), se, Mn.default.createElement(RZ, { ref: y, $color: O }, Mn.default.createElement("span", null, r.subSequence.timeScale.toFixed(2), "x")), Mn.default.createElement(OZ, V(L({ ref: w, $position: "left", "data-handle": "left", title: isFinite(Ce) ? "Sub-sequence start: ".concat(Ce.toFixed(2)) : "Sub-sequence start" }, isFinite(Ce) ? js.includePositionSnapAttrs(Ce) : {}), { $color: O })), Mn.default.createElement(FZ, V(L({ ref: P, $position: "right", "data-handle": "right", title: isFinite(le) ? "Sub-sequence end: ".concat(le.toFixed(2)) : "Sub-sequence end" }, isFinite(le) ? js.includePositionSnapAttrs(le) : {}), { $color: O })));
      }, HZ = qZ;
    }), dj, $Z, WZ, KZ, YZ, RSe = R(() => {
      dj = Y(xe()), it(), MSe(), WZ = ee.div($Z || ($Z = $([`
  position: relative;
  height: 100%;
  width: 100%;
`]))), KZ = ({ layoutP: r, leaf: s }) => dj.default.createElement(WZ, null, dj.default.createElement(HZ, { layoutP: r, leaf: s })), YZ = KZ;
    }), hj, XZ, QZ, ISe = R(() => {
      hj = Y(xe()), IM(), RSe(), XZ = ({ leaf: r, layoutP: s }) => hj.default.createElement(hm, { leaf: r, node: hj.default.createElement(YZ, { layoutP: s, leaf: r }) }, null), QZ = XZ;
    }), nR, pj, ZZ, fj, mj = R(() => {
      nR = Y(xe()), pj = (0, nR.createContext)({ searchTerm: "", searchTrigger: 0 }), ZZ = ({ searchTerm: r, searchTrigger: s, children: a }) => nR.default.createElement(pj.Provider, { value: { searchTerm: r, searchTrigger: s } }, a), fj = () => (0, nR.useContext)(pj);
    });
    function ov(r, s) {
      pe().transaction(({ stateEditors: a }) => {
        a.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.sequenceEditorCollapsableItems.set(V(L({}, s.sheetAddress), { studioSheetItemKey: s.sheetItemKey, isCollapsed: r }));
      });
    }
    var gj = R(() => {
      st();
    });
    function NSe(r, s) {
      if (!s.trim()) return;
      let a = s.toLowerCase().trim();
      r.children.filter((d) => d.type === "sheetObject").forEach((d) => {
        FSe(d, a) && (ov(!1, { sheetAddress: d.sheetObject.address, sheetItemKey: d.sheetItemKey }), tJ(d.children, a, d.sheetObject.address));
      });
    }
    function OSe(r) {
      r.children.filter((s) => s.type === "sheetObject").forEach((s) => {
        let a = "".concat(s.sheetObject.address.projectId, ":").concat(s.sheetObject.address.sheetId, ":").concat(s.sheetItemKey);
        vm.set(a, s.isCollapsed), JZ(s.children, s.sheetObject.address);
      });
    }
    function JZ(r, s) {
      r.forEach((a) => {
        if (a.type === "propWithChildren") {
          let d = "".concat(s.projectId, ":").concat(s.sheetId, ":").concat(a.sheetItemKey);
          vm.set(d, a.isCollapsed), JZ(a.children, s);
        }
      });
    }
    function DSe(r) {
      r.children.filter((s) => s.type === "sheetObject").forEach((s) => {
        let a = "".concat(s.sheetObject.address.projectId, ":").concat(s.sheetObject.address.sheetId, ":").concat(s.sheetItemKey), d = vm.get(a);
        d !== void 0 && d !== s.isCollapsed && ov(d, { sheetAddress: s.sheetObject.address, sheetItemKey: s.sheetItemKey }), eJ(s.children, s.sheetObject.address);
      }), vm.clear();
    }
    function eJ(r, s) {
      r.forEach((a) => {
        if (a.type === "propWithChildren") {
          let d = "".concat(s.projectId, ":").concat(s.sheetId, ":").concat(a.sheetItemKey), m = vm.get(d);
          m !== void 0 && m !== a.isCollapsed && ov(m, { sheetAddress: s, sheetItemKey: a.sheetItemKey }), eJ(a.children, s);
        }
      });
    }
    function FSe(r, s) {
      return r.sheetObject.address.objectKey.toLowerCase().includes(s) ? !0 : r.children.some((a) => yj(a, s));
    }
    function tJ(r, s, a) {
      r.forEach((d) => {
        var m;
        if (d.type === "propWithChildren") {
          let y = (((m = d.pathToProp[d.pathToProp.length - 1]) == null ? void 0 : m.toString().toLowerCase()) || "").includes(s), x = d.children.some((w) => yj(w, s));
          (y || x) && (ov(!1, { sheetAddress: a, sheetItemKey: d.sheetItemKey }), tJ(d.children, s, a));
        }
      });
    }
    function yj(r, s) {
      var a;
      return (((a = r.pathToProp[r.pathToProp.length - 1]) == null ? void 0 : a.toString().toLowerCase()) || "").includes(s) ? !0 : r.type === "propWithChildren" ? r.children.some((d) => yj(d, s)) : !1;
    }
    function nJ(r, s) {
      if (!s.trim()) return DSe(r), r;
      vm.size === 0 && OSe(r), NSe(r, s);
      let a = s.toLowerCase().trim(), d = r.children.map((w) => w.type === "sheetObject" ? BSe(w, a) : null).filter((w) => w !== null), m = r.top, y = r.n, x = d.map((w) => {
        let T = LSe(w, m, y);
        return m = T.top + T.heightIncludingChildren, y = T.n + 1, T;
      });
      return V(L({}, r), { children: x, heightIncludingChildren: m - r.top, isCollapsed: !1 });
    }
    function BSe(r, s) {
      if (r.sheetObject.address.objectKey.toLowerCase().includes(s)) return V(L({}, r), { children: r.children, isCollapsed: !1 });
      {
        let a = r.children.map((d) => rJ(d, s)).filter((d) => d !== null);
        if (a.length > 0) return V(L({}, r), { children: a, isCollapsed: !1 });
      }
      return null;
    }
    function rJ(r, s) {
      var a;
      let d = (((a = r.pathToProp[r.pathToProp.length - 1]) == null ? void 0 : a.toString().toLowerCase()) || "").includes(s);
      if (r.type === "primitiveProp") return d ? r : null;
      if (d) return V(L({}, r), { children: r.children, isCollapsed: !1 });
      {
        let m = r.children.map((y) => rJ(y, s)).filter((y) => y !== null);
        if (m.length > 0) return V(L({}, r), { children: m, isCollapsed: !1 });
      }
      return null;
    }
    function LSe(r, s, a) {
      let d = s, m = a, y = V(L({}, r), { top: d, n: m });
      d += r.nodeHeight, m += 1;
      let x = r.children.map((w) => {
        let T = iJ(w, d, m);
        return d = T.top + T.nodeHeight, T.type === "propWithChildren" && (d += T.heightIncludingChildren - T.nodeHeight), m = T.n + 1, T;
      });
      return V(L({}, y), { children: x, heightIncludingChildren: d - y.top });
    }
    function iJ(r, s, a) {
      let d = V(L({}, r), { top: s, n: a });
      if (r.type === "propWithChildren") {
        let m = s + r.nodeHeight, y = a + 1, x = r.children.map((w) => {
          let T = iJ(w, m, y);
          return m = T.top + T.nodeHeight, T.type === "propWithChildren" && (m += T.heightIncludingChildren - T.nodeHeight), y = T.n + 1, T;
        });
        return V(L({}, d), { children: x, heightIncludingChildren: m - d.top });
      }
      return d;
    }
    var vm, sJ = R(() => {
      gj(), vm = /* @__PURE__ */ new Map();
    });
    function vj(r, s = []) {
      r.shouldRender && s.push(r);
      let a = "isCollapsed" in r ? r.isCollapsed : !1;
      if ((r.type === "sheet" || !a) && "children" in r) for (let d of r.children) vj(d, s);
      return s;
    }
    var oJ = R(() => {
    }), rR, ep, av, aJ, lJ, uJ, cJ, dJ, hJ, bj = R(() => {
      zt(), rR = ut(), ep = Y(xe()), it(), A1e(), j3(), ASe(), ISe(), mj(), sJ(), Nl(), oJ(), TM(), wZ(), av = 1e6, lJ = ee.div(aJ || (aJ = $([`
  position: relative;
`]))), cJ = ee.div(uJ || (uJ = $([`
  margin: 0;
  padding: 0;
  position: absolute;
  left: 0;
  width: `, `px;
  z-index: 10;
`])), av), dJ = ({ layoutP: r }) => {
        let { searchTerm: s, searchTrigger: a } = fj(), d = R3(), { scrollTop: m, clientHeight: y } = nn(d);
        return At(() => {
          let x = (0, rR.val)(r.tree), w = s.trim() ? nJ(x, s) : x, T = (0, rR.val)(r.tree.top) + Math.max(w.heightIncludingChildren, (0, rR.val)(r.dopeSheetDims.height)), P = vj(w), M = [], F = 500, O = m - F, N = m + y + F, B = -1;
          for (let U = 0; U < P.length; U++) {
            let H = P[U];
            if (H.top + H.nodeHeight >= O) {
              B = U;
              break;
            }
          }
          if (B !== -1) for (let U = B; U < P.length; U++) {
            let H = P[U];
            if (H.top > N) break;
            M.push(H);
          }
          return ep.default.createElement(lJ, null, ep.default.createElement(MM, { layoutP: r, height: T }, ep.default.createElement(AY, { layoutP: r, height: T }, ep.default.createElement(cJ, { style: { top: "0px" } }, M.map((U) => {
            let H = null;
            return U.type === "subSequence" ? H = ep.default.createElement(QZ, { layoutP: r, key: Ji.forSubSequence(U.subSequence.id), leaf: U }) : U.type === "sheetObject" ? H = ep.default.createElement(TZ, { layoutP: r, key: "sheetObject-" + U.sheetObject.address.objectKey, leaf: U, renderChildren: !1 }) : (U.type === "propWithChildren" || U.type === "primitiveProp") && (H = tR(U, r, !1)), H ? ep.default.createElement("div", { key: U.type + "-" + (U.sheetItemKey || U.top), style: { position: "absolute", top: U.top + "px", width: "100%", height: U.nodeHeight + "px" } }, H) : null;
          })))));
        }, [r, s, a, m, y]);
      }, hJ = dJ;
    });
    function xj(r, s, a, d) {
      let m = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(r, "px)"), y = "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(s, ") * 1px)");
      a === 0 && (a = 1e-4);
      let x = "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(a, ")");
      d === 0 && (d = 1e-3);
      let w = "calc(var(--graphEditorVerticalSpace) * ".concat(d * -1, ")");
      return "translate(".concat(m, ", ").concat(y, ") scale(").concat(x, ", ").concat(w, ")");
    }
    function jSe(r, s) {
      let { index: a, trackData: d } = s, m = d.keyframes[a], y = d.keyframes[a + 1];
      return Bs(r, { menuItems: () => [{ label: "Delete", callback: () => {
        pe().transaction(({ stateEditors: x }) => {
          let { deleteKeyframes: w } = x.coreByProject.historic.sheetsById.sequence;
          w(V(L({}, s.sheetObject.address), { trackId: s.trackId, keyframeIds: [m.id, y.id] }));
        });
      } }] });
    }
    var iR, pJ, fJ, mJ, gJ, yJ, _j = R(() => {
      Wh(), st(), Ls(), Hn(), iR = Y(xe()), it(), fJ = ee.path(pJ || (pJ = $([`
  stroke-width: 2;
  stroke: var(--main-color);
  fill: none;
  vector-effect: non-scaling-stroke;
`]))), mJ = "M 0 0 L 1 0 L 1 1", gJ = (r) => {
        let { index: s, trackData: a } = r, d = a.keyframes[s], m = a.keyframes[s + 1], y = m.position - d.position, [x, w] = kn(null), [T] = jSe(w, r), P = r.isScalar ? cM(d.value, r.propConfig) : 0, M = r.isScalar ? cM(m.value, r.propConfig) : 1, F = r.extremumSpace.fromValueSpace(P), O = r.extremumSpace.fromValueSpace(M) - F, N = xj(d.position, F, y, O), B = d.handles[2], U = d.handles[3], H = m.handles[0], W = m.handles[1], Q = "M 0 0 C ".concat(B, " ").concat(U, " ").concat(H, " ").concat(W, " 1 1");
        return iR.default.createElement(iR.default.Fragment, null, iR.default.createElement(fJ, { ref: x, d: !d.type || d.type === "bezier" ? Q : mJ, style: { transform: N } }), T);
      }, yJ = gJ;
    });
    function USe(r, s) {
      let a = (0, bm.useRef)(s);
      a.current = s;
      let d = (0, bm.useMemo)(() => ({ debugName: "CurveHandler/useOurDrags", lockCSSCursorTo: "move", onDragStart() {
        let m, y = a.current, x = (0, fS.val)(y.layoutP.scaledSpace.toUnitSpace), w = (0, fS.val)(y.layoutP.graphEditorVerticalSpace.toExtremumSpace), T = y.extremumSpace.lock();
        return { onDrag(P, M) {
          m && (m.discard(), m = void 0);
          let { index: F, trackData: O } = y, N = O.keyframes[F], B = O.keyframes[F + 1], U = x(P) / (B.position - N.position), H = -M, W = w(H), Q = y.extremumSpace.deltaToValueSpace(W), ne = s.isScalar ? N.value : 0, ce = s.isScalar ? B.value : 1, ue = Q / (ce - ne);
          if (y.which === "left") {
            let se = ir(N.handles[2] + U, 0, 1), Oe = N.handles[3] + ue;
            m = pe().tempTransaction(({ stateEditors: he }) => {
              he.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, y.sheetObject.address), { snappingFunction: (0, fS.val)(y.layoutP.sheet).getSequence().closestGridPosition, trackId: y.trackId, keyframes: [V(L({}, N), { handles: [N.handles[0], N.handles[1], se, Oe] })] }));
            });
          } else {
            let se = ir(B.handles[0] + U, 0, 1), Oe = B.handles[1] + ue;
            m = pe().tempTransaction(({ stateEditors: he }) => {
              he.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, y.sheetObject.address), { trackId: y.trackId, snappingFunction: (0, fS.val)(y.layoutP.sheet).getSequence().closestGridPosition, keyframes: [V(L({}, B), { handles: [se, Oe, B.handles[2], B.handles[3]] })] }));
            });
          }
        }, onDragEnd(P) {
          T(), P ? m && m.commit() : m && m.discard();
        } };
      } }), []);
      Fr(r, d);
    }
    function zSe(r, s) {
      return Bs(r, { menuItems: () => [{ label: "Delete", callback: () => {
        pe().transaction(({ stateEditors: a }) => {
          a.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, s.sheetObject.address), { keyframeIds: [s.keyframe.id], trackId: s.trackId }));
        });
      } }] });
    }
    var fS, bm, vJ, Sj, bJ, xJ, _J, SJ, wJ, wj, VSe = R(() => {
      st(), Ls(), li(), Hn(), fS = ut(), tn(), bm = Y(xe()), it(), _j(), Xn(), Sj = ee.circle(vJ || (vJ = $([`
  stroke-width: 1px;
  vector-effect: non-scaling-stroke;
  fill: var(--main-color);
  r: 2px;
  pointer-events: none;
`]))), xJ = ee.circle(bJ || (bJ = $([`
  stroke-width: 6px;
  vector-effect: non-scaling-stroke;
  r: 6px;
  fill: transparent;
  cursor: move;
  `, `;
  &:hover {
  }
  &:hover + `, ` {
    r: 6px;
  }
`])), Ln, Sj), SJ = ee.path(_J || (_J = $([`
  stroke-width: 1;
  stroke: var(--main-color);
  /* stroke: gray; */
  fill: none;
  vector-effect: non-scaling-stroke;
`]))), wJ = (r) => {
        let [s, a] = kn(null), { index: d, trackData: m } = r, y = m.keyframes[d], x = m.keyframes[d + 1], [w] = zSe(a, r);
        USe(a, r);
        let T = r.which === "left" ? y.handles[2] : x.handles[0], P = y.position + (x.position - y.position) * T, M = r.which === "left" ? y.handles[3] : x.handles[1], F = r.isScalar ? y.value : 0, O = r.isScalar ? x.value : 1, N = F + (O - F) * M, B = r.extremumSpace.fromValueSpace(N), U = B - r.extremumSpace.fromValueSpace(r.which === "left" ? F : O), H = xj(r.which === "left" ? y.position : x.position, r.extremumSpace.fromValueSpace(r.which === "left" ? F : O), P - (r.which === "left" ? y.position : x.position), U);
        return bm.default.createElement("g", null, bm.default.createElement(xJ, { ref: s, style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(P, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(B, ") * 1px)") } }), bm.default.createElement(Sj, { style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(P, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(B, ") * 1px)") } }), bm.default.createElement(SJ, { d: "M 0 0 L 1 1", style: { transform: H } }), w);
      }, wj = wJ;
    });
    function GSe(r) {
      let [s, a] = (0, tp.useState)(!1);
      $u(s, r.props.keyframe.position);
      let d = (0, tp.useRef)(r.props);
      d.current = r.props;
      let m = (0, tp.useMemo)(() => ({ debugName: "GraphEditorDotScalar/useDragKeyframe", lockCSSCursorTo: "move", onDragStart(y) {
        a(!0);
        let x = !!y.altKey, w = d.current, T = (0, sR.val)(w.layoutP.scaledSpace.toUnitSpace), P = (0, sR.val)(w.layoutP.graphEditorVerticalSpace.toExtremumSpace), M = w.extremumSpace.lock(), F;
        return { onDrag(O, N) {
          let B = w.trackData.keyframes[w.index], U = T(O), H = -N, W = P(H), Q = w.extremumSpace.deltaToValueSpace(W), ne = [], ce = V(L({}, B), { position: B.position + U, value: B.value + Q, handles: [...B.handles] });
          if (ne.push(ce), x) {
            let ue = w.trackData.keyframes[w.index - 1];
            if (ue && Math.abs(B.value - ue.value) > 0) {
              let Oe = V(L({}, ue), { handles: [...ue.handles] });
              ne.push(Oe), Oe.handles[3] = HSe(ue.handles[3], ue.value, ue.value, B.value, ce.value);
            }
            let se = w.trackData.keyframes[w.index + 1];
            if (se && Math.abs(B.value - se.value) > 0) {
              let Oe = V(L({}, se), { handles: [...se.handles] });
              ne.push(Oe), Oe.handles[1] = $Se(Oe.handles[1], Oe.value, Oe.value, B.value, ce.value);
            }
          }
          F?.discard(), F = pe().tempTransaction(({ stateEditors: ue }) => {
            ue.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, w.sheetObject.address), { trackId: w.trackId, keyframes: ne, snappingFunction: (0, sR.val)(w.layoutP.sheet).getSequence().closestGridPosition }));
          });
        }, onDragEnd(O) {
          a(!1), M(), O ? F?.commit() : (F?.discard(), r.onDetectedClick(y));
        } };
      } }), []);
      return Fr(r.node, m), Ao(s, "draggingPositionInSequenceEditor", "move"), s;
    }
    function qSe(r, s) {
      return Bs(r, { menuItems: () => [{ label: "Delete", callback: () => {
        pe().transaction(({ stateEditors: a }) => {
          a.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, s.sheetObject.address), { keyframeIds: [s.keyframe.id], trackId: s.trackId }));
        });
      } }] });
    }
    function HSe(r, s, a, d, m) {
      return (d - s) * r / (m - a);
    }
    function $Se(r, s, a, d, m) {
      return ((s - d) * r + d - s + a - m) / (a - m);
    }
    var sR, tp, EJ, Ej, TJ, CJ, PJ, AJ, WSe = R(() => {
      st(), Ls(), li(), Hn(), sR = ut(), tp = Y(xe()), it(), Ui(), Ui(), Xn(), Os(), zl(), Q3(), J1(), Ej = ee.circle(EJ || (EJ = $([`
  fill: var(--main-color);
  stroke-width: 1px;
  vector-effect: non-scaling-stroke;

  r: 2px;
`]))), CJ = ee.circle(TJ || (TJ = $([`
  stroke-width: 6px;
  vector-effect: non-scaling-stroke;
  r: 6px;
  fill: transparent;
  `, `;

  &:hover + `, ` {
    r: 6px;
  }

  #pointer-root.normal & {
    cursor: move;
  }

  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
    cursor: var(`, `);
  }

  &.beingDragged {
    pointer-events: none !important;
  }
`])), Ln, Ej, Ml), PJ = (r) => {
        let [s, a] = kn(null), { index: d, trackData: m } = r, y = m.keyframes[d], [x] = qSe(a, r), w = K0(r.itemKey), T = y.value, P = r.extremumSpace.fromValueSpace(T), M = X3([{ type: "primitiveProp", keyframe: r.keyframe, pathToProp: r.pathToProp, propConfig: r.propConfig, sheetObject: r.sheetObject, trackId: r.trackId }]), F = GSe({ node: a, props: r, onDetectedClick: (O) => M.toggle(O, O.target instanceof Element ? O.target : a) });
        return tp.default.createElement(tp.default.Fragment, null, tp.default.createElement(CJ, V(L(L(L({ ref: s, style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(y.position, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(P, ") * 1px)") } }, Wu(y.position)), js.includePositionSnapAttrs(y.position)), w.attrs), { className: F ? "beingDragged" : "" })), tp.default.createElement(Ej, { style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(y.position, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(P, ") * 1px)"), fill: w.flag === 2 ? "white" : void 0 } }), M.node, x);
      }, AJ = PJ;
    });
    function KSe(r) {
      let [s, a] = (0, np.useState)(!1);
      $u(s, r.props.keyframe.position);
      let d = (0, np.useRef)(r.props);
      d.current = r.props;
      let m = (0, np.useMemo)(() => ({ debugName: "GraphEditorDotNonScalar/useDragKeyframe", lockCSSCursorTo: "ew-resize", onDragStart(y) {
        a(!0);
        let x = d.current, w = (0, Tj.val)(x.layoutP.scaledSpace.toUnitSpace), T = x.extremumSpace.lock(), P;
        return { onDrag(M, F) {
          let O = x.trackData.keyframes[x.index], N = w(M), B = [], U = V(L({}, O), { position: O.position + N, value: O.value, handles: [...O.handles] });
          B.push(U), P?.discard(), P = pe().tempTransaction(({ stateEditors: H }) => {
            H.coreByProject.historic.sheetsById.sequence.replaceKeyframes(V(L({}, x.sheetObject.address), { trackId: x.trackId, keyframes: B, snappingFunction: (0, Tj.val)(x.layoutP.sheet).getSequence().closestGridPosition }));
          });
        }, onDragEnd(M) {
          a(!1), T(), M ? P?.commit() : (P?.discard(), r.onDetectedClick(y));
        } };
      } }), []);
      return Fr(r.node, m), Ao(s, "draggingPositionInSequenceEditor", "ew-resize"), s;
    }
    function YSe(r, s) {
      return Bs(r, { menuItems: () => [{ label: "Delete", callback: () => {
        pe().transaction(({ stateEditors: a }) => {
          a.coreByProject.historic.sheetsById.sequence.deleteKeyframes(V(L({}, s.sheetObject.address), { keyframeIds: [s.keyframe.id], trackId: s.trackId }));
        });
      } }] });
    }
    var Tj, np, kJ, Cj, MJ, RJ, IJ, Pj, XSe = R(() => {
      st(), Ls(), li(), Hn(), Tj = ut(), np = Y(xe()), it(), Ui(), Ui(), Xn(), Os(), zl(), Q3(), J1(), Cj = ee.circle(kJ || (kJ = $([`
  fill: var(--main-color);
  stroke-width: 1px;
  vector-effect: non-scaling-stroke;

  r: 2px;
`]))), RJ = ee.circle(MJ || (MJ = $([`
  stroke-width: 6px;
  vector-effect: non-scaling-stroke;
  r: 6px;
  fill: transparent;
  `, `;

  &:hover + `, ` {
    r: 6px;
  }

  #pointer-root.normal & {
    cursor: ew-resize;
  }

  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
    cursor: var(`, `);
  }

  &.beingDragged {
    pointer-events: none !important;
  }
`])), Ln, Cj, Ml), IJ = (r) => {
        let [s, a] = kn(null), { index: d, trackData: m, itemKey: y } = r, x = m.keyframes[d], [w] = YSe(a, r), T = K0(y), P = r.which === "left" ? 0 : 1, M = X3([{ type: "primitiveProp", keyframe: r.keyframe, pathToProp: r.pathToProp, propConfig: r.propConfig, sheetObject: r.sheetObject, trackId: r.trackId }]), F = KSe({ node: a, props: r, onDetectedClick: (N) => M.toggle(N, N.target instanceof Element ? N.target : a) }), O = r.extremumSpace.fromValueSpace(P);
        return np.default.createElement(np.default.Fragment, null, np.default.createElement(RJ, V(L(L(L({ ref: s, style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(x.position, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(O, ") * 1px)") } }, T.attrs), Wu(x.position)), js.includePositionSnapAttrs(x.position)), { className: F ? "beingDragged" : "" })), np.default.createElement(Cj, { style: { cx: "calc(var(--unitSpaceToScaledSpaceMultiplier) * ".concat(x.position, " * 1px)"), cy: "calc((var(--graphEditorVerticalSpace) - var(--graphEditorVerticalSpace) * ".concat(O, ") * 1px)"), fill: T.flag === 2 ? "white" : void 0 } }), M.node, w);
      }, Pj = IJ;
    }), oR, NJ, OJ, DJ, FJ, QSe = R(() => {
      oR = Y(xe()), it(), _j(), OJ = ee.path(NJ || (NJ = $([`
  stroke-width: 2;
  stroke: var(--main-color);
  stroke-dasharray: 3 2;
  fill: none;
  vector-effect: non-scaling-stroke;
  opacity: 0.3;
`]))), DJ = (r) => {
        let { index: s, trackData: a } = r, d = "M 0 0 L 1 1", m = xj(a.keyframes[s].position, r.extremumSpace.fromValueSpace(0), 0, r.extremumSpace.fromValueSpace(1) - r.extremumSpace.fromValueSpace(0));
        return oR.default.createElement(oR.default.Fragment, null, oR.default.createElement(OJ, { d, style: { transform: m } }));
      }, FJ = DJ;
    }), xs, BJ, LJ, jJ, UJ, zJ, ZSe = R(() => {
      xs = Y(xe()), it(), _j(), VSe(), WSe(), XSe(), QSe(), LJ = ee.g(BJ || (BJ = $([`
  /* position: absolute; */
`]))), jJ = xs.default.createElement(xs.default.Fragment, null), UJ = (r) => {
        let { index: s, trackData: a, isScalar: d } = r, m = a.keyframes[s], y = a.keyframes[s + 1], x = m.connectedRight && !!y && y.value !== m.value;
        return xs.default.createElement(LJ, null, x ? xs.default.createElement(xs.default.Fragment, null, xs.default.createElement(yJ, L({}, r)), !m.type || m.type === "bezier" && xs.default.createElement(xs.default.Fragment, null, xs.default.createElement(wj, V(L({}, r), { which: "left" })), xs.default.createElement(wj, V(L({}, r), { which: "right" })))) : jJ, d ? xs.default.createElement(AJ, L({}, r)) : xs.default.createElement(xs.default.Fragment, null, xs.default.createElement(Pj, V(L({}, r), { which: "left" })), xs.default.createElement(Pj, V(L({}, r), { which: "right" })), xs.default.createElement(FJ, L({}, r))));
      }, zJ = UJ;
    });
    function JSe(r, s) {
      let a = 1 / 0, d = -1 / 0;
      function m(y) {
        a = Math.min(y, a), d = Math.max(y, d);
      }
      return r.forEach((y, x) => {
        let w = cM(y.value, s);
        if (m(w), !y.connectedRight) return;
        let T = r[x + 1];
        if (!T) return;
        let P = (typeof T.value == "number" ? T.value : 1) - w;
        m(w + y.handles[3] * P), m(w + T.handles[1] * P);
      }), [a, d];
    }
    function ewe(r) {
      let s = 0, a = 1;
      function d(m) {
        s = Math.min(m, s), a = Math.max(m, a);
      }
      return r.forEach((m, y) => {
        if (!m.connectedRight) return;
        let x = r[y + 1];
        x && (d(m.handles[3]), d(x.handles[1]));
      }), [s, a];
    }
    var Ku, VJ, GJ, twe = R(() => {
      Nl(), Ku = Y(xe()), lR(), ZSe(), Wh(), zt(), VJ = Ku.default.memo(({ layoutP: r, trackData: s, sheetObject: a, trackId: d, color: m, pathToProp: y }) => {
        let x = $0(nn(a.template.configPointer), y);
        if (Hu(x)) return console.error("Composite prop types cannot be keyframed"), Ku.default.createElement(Ku.default.Fragment, null);
        let [w, T] = (0, Ku.useState)(!1), P = (0, Ku.useMemo)(() => {
          let N = /* @__PURE__ */ new Set();
          return function() {
            let B = N.size === 0;
            N.add(U), B && T(!0);
            function U() {
              let H = N.size > 0;
              N.delete(U), H && N.size === 0 && T(!1);
            }
            return U;
          };
        }, []), M = (0, Ku.useMemo)(() => {
          let N = x.type === "number" ? JSe(s.keyframes, x) : ewe(s.keyframes), B = (W) => (W - N[0]) / (N[1] - N[0]), U = (W) => N[0] + H(W), H = (W) => W * (N[1] - N[0]);
          return { fromValueSpace: B, toValueSpace: U, deltaToValueSpace: H, lock: P };
        }, [s.keyframes]), F = (0, Ku.useRef)(void 0);
        w || (F.current = M);
        let O = s.keyframes.map((N, B) => Ku.default.createElement(zJ, { pathToProp: y, propConfig: x, itemKey: Ji.forTrackKeyframe(a, d, N.id), keyframe: N, index: B, trackData: s, layoutP: r, sheetObject: a, trackId: d, isScalar: x.type === "number", key: N.id, extremumSpace: F.current, color: m }));
        return Ku.default.createElement("g", { style: { "--main-color": mS[m].iconColor } }, O);
      }), GJ = VJ;
    }), qJ, aR, HJ, $J, nwe = R(() => {
      st(), zt(), qJ = ut(), aR = Y(xe()), twe(), HJ = (r) => At(() => {
        let { sheetObject: s, trackId: a } = r, d = (0, qJ.val)(pe().atomP.historic.coreByProject[s.address.projectId].sheetsById[s.address.sheetId].sequence.tracksByObject[s.address.objectKey].trackData[a]);
        return d?.type !== "BasicKeyframedTrack" ? (console.error("trackData type ".concat(d?.type, " is not yet supported on the graph editor")), aR.default.createElement(aR.default.Fragment, null)) : aR.default.createElement(GJ, V(L({}, r), { trackData: d }));
      }, [r.trackId, r.layoutP]), $J = HJ;
    });
    function WJ({ clippedSpaceRange: r, clippedSpaceWidth: s, fps: a, gapWidth: d = 120 }, m) {
      let y = 1 / a, x = r.end - r.start, w = s / (a * x), T = Math.floor(d / w), P = (T < a ? KJ(a).find((O) => O >= T) : a * Math.floor(T / a)) * y, M = Math.floor(r.start / P), F = Math.ceil(r.end / P);
      for (let O = M; O <= F; O++) {
        let N = O * P, B = N % 1 === 0;
        m(N, B);
      }
    }
    var KJ, YJ = R(() => {
      tn(), KJ = qx((r) => {
        let s = [];
        for (let a = 1; a <= r; a++) r % a === 0 && s.push(a);
        return s;
      });
    });
    function rwe(r) {
      let { clippedSpaceWidth: s, height: a, ctx: d, unitSpaceToClippedSpace: m, snapToGrid: y } = r;
      d.clearRect(0, 0, s, a), WJ(r, (x, w) => {
        let T = y(x), P = Math.floor(m(T));
        d.strokeStyle = w ? "rgba(225, 225, 225, 0.04)" : "rgba(255, 255, 255, 0.01)", d.beginPath(), d.moveTo(P, 0), d.lineTo(P, a), d.stroke(), d.closePath();
      });
    }
    var xm, _m, XJ, QJ, ZJ, JJ, eee, tee, nee, ree, Aj, iee = R(() => {
      xm = ut(), _m = Y(xe()), it(), YJ(), st(), QJ = ee.div(XJ || (XJ = $([`
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  pointer-events: none;
`]))), JJ = ee.canvas(ZJ || (ZJ = $([`
  position: relative;
  left: 0;
`]))), eee = (r) => {
        let s = r;
        return s.webkitBackingStorePixelRatio || s.mozBackingStorePixelRatio || s.msBackingStorePixelRatio || s.oBackingStorePixelRatio || s.backingStorePixelRatio || 1;
      }, tee = () => window.devicePixelRatio || 1, nee = (r) => tee() / eee(r), ree = ({ layoutP: r, width: s, height: a }) => {
        let d = (0, _m.useRef)(null), [m, y] = (0, _m.useState)(null), { ctx: x, ratio: w } = (0, _m.useMemo)(() => {
          if (!m) return {};
          let T = m.getContext("2d"), P = nee(T);
          return { ctx: T, ratio: P };
        }, [m]);
        return (0, _m.useLayoutEffect)(() => {
          if (!x) return;
          m.width = s * w, m.height = a * w;
          let T = (0, xm.prism)(() => {
            let P = (0, xm.val)(r.sheet).getSequence();
            return { ctx: x, clippedSpaceRange: (0, xm.val)(r.clippedSpace.range), clippedSpaceWidth: (0, xm.val)(r.clippedSpace.width), unitSpaceToClippedSpace: (0, xm.val)(r.clippedSpace.fromUnitSpace), height: a, leftPadding: (0, xm.val)(r.scaledSpace.leftPadding), fps: P.subUnitsPerUnit, snapToGrid: (M) => P.closestGridPosition(M) };
          }).onChange(pe().ticker, (P) => {
            x.save(), x.scale(w, w), rwe(P), x.restore();
          }, !0);
          return () => {
            T();
          };
        }, [x, s, a, r]), _m.default.createElement(QJ, { ref: d, style: { width: s + "px" } }, _m.default.createElement(JJ, { ref: y, style: { width: s + "px", height: a + "px" } }));
      }, Aj = ree;
    }), Yu, Sm, mS, see, oee, aee, lee, uee, cee, lR = R(() => {
      st(), Xh(), dM(), zt(), Yu = ut(), Sm = Y(xe()), it(), bj(), j3(), nwe(), iee(), Al(), mS = { 1: { iconColor: "#b98b08" }, 2: { iconColor: "#70a904" }, 3: { iconColor: "#2e928a" }, 4: { iconColor: "#a943bb" }, 5: { iconColor: "#b90808" }, 6: { iconColor: "#b4bf0e" } }, oee = ee.div(see || (see = $([`
  position: absolute;
  right: 0;
  bottom: 0;
  padding-bottom: 25px;
  background: `, `;
`])), Uu(0.03, "#1a1c1e")), lee = ee.svg(aee || (aee = $([`
  position: absolute;
  top: 0;
  left: 0;
  margin: 0;
  pointer-events: none;
`]))), uee = ({ layoutP: r }) => At(() => {
        let s = (0, Yu.val)(r.sheet), a = (0, Yu.val)(pe().atomP.historic.projects.stateByProjectId[s.address.projectId].stateBySheetId[s.address.sheetId].sequenceEditor.selectedPropsByObject), d = (0, Yu.val)(r.graphEditorDims.height), m = (0, Yu.val)(r.scaledSpace.fromUnitSpace)(1), y = [];
        if (a) for (let [w, T] of Object.entries(a)) {
          let P = s.getObject(w);
          if (!P) continue;
          let M = (0, Yu.val)(P.template.getMapOfValidSequenceTracks_forStudio());
          for (let [F, O] of Object.entries(T)) {
            let N = _3(F), B = Kh(M, N);
            B && y.push(Sm.default.createElement($J, { key: "graph-".concat(w, "-").concat(F), sheetObject: P, pathToProp: N, layoutP: r, trackId: B, color: O }));
          }
        }
        let x = (0, Yu.val)(r.rightDims.width);
        return Sm.default.createElement(oee, { style: { width: x + "px", height: d + "px", "--unitSpaceToScaledSpaceMultiplier": m, "--graphEditorVerticalSpace": "".concat((0, Yu.val)(r.graphEditorVerticalSpace.space)) } }, Sm.default.createElement(Aj, { layoutP: r, width: x, height: d }), Sm.default.createElement(MM, { layoutP: r, height: d }, Sm.default.createElement(lee, { width: av, height: d, viewBox: "0 0 ".concat(av, " ").concat(d) }, Sm.default.createElement("g", { style: { transform: "translate(".concat((0, Yu.val)(r.scaledSpace.leftPadding), "px, ").concat((0, Yu.val)(r.graphEditorDims.padding.top), "px)") } }, y))));
      }, [r]), cee = uee;
    }), dee, Ro, hee, pee, fee, mee, kj, gee, yee, vee, bee, xee, _ee, See, wee, Eee, iwe = R(() => {
      st(), Xh(), z1(), zt(), dee = ut(), Ro = Y(xe()), it(), m1e(), gM(), lR(), _M(), sd(), ML(), Ls(), gK(), hee = { label: { color: "#9a9a9a" } }, fee = ee(y3)(pee || (pee = $([""]))), kj = ee(xM)(mee || (mee = $([`
  display: flex;
  color: `, `;
  padding-left: calc(10px + var(--depth) * 10px);
  padding-right: 12px;
  align-items: center;
  justify-content: flex-end;
  box-sizing: border-box;
`])), hee.label.color), yee = ee.button(gee || (gee = $([`
  background: none;
  border: none;
  outline: none;
  display: flex;
  box-sizing: border-box;
  font-size: 14px;
  align-items: center;
  height: 100%;
  margin-left: 12px;
  color: `, `;

  &:not([disabled]):hover {
    color: white;
  }
`])), (r) => r.isSelected ? mS[r.graphEditorColor].iconColor : Yh.offColor), vee = () => Ro.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "10", height: "12", viewBox: "0 0 640 512" }, Ro.default.createElement("g", { transform: "translate(0 100)" }, Ro.default.createElement("path", { fill: "currentColor", d: "M368 32h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32V64c0-17.67-14.33-32-32-32zM208 88h-84.75C113.75 64.56 90.84 48 64 48 28.66 48 0 76.65 0 112s28.66 64 64 64c26.84 0 49.75-16.56 59.25-40h79.73c-55.37 32.52-95.86 87.32-109.54 152h49.4c11.3-41.61 36.77-77.21 71.04-101.56-3.7-8.08-5.88-16.99-5.88-26.44V88zm-48 232H64c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32zM576 48c-26.84 0-49.75 16.56-59.25 40H432v72c0 9.45-2.19 18.36-5.88 26.44 34.27 24.35 59.74 59.95 71.04 101.56h49.4c-13.68-64.68-54.17-119.48-109.54-152h79.73c9.5 23.44 32.41 40 59.25 40 35.34 0 64-28.65 64-64s-28.66-64-64-64zm0 272h-96c-17.67 0-32 14.33-32 32v96c0 17.67 14.33 32 32 32h96c17.67 0 32-14.33 32-32v-96c0-17.67-14.33-32-32-32z" }))), xee = ee.span(bee || (bee = $([`
  margin-right: 4px;
  `, `;

  `, `:hover & {
    color: #ccc;
  }
`])), Ol, kj), See = ee.div(_ee || (_ee = $([`
  margin-right: auto;
  margin-left: 8px;
  display: flex;
  align-items: center;
  min-width: 0;
  flex: 1;

  /* Override some default input styles to fit in the row */
  input {
    font-size: 11px;
    height: 24px;
    padding: 2px 4px;
  }
`]))), wee = ({ leaf: r }) => {
        var s;
        let a = z0(r.sheetObject.propsP, r.pathToProp), d = r.sheetObject, m = f1e(a, d, r.propConf), y = At(() => {
          let B = r.sheetObject.address, U = Ul(r.pathToProp);
          return (0, dee.val)(pe().atomP.historic.projects.stateByProjectId[B.projectId].stateBySheetId[B.sheetId].sequenceEditor.selectedPropsByObject[B.objectKey][U]);
        }, [r]), x = (0, Ro.useRef)(!1), w = typeof y == "string";
        x.current = w;
        let T = (0, Ro.useCallback)(() => {
          let B = r.sheetObject.address;
          pe().transaction(({ stateEditors: U }) => {
            x.current ? U.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removePropFromGraphEditor(V(L({}, B), { pathToProp: r.pathToProp })) : r.trackId && (U.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.addPropToGraphEditor(V(L({}, B), { pathToProp: r.pathToProp })), U.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({ isOpen: !0 }));
          });
        }, [r]), P = (s = r.propConf.label) != null ? s : r.pathToProp[r.pathToProp.length - 1], M = !!r.trackId, F = (0, Ro.useRef)(null);
        kL(F.current, r);
        let [O] = Bs(F.current, { menuItems: m.contextMenuItems }), N = a3[r.propConf.type];
        return Ro.default.createElement(fee, { depth: r.depth }, O, Ro.default.createElement(kj, { ref: F, isEven: r.n % 2 === 0, style: { height: r.nodeHeight + "px" }, isSelected: w === !0 }, Ro.default.createElement(xee, null, P), Ro.default.createElement(See, null, Ro.default.createElement(N, { editingTools: m, propConfig: r.propConf, value: m.value })), m.controlIndicators, Ro.default.createElement(yee, { onClick: T, isSelected: w === !0, graphEditorColor: y ?? "1", style: { opacity: M ? 1 : 0.25 }, disabled: !M }, Ro.default.createElement(vee, null))));
      }, Eee = wee;
    }), lv, uR, Tee, Cee = R(() => {
      lv = Y(xe()), _M(), iwe(), gj(), $K(), z1(), uR = (r, s = !0) => {
        let a = "prop" + r.pathToProp[r.pathToProp.length - 1];
        return r.shouldRender ? r.type === "propWithChildren" ? lv.default.createElement(Tee, { leaf: r, key: a, renderChildren: s }) : lv.default.createElement(Eee, { leaf: r, key: a }) : lv.default.createElement(lv.default.Fragment, { key: a });
      }, Tee = ({ leaf: r, renderChildren: s = !0 }) => {
        var a;
        let d = z0(r.sheetObject.propsP, r.pathToProp), m = HK(d, r.sheetObject, r.propConf);
        return lv.default.createElement(b3, { leaf: r, label: (a = r.propConf.label) != null ? a : r.pathToProp[r.pathToProp.length - 1], isCollapsed: r.isCollapsed, contextMenuItems: m.contextMenuItems, toggleCollapsed: () => ov(!r.isCollapsed, { sheetAddress: r.sheetObject.address, sheetItemKey: r.sheetItemKey }) }, s && r.children.map((y) => uR(y)));
      };
    }), Pee, Aee, kee, Mee, swe = R(() => {
      Pee = Y(xe()), _M(), Cee(), gj(), st(), $K(), zt(), Aee = ut(), EM(), JQ(), kee = ({ leaf: r, renderChildren: s = !0, layoutP: a }) => {
        let d = r.sheetObject, m = HK(d.propsP, d, d.template.staticConfig), y = At(() => {
          var x;
          let w = wM(r), T = w.byPosition.size > 0, P = (x = (0, Aee.pointerToPrism)(pe().atomP.ahistoric.clipboard.keyframesWithRelativePaths).getValue()) != null ? x : [];
          return [{ label: "Copy Keyframes", enabled: T, callback: () => ZQ(r, w) }, { label: "Paste Keyframes", enabled: P.length > 0, callback: () => XQ(r, a, P) }];
        }, [r, a]);
        return Pee.default.createElement(b3, { leaf: r, label: r.sheetObject.address.objectKey, isCollapsed: r.isCollapsed, contextMenuItems: [...m.contextMenuItems, ...y], toggleSelect: () => {
          pe().transaction(({ stateEditors: x }) => {
            x.studio.historic.panels.outline.selection.set([r.sheetObject]);
          });
        }, toggleCollapsed: () => ov(!r.isCollapsed, { sheetAddress: r.sheetObject.address, sheetItemKey: r.sheetItemKey }) }, s && r.children.map((x) => uR(x)));
      }, Mee = kee;
    }), gS, Mj, Ree, Iee, Nee, Rj, Oee, Dee, Fee, Bee, owe = R(() => {
      gS = Y(xe()), it(), _M(), sd(), ML(), st(), Ls(), Mj = ut(), Iee = ee.li(Ree || (Ree = $([`
  --depth: `, `;
  margin: 0;
  padding: 0;
  list-style: none;
`])), (r) => r.depth - 1), Rj = ee(xM)(Nee || (Nee = $([`
  padding-left: calc(var(--depth) * 10px);
  display: flex;
  align-items: stretch;
  color: #999;
  box-sizing: border-box;

  &:hover {
    background: rgba(255, 255, 255, 0.05);
  }
`]))), Dee = ee.span(Oee || (Oee = $([`
  `, `;
  overflow-x: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  padding-right: 4px;
  padding-left: 20px;
  line-height: 26px;
  flex-wrap: nowrap;
  color: #ccc;

  `, `:hover & {
    color: #fff;
  }
`])), Ol, Rj), Fee = ({ leaf: r }) => {
        let s = (0, gS.useRef)(null);
        kL(s.current, r);
        let a = r.subSequence.label === void 0 ? "" : r.subSequence.label, d = "".concat(a, " (").concat(r.subSequence.sheetId, ")"), [m] = Bs(s.current, { menuItems: () => [{ label: "Edit Label", callback: () => {
          let y = prompt("Enter new label:", r.subSequence.label);
          y !== null && y.trim() !== "" && pe().transaction(({ stateEditors: x }) => {
            x.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { label: y.trim() } });
          });
        } }, { label: "Edit Duration", callback: () => {
          var y, x;
          let w = (y = r.subSequence.duration) != null ? y : 0;
          if (w === 0) {
            let P = pe(), M = (0, Mj.val)(P.projectsP)[r.sheet.address.projectId];
            w = (x = (0, Mj.val)(M.pointers.historic.sheetsById[r.subSequence.sheetId].sequence.length)) != null ? x : 0;
          }
          let T = prompt("Enter new duration (seconds):", String(w));
          if (T !== null) {
            let P = parseFloat(T);
            !isNaN(P) && P > 0 && pe().transaction(({ stateEditors: M }) => {
              M.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { duration: P } });
            });
          }
        } }, { label: "Edit Time Scale", callback: () => {
          var y;
          let x = (y = r.subSequence.timeScale) != null ? y : 1, w = prompt("Enter new time scale:", String(x));
          if (w !== null) {
            let T = parseFloat(w);
            !isNaN(T) && T > 0 && pe().transaction(({ stateEditors: P }) => {
              P.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id, updates: { timeScale: T } });
            });
          }
        } }, { label: "Delete Sub-sequence", callback: () => {
          confirm('Are you sure you want to delete sub-sequence "'.concat(r.subSequence.label, '"?')) && pe().transaction(({ stateEditors: y }) => {
            y.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeSubSequence({ sheetAddress: r.sheet.address, subSequenceId: r.subSequence.id });
          });
        } }] });
        return r.shouldRender ? gS.default.createElement(Iee, { depth: r.depth }, m, gS.default.createElement(Rj, { ref: s, style: { height: r.nodeHeight + "px" }, isEven: r.n % 2 === 0 }, gS.default.createElement(Dee, null, d))) : null;
      }, Bee = Fee;
    }), yS, Hr, Lee, jee, Uee, zee, Vee, Gee, awe = R(() => {
      zt(), yS = ut(), Hr = Y(xe()), it(), swe(), owe(), y1e(), Nl(), mj(), sJ(), Dl(), Fl(), oJ(), TM(), Cee(), jee = ee.div(Lee || (Lee = $([`
  position: absolute;
  left: 0;
  overflow-x: visible;

  &.drop-target {
    background: rgba(64, 170, 164, 0.1);
    outline: 2px dashed rgba(64, 170, 164, 0.5);
    outline-offset: -2px;
  }
`]))), zee = ee.div(Uee || (Uee = $([`
  margin: 0 0 50px 0;
  padding: 0;
  position: relative;
`]))), Vee = ({ layoutP: r }) => {
        let { searchTerm: s, searchTrigger: a } = fj(), [d, m] = (0, Hr.useState)(!1), [y, x] = (0, Hr.useState)(null), w = (0, Hr.useRef)(null), T = R3();
        (0, Hr.useLayoutEffect)(() => {
          let B = w.current;
          if (!B) return;
          let U = (H) => {
            H.stopPropagation();
          };
          return B.addEventListener("wheel", U, { passive: !0 }), () => B.removeEventListener("wheel", U);
        }, []);
        let P = ko({ debugName: "Left/addSubSequence" }, () => {
          if (!y) return Hr.default.createElement(Hr.default.Fragment, null);
          let B = y.sheetId;
          return Hr.default.createElement(Mo, null, Hr.default.createElement("div", { style: { padding: "8px", minWidth: "300px" } }, Hr.default.createElement("div", { style: { marginBottom: "8px", fontWeight: "bold", color: "#CCC" } }, "Add Sub-sequence"), Hr.default.createElement("div", { style: { marginBottom: "4px", fontSize: "11px", color: "#999" } }, "Label:"), Hr.default.createElement("input", { type: "text", defaultValue: y.sheetId, onChange: (U) => {
            B = U.target.value;
          }, style: { width: "100%", padding: "6px 8px", marginBottom: "12px", background: "rgba(0, 0, 0, 0.3)", border: "1px solid rgba(255, 255, 255, 0.1)", borderRadius: "2px", color: "#FFF", fontSize: "11px" }, autoFocus: !0, onKeyDown: (U) => {
            U.key === "Enter" ? ((0, yS.val)(r.sheet).getSequence().addSubSequence(y.sheetId, 0, { label: B.trim() || y.sheetId }), P.close("user action"), x(null)) : U.key === "Escape" && (P.close("user action"), x(null));
          } }), Hr.default.createElement("div", { style: { display: "flex", justifyContent: "flex-end", gap: "8px" } }, Hr.default.createElement("button", { onClick: () => {
            P.close("user action"), x(null);
          }, style: { padding: "6px 12px", background: "rgba(255, 255, 255, 0.1)", color: "#CCC", border: "1px solid rgba(255, 255, 255, 0.1)", borderRadius: "2px", cursor: "pointer", fontSize: "11px" } }, "Cancel"), Hr.default.createElement("button", { onClick: () => {
            (0, yS.val)(r.sheet).getSequence().addSubSequence(y.sheetId, 0, { label: B.trim() || y.sheetId }), P.close("user action"), x(null);
          }, style: { padding: "6px 12px", background: "#40AAA4", color: "white", border: "none", borderRadius: "2px", cursor: "pointer", fontSize: "11px" } }, "Ok"))));
        }), M = (0, Hr.useCallback)((B) => {
          B.preventDefault(), B.stopPropagation(), m(!0);
        }, []), F = (0, Hr.useCallback)((B) => {
          B.preventDefault(), B.stopPropagation(), m(!1);
          try {
            let U = B.dataTransfer.getData("application/json");
            if (!U) return;
            let H = JSON.parse(U);
            if (H.type !== "theatre-sheet") return;
            x({ sheetId: H.sheetId, projectId: H.projectId, sheetInstanceId: H.sheetInstanceId }), w.current && P.open({ clientX: B.clientX, clientY: B.clientY }, w.current);
          } catch (U) {
            console.error("Error handling drop:", U);
          }
        }, [P]), { scrollTop: O, clientHeight: N } = nn(T);
        return At(() => {
          let B = (0, yS.val)(r.tree), U = (0, yS.val)(r.leftDims.width), H = s.trim() ? nJ(B, s) : B, W = vj(H), Q = [], ne = 500, ce = O - ne, ue = O + N + ne, se = -1;
          for (let ie = 0; ie < W.length; ie++) {
            let ye = W[ie];
            if (ye.top + ye.nodeHeight >= ce) {
              se = ie;
              break;
            }
          }
          if (se !== -1) for (let ie = se; ie < W.length; ie++) {
            let ye = W[ie];
            if (ye.top > ue) break;
            Q.push(ye);
          }
          let Oe = W[W.length - 1], he = Oe ? Oe.top + Oe.nodeHeight : 0;
          return Hr.default.createElement(Hr.default.Fragment, null, P.node, Hr.default.createElement(jee, { id: "leftContainer", ref: w, style: { width: U + "px", top: 0, pointerEvents: y !== null ? "none" : "auto" }, className: d ? "drop-target" : "", onDragOver: M, onDrop: F }, Hr.default.createElement(zee, { style: { height: he + "px" } }, Q.map((ie) => {
            let ye = null;
            return ie.type === "subSequence" ? ye = Hr.default.createElement(Bee, { key: Ji.forSubSequence(ie.subSequence.id), leaf: ie }) : ie.type === "sheetObject" ? ye = Hr.default.createElement(Mee, { key: "sheetObject-" + g1e(ie.sheetObject), leaf: ie, renderChildren: !1, layoutP: r }) : (ie.type === "propWithChildren" || ie.type === "primitiveProp") && (ye = uR(ie, !1)), ye ? Hr.default.createElement("div", { key: ie.type + "-" + (ie.sheetItemKey || ie.top), style: { position: "absolute", top: ie.top + "px", width: "100%" } }, ye) : null;
          }))));
        }, [r, s, a, d, y, M, F, P.node, O, N]);
      }, Gee = Vee;
    }), cR, dR, qee, Hee, $ee, Wee, lwe = R(() => {
      Hn(), st(), li(), cR = ut(), dR = Y(xe()), it(), zt(), Hee = ee.div(qee || (qee = $([`
  position: absolute;
  top: 0;
  bottom: 0;
  width: 11px;
  margin-left: -5px;
  cursor: ew-resize;
  z-index: 1;
  pointer-events: auto;

  &:hover,
  &.isDragging {
    background: linear-gradient(
      to right,
      transparent 5px,
      #478698 5px,
      #478698 6px,
      transparent 6px
    );
  }
`]))), $ee = ({ layoutP: r }) => {
        let s = nn(r.leftDims.width), [a, d] = kn(null), m = (0, dR.useRef)(0), y = (0, dR.useMemo)(() => ({ debugName: "DopesheetSplitter", lockCursorTo: "ew-resize", onDragStart() {
          var w;
          let T;
          return m.current = (w = (0, cR.val)(pe().atomP.historic.panels.sequenceEditor.dopesheetLeftWidth)) != null ? w : (0, cR.val)(r.leftDims.width), { onDrag(P) {
            let M = (0, cR.val)(r.dopeSheetDims.width) - 100, F = Math.min(M, Math.max(225, m.current + P));
            T?.discard(), T = pe().tempTransaction(({ stateEditors: O }) => {
              O.studio.historic.panels.sequenceEditor.setDopesheetLeftWidth(F);
            });
          }, onDragEnd(P) {
            P ? T?.commit() : T?.discard();
          } };
        } }), []), [x] = Fr(d, y);
        return dR.default.createElement(Hee, { ref: a, className: x ? "isDragging" : "", style: { left: "".concat(s, "px") } });
      }, Wee = $ee;
    }), Ij, Kee, Yee, Xee, Qee, uwe = R(() => {
      Xn(), ec(), zt(), Al(), Ij = Y(xe()), it(), iee(), Yee = ee.div(Kee || (Kee = $([`
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  z-index: `, `;
  overflow: hidden;
  background: `, `;
  pointer-events: none;
`])), () => Hl.rightBackground, Uu(0.01, EB(1 * 0.03, A0.panel.bg))), Xee = ({ layoutP: r }) => {
        let s = nn(r.rightDims.width), a = nn(r.panelDims.height);
        return Ij.default.createElement(Yee, { style: { width: s + "px" } }, Ij.default.createElement(Aj, { width: s, height: a, layoutP: r }));
      }, Qee = Xee;
    }), wm, Zee, Jee, ete, tte, cwe = R(() => {
      zt(), wm = Y(xe()), it(), awe(), lwe(), uwe(), bj(), TM(), Jee = ee.div(Zee || (Zee = $([`
  position: absolute;
  left: 0;
  right: 0;
`]))), ete = ({ layoutP: r }) => {
        let s = nn(r.dopeSheetDims.height);
        return wm.default.createElement(Jee, { style: { height: s + "px" } }, wm.default.createElement(Qee, { layoutP: r }), wm.default.createElement(OY, null, wm.default.createElement(Gee, { layoutP: r }), wm.default.createElement(hJ, { layoutP: r })), wm.default.createElement(Wee, { layoutP: r }));
      }, tte = ete;
    });
    function dwe(r, s, a) {
      return Nj.prism.memo(r, () => (0, Nj.prism)(s), a).getValue();
    }
    var Nj, hwe = R(() => {
      Nj = ut();
    });
    function Ar(r) {
      return function(s, a) {
        return r(s, a());
      };
    }
    function la(r) {
      return Object.freeze({ audience: Em(r, 8) ? "internal" : Em(r, 16) ? "dev" : "public", category: Em(r, 4) ? "troubleshooting" : Em(r, 2) ? "todo" : "general", level: Em(r, 512) ? 512 : Em(r, 256) ? 256 : Em(r, 128) ? 128 : 64 });
    }
    function Em(r, s) {
      return (r & s) === s;
    }
    function kr(r, s) {
      return ((s & 32) === 32 ? !0 : (s & 16) === 16 ? r.dev : (s & 8) === 8 ? r.internal : !1) && r.min <= s;
    }
    function nte(r = console, s = {}) {
      let a = V(L({}, Xu), { includes: L({}, Xu.includes) }), d = { styled: mwe.bind(a, r), noStyle: ywe.bind(a, r) }, m = fwe.bind(a);
      function y() {
        return a.loggingConsoleStyle && a.loggerConsoleStyle ? d.styled : d.noStyle;
      }
      return a.create = y(), { configureLogger(x) {
        var w;
        x === "console" ? (a.loggerConsoleStyle = Xu.loggerConsoleStyle, a.create = y()) : x.type === "console" ? (a.loggerConsoleStyle = (w = x.style) != null ? w : Xu.loggerConsoleStyle, a.create = y()) : x.type === "keyed" ? (a.creatExt = (T) => x.keyed(T.names), a.create = m) : x.type === "named" && (a.creatExt = pwe.bind(null, x.named), a.create = m);
      }, configureLogging(x) {
        var w, T, P, M, F;
        a.includes.dev = (w = x.dev) != null ? w : Xu.includes.dev, a.includes.internal = (T = x.internal) != null ? T : Xu.includes.internal, a.includes.min = (P = x.min) != null ? P : Xu.includes.min, a.include = (M = x.include) != null ? M : Xu.include, a.loggingConsoleStyle = (F = x.consoleStyle) != null ? F : Xu.loggingConsoleStyle, a.create = y();
      }, getLogger() {
        return a.create({ names: [] });
      } };
    }
    function pwe(r, s) {
      let a = [];
      for (let { name: d, key: m } of s.names) a.push(m == null ? d : "".concat(d, " (").concat(m, ")"));
      return r(a);
    }
    function fwe(r) {
      let s = L(L({}, this.includes), this.include(r)), a = this.filtered, d = this.named.bind(this, r), m = this.creatExt(r), y = kr(s, 524), x = kr(s, 522), w = kr(s, 521), T = kr(s, 529), P = kr(s, 545), M = kr(s, 265), F = kr(s, 268), O = kr(s, 273), N = kr(s, 289), B = kr(s, 137), U = kr(s, 145), H = kr(s, 73), W = kr(s, 81), Q = y ? m.error.bind(m, Io._hmm) : a.bind(r, 524), ne = x ? m.error.bind(m, Io._todo) : a.bind(r, 522), ce = w ? m.error.bind(m, Io._error) : a.bind(r, 521), ue = T ? m.error.bind(m, Io.errorDev) : a.bind(r, 529), se = P ? m.error.bind(m, Io.errorPublic) : a.bind(r, 545), Oe = F ? m.warn.bind(m, Io._kapow) : a.bind(r, 268), he = M ? m.warn.bind(m, Io._warn) : a.bind(r, 265), ie = O ? m.warn.bind(m, Io.warnDev) : a.bind(r, 273), ye = N ? m.warn.bind(m, Io.warnPublic) : a.bind(r, 273), Ee = B ? m.debug.bind(m, Io._debug) : a.bind(r, 137), ve = U ? m.debug.bind(m, Io.debugDev) : a.bind(r, 145), Xe = H ? m.trace.bind(m, Io._trace) : a.bind(r, 73), Se = W ? m.trace.bind(m, Io.traceDev) : a.bind(r, 81), nt = { _hmm: Q, _todo: ne, _error: ce, errorDev: ue, errorPublic: se, _kapow: Oe, _warn: he, warnDev: ie, warnPublic: ye, _debug: Ee, debugDev: ve, _trace: Xe, traceDev: Se, lazy: { _hmm: y ? Ar(Q) : Q, _todo: x ? Ar(ne) : ne, _error: w ? Ar(ce) : ce, errorDev: T ? Ar(ue) : ue, errorPublic: P ? Ar(se) : se, _kapow: F ? Ar(Oe) : Oe, _warn: M ? Ar(he) : he, warnDev: O ? Ar(ie) : ie, warnPublic: N ? Ar(ye) : ye, _debug: B ? Ar(Ee) : Ee, debugDev: U ? Ar(ve) : ve, _trace: H ? Ar(Xe) : Xe, traceDev: W ? Ar(Se) : Se }, named: d, utilFor: { internal() {
        return { debug: nt._debug, error: nt._error, warn: nt._warn, trace: nt._trace, named(De, Ce) {
          return nt.named(De, Ce).utilFor.internal();
        } };
      }, dev() {
        return { debug: nt.debugDev, error: nt.errorDev, warn: nt.warnDev, trace: nt.traceDev, named(De, Ce) {
          return nt.named(De, Ce).utilFor.dev();
        } };
      }, public() {
        return { error: nt.errorPublic, warn: nt.warnPublic, debug(De, Ce) {
          nt._warn('(public "debug" filtered out) '.concat(De), Ce);
        }, trace(De, Ce) {
          nt._warn('(public "trace" filtered out) '.concat(De), Ce);
        }, named(De, Ce) {
          return nt.named(De, Ce).utilFor.public();
        } };
      } } };
      return nt;
    }
    function mwe(r, s) {
      let a = L(L({}, this.includes), this.include(s)), d = [], m = "";
      for (let T = 0; T < s.names.length; T++) {
        let { name: P, key: M } = s.names[T];
        if (m += " %c".concat(P), d.push(this.style.css(P)), M != null) {
          let F = "%c#".concat(M);
          m += F, d.push(this.style.css(F));
        }
      }
      let y = this.filtered, x = this.named.bind(this, s), w = [m, ...d];
      return rte(y, s, a, r, w, gwe(w), x);
    }
    function gwe(r) {
      let s = r.slice(0);
      for (let a = 1; a < s.length; a++) s[a] += ";background-color:#e0005a;padding:2px;color:white";
      return s;
    }
    function ywe(r, s) {
      let a = L(L({}, this.includes), this.include(s)), d = "";
      for (let w = 0; w < s.names.length; w++) {
        let { name: T, key: P } = s.names[w];
        d += " ".concat(T), P != null && (d += "#".concat(P));
      }
      let m = this.filtered, y = this.named.bind(this, s), x = [d];
      return rte(m, s, a, r, x, x, y);
    }
    function rte(r, s, a, d, m, y, x) {
      let w = kr(a, 524), T = kr(a, 522), P = kr(a, 521), M = kr(a, 529), F = kr(a, 545), O = kr(a, 265), N = kr(a, 268), B = kr(a, 273), U = kr(a, 289), H = kr(a, 137), W = kr(a, 145), Q = kr(a, 73), ne = kr(a, 81), ce = w ? d.error.bind(d, ...m) : r.bind(s, 524), ue = T ? d.error.bind(d, ...m) : r.bind(s, 522), se = P ? d.error.bind(d, ...m) : r.bind(s, 521), Oe = M ? d.error.bind(d, ...m) : r.bind(s, 529), he = F ? d.error.bind(d, ...m) : r.bind(s, 545), ie = N ? d.warn.bind(d, ...y) : r.bind(s, 268), ye = O ? d.warn.bind(d, ...m) : r.bind(s, 265), Ee = B ? d.warn.bind(d, ...m) : r.bind(s, 273), ve = U ? d.warn.bind(d, ...m) : r.bind(s, 273), Xe = H ? d.info.bind(d, ...m) : r.bind(s, 137), Se = W ? d.info.bind(d, ...m) : r.bind(s, 145), nt = Q ? d.debug.bind(d, ...m) : r.bind(s, 73), De = ne ? d.debug.bind(d, ...m) : r.bind(s, 81), Ce = { _hmm: ce, _todo: ue, _error: se, errorDev: Oe, errorPublic: he, _kapow: ie, _warn: ye, warnDev: Ee, warnPublic: ve, _debug: Xe, debugDev: Se, _trace: nt, traceDev: De, lazy: { _hmm: w ? Ar(ce) : ce, _todo: T ? Ar(ue) : ue, _error: P ? Ar(se) : se, errorDev: M ? Ar(Oe) : Oe, errorPublic: F ? Ar(he) : he, _kapow: N ? Ar(ie) : ie, _warn: O ? Ar(ye) : ye, warnDev: B ? Ar(Ee) : Ee, warnPublic: U ? Ar(ve) : ve, _debug: H ? Ar(Xe) : Xe, debugDev: W ? Ar(Se) : Se, _trace: Q ? Ar(nt) : nt, traceDev: ne ? Ar(De) : De }, named: x, utilFor: { internal() {
        return { debug: Ce._debug, error: Ce._error, warn: Ce._warn, trace: Ce._trace, named(le, Ie) {
          return Ce.named(le, Ie).utilFor.internal();
        } };
      }, dev() {
        return { debug: Ce.debugDev, error: Ce.errorDev, warn: Ce.warnDev, trace: Ce.traceDev, named(le, Ie) {
          return Ce.named(le, Ie).utilFor.dev();
        } };
      }, public() {
        return { error: Ce.errorPublic, warn: Ce.warnPublic, debug(le, Ie) {
          Ce._warn('(public "debug" filtered out) '.concat(le), Ie);
        }, trace(le, Ie) {
          Ce._warn('(public "trace" filtered out) '.concat(le), Ie);
        }, named(le, Ie) {
          return Ce.named(le, Ie).utilFor.public();
        } };
      } } };
      return Ce;
    }
    var Io, Xu, ite = R(() => {
      Io = { _hmm: la(524), _todo: la(522), _error: la(521), errorDev: la(529), errorPublic: la(545), _kapow: la(268), _warn: la(265), warnDev: la(273), warnPublic: la(289), _debug: la(137), debugDev: la(145), _trace: la(73), traceDev: la(81) }, Xu = { loggingConsoleStyle: !0, loggerConsoleStyle: !0, includes: Object.freeze({ internal: !1, dev: !1, min: 256 }), filtered: function() {
      }, include: function() {
        return {};
      }, create: null, creatExt: null, named(r, s, a) {
        return this.create({ names: [...r.names, { name: s, key: a }] });
      }, style: { bold: void 0, italic: void 0, cssMemo: /* @__PURE__ */ new Map([["", ""]]), collapseOnRE: /[a-z- ]+/g, color: void 0, collapsed(r) {
        if (r.length < 5) return r;
        let s = r.replace(this.collapseOnRE, "");
        return this.cssMemo.has(s) || this.cssMemo.set(s, this.css(r)), s;
      }, css(r) {
        var s, a, d, m;
        let y = this.cssMemo.get(r);
        if (y) return y;
        let x = "color:".concat((a = (s = this.color) == null ? void 0 : s.call(this, r)) != null ? a : "hsl(".concat((r.charCodeAt(0) + r.charCodeAt(r.length - 1)) % 360, ", 100%, 60%)"));
        return (d = this.bold) != null && d.test(r) && (x += ";font-weight:600"), (m = this.italic) != null && m.test(r) && (x += ";font-style:italic"), this.cssMemo.set(r, x), x;
      } } };
    }), Oj, hR, pR = R(() => {
      ite(), ite(), Oj = nte(console, {}), Oj.configureLogging({ dev: !0, min: 64 }), hR = Oj.getLogger().named("Theatre.js (default logger)").utilFor.dev();
    }), pd, rp, ste, vwe = R(() => {
      Nl(), pd = ut(), pR(), rp = 28, ste = (r, s) => {
        pd.prism.ensurePrism();
        let a = !1, d = 30, m = 0, y = s.atomP.ahistoric.projects.stateByProjectId[r.address.projectId].stateBySheetId[r.address.sheetId].sequence.collapsableItems, x = { type: "sheet", isCollapsed: !1, sheet: r, children: [], sheetItemKey: Ji.forSheet(), shouldRender: a, top: 60, depth: 0, n: m, nodeHeight: 0, heightIncludingChildren: -1 };
        for (let B of Object.values((0, pd.val)(r.objectsP))) B && P(B, x.children, x.depth + 1, !0);
        let w = (0, pd.val)(s.atomP.historic.projects.stateByProjectId[r.address.projectId].stateBySheetId[r.address.sheetId]), T = (0, pd.val)(w.sequenceEditor);
        if (T) {
          let B = T.subSequenceSet;
          if (B) {
            let U = Object.values(B.byId || {}).filter((H) => H !== void 0).map((H) => H).sort((H, W) => H.position - W.position);
            for (let H of U) {
              let W = { type: "subSequence", subSequence: H, sheet: r, sheetItemKey: Ji.forSubSequence(H.id), shouldRender: !0, top: d, depth: x.depth + 1, n: m, nodeHeight: rp, heightIncludingChildren: rp };
              x.children.push(W), d += rp, m += 1;
            }
          }
        }
        x.heightIncludingChildren = d - x.top;
        function P(B, U, H, W) {
          var Q;
          let ne = (0, pd.val)(B.template.getMapOfValidSequenceTracks_forStudio()), ce = (0, pd.val)(B.template.configPointer);
          if (Object.keys(ce.props).length === 0) return;
          let ue = (Q = (0, pd.val)(y.byId[Ji.forSheetObject(B)].isCollapsed)) != null ? Q : !0, se = { type: "sheetObject", isCollapsed: ue, sheetItemKey: Ji.forSheetObject(B), shouldRender: W, top: d, children: [], depth: H, n: m, sheetObject: B, nodeHeight: rp, heightIncludingChildren: -1 };
          U.push(se), m += 1, d += se.nodeHeight, M(B, ce.props, ne, [], ce, se.children, H + 1, !ue), se.heightIncludingChildren = d - se.top;
        }
        function M(B, U, H, W, Q, ne, ce, ue) {
          for (let [se, Oe] of Object.entries(U)) {
            let he = H[se];
            F(B, he, [...W, se], Oe, ne, ce, ue);
          }
        }
        function F(B, U, H, W, Q, ne, ce) {
          W.type === "compound" ? O(B, U || {}, W, H, W, Q, ne, ce) : W.type === "enum" ? hR.warn("Prop type enum is not yet supported in the sequence editor") : N(B, U, H, W, Q, ne, ce);
        }
        function O(B, U, H, W, Q, ne, ce, ue) {
          var se;
          let Oe = (se = (0, pd.val)(y.byId[Ji.forSheetObjectProp(B, W)].isCollapsed)) != null ? se : !1, he = { type: "propWithChildren", isCollapsed: Oe, propConf: H, pathToProp: W, sheetItemKey: Ji.forSheetObjectProp(B, W), sheetObject: B, shouldRender: ue, top: d, children: [], nodeHeight: ue ? rp : 0, heightIncludingChildren: -1, depth: ce, trackMapping: U, n: m };
          ne.push(he), ue && (d += he.nodeHeight, m += 1), M(B, Q.props, U, W, Q, he.children, ce + 1, ue && !Oe), he.heightIncludingChildren = d - he.top;
        }
        function N(B, U, H, W, Q, ne, ce) {
          let ue = { type: "primitiveProp", propConf: W, depth: ne, sheetItemKey: Ji.forSheetObjectProp(B, H), sheetObject: B, pathToProp: H, shouldRender: ce, top: d, nodeHeight: ce ? rp : 0, heightIncludingChildren: ce ? rp : 0, trackId: U, n: m };
          Q.push(ue), m += 1, d += ue.nodeHeight;
        }
        return x;
      };
    });
    function bwe(r, s) {
      let a = pe(), d = a.atomP.ahistoric.projects.stateByProjectId[r.address.projectId].stateBySheetId[r.address.sheetId], m = a.atomP.historic.projects.stateByProjectId[r.address.projectId].stateBySheetId[r.address.sheetId];
      return (0, es.prism)(() => {
        var y, x, w;
        let T = dwe("tree", () => ste(r, a), []), P = (0, es.val)(s), M = (0, es.val)(a.atomP.historic.panels.sequenceEditor.graphEditor), F = a.atomP.historic.panels.sequenceEditor.rightPanelOpen, O = (y = (0, es.val)(F)) != null ? y : !0, N = (0, es.val)(m.sequenceEditor.selectedPropsByObject), B = !!N && Object.keys(N).length > 0, U = (x = (0, es.val)(a.atomP.historic.panels.sequenceEditor.dopesheetLeftWidth)) != null ? x : Math.floor(P.width * ote), { leftDims: H, rightDims: W, graphEditorDims: Q, dopeSheetDims: ne, horizontalScrollbarDims: ce } = es.prism.memo("leftDims", () => {
          var De, Ce;
          let le = (De = (0, es.val)(F)) != null ? De : !0, Ie = { width: U, height: P.height, screenX: P.screenX, screenY: P.screenY }, $e = { width: le ? P.width - Ie.width : 0, height: P.height, screenX: P.screenX + Ie.width, screenY: P.screenY }, de = B && M?.isOpen === !0, Ae = Math.floor((de ? ir((Ce = M?.height) != null ? Ce : 0.5, 0.1, 0.7) : 0) * P.heightWithoutBorder), Je = P.height, rt = { width: P.width, height: Je, screenX: P.screenX, screenY: P.screenY }, Ve = { isAvailable: B, isOpen: de, width: $e.width, height: Ae, screenX: P.screenX, screenY: P.screenY + Je, padding: { top: 20, bottom: 20 } };
          return { leftDims: Ie, rightDims: $e, graphEditorDims: Ve, dopeSheetDims: rt, horizontalScrollbarDims: { bottom: 0 } };
        }, [P, M, B, F, U]), ue = es.prism.memo("graphEditorVerticalSpace", () => {
          let De = Q.height - Q.padding.top - Q.padding.bottom;
          return { space: De, fromExtremumSpace(Ce) {
            return Ce * De;
          }, toExtremumSpace(Ce) {
            return Ce / De;
          } };
        }, [Q]), [se, Oe] = es.prism.state("isSeeking", !1), he = { isSeeking: se, setIsSeeking: Oe }, ie = {}, ye = (w = (0, es.val)(d.sequence.clippedSpaceRange)) != null ? w : ate, Ee = es.prism.memo("scaledSpace", () => {
          let De = ye.end - ye.start, Ce = W.width, le = De / Ce, Ie = Ce / De;
          return { fromUnitSpace($e) {
            return $e * Ie;
          }, toUnitSpace($e) {
            return $e * le;
          }, leftPadding: 10 };
        }, [ye, W.width]), ve = es.prism.memo("setClippedSpaceRange", () => function(De) {
          a.transaction(({ stateEditors: Ce }) => {
            let le = L({}, De);
            if (le.end <= le.start && (le.end = le.start + 1), le.start < 0) {
              let Ie = le.end - le.start;
              le.start = 0, le.end = Ie;
            }
            Ce.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.clippedSpaceRange.set(V(L({}, r.address), { range: le }));
          });
        }, []), Xe = es.prism.memo("clippedSpace", () => ({ range: ye, width: W.width, fromUnitSpace(De) {
          return Ee.fromUnitSpace(De - ye.start) + Ee.leftPadding;
        }, toUnitSpace(De) {
          return Ee.toUnitSpace(De - Ee.leftPadding) + ye.start;
        }, setRange: ve }), [ye, W.width, Ee, ve]), Se = es.prism.memo("selection.current", () => new es.Atom({ current: void 0 }), []), nt = es.prism.memo("setRightPanelOpen", () => function(De) {
          a.transaction(({ stateEditors: Ce }) => {
            Ce.studio.historic.panels.sequenceEditor.setRightPanelOpen(De);
          });
        }, []);
        return AL("finalAtom", { sheet: r, tree: T, panelDims: P, leftDims: H, rightDims: W, dopeSheetDims: ne, horizontalScrollbarDims: ce, seeker: he, unitSpace: ie, scaledSpace: Ee, clippedSpace: Xe, graphEditorDims: Q, graphEditorVerticalSpace: ue, selectionAtom: Se, rightPanelOpen: O, setRightPanelOpen: nt }).pointer;
      });
    }
    var es, ote, ate, Dj, xwe = R(() => {
      st(), hwe(), a9(), es = ut(), vwe(), tn(), ote = 0.3, ate = { start: 0, end: 10 }, Dj = 250;
    });
    function _we(r) {
      let { fullSecondStampsContainer: s, sequencePositionFormatter: a, snapToGrid: d, unitSpaceToClippedSpace: m } = r, y = "";
      WJ(r, (x, w) => {
        let T = d(x), P = m(T);
        w ? y += lte(a.formatFullUnitForGrid(T), P, "full-unit") : y += lte(a.formatSubUnitForGrid(T), P, "sub-unit");
      }), s.innerHTML = y;
    }
    function lte(r, s, a) {
      return '<span class="'.concat(a, '" style="transform: translate3d(').concat(s.toFixed(1), 'px, -50%, 0);">').concat(r, "</span>");
    }
    var Tm, Cm, ute, cte, Pm, dte, hte, pte, fte, mte, gte, yte = R(() => {
      Tm = ut(), Cm = Y(xe()), it(), YJ(), st(), cte = ee.div(ute || (ute = $([`
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  pointer-events: none;
`]))), Pm = { fullUnitStampColor: "#999999", stampFontSize: "10px", subUnitStampColor: "#666666" }, hte = ee.div(dte || (dte = $([`
  position: absolute;
  top: 0;
  height: 100%;
  left: 0;
  overflow: hidden;
  z-index: 2;
  will-change: transform;
  pointer-events: none;
`]))), fte = ee.div(pte || (pte = $([`
  position: absolute;
  top: 0;
  left: 0;

  & > span {
    position: absolute;
    display: block;
    top: 9px;
    left: -10px;
    color: `, `;
    text-align: center;
    font-size: `, `;
    width: 20px;

    &.full-unit {
      color: `, `;
    }

    &.sub-unit {
      color: `, `;
    }
  }

  pointer-events: none;
`])), Pm.fullUnitStampColor, Pm.stampFontSize, Pm.fullUnitStampColor, Pm.subUnitStampColor), mte = ({ layoutP: r, width: s }) => {
        let a = (0, Cm.useRef)(null), [d, m] = (0, Cm.useState)(null);
        return (0, Cm.useLayoutEffect)(() => {
          if (d) return (0, Tm.prism)(() => {
            let y = (0, Tm.val)(r.sheet).getSequence();
            return { fullSecondStampsContainer: d, clippedSpaceRange: (0, Tm.val)(r.clippedSpace.range), clippedSpaceWidth: (0, Tm.val)(r.clippedSpace.width), unitSpaceToClippedSpace: (0, Tm.val)(r.clippedSpace.fromUnitSpace), leftPadding: (0, Tm.val)(r.scaledSpace.leftPadding), fps: y.subUnitsPerUnit, sequencePositionFormatter: y.positionFormatter, snapToGrid: (x) => y.closestGridPosition(x) };
          }).onChange(pe().ticker, _we, !0);
        }, [d, s, r]), Cm.default.createElement(cte, { ref: a, style: { width: s + "px" } }, Cm.default.createElement(hte, { style: { width: s + "px" } }, Cm.default.createElement(fte, { ref: m })));
      }, gte = mte;
    });
    function Swe(r) {
      let [s, a] = (0, Fj.useState)(!1);
      return (0, Fj.useEffect)(() => {
        if (a(!1), !r) return;
        let d = (y) => {
          y.target === r ? a(!0) : a(!1);
        }, m = () => {
          a(!1);
        };
        return r.addEventListener("mouseenter", d), r.addEventListener("mousemove", d), r.addEventListener("mouseleave", m), () => {
          a(!1), r.removeEventListener("mouseenter", d), r.removeEventListener("mousemove", d), r.removeEventListener("mouseleave", m);
        };
      }, [r]), s;
    }
    var Fj, wwe = R(() => {
      Fj = Y(xe());
    });
    function Ewe(r, s) {
      let a = 0, [d, m] = r, [y, x] = s;
      return m - d > x - y ? [y, x] : (d < y && (a = 0 - d), m > x && (a = x - m), [d + a, m + a]);
    }
    var Qu, ip, Ci, Bj, vte, fR, bte, xte, _te = R(() => {
      Qu = ut(), zt(), Xn(), st(), km(), Ls(), li(), Hn(), ip = Y(xe()), it(), Ui(), Ci = { enabled: { backgroundColor: "#2C2F34", stroke: "#646568" }, disabled: { backgroundColor: "#282a2cc5", stroke: "#595a5d" }, hover: { backgroundColor: "#34373D", stroke: "#C8CAC0" }, dragging: { backgroundColor: "#3F444A", stroke: "#C8CAC0" }, thumbWidth: 9, hitZoneWidth: 26, rangeStripMinWidth: 30 }, Bj = 1e3, fR = ee.div(vte || (vte = $([`
  position: absolute;
  height: `, `px;
  background-color: `, `;
  cursor: grab;
  top: 0;
  left: 0;
  width: `, `px;
  transform-origin: left top;
  &:hover {
    background-color: `, `;
  }
  &.dragging {
    background-color: `, `;
    cursor: grabbing !important;
  }
  `, `;

  /* covers the one pixel space between the focus range strip and the top strip
  of the sequence editor panel, which would have caused that one pixel to act
  like a panel drag zone */
  &:after {
    display: block;
    content: ' ';
    position: absolute;
    bottom: -1px;
    height: 1px;
    left: 0;
    right: 0;
    background: transparent;
    pointer-events: normal;
    z-index: -1;
  }
`])), () => Ju - 1, (r) => r.enabled ? Ci.enabled.backgroundColor : Ci.disabled.backgroundColor, Bj, Ci.hover.backgroundColor, Ci.dragging.backgroundColor, Ln), bte = ({ layoutP: r }) => {
        let s = (0, ip.useMemo)(() => (0, Qu.prism)(() => {
          let { projectId: P, sheetId: M } = (0, Qu.val)(r.sheet).address;
          return (0, Qu.val)(pe().atomP.ahistoric.projects.stateByProjectId[P].stateBySheetId[M].sequence.focusRange);
        }), [r]), [a, d] = kn(null), [m] = Bs(d, { menuItems: () => {
          let P = (0, Qu.val)(r.sheet), M = s.getValue();
          return [{ label: "Delete focus range", callback: () => {
            pe().tempTransaction(({ stateEditors: F }) => {
              F.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.unset(L({}, P.address));
            }).commit();
          } }, { label: M != null && M.enabled ? "Disable focus range" : "Enable focus range", callback: () => {
            M !== void 0 && pe().tempTransaction(({ stateEditors: F }) => {
              F.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(V(L({}, P.address), { range: M.range, enabled: !M.enabled }));
            }).commit();
          } }];
        } }), y = nn(r.scaledSpace.toUnitSpace), x = nn(r.sheet), w = (0, ip.useMemo)(() => {
          let P, M;
          return { debugName: "FocusRangeStrip", onDragStart(F) {
            let O, N = s.getValue();
            if (!N) return !1;
            let B = N.range.start, U = N.range.end, H = !1, W = (0, Qu.val)(r.sheet).getSequence();
            return { onDrag(Q) {
              if (N = s.getValue(), N) {
                H = !0;
                let ne = y(Q), ce = B + ne, ue = U + ne;
                ue < ce && (ue = ce), [P, M] = Ewe([ce, ue], [0, W.length]).map((se) => W.closestGridPosition(se)), O && O.discard(), O = pe().tempTransaction(({ stateEditors: se }) => {
                  var Oe;
                  se.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(V(L({}, x.address), { range: { start: P, end: M }, enabled: (Oe = N?.enabled) != null ? Oe : !0 }));
                });
              }
            }, onDragEnd() {
              N && (H && O !== void 0 ? O.commit() : O && O.discard());
            } };
          }, lockCSSCursorTo: "grabbing" };
        }, [x, y]), [T] = Fr(d, w);
        return $u(T, -1), At(() => {
          let P = s.getValue(), M = P?.range || { start: 0, end: 0 }, F = (0, Qu.val)(r.clippedSpace.fromUnitSpace)(M.start), O = (0, Qu.val)(r.clippedSpace.fromUnitSpace)(M.end), N, B;
          return F < 0 && (F = 0), O > (0, Qu.val)(r.clippedSpace.width) && (O = (0, Qu.val)(r.clippedSpace.width)), F > O ? (B = 0, N = 0) : (B = F, N = (O - F) / Bj), P ? ip.default.createElement(ip.default.Fragment, null, m, ip.default.createElement(fR, { id: "range-strip", enabled: P.enabled, className: "".concat(T ? "dragging" : "", " ").concat(P.enabled ? "enabled" : ""), ref: a, style: { transform: "translateX(".concat(B, "px) scale(").concat(N, ", 1)") } })) : ip.default.createElement(ip.default.Fragment, null);
        }, [r, a, s, m, T]);
      }, xte = bte;
    }), sp, fd, Ste, wte, Ete, Tte, Cte, Pte, Ate, Lj, Twe = R(() => {
      sp = ut(), zt(), st(), km(), Os(), li(), Hn(), fd = Y(xe()), it(), Ui(), _te(), zl(), wte = ee.div(Ste || (Ste = $([`
  position: absolute;
  top: 0;
  // the right handle has to be pulled back by its width since its right side indicates its position, not its left side
  left: `, `px;
  transform-origin: left top;
  width: `, `px;
  height: `, `px;
  z-index: 3;

  --bg: `, `;

  stroke: `, `;
  user-select: none;

  cursor: `, `;

  // no pointer events unless pointer-root is in normal mode _and_ the
  // focus range is enabled
  #pointer-root & {
    pointer-events: none;
  }

  #pointer-root.normal & {
    pointer-events: auto;
  }

  #pointer-root.draggingPositionInSequenceEditor & {
    pointer-events: auto;
    cursor: var(`, `);
  }

  &.dragging {
    pointer-events: none !important;
  }

  // highlight the handle if it's hovered, or the whole strip is hovverd
  `, `:hover ~ &, &:hover {
    --bg: `, `;
    stroke: `, `;
  }

  // highlight the handle when it's being dragged or the whole strip is being dragged.
  // using dragging.dragging to give this selector priority, as it seems to be overridden
  // by the hover selector above
  &.dragging,
  `, `.dragging.dragging ~ & {
    --bg: `, `;
    stroke: `, `;
  }

  #pointer-root.draggingPositionInSequenceEditor &:hover {
    --bg: `, `;
    stroke: #40aaa4;
  }

  background-color: var(--bg);

  // a larger hit zone
  &:before {
    display: block;
    content: ' ';
    position: absolute;
    inset: -8px;
  }
`])), (r) => r.type === "start" ? 0 : -Ci.thumbWidth, Ci.thumbWidth, () => Ju - 1, ({ enabled: r }) => r ? Ci.enabled.backgroundColor : Ci.disabled.backgroundColor, Ci.enabled.stroke, (r) => r.type === "start" ? "w-resize" : "e-resize", Ml, () => fR, Ci.hover.backgroundColor, Ci.hover.stroke, () => fR, Ci.dragging.backgroundColor, Ci.dragging.stroke, Ci.dragging.backgroundColor), Tte = ee.div(Ete || (Ete = $([`
  position: absolute;
  top: 0;
  bottom: 0;
  pointer-events: none;

  background: linear-gradient(
    `, `deg,
    var(--bg) 0%,
    #ffffff00 100%
  );

  width: 12px;
  left: `, `px;
`])), (r) => r.type === "start" ? 90 : -90, (r) => r.type === "start" ? Ci.thumbWidth : -Ci.thumbWidth + 1), Pte = ee.div(Cte || (Cte = $([`
  position: absolute;
  top: 0;
  bottom: 0;
  pointer-events: none;

  background: linear-gradient(
    `, `deg,
    `, ` 0%,
    #ffffff00 100%
  );

  width: 12px;
  left: `, `px;
`])), (r) => r.type === "start" ? -90 : 90, () => vS.backgroundColor, (r) => r.type === "start" ? -12 : Ci.thumbWidth), Ate = ({ layoutP: r, thumbType: s }) => {
        var a;
        let [d, m] = kn(null), y = (0, fd.useMemo)(() => (0, sp.prism)(() => {
          let { projectId: P, sheetId: M } = (0, sp.val)(r.sheet).address;
          return (0, sp.val)(pe().atomP.ahistoric.projects.stateByProjectId[P].stateBySheetId[M].sequence.focusRange);
        }), [r]), x = (0, fd.useMemo)(() => ({ debugName: "FocusRangeThumb", onDragStart() {
          let P, M, F = (0, sp.val)(r.sheet), O = { start: 0, end: F.getSequence().length }, N = y.getValue() || { range: O, enabled: !1 }, B = N.enabled, U = N.range[s], H = (0, sp.val)(r.scaledSpace.toUnitSpace), W = H(Ci.rangeStripMinWidth);
          return { onDrag(Q, ne, ce) {
            var ue;
            let se, Oe = js.checkIfMouseEventSnapToPos(ce, { ignore: m });
            if (Oe == null) {
              let ie = H(Q);
              se = U + ie;
            } else se = Oe;
            M = ((ue = y.getValue()) == null ? void 0 : ue.range) || O, s === "start" ? se = Math.max(Math.min(se, M.end - W), 0) : se = Math.min(Math.max(se, M.start + W), F.getSequence().length);
            let he = F.getSequence().closestGridPosition(se);
            P !== void 0 && P.discard(), P = pe().tempTransaction(({ stateEditors: ie }) => {
              ie.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(V(L({}, F.address), { range: V(L({}, M), { [s]: he }), enabled: B }));
            });
          }, onDragEnd(Q) {
            Q ? P?.commit() : P?.discard();
          } };
        } }), [r]), [w] = Fr(m, x);
        Ao(w, "draggingPositionInSequenceEditor", s === "start" ? "w-resize" : "e-resize");
        let T = nn(y);
        return $u(w, (a = T?.range[s]) != null ? a : 0), At(() => {
          let P = y.getValue();
          if (!P) return null;
          let { enabled: M } = P, F = P.range[s], O = (0, sp.val)(r.clippedSpace.fromUnitSpace)(F);
          return (O < 0 || (0, sp.val)(r.clippedSpace.width) < O) && (O = -1e4), fd.default.createElement(wte, V(L(L({ ref: d }, js.includePositionSnapAttrs(F)), Wu(F)), { className: "".concat(w && "dragging", " ").concat(M && "enabled"), enabled: M, type: s, style: { transform: "translate3d(".concat(O, "px, 0, 0)") } }), fd.default.createElement(Tte, { type: s, enabled: M }), fd.default.createElement(Pte, { type: s }), fd.default.createElement("svg", { viewBox: "0 0 9 18", xmlns: "http://www.w3.org/2000/svg" }, fd.default.createElement("line", { x1: "4", y1: "6", x2: "4", y2: "12" }), fd.default.createElement("line", { x1: "6", y1: "6", x2: "6", y2: "12" })));
        }, [r, d, y, w]);
      }, Lj = Ate;
    });
    function Cwe(r, s) {
      let [a, d] = (0, Zu.useState)("none");
      return Ao(a !== "none", "dragging", a === "creating" ? "ew-resize" : "move"), (0, Zu.useMemo)(() => {
        let m = () => ({ debugName: "FocusRangeZone/focusRangeCreationGestureHandlers", onDragStart(x) {
          let w, T = (0, Am.val)(r.clippedSpace.toUnitSpace), P = (0, Am.val)(r.scaledSpace.toUnitSpace), M = (0, Am.val)(r.sheet), F = M.getSequence(), O = x.target.getBoundingClientRect(), N = T(x.clientX - O.left), B = P(Ci.rangeStripMinWidth);
          return { onDrag(U) {
            let H = P(U), W = N, Q = N + H;
            [W, Q] = [ir(W, 0, F.length), ir(Q, 0, F.length)].map((ne) => F.closestGridPosition(ne)), Q < W ? [W, Q] = [Math.max(Math.min(Q, W - B), 0), W] : U > 0 && (Q = Math.min(Math.max(Q, W + B), F.length)), w && w.discard(), w = pe().tempTransaction(({ stateEditors: ne }) => {
              ne.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.focusRange.set(V(L({}, M.address), { range: { start: W, end: Q }, enabled: !0 }));
            });
          }, onDragEnd(U) {
            U && w !== void 0 ? w.commit() : w && w.discard();
          } };
        }, lockCSSCursorTo: "ew-resize" }), y = () => ({ debugName: "FocusRangeZone/panelMoveGestureHandlers", onDragStart() {
          let x, w = s.current, T = s.current.addBoundsHighlightLock();
          return { onDrag(P, M) {
            let F = V(L({}, w.dims), { top: ir(w.dims.top + M, 0, window.innerHeight - zu), left: ir(w.dims.left + P, -w.dims.width + zu, window.innerWidth - zu) }), O = Vk(F, { width: window.innerWidth, height: window.innerHeight });
            x?.discard(), x = pe().tempTransaction(({ stateEditors: N }) => {
              N.studio.historic.panelPositions.setPanelPosition({ position: O, panelId: w.panelId });
            });
          }, onDragEnd(P) {
            T(), P ? x?.commit() : x?.discard();
          } };
        }, lockCSSCursorTo: "move" });
        return { debugName: "FocusRangeZone", onDragStart(x) {
          let [w, T] = x.shiftKey ? ["creating", m().onDragStart(x)] : ["moving-panel", y().onDragStart(x)];
          return d(w), T === !1 ? !1 : { onDrag(P, M, F, O, N) {
            T.onDrag(P, M, F, O, N);
          }, onDragEnd(P) {
            var M;
            d("none"), (M = T.onDragEnd) == null || M.call(T, P);
          } };
        } };
      }, [r, s]);
    }
    var Am, Zu, kte, Mte, Rte, Ite, Pwe = R(() => {
      Am = ut(), zt(), st(), O0(), km(), Os(), li(), wwe(), vY(), Hn(), tn(), Zu = Y(xe()), it(), _te(), Twe(), qh(), Mte = ee.div(kte || (kte = $([`
  position: absolute;
  height: `, `px;
  left: 0;
  right: 0;
  box-sizing: border-box;
  /* Use the "grab" cursor if the shift key is up, which is the one used on the top strip of the sequence editor */
  cursor: `, `;
`])), () => Ju, (r) => r.isShiftDown ? "ew-resize" : "move"), Rte = ({ layoutP: r }) => {
        let [s, a] = kn(null), d = N0(), m = (0, Zu.useRef)(d);
        m.current = d;
        let y = (0, Zu.useMemo)(() => (0, Am.prism)(() => {
          let { projectId: T, sheetId: P } = (0, Am.val)(r.sheet).address;
          return (0, Am.val)(pe().atomP.ahistoric.projects.stateByProjectId[T].stateBySheetId[P].sequence.focusRange);
        }), [r]);
        Fr(a, Cwe(r, m));
        let x = gY("Shift"), w = Swe(a);
        return (0, Zu.useEffect)(() => {
          if (!x && w) return m.current.addBoundsHighlightLock();
        }, [!x && w]), At(() => Zu.default.createElement(Mte, { ref: s, isShiftDown: x }, Zu.default.createElement(xte, { layoutP: r }), Zu.default.createElement(Lj, { thumbType: "start", layoutP: r }), Zu.default.createElement(Lj, { thumbType: "end", layoutP: r })), [r, y, x]);
      }, Ite = Rte;
    }), uv, Ju, vS, Nte, Ote, Dte, Fte, km = R(() => {
      zt(), uv = Y(xe()), it(), yte(), Ui(), Xn(), Pwe(), Ju = 30, vS = { backgroundColor: "#1f2120eb", borderColor: "#1c1e21" }, Ote = ee.div(Nte || (Nte = $([`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: `, `px;
  box-sizing: border-box;
  background: `, `;
  border-bottom: 1px solid `, `;
  z-index: -10;
  `, `;
`])), Ju, vS.backgroundColor, vS.borderColor, Ln), Dte = ({ layoutP: r }) => {
        let s = nn(r.rightDims.width);
        return uv.default.createElement(uv.default.Fragment, null, uv.default.createElement(Ote, L({}, Wu("hide")), uv.default.createElement(gte, { layoutP: r, width: s, height: Ju }), uv.default.createElement(Ite, { layoutP: r })));
      }, Fte = Dte;
    }), Mm, Bte, Lte, jte, Ute, zte, Vte, Gte, qte, Awe = R(() => {
      Mm = Y(xe()), it(), zt(), st(), H1(), sd(), Bte = (r) => isFinite(r) && r > 0, jte = ee.div(Lte || (Lte = $([`
  display: flex;
  gap: 8px;
  padding: 4px 8px;
  height: 28px;
  align-items: center;
`]))), zte = ee.div(Ute || (Ute = $([`
  `, `;
  white-space: nowrap;
`])), Ol), Vte = ({ deltaX: r }) => r * 0.25, Gte = ({ layoutP: r }) => {
        let s = nn(r.sheet), a = (0, Mm.useMemo)(() => {
          let m;
          return { temporarilySetValue(y) {
            m && (m.discard(), m = void 0), m = pe().tempTransaction(({ stateEditors: x }) => {
              x.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, s.address), { length: y }));
            });
          }, discardTemporaryValue() {
            m && (m.discard(), m = void 0);
          }, permanentlySetValue(y) {
            m && (m.discard(), m = void 0), pe().transaction(({ stateEditors: x }) => {
              x.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, s.address), { length: y }));
            });
          } };
        }, [r, s]), d = (0, Mm.useRef)(null);
        return (0, Mm.useLayoutEffect)(() => {
          d.current.focus();
        }, []), At(() => {
          let m = s.getSequence().length;
          return Mm.default.createElement(jte, null, Mm.default.createElement(zte, null, "Sequence length"), Mm.default.createElement(V0, V(L({ value: m }, a), { isValid: Bte, inputRef: d, nudge: Vte })));
        }, [s, a, d]);
      }, qte = Gte;
    });
    function kwe(r, s) {
      let a = (0, No.useRef)(s);
      a.current = s;
      let d = (0, No.useMemo)(() => ({ debugName: "LengthIndicator/useDragBulge", lockCSSCursorTo: "ew-resize", onDragStart(y) {
        let x, w = a.current, T = (0, Rm.val)(a.current.layoutP.sheet), P = T.getSequence().length, M = (0, Rm.val)(w.layoutP.scaledSpace.toUnitSpace);
        return { onDrag(F, O, N) {
          let B = M(F);
          x && (x.discard(), x = void 0), x = pe().tempTransaction(({ stateEditors: U }) => {
            U.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, T.address), { length: P + B }));
          });
        }, onDragEnd(F) {
          F ? x && x.commit() : x && x.discard();
        } };
      } }), []), [m] = Fr(r, d);
      return $u(m, -1), [m];
    }
    var Rm, No, jj, bS, Hte, op, $te, Wte, Kte, Yte, Xte, Qte, Zte, Jte, ene, tne, nne, Mwe = R(() => {
      zt(), Rm = ut(), No = Y(xe()), it(), ec(), km(), Hn(), li(), st(), Dl(), Ui(), U1(), Awe(), Xn(), Fl(), jj = 1e3, bS = { stripNormal: "#0000006c", stripActive: "#000000" }, op = ee.div(Hte || (Hte = $([`
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  z-index: `, `;
  pointer-events: none;

  &:after {
    display: block;
    content: ' ';
    position: absolute;
    /* top: `, `px; */
    top: 0;
    bottom: 0;
    left: -1px;
    width: 1px;
    background-color: `, `;
  }

  &:hover:after,
  &.dragging:after {
    background-color: `, `;
  }
`])), () => Hl.lengthIndicatorStrip, Ju, bS.stripNormal, bS.stripActive), Wte = ee.div($te || ($te = $([`
  position: absolute;
  top: `, `px;
  width: 100px;
  left: -50px;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1;
`])), Ju - 15), Yte = ee.div(Kte || (Kte = $([`
  margin-top: 8px;
  font-size: 10px;
  white-space: nowrap;
  padding: 2px 8px;
  border-radius: 2px;
  `, `;
  cursor: ew-resize;
  color: #464646;
  background-color: #0000004d;
  display: none;

  `, ":hover &, ", `.dragging & {
    display: block;
    color: white;
    background-color: `, `;
  }
`])), Ln, op, op, bS.stripActive), Qte = ee.div(Xte || (Xte = $([`
  font-size: 10px;
  white-space: nowrap;
  padding: 1px 2px;
  border-radius: 2px;
  `, `;
  justify-content: center;
  align-items: center;
  cursor: ew-resize;
  color: #5d5d5d;
  background-color: #191919;

  `, ":hover &, ", `.dragging & {
    color: white;
    background-color: `, `;

    & > svg:first-child {
      margin-right: -1px;
    }
  }

  & > svg:first-child {
    margin-right: -4px;
  }
`])), Ln, op, op, bS.stripActive), Jte = ee.div(Zte || (Zte = $([`
  position: absolute;
  top: 0;
  left: 0;
  background-color: rgb(23 23 23 / 43%);
  width: `, `px;
  z-index: `, `;
  transform-origin: left top;

  `, ".dragging ~ &, ", `:hover ~ & {
    background-color: rgb(23 23 23 / 60%);
  }
`])), jj, () => Hl.lengthIndicatorCover, op, op), ene = -1e4, tne = ({ layoutP: r }) => {
        let [s, a] = kn(null), [d] = kwe(a, { layoutP: r }), { node: m, toggle: y, close: x } = ko({ debugName: "LengthIndicator" }, () => No.default.createElement(Mo, null, No.default.createElement(qte, { layoutP: r, onRequestClose: x })));
        return At(() => {
          let w = (0, Rm.val)(r.sheet), T = (0, Rm.val)(r.rightDims.height), P = w.getSequence(), M = P.length, F = M, O = (0, Rm.val)(r.clippedSpace.fromUnitSpace)(F), N = (0, Rm.val)(r.clippedSpace.width), B, U;
          return O > N ? (U = 0, B = 0) : (O < 0 && (O = 0), U = O, B = (N - O) / jj), No.default.createElement(No.default.Fragment, null, m, No.default.createElement(op, { style: { height: T + "px", transform: "translateX(".concat(U === 0 ? ene : U, "px)") }, className: d ? "dragging" : "" }, No.default.createElement(Wte, null, No.default.createElement(Qte, L({ ref: s, onClick: (H) => {
            y(H, a);
          } }, Wu("hide")), No.default.createElement(Yxe, null), No.default.createElement(Xxe, null)), No.default.createElement(Yte, null, "Sequence length:", " ", P.positionFormatter.formatBasic(M)))), No.default.createElement(Jte, { title: "Length", style: { height: T + "px", transform: "translateX(".concat(U, "px) scale(").concat(B, ", 1)") } }));
        }, [r, s, d, m]);
      }, nne = tne;
    }), Uj, md, rne, ine, sne, one, ane, lne, une, cne, Rwe = R(() => {
      zt(), Uj = ut(), md = Y(xe()), it(), yte(), ec(), km(), Ui(), ine = ee.div(rne || (rne = $([`
  position: absolute;
  top: 0;
  left: 0;
  margin-top: 0px;
`]))), one = ee.div(sne || (sne = $([`
  position: absolute;
  top: 16px;
  font-size: `, `;
  color: `, `;
  text-align: center;
  transform: translateX(-50%);
  background: `, `;
  padding: 1px 8px;
  font-variant-numeric: tabular-nums;
  pointer-events: none;
  z-index: `, `;
`])), Pm.stampFontSize, Pm.fullUnitStampColor, vS.backgroundColor, () => Hl.currentFrameStamp), lne = ee.div(ane || (ane = $([`
  position: absolute;
  top: 5px;
  left: -0px;
  bottom: 0;
  width: 0.5px;
  background: rgba(100, 100, 100, 0.2);
  pointer-events: none;
`]))), une = md.default.memo(({ layoutP: r }) => {
        let [s, a] = nn(UY()), d = nn(r.clippedSpace.fromUnitSpace), { sequence: m, formatter: y, clippedSpaceWidth: x } = At(() => {
          let M = (0, Uj.val)(r.sheet).getSequence(), F = (0, Uj.val)(r.clippedSpace.width);
          return { sequence: M, formatter: M.positionFormatter, clippedSpaceWidth: F };
        }, [r]);
        if (s == -1) return md.default.createElement(md.default.Fragment, null);
        let w = a === 3 ? m.closestGridPosition(s) : s, T = d(w), P = T >= 0 && T <= x;
        return md.default.createElement(md.default.Fragment, null, md.default.createElement(ine, null, md.default.createElement(one, { style: { opacity: P ? 1 : 0, transform: "translate3d(calc(".concat(T, "px - 50%), 0, 0)") } }, y.formatForPlayhead(w)), md.default.createElement(lne, { posType: a, style: { opacity: P ? 1 : 0, transform: "translate3d(".concat(T, "px, 0, 0)") } })), " ");
      }), cne = une;
    }), Ha, $r, dne, hne, pne, fne, mne, mR, gne, zj, yne, gR, vne, yR, bne, Vj, xne, Gj, _ne, Sne, Iwe = R(() => {
      zt(), Ha = ut(), p0(), Al(), $r = Y(xe()), it(), ec(), Ui(), Xn(), li(), hne = ee.div(dne || (dne = $([`
  --threadHeight: 20px;
  --bg-inactive: #32353b;
  --bg-active: #5b5c5d;
  position: absolute;
  height: 0;
  width: 100%;
  left: 12px;
  /* bottom: 8px; */
  z-index: `, `;
  `, `
`])), () => Hl.horizontalScrollbar, Ln), fne = ee.div(pne || (pne = $([`
  position: relative;
  top: 0;
  left: 0;
  width: 100%;
  height: var(--threadHeight);
`]))), mR = ee.div(mne || (mne = $([`
  position: absolute;
  height: 20px;
  background: var(--bg-inactive);
  cursor: ew-resize;
  z-index: 2;

  &:hover,
  &:active {
    background: var(--bg-active);
  }

  &:after {
    `, `;
    display: block;
    content: ' ';
  }
`])), SB("absolute", "-4px")), zj = ee.div(gne || (gne = $([`
  position: absolute;
  height: 20px;
  width: 7px;
  left: 0;
  z-index: 2;
  top: 0;
  bottom: 0;
  display: block;

  &:hover:before {
    background: var(--bg-active);
  }

  &:before {
    `, `;
    display: block;
    content: ' ';
    background: var(--bg-inactive);
    border-radius: 0 2px 2px 0;
  }

  &:after {
    `, `;
    display: block;
    content: ' ';
  }
`])), SB("absolute", "0"), SB("absolute", "-4px")), gR = ee(zj)(yne || (yne = $([`
  left: calc(-1 * 7px);
  cursor: w-resize;
  &:before {
    transform: scaleX(-1);
  }
`]))), yR = ee(zj)(vne || (vne = $([`
  cursor: e-resize;
  left: 0px;
`]))), Vj = ee.div(bne || (bne = $([`
  display: `, `;
  position: absolute;
  top: -20px;
  left: 4px;
  padding: 0 4px;
  transform: translateX(-50%);
  background: #131d1f;
  border-radius: 4px;
  color: #fff;
  font-size: 10px;
  line-height: 18px;
  text-align: center;

  `, `:hover &,
  `, `:hover &,
  `, ":hover ~ ", ` &,
  `, ":hover ~ ", ` & {
    display: block;
  }
`])), (r) => r.active ? "block" : "none", gR, yR, mR, gR, mR, yR), Gj = ee.input(xne || (xne = $([`
  background: transparent;
  border: none;
  color: #fff;
  font-size: 10px;
  line-height: 18px;
  text-align: center;
  width: 40px;
  outline: none;

  &:focus {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
  }
`]))), _ne = ({ layoutP: r }) => {
        let s = (0, $r.useCallback)((ie) => ie.toFixed(2), []), a = (0, $r.useMemo)(() => (0, Ha.prism)(() => {
          let ie = (0, Ha.val)(r.rightDims.width) - 25, ye = (0, Ha.val)(r.clippedSpace.range), Ee = (0, Ha.val)(r.sheet).getSequence().length, ve = Math.max(ye.end, Ee), Xe = ye.start / ve * ie, Se = ye.end / ve * ie;
          return { rightWidth: ie, clippedSpaceRange: ye, sequenceLength: Ee, assumedLengthOfSequence: ve, rangeStartX: Xe, rangeEndX: Se, bottom: (0, Ha.val)(r.horizontalScrollbarDims.bottom) };
        }), [r]), { rangeStartX: d, rangeEndX: m, clippedSpaceRange: y, bottom: x } = nn(a), [w, T] = (0, $r.useState)("nothing"), [P, M] = (0, $r.useState)(!1), [F, O] = (0, $r.useState)(!1), [N, B] = (0, $r.useState)(""), [U, H] = (0, $r.useState)(""), W = (0, $r.useMemo)(() => {
          let ie = (ye, Ee) => {
            let ve = Math.max(0, Math.min(ye, Ee - 0.01)), Xe = Math.max(ye + 0.01, Ee);
            (0, Ha.val)(r.clippedSpace.setRange)({ start: ve, end: Xe });
          };
          return { onStartInputClick: (ye) => {
            ye.stopPropagation(), M(!0), B(s(y.start));
          }, onEndInputClick: (ye) => {
            ye.stopPropagation(), O(!0), H(s(y.end));
          }, onStartInputChange: (ye) => {
            B(ye.target.value);
          }, onEndInputChange: (ye) => {
            H(ye.target.value);
          }, onStartInputKeyDown: (ye) => {
            if (ye.key === "Enter") {
              let Ee = parseFloat(N);
              isNaN(Ee) || ie(Ee, y.end), M(!1);
            } else ye.key === "Escape" && M(!1);
          }, onEndInputKeyDown: (ye) => {
            if (ye.key === "Enter") {
              let Ee = parseFloat(U);
              isNaN(Ee) || ie(y.start, Ee), O(!1);
            } else ye.key === "Escape" && O(!1);
          }, onStartInputBlur: () => {
            let ye = parseFloat(N);
            isNaN(ye) || ie(ye, y.end), M(!1);
          }, onEndInputBlur: () => {
            let ye = parseFloat(U);
            isNaN(ye) || ie(y.start, ye), O(!1);
          } };
        }, [r, a, y, N, U, s]), Q = (0, $r.useMemo)(() => {
          let ie = (0, Ha.val)(a), ye = () => {
            ie = (0, Ha.val)(a);
          }, Ee = (ve) => ve / ie.rightWidth * ie.assumedLengthOfSequence;
          return { onRangeDragStart() {
            return ye(), { onDrag(ve) {
              T("both");
              let Xe = Ee(ve), Se = Zc(ie.clippedSpaceRange, (nt) => nt + Xe);
              (0, Ha.val)(r.clippedSpace.setRange)(Se);
            }, onDragEnd() {
              T("nothing");
            } };
          }, onRangeStartDragStart() {
            return ye(), { onDrag(ve) {
              T("start");
              let Xe = Ee(ve), Se = { start: ie.clippedSpaceRange.start + Xe, end: ie.clippedSpaceRange.end };
              Se.start > Se.end - 1 && (Se.start = Se.end - 1), Se.start <= 0 && (Se.start = 0), (0, Ha.val)(r.clippedSpace.setRange)(Se);
            }, onDragEnd() {
              T("nothing");
            } };
          }, onRangeEndDragStart() {
            return ye(), { onDrag(ve) {
              T("end");
              let Xe = Ee(ve), Se = { start: ie.clippedSpaceRange.start, end: ie.clippedSpaceRange.end + Xe };
              Se.end < Se.start + 1 && (Se.end = Se.start + 1), Se.end >= ie.assumedLengthOfSequence && (Se.end = ie.assumedLengthOfSequence), (0, Ha.val)(r.clippedSpace.setRange)(Se);
            }, onDragEnd() {
              T("nothing");
            } };
          } };
        }, [r, a]), [ne, ce] = (0, $r.useState)(null);
        Fr(ne, { debugName: "HorizontalScrollbar/onRangeDrag", onDragStart: Q.onRangeDragStart, lockCSSCursorTo: "ew-resize" });
        let [ue, se] = (0, $r.useState)(null);
        Fr(ue, { debugName: "HorizontalScrollbar/onRangeStartDrag", onDragStart: Q.onRangeStartDragStart, lockCSSCursorTo: "w-resize" });
        let [Oe, he] = (0, $r.useState)(null);
        return Fr(Oe, { debugName: "HorizontalScrollbar/onRangeEndDrag", onDragStart: Q.onRangeEndDragStart, lockCSSCursorTo: "e-resize" }), $r.default.createElement(hne, L({ style: { bottom: x + 23 + "px" } }, Wu("hide")), $r.default.createElement(fne, null, $r.default.createElement(mR, { ref: ce, style: { width: "".concat(m - d, "px"), transform: "translate3d(".concat(d, "px, 0, 0)") } }), $r.default.createElement(gR, { ref: se, style: { transform: "translate3d(".concat(d, "px, 0, 0)") } }, $r.default.createElement(Vj, { active: w === "both" || w === "start" || P }, P ? $r.default.createElement(Gj, { value: N, onChange: W.onStartInputChange, onKeyDown: W.onStartInputKeyDown, onBlur: W.onStartInputBlur, autoFocus: !0 }) : $r.default.createElement("span", { onClick: W.onStartInputClick }, s(y.start)))), $r.default.createElement(yR, { ref: he, style: { transform: "translate3d(".concat(m, "px, 0, 0)") } }, $r.default.createElement(Vj, { active: w === "both" || w === "end" || F }, F ? $r.default.createElement(Gj, { value: U, onChange: W.onEndInputChange, onKeyDown: W.onEndInputKeyDown, onBlur: W.onEndInputBlur, autoFocus: !0 }) : $r.default.createElement("span", { onClick: W.onEndInputClick }, s(y.end))))));
      }, Sne = _ne;
    }), wne, Ene, Tne, Cne, Pne, Nwe = R(() => {
      wne = Y(xe()), it(), Tne = ee.div(Ene || (Ene = $([`
  position: absolute;
  inset: `, `px;
`])), (r) => r.room * -1), Cne = (r) => wne.default.createElement(Tne, { room: r.room }), Pne = Cne;
    }), vR, bR, qj, Ane, kne, Mne, Rne, Ine, Nne, One, Dne, Owe = R(() => {
      it(), zt(), H1(), sd(), vR = Y(xe()), bR = Y(xe()), qj = ut(), Df(), Ane = (r) => isFinite(r) && r >= 0, Mne = ee.div(kne || (kne = $([`
  display: flex;
  gap: 8px;
  padding: 4px 8px;
  height: 28px;
  align-items: center;
`]))), Ine = ee.div(Rne || (Rne = $([`
  `, `;
  white-space: nowrap;
`])), Ol), Nne = ({ deltaX: r }) => r * 0.25, One = ({ layoutP: r, onRequestClose: s }) => {
        let a = (0, qj.val)(r.sheet), d = a.getSequence(), m = (0, vR.useMemo)(() => {
          let x, w = d.position;
          return { temporarilySetValue(T) {
            x && (x = void 0), x = ir(T, 0, d.length), d.position = x;
          }, discardTemporaryValue() {
            x && (x = void 0, d.position = w, s("discardTemporaryValue"));
          }, permanentlySetValue(T) {
            x && (x = void 0), d.position = ir(T, 0, d.length), s("permanentlySetValue");
          } };
        }, [r, d]), y = (0, vR.useRef)(null);
        return (0, vR.useLayoutEffect)(() => {
          y.current.focus();
        }, []), At(() => {
          let x = a.getSequence(), w = Number((0, qj.val)(x.pointer.position).toFixed(3));
          return bR.default.createElement(Mne, null, bR.default.createElement(Ine, null, "Sequence position"), bR.default.createElement(V0, V(L({ value: w }, m), { isValid: Ane, inputRef: y, nudge: Nne })));
        }, [a, m, y]);
      }, Dne = One;
    }), Fne, Dwe = R(() => {
      Fne = typeof navigator < "u" && navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    }), Bne, Fwe = R(() => {
      Dwe(), Bne = (r) => Fne ? r.metaKey === !0 : r.ctrlKey === !0;
    });
    function Bwe() {
      xR = !1;
    }
    function Lwe() {
      xR = !0;
    }
    function jwe() {
      let r = pe();
      (0, Lne.useEffect)(() => {
        let s = (a) => {
          let d = a.composedPath()[0];
          if (!(d && (d.tagName === "INPUT" || d.tagName === "TEXTAREA"))) {
            if (a.key === "z" || a.key === "Z" || a.code === "KeyZ") if (Bne(a)) a.shiftKey === !0 ? r.redo() : r.undo();
            else return;
            else if (a.code === "Space" && !a.shiftKey && !a.metaKey && !a.altKey && !a.ctrlKey) {
              if (!xR) return;
              let m = fxe();
              if (m) if (m.playing) m.pause();
              else {
                let { projectId: y, sheetId: x } = m.address, w = (0, Gl.prism)(() => {
                  let M = (0, Gl.val)(pe().atomP.ahistoric.projects.stateByProjectId[y].stateBySheetId[x].sequence.focusRange);
                  return Gl.prism.memo("shouldFollowFocusRange", () => {
                    let F = m.position;
                    if (M) {
                      let O = F >= M.range.start && F <= M.range.end;
                      return M.enabled ? !!O : !0;
                    } else return !0;
                  }, []) && M && M.enabled ? { range: [M.range.start, M.range.end], isFollowingARange: !0 } : { range: [0, (0, Gl.val)(m.pointer.length)], isFollowingARange: !1 };
                }), T = m.playDynamicRange((0, Gl.prism)(() => (0, Gl.val)(w).range), pe().ticker), P = Hj(m);
                T.finally(() => {
                  P.set(void 0);
                }), P.set(w);
              }
              else return;
            } else if (a.altKey && (a.key === "\\" || a.code === "Backslash" || a.code === "IntlBackslash")) r.transaction(({ stateEditors: m, drafts: y }) => {
              m.studio.ahistoric.setVisibilityState(y.ahistoric.visibilityState === "everythingIsHidden" ? "everythingIsVisible" : "everythingIsHidden");
            });
            else return;
            a.preventDefault(), a.stopPropagation();
          }
        };
        return window.addEventListener("keydown", s), () => {
          window.removeEventListener("keydown", s);
        };
      }, []);
    }
    var Lne, Gl, xR, Hj, jne, $j = R(() => {
      Lne = Y(xe()), st(), Fwe(), M0(), Gl = ut(), l3(), xR = !0, Hj = uM((r) => new Gl.Atom(void 0)), jne = uM((r) => (0, Gl.prism)(() => {
        let s = Hj(r).prism.getValue();
        if (s) return s.getValue().isFollowingARange;
        {
          let { projectId: a, sheetId: d } = r.address, m = (0, Gl.val)(pe().atomP.ahistoric.projects.stateByProjectId[a].stateBySheetId[d].sequence.focusRange);
          if (!m || !m.enabled) return !1;
          let y = (0, Gl.val)(r.pointer.position);
          return y >= m.range.start && y <= m.range.end;
        }
      }));
    });
    function Uwe(r, s) {
      return Bs(r, { menuItems() {
        return [{ label: "Place marker", callback: () => {
          pe().transaction(({ stateEditors: a }) => {
            let d = (0, $a.val)(s.layoutP.sheet), m = d.getSequence();
            a.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers({ sheetAddress: d.address, markers: [{ id: s9(), position: m.position }], snappingFunction: m.closestGridPosition });
          });
        } }, { label: "Place event", callback: () => {
          pe().transaction(({ stateEditors: a }) => {
            let d = (0, $a.val)(s.layoutP.sheet), m = d.getSequence();
            a.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents({ sheetAddress: d.address, events: [{ id: o9(), name: "event", position: m.position }] });
          });
        } }, { label: "Attach audio", callback: () => {
          let a = new CustomEvent("theatre:attachAudio", { detail: { sheet: (0, $a.val)(s.layoutP.sheet) } });
          document.dispatchEvent(a);
        } }];
      } });
    }
    var $a, Wa, Une, Im, zne, Vne, Gne, Wj, qne, Hne, $ne, Wne, Kne, Yne, zwe = R(() => {
      Nwe(), li(), Hn(), zt(), $a = ut(), Df(), Wa = Y(xe()), it(), ec(), Ui(), Xn(), Dl(), Fl(), Owe(), $j(), Os(), Ls(), st(), Nl(), zl(), ev(), Im = ee.div(Une || (Une = $([`
  --thumbColor: #00e0ff;
  position: absolute;
  top: 0;
  left: 0;
  width: 5px;
  height: 100%;
  z-index: `, `;
  pointer-events: none;

  display: `, `;
`])), () => Hl.playhead, (r) => r.isVisible ? "block" : "none"), Vne = ee.div(zne || (zne = $([`
  position: absolute;
  top: 30px;
  width: 0;
  height: calc(100% - 30px);
  border-left: 1px solid #27e0fd;
  z-index: 10;
  pointer-events: none;

  #pointer-root.draggingPositionInSequenceEditor &:not(.seeking) {
    /* pointer-events: auto; */
    /* cursor: var(`, `); */

    &:after {
      position: absolute;
      inset: -8px;
      display: block;
      content: ' ';
    }
  }
`])), Ml), Wj = ee.div(Gne || (Gne = $([`
  background-color: var(--thumbColor);
  position: absolute;
  width: 5px;
  height: 34px;
  top: -4px;
  left: -2px;
  z-index: 11;
  cursor: ew-resize;
  --sunblock-color: #1f2b2b;

  `, `;

  `, `.seeking > & {
    pointer-events: none !important;
  }

  #pointer-root.draggingPositionInSequenceEditor
    `, `:not(.seeking)
    > & {
    pointer-events: auto;
    cursor: var(`, `);
  }

  `, `.playheadattachedtofocusrange > & {
    top: -8px;
    --sunblock-color: #005662;
    &:before,
    &:after {
      border-bottom-width: 8px;
    }
  }

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    left: -2px;
    width: 0;
    height: 0;
    border-bottom: 4px solid var(--sunblock-color);
    border-left: 2px solid transparent;
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    right: -2px;
    width: 0;
    height: 0;
    border-bottom: 4px solid var(--sunblock-color);
    border-right: 2px solid transparent;
  }
`])), Ln, Im, Im, Ml, Im), Hne = ee.div(qne || (qne = $([`
  position: absolute;
  left: 1px;
  right: 1px;
  top: 35px;
  border-top: 3px solid var(--thumbColor);
  border-right: 1px solid transparent;
  border-left: 1px solid transparent;
  pointer-events: none;

  /* `, `.playheadattachedtofocusrange & {
    top: 10px;
    &:before,
    &:after {
      height: 15px;
    }
  } */

  &:before {
    position: absolute;
    display: block;
    content: ' ';
    top: -4px;
    left: -2px;
    height: 8px;
    width: 2px;
    background: none;
    border-radius: 0 100% 0 0;
    border-top: 1px solid var(--thumbColor);
    border-right: 1px solid var(--thumbColor);
  }

  &:after {
    position: absolute;
    display: block;
    content: ' ';
    top: -4px;
    right: -2px;
    height: 8px;
    width: 2px;
    background: none;
    border-radius: 100% 0 0 0;
    border-top: 1px solid var(--thumbColor);
    border-left: 1px solid var(--thumbColor);
  }
`])), Im), Wne = ee.div($ne || ($ne = $([`
  display: none;
  position: absolute;
  top: -20px;
  left: 4px;
  padding: 0 2px;
  transform: translateX(-50%);
  background: #1a1a1a;
  border-radius: 4px;
  color: #fff;
  font-size: 10px;
  line-height: 18px;
  text-align: center;
  `, ":hover &, ", `.seeking & {
    display: block;
  }
`])), Wj, Im), Kne = ({ layoutP: r }) => {
        let [s, a] = kn(null), { node: d, toggle: m, close: y } = ko({ debugName: "Playhead" }, () => Wa.default.createElement(Mo, null, Wa.default.createElement(Dne, { layoutP: r, onRequestClose: y }))), x = (0, Wa.useMemo)(() => ({ debugName: "RightOverlay/Playhead", onDragStart() {
          let P = (0, $a.val)(r.sheet).getSequence(), M = P.position, F = (0, $a.val)(r.scaledSpace.toUnitSpace), O = (0, $a.val)(r.seeker.setIsSeeking);
          return O(!0), kM(), { onDrag(N, B, U) {
            var H;
            let W = F(N);
            P.position = (H = js.checkIfMouseEventSnapToPos(U, { ignore: a })) != null ? H : ir(M + W, 0, P.length);
          }, onDragEnd(N) {
            O(!1), J0();
          }, onClick(N) {
            m(N, s.current);
          } };
        } }), [r, a]), [w] = Fr(a, x);
        Ao(w, "draggingPositionInSequenceEditor", "ew-resize"), $u(nn(r.seeker.isSeeking) || w, -1);
        let [T] = Uwe(a, { layoutP: r });
        return At(() => {
          let P = (0, $a.val)(r.seeker.isSeeking), M = (0, $a.val)(r.sheet).getSequence(), F = (0, $a.val)(jne(M)), O = M.positionPrism.getValue(), N = (0, $a.val)(r.clippedSpace.fromUnitSpace)(O), B = N >= 0 && N <= (0, $a.val)(r.clippedSpace.width);
          return Wa.default.createElement(Wa.default.Fragment, null, T, d, Wa.default.createElement(Im, L({ isVisible: B, style: { transform: "translate3d(".concat(N, "px, 0, 0)") }, className: "".concat(P && "seeking", " ").concat(F && "playheadattachedtofocusrange") }, Wu("hide")), Wa.default.createElement(Wj, L({ ref: s }, js.includePositionSnapAttrs(O)), Wa.default.createElement(Pne, { room: 8 }), Wa.default.createElement(Hne, null), Wa.default.createElement(Wne, null, M.positionFormatter.formatForPlayhead(M.closestGridPosition(O)))), Wa.default.createElement(Vne, V(L({}, js.includePositionSnapAttrs(O)), { className: P ? "seeking" : "" }))));
        }, [r, s, d]);
      }, Yne = Kne;
    }), Nm, xS, _R, Xne, Qne, Zne, Jne, Vwe = R(() => {
      Nm = ut(), zt(), st(), km(), xS = Y(xe()), it(), _R = 1e3, Qne = ee.div(Xne || (Xne = $([`
  position: absolute;
  top: `, `px;
  left: 0;
  opacity: 0.15;
  width: `, `px;
  transform-origin: top left;
  pointer-events: none;
  background-color: `, `;
`])), Ju, _R, (r) => r.enabled ? "#000000" : "transparent"), Zne = ({ layoutP: r }) => {
        let s = (0, xS.useMemo)(() => (0, Nm.prism)(() => {
          let { projectId: a, sheetId: d } = (0, Nm.val)(r.sheet).address;
          return (0, Nm.val)(pe().atomP.ahistoric.projects.stateByProjectId[a].stateBySheetId[d].sequence.focusRange);
        }), [r]);
        return At(() => {
          let a = s.getValue();
          if (!a || !a.enabled) return null;
          let { range: d } = a, m = (0, Nm.val)(r.rightDims.height) - Ju, y = (0, Nm.val)(r.clippedSpace.fromUnitSpace), x = (0, Nm.val)(r.clippedSpace.width), w = [];
          {
            let T = 0, P = y(a.range.start), M, F;
            T > P ? (F = 0, M = 0) : (P > x && (P = x), F = T, M = (P - T) / _R), w.push({ translateX: F, scaleX: M });
          }
          {
            let T = y(a.range.end), P = x, M, F;
            T > P ? (F = 0, M = 0) : (T < 0 && (T = 0), F = T, M = (P - T) / _R), w.push({ translateX: F, scaleX: M });
          }
          return xS.default.createElement(xS.default.Fragment, null, w.map(({ translateX: T, scaleX: P }, M) => xS.default.createElement(Qne, { key: "curtain-".concat(M), enabled: !0, style: { height: "".concat(m, "px"), transform: "translateX(".concat(T, "px) scaleX(").concat(P, ")") } })));
        }, [r, s]);
      }, Jne = Zne;
    }), cv, ere, tre, nre, rre, ire, Gwe = R(() => {
      cv = Y(xe()), it(), zt(), st(), sd(), G0(), tre = ee.div(ere || (ere = $([`
  display: flex;
  gap: 8px;
  /* padding: 4px 8px; */
  height: 28px;
  align-items: center;
`]))), ee.div(nre || (nre = $([`
  `, `;
  white-space: nowrap;
`])), Ol), rre = ({ layoutP: r, marker: s }) => {
        var a;
        let d = nn(r.sheet), m = (0, cv.useMemo)(() => {
          let x;
          return { temporarilySetValue(w) {
            x && (x.discard(), x = void 0), x = pe().tempTransaction(({ stateEditors: T }) => {
              T.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateMarker({ sheetAddress: d.address, markerId: s.id, label: w });
            });
          }, discardTemporaryValue() {
            x && (x.discard(), x = void 0);
          }, permanentlySetValue(w) {
            x && (x.discard(), x = void 0), pe().transaction(({ stateEditors: T }) => {
              T.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateMarker({ sheetAddress: d.address, markerId: s.id, label: w });
            });
          } };
        }, [r, d]), y = (0, cv.useRef)(null);
        return (0, cv.useLayoutEffect)(() => {
          y.current.focus();
        }, []), cv.default.createElement(tre, null, cv.default.createElement(Hh, V(L({ value: (a = s.label) != null ? a : "" }, m), { isValid: () => !0, inputRef: y })));
      }, ire = rre;
    });
    function qwe(r, s) {
      return Bs(r, { menuItems() {
        return [{ label: "Remove marker", callback: () => {
          pe().transaction(({ stateEditors: a }) => {
            a.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeMarker({ sheetAddress: s.sheetAddress, markerId: s.markerId });
          });
        } }];
      } });
    }
    function Hwe(r, s) {
      let a = (0, oo.useRef)(s);
      a.current = s;
      let d = (0, oo.useMemo)(() => ({ debugName: "MarkerDot/useDragMarker (".concat(s.marker.id, ")"), onDragStart(y) {
        let x = a.current.marker, w = (0, SR.val)(s.layoutP.scaledSpace.toUnitSpace), T;
        return kM(), { onDrag(P, M, F) {
          var O;
          let N = x, B = Math.max((O = js.checkIfMouseEventSnapToPos(F, { ignore: r })) != null ? O : N.position + w(P), 0);
          T?.discard(), T = pe().tempTransaction(({ stateEditors: U }) => {
            U.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers({ sheetAddress: (0, SR.val)(s.layoutP.sheet.address), markers: [V(L({}, N), { position: B })], snappingFunction: (0, SR.val)(s.layoutP.sheet).getSequence().closestGridPosition });
          });
        }, onDragEnd(P) {
          P ? T?.commit() : T?.discard(), J0();
        } };
      } }), []), [m] = Fr(r, d);
      return $u(m, s.marker.position), Ao(m, "draggingPositionInSequenceEditor draggingMarker", "ew-resize"), [m];
    }
    var SR, oo, Kj, Yj, sre, ore, are, lre, ure, wR, cre, dre, hre, pre, fre, mre, $we = R(() => {
      SR = ut(), zt(), st(), Os(), Ls(), Hn(), oo = Y(xe()), it(), Ui(), li(), ec(), zl(), CM(), D3(), ev(), Dl(), Fl(), Gwe(), Kj = 12, Yj = 12, sre = Kj * 2, ore = Yj * 2, lre = ee.div(are || (are = $([`
  position: absolute;
  // below the sequence ruler "top bar"
  top: 30px;
  z-index: `, `;
`])), () => Hl.marker), wR = ee.div(ure || (ure = $([`
  position: absolute;
  `, `
  pointer-events: none;
`])), Vl(Kj, Yj)), cre = oo.default.memo(() => oo.default.createElement(wR, { children: oo.default.createElement("svg", { width: "100%", height: "100%", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, oo.default.createElement("path", { d: "M12 5H0V7H2.71973L5.96237 10.2426L9.20501 7H12V5Z", fill: "#40AAA4" })) })), hre = ee.div(dre || (dre = $([`
  z-index: 1;
  cursor: ew-resize;

  `, `

  // :not dragging marker to ensure that markers don't snap to other markers
  // this works because only one marker track (so this technique is not used by keyframes...)
  #pointer-root.draggingPositionInSequenceEditor:not(.draggingMarker) & {
    `, `
  }

  // "All instances of this component <Mark/> inside #pointer-root when it has the .draggingPositionInSequenceEditor class"
  // ref: https://styled-components.com/docs/basics#pseudoelements-pseudoselectors-and-nesting
  #pointer-root.draggingPositionInSequenceEditor:not(.draggingMarker) &,
  #pointer-root.draggingPositionInSequenceEditor
    &.`, ` {
    pointer-events: auto;
    cursor: var(`, `);
  }

  &:hover
    + `, `,
    // notice , "or" in CSS
    &.`, `
    + `, ` {
    `, `
  }
`])), so.CSS, so.CSS_WHEN_SOMETHING_DRAGGING, so.BEING_DRAGGED_CLASS, Ml, wR, so.BEING_DRAGGED_CLASS, wR, Vl(sre, ore)), pre = ({ layoutP: r, markerId: s }) => {
        let a = nn(r.sheet.address), d = nn(pe().atomP.historic.projects.stateByProjectId[a.projectId].stateBySheetId[a.sheetId].sequenceEditor.markerSet.byId[s]);
        if (!d) return null;
        let m = nn(r.clippedSpace.width), y = nn(r.clippedSpace.fromUnitSpace)(d.position), x = y <= 0 || y > m, w = x ? -1e4 : y, T = x ? 0 : 1;
        return oo.default.createElement(lre, { style: { transform: "translateX(".concat(w, "px) scale(").concat(T, ")") } }, oo.default.createElement(mre, { marker: d, layoutP: r }));
      }, fre = pre, mre = ({ layoutP: r, marker: s }) => {
        let a = nn(r.sheet.address), [d, m] = kn(null), [y] = qwe(m, { sheetAddress: a, markerId: s.id }), [x] = Hwe(m, { layoutP: r, marker: s }), { node: w, toggle: T, close: P } = ko({ debugName: "MarkerPopover" }, () => oo.default.createElement(Mo, null, oo.default.createElement(ire, { marker: s, layoutP: r, onRequestClose: P })));
        return oo.default.createElement(oo.default.Fragment, null, y, w, oo.default.createElement(hre, L({ title: s.label ? "Marker: ".concat(s.label) : "Marker", ref: d, onClick: (M) => {
          T(M, d.current);
        } }, so.reactProps({ isDragging: x, position: s.position }))), oo.default.createElement(cre, null));
      };
    }), ER, gre, yre, Wwe = R(() => {
      zt(), st(), ER = Y(xe()), $we(), gre = ({ layoutP: r }) => {
        let s = nn(r.sheet.address), a = pe().atomP.historic.projects.stateByProjectId[s.projectId].stateBySheetId[s.sheetId].sequenceEditor.markerSet, d = nn(a.allIds);
        return ER.default.createElement(ER.default.Fragment, null, d && Object.keys(d).map((m) => ER.default.createElement(fre, { key: m, layoutP: r, markerId: m })));
      }, yre = gre;
    }), _s, vre, bre, xre, TR, _re, CR, Sre, wre, Kwe = R(() => {
      _s = Y(xe()), it(), zt(), st(), sd(), G0(), H1(), bre = ee.div(vre || (vre = $([`
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding: 8px;
  min-width: 200px;
`]))), TR = ee.div(xre || (xre = $([`
  display: flex;
  gap: 8px;
  height: 28px;
  align-items: center;
`]))), CR = ee.div(_re || (_re = $([`
  `, `;
  white-space: nowrap;
  min-width: 60px;
`])), Ol), Sre = ({ layoutP: r, event: s }) => {
        var a;
        let d = nn(r.sheet), m = (0, _s.useMemo)(() => {
          let P;
          return { temporarilySetValue(M) {
            P && (P.discard(), P = void 0), P = pe().tempTransaction(({ stateEditors: F }) => {
              F.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateEvent({ sheetAddress: d.address, eventId: s.id, name: M, value: s.value });
            });
          }, discardTemporaryValue() {
            P && (P.discard(), P = void 0);
          }, permanentlySetValue(M) {
            P && (P.discard(), P = void 0), pe().transaction(({ stateEditors: F }) => {
              F.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateEvent({ sheetAddress: d.address, eventId: s.id, name: M, value: s.value });
            });
          } };
        }, [r, d, s]), y = (0, _s.useMemo)(() => {
          let P;
          return { temporarilySetValue(M) {
            P && (P.discard(), P = void 0), P = pe().tempTransaction(({ stateEditors: F }) => {
              F.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents({ sheetAddress: d.address, events: [V(L({}, s), { position: M })] });
            });
          }, discardTemporaryValue() {
            P && (P.discard(), P = void 0);
          }, permanentlySetValue(M) {
            P && (P.discard(), P = void 0), pe().transaction(({ stateEditors: F }) => {
              F.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents({ sheetAddress: d.address, events: [V(L({}, s), { position: M })] });
            });
          } };
        }, [r, d, s]), x = (0, _s.useMemo)(() => {
          let P;
          return { temporarilySetValue(M) {
            P && (P.discard(), P = void 0);
            let F = M;
            try {
              M.trim() !== "" && (F = JSON.parse(M));
            } catch {
            }
            P = pe().tempTransaction(({ stateEditors: O }) => {
              O.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateEvent({ sheetAddress: d.address, eventId: s.id, name: s.name, value: F });
            });
          }, discardTemporaryValue() {
            P && (P.discard(), P = void 0);
          }, permanentlySetValue(M) {
            P && (P.discard(), P = void 0);
            let F = M;
            try {
              M.trim() !== "" && (F = JSON.parse(M));
            } catch {
            }
            pe().transaction(({ stateEditors: O }) => {
              O.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.updateEvent({ sheetAddress: d.address, eventId: s.id, name: s.name, value: F });
            });
          } };
        }, [r, d, s]), w = (0, _s.useRef)(null);
        (0, _s.useLayoutEffect)(() => {
          w.current.focus();
        }, []);
        let T = (0, _s.useMemo)(() => s.value === void 0 || s.value === null ? "" : typeof s.value == "string" ? s.value : JSON.stringify(s.value), [s.value]);
        return _s.default.createElement(bre, null, _s.default.createElement(TR, null, _s.default.createElement(CR, null, "Name"), _s.default.createElement(Hh, V(L({ value: (a = s.name) != null ? a : "" }, m), { isValid: () => !0, inputRef: w }))), _s.default.createElement(TR, null, _s.default.createElement(CR, null, "Time"), _s.default.createElement(V0, V(L({ value: s.position }, y), { isValid: () => !0, nudge: ({ deltaX: P }) => P * 0.25 }))), _s.default.createElement(TR, null, _s.default.createElement(CR, null, "Value"), _s.default.createElement(Hh, V(L({ value: T }, x), { isValid: () => !0 }))));
      }, wre = Sre;
    });
    function Ywe(r, s) {
      return Bs(r, { menuItems() {
        return [{ label: "Remove event", callback: () => {
          pe().transaction(({ stateEditors: a }) => {
            a.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeEvent({ sheetAddress: s.sheetAddress, eventId: s.eventId });
          });
        } }];
      } });
    }
    function Xwe(r, s) {
      let a = (0, ao.useRef)(s);
      a.current = s;
      let d = (0, ao.useMemo)(() => ({ debugName: "EventDot/useDragEvent (".concat(s.event.id, ")"), onDragStart(y) {
        let x = a.current.event, w = (0, Xj.val)(s.layoutP.scaledSpace.toUnitSpace), T;
        return kM(), { onDrag(P, M, F) {
          var O;
          let N = x, B = Math.max((O = js.checkIfMouseEventSnapToPos(F, { ignore: r })) != null ? O : N.position + w(P), 0);
          T?.discard(), T = pe().tempTransaction(({ stateEditors: U }) => {
            U.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents({ sheetAddress: (0, Xj.val)(s.layoutP.sheet.address), events: [V(L({}, N), { position: B })] });
          });
        }, onDragEnd(P) {
          P ? T?.commit() : T?.discard(), J0();
        } };
      } }), []), [m] = Fr(r, d);
      return $u(m, s.event.position), Ao(m, "draggingPositionInSequenceEditor draggingEvent", "ew-resize"), [m];
    }
    var Xj, ao, Qj, Zj, Ere, Tre, Cre, Pre, Are, PR, kre, Mre, Rre, Ire, Nre, Ore, Qwe = R(() => {
      Xj = ut(), zt(), st(), Os(), Ls(), Hn(), ao = Y(xe()), it(), Ui(), li(), ec(), zl(), CM(), D3(), ev(), Dl(), Fl(), Kwe(), Qj = 12, Zj = 12, Ere = Qj * 2, Tre = Zj * 2, Pre = ee.div(Cre || (Cre = $([`
  position: absolute;
  // below the sequence ruler "top bar"
  top: 15px;
  z-index: `, `;
`])), () => Hl.marker), PR = ee.div(Are || (Are = $([`
  position: absolute;
  `, `
  pointer-events: none;
`])), Vl(Qj, Zj)), kre = ao.default.memo(() => ao.default.createElement(PR, { children: ao.default.createElement("svg", { width: "100%", height: "100%", viewBox: "0 0 12 12", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, ao.default.createElement("circle", { cx: "6", cy: "6", r: "5", fill: "#2b86ee", stroke: "#FFFFFF", strokeWidth: "1" })) })), Rre = ee.div(Mre || (Mre = $([`
  z-index: 1;
  cursor: ew-resize;

  `, `

  // :not dragging event to ensure that events don't snap to other events
  // this works because only one event track (so this technique is not used by keyframes...)
  #pointer-root.draggingPositionInSequenceEditor:not(.draggingEvent) & {
    `, `
  }

  // "All instances of this component <Event/> inside #pointer-root when it has the .draggingPositionInSequenceEditor class"
  // ref: https://styled-components.com/docs/basics#pseudoelements-pseudoselectors-and-nesting
  #pointer-root.draggingPositionInSequenceEditor:not(.draggingEvent) &,
  #pointer-root.draggingPositionInSequenceEditor
    &.`, ` {
    pointer-events: auto;
    cursor: var(`, `);
  }

  &:hover
    + `, `,
    // notice , "or" in CSS
    &.`, `
    + `, ` {
    `, `
  }
`])), so.CSS, so.CSS_WHEN_SOMETHING_DRAGGING, so.BEING_DRAGGED_CLASS, Ml, PR, so.BEING_DRAGGED_CLASS, PR, Vl(Ere, Tre)), Ire = ({ layoutP: r, eventId: s }) => {
        let a = nn(r.sheet.address), d = nn(pe().atomP.historic.projects.stateByProjectId[a.projectId].stateBySheetId[a.sheetId].sequenceEditor.eventSet.byId[s]);
        if (!d) return null;
        let m = nn(r.clippedSpace.width), y = nn(r.clippedSpace.fromUnitSpace)(d.position), x = y <= 0 || y > m, w = x ? -1e4 : y, T = x ? 0 : 1;
        return ao.default.createElement(Pre, { style: { transform: "translateX(".concat(w, "px) scale(").concat(T, ")") } }, ao.default.createElement(Ore, { event: d, layoutP: r }));
      }, Nre = Ire, Ore = ({ layoutP: r, event: s }) => {
        let a = nn(r.sheet.address), [d, m] = kn(null), [y] = Ywe(m, { sheetAddress: a, eventId: s.id }), [x] = Xwe(m, { layoutP: r, event: s }), { node: w, toggle: T, close: P } = ko({ debugName: "EventPopover" }, () => ao.default.createElement(Mo, null, ao.default.createElement(wre, { event: s, layoutP: r, onRequestClose: P })));
        return ao.default.createElement(ao.default.Fragment, null, y, w, ao.default.createElement(Rre, L({ title: s.name ? "Event: ".concat(s.name) : "Event", ref: d, onClick: (M) => {
          T(M, d.current);
        } }, so.reactProps({ isDragging: x, position: s.position }))), ao.default.createElement(kre, null));
      };
    }), AR, Dre, Fre, Zwe = R(() => {
      zt(), st(), AR = Y(xe()), Qwe(), Dre = ({ layoutP: r }) => {
        let s = nn(r.sheet.address), a = pe().atomP.historic.projects.stateByProjectId[s.projectId].stateBySheetId[s.sheetId].sequenceEditor.eventSet, d = nn(a.allIds);
        return AR.default.createElement(AR.default.Fragment, null, d && Object.keys(d).map((m) => AR.default.createElement(Nre, { key: m, layoutP: r, eventId: m })));
      }, Fre = Dre;
    }), Bre, ql, Lre, jre, Ure, zre, Vre, Gre, Jwe = R(() => {
      ec(), zt(), Bre = ut(), ql = Y(xe()), it(), Mwe(), Rwe(), Iwe(), zwe(), km(), Vwe(), Wwe(), Zwe(), jre = ee.div(Lre || (Lre = $([`
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  z-index: `, `;
  overflow: visible;
  pointer-events: none;
`])), () => Hl.rightOverlay), zre = ee.div(Ure || (Ure = $([`
  background: #222;
  position: absolute;
  top: 30px;
  width: 100%;
  height: 30px;
`]))), Vre = ({ layoutP: r }) => At(() => {
        let s = (0, Bre.val)(r.rightDims.width);
        return ql.default.createElement(jre, { style: { width: s + "px" } }, ql.default.createElement(Yne, { layoutP: r }), ql.default.createElement(Sne, { layoutP: r }), ql.default.createElement(cne, { layoutP: r }), ql.default.createElement(Fte, { layoutP: r }), ql.default.createElement(zre, null, ql.default.createElement(yre, { layoutP: r }), ql.default.createElement(Fre, { layoutP: r })), ql.default.createElement(nne, { layoutP: r }), ql.default.createElement(Jne, { layoutP: r }));
      }, [r]), Gre = Vre;
    }), qre, kR, Hre, $re, Wre, Kre, eEe = R(() => {
      qre = ut(), zt(), st(), kR = Y(xe()), it(), U1(), Ui(), $re = ee.button(Hre || (Hre = $([`
  outline: none;
  background-color: #1c1d21;
  border: 1px solid #191919;
  border-radius: 2px;
  display: flex;
  bottom: 25px;
  right: 15px;
  z-index: 1;
  position: absolute;

  padding: 4px 8px;
  display: flex;
  color: #656d77;
  line-height: 20px;
  font-size: 10px;

  &:hover {
    color: white;
  }

  & > svg {
    transition: transform 0.3s;
    transform: rotateZ(0deg);
  }

  &:hover > svg {
    transform: rotateZ(-20deg);
  }

  &.open > svg {
    transform: rotateZ(-180deg);
  }

  &.open:hover > svg {
    transform: rotateZ(-160deg);
  }
`]))), Wre = ({ layoutP: r }) => {
        let s = nn(r.graphEditorDims.isOpen), a = (0, kR.useCallback)(() => {
          let d = (0, qre.val)(r.graphEditorDims.isOpen);
          pe().transaction(({ stateEditors: m }) => {
            m.studio.historic.panels.sequenceEditor.graphEditor.setIsOpen({ isOpen: !d });
          });
        }, [r]);
        return kR.default.createElement($re, L({ onClick: a, title: "Toggle graph editor", className: s ? "open" : "" }, Wu("hide")), kR.default.createElement(f_e, null));
      }, Kre = Wre;
    }), Oo, _S, Yre, Xre, Qre, Zre, Jj, Jre, tEe = R(() => {
      Oo = Y(xe()), it(), zt(), _S = ut(), bj(), j3(), Xre = ee.div(Yre || (Yre = $([`
  position: absolute;
  right: 0;
  bottom: 0;
  padding-bottom: 10px;
  pointer-events: none;
  z-index: 1;
  display: `, `;
`])), (r) => r.isVisible ? "block" : "none"), Zre = ee.svg(Qre || (Qre = $([`
  position: absolute;
  top: 0;
  left: 0;
  margin: 0;
  pointer-events: none;
`]))), Jj = (0, Oo.forwardRef)(({ layoutP: r, sheetAddress: s, renderMode: a = "both", color: d = "#4a9eff", strokeWidth: m = 2, circleRadius: y = 3, height: x }, w) => {
        let T = (H) => H ? "svgViewer_".concat(H.projectId, "_").concat(H.sheetId) : "svgViewer_default", P = (H) => {
          try {
            let W = T(H), Q = localStorage.getItem(W);
            if (Q) {
              let ne = JSON.parse(Q);
              if (Array.isArray(ne)) return ne.length > 0 && typeof ne[0] == "object" && "time" in ne[0] ? [{ id: "legacy", data: ne, color: "#4a9eff", name: "Legacy Data" }] : ne.filter((ce) => ce && typeof ce == "object" && Array.isArray(ce.data) && typeof ce.color == "string");
            }
          } catch (W) {
            console.warn(" SVGViewer: Failed to load data from localStorage:", W);
          }
          return [];
        }, M = (H, W) => {
          try {
            let Q = T(W);
            localStorage.setItem(Q, JSON.stringify(H));
          } catch (Q) {
            console.warn(" SVGViewer: Failed to save data to localStorage:", Q);
          }
        }, [F, O] = (0, Oo.useState)(() => P(s)), [N, B] = (0, Oo.useState)(!0);
        (0, Oo.useEffect)(() => {
          let H = P(s);
          O(H);
        }, [s?.projectId, s?.sheetId]);
        let U = (H) => {
          try {
            let W = JSON.parse(H);
            if (Array.isArray(W)) return W.filter((Q) => typeof Q == "object" && typeof Q.time == "number" && typeof Q.value == "number");
          } catch {
            let Q = H.trim().split(`
`), ne = [];
            for (let ce of Q) {
              if (!ce.trim() || ce.toLowerCase().includes("time") || ce.toLowerCase().includes("value")) continue;
              let ue = ce.split(",").map((se) => se.trim());
              if (ue.length >= 2) {
                let se = parseFloat(ue[0]), Oe = parseFloat(ue[1]);
                !isNaN(se) && !isNaN(Oe) && ne.push({ time: se, value: Oe });
              } else {
                let se = ce.split(/\s+/).filter((Oe) => Oe.length > 0);
                if (se.length >= 2) {
                  let Oe = parseFloat(se[0]), he = parseFloat(se[1]);
                  !isNaN(Oe) && !isNaN(he) && ne.push({ time: Oe, value: he });
                }
              }
            }
            return ne;
          }
          return [];
        };
        return (0, Oo.useImperativeHandle)(w, () => ({ clearData: () => {
          let H = [];
          O(H), M(H, s);
        }, addData: (H, W) => {
          console.log(" SVGViewer: Adding dataset with", H.length, "points", W ? "and color ".concat(W) : "");
          let Q = { id: "dataset-".concat(Date.now(), "-").concat(Math.random().toString(36).substring(2, 11)), data: H, color: W || d, name: "Dataset ".concat(F.length + 1) }, ne = [...F, Q];
          O(ne), M(ne, s);
        }, loadData: (H, W) => {
          console.log(" SVGViewer: loadData called, redirecting to addData");
          let Q = { id: "dataset-".concat(Date.now(), "-").concat(Math.random().toString(36).substring(2, 11)), data: H, color: W || d, name: "Dataset ".concat(F.length + 1) }, ne = [...F, Q];
          O(ne), M(ne, s);
        }, loadFromClipboard: () => dt(void 0, null, function* () {
          try {
            let H = yield navigator.clipboard.readText(), W = U(H);
            if (W.length > 0) {
              console.log(" SVGViewer: Successfully parsed", W.length, "data points from clipboard");
              let Q = { id: "clipboard-".concat(Date.now(), "-").concat(Math.random().toString(36).substring(2, 11)), data: W, color: d, name: "Clipboard Data ".concat(F.length + 1) }, ne = [...F, Q];
              O(ne), M(ne, s);
            } else console.warn(" SVGViewer: No valid data found in clipboard");
          } catch (H) {
            throw console.error(" SVGViewer: Failed to read from clipboard:", H), H;
          }
        }), show: () => {
          console.log(" SVGViewer: Showing component"), B(!0);
        }, hide: () => {
          console.log(" SVGViewer: Hiding component"), B(!1);
        } }), [s, F, d]), At(() => {
          let H = (0, _S.val)(r.rightDims.width), W = x || (0, _S.val)(r.dopeSheetDims.height) - 30, Q = (0, _S.val)(r.scaledSpace.fromUnitSpace)(1), ne = (0, _S.val)(r.scaledSpace.leftPadding), ce = 0, ue = 1;
          return Oo.default.createElement(Xre, { isVisible: N, style: { width: H + "px", height: W + "px", "--unitSpaceToScaledSpaceMultiplier": Q } }, Oo.default.createElement(MM, { layoutP: r, height: W }, Oo.default.createElement(Zre, { width: av, height: W, viewBox: "0 0 ".concat(av, " ").concat(W) }, Oo.default.createElement("g", { style: { transform: "translate(".concat(ne, "px, 0px)") } }, F.map((se) => {
            let Oe = se.data.map((ie, ye) => {
              let Ee = ie.time * Q, ve = (ie.value - ce) / ue, Xe = W - ve * (W - 40) - 20;
              return { x: Ee, y: Xe, originalValue: ie.value, time: ie.time, index: ye };
            }), he = Oe.length > 0 ? "M ".concat(Oe[0].x, " ").concat(Oe[0].y, " ") + Oe.slice(1).map((ie) => "L ".concat(ie.x, " ").concat(ie.y)).join(" ") : "";
            return Oo.default.createElement("g", { key: se.id }, (a === "lines" || a === "both") && Oe.length > 1 && Oo.default.createElement("path", { d: he, fill: "none", stroke: se.color, strokeWidth: m, opacity: 0.8 }), (a === "circles" || a === "both") && Oe.map((ie) => Oo.default.createElement("circle", { key: "".concat(se.id, "-point-").concat(ie.index, "-").concat(ie.time, "-").concat(ie.originalValue), cx: ie.x, cy: ie.y, r: y, fill: se.color, opacity: 0.9 }, Oo.default.createElement("title", null, "".concat(se.name || "Dataset", " - Time: ").concat(ie.time.toFixed(2), ", Value: ").concat(ie.originalValue.toFixed(3))))));
          })))));
        }, [r, F, a, m, y, x, N]);
      }), Jj.displayName = "SVGViewer", Jre = Jj;
    });
    function nEe(r) {
      return dt(this, arguments, function* (s, a = {}) {
        let { sampleRate: d = 100, normalize: m = !0 } = a;
        try {
          let y = new (window.AudioContext || window.webkitAudioContext)(), x = yield s.arrayBuffer(), w = yield y.decodeAudioData(x), T = w.getChannelData(0), P = w.duration, M = w.sampleRate, F = Math.floor(M / d), O = Math.floor(T.length / F), N = [], B = 0;
          for (let U = 0; U < O; U++) {
            let H = U * F, W = Math.min(H + F, T.length), Q = 0;
            for (let ue = H; ue < W; ue++) Q += T[ue] * T[ue];
            let ne = Math.sqrt(Q / (W - H)), ce = U * F / M;
            N.push({ time: ce, amplitude: ne }), ne > B && (B = ne);
          }
          if (m && B > 0) for (let U of N) U.amplitude = U.amplitude / B;
          return yield y.close(), console.log(" Audio analysis complete: ".concat(N.length, " data points over ").concat(P.toFixed(2), "s")), N;
        } catch (y) {
          throw console.error(" Audio analysis failed:", y), new Error("Failed to analyze audio file: ".concat(y instanceof Error ? y.message : "Unknown error"));
        }
      });
    }
    function eie(r) {
      return ["audio/mpeg", "audio/wav", "audio/ogg", "audio/mp4", "audio/aac"].includes(r.type) || r.name.toLowerCase().match(/\.(mp3|wav|ogg|m4a|aac)$/) !== null;
    }
    function tie(r) {
      if (r === 0) return "0 Bytes";
      let s = 1024, a = ["Bytes", "KB", "MB", "GB"], d = Math.floor(Math.log(r) / Math.log(s));
      return parseFloat((r / Math.pow(s, d)).toFixed(2)) + " " + a[d];
    }
    var nie = R(() => {
    }), _n, rie, iie, sie, oie, aie, lie, uie, eU, cie, MR, die, hie, pie, fie, mie, gie, yie, vie, bie, xie, _ie, Sie, wie, tU, Eie, Tie, Cie, Pie, Aie, kie, Mie, nU, Rie, Iie, Nie, Oie, Die, Fie, Bie, Lie, jie, Uie, zie, Vie, Gie, qie, Hie, rEe = R(() => {
      _n = Y(xe()), it(), G0(), sd(), nie(), iie = ee.div(rie || (rie = $([`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
`]))), oie = ee.div(sie || (sie = $([`
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  min-width: 400px;
  max-width: 500px;
  background: #2a2a2a;
  border: 1px solid #3a3a3a;
  border-radius: 6px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
`]))), lie = ee.h3(aie || (aie = $([`
  margin: 0;
  font-size: 14px;
  font-weight: 500;
  color: #ccc;
`]))), eU = ee.div(uie || (uie = $([`
  display: flex;
  flex-direction: column;
  gap: 8px;
`]))), MR = ee.div(cie || (cie = $([`
  `, `;
  font-size: 12px;
  color: #999;
`])), Ol), hie = ee.div(die || (die = $([`
  font-size: 11px;
  color: #666;
  font-style: italic;
  margin-top: 4px;
`]))), fie = ee.div(pie || (pie = $([`
  display: flex;
  gap: 8px;
  align-items: center;
`]))), gie = ee.input(mie || (mie = $([`
  width: 40px;
  height: 28px;
  border: 1px solid #3a3a3a;
  border-radius: 4px;
  background: transparent;
  cursor: pointer;

  &::-webkit-color-swatch-wrapper {
    padding: 2px;
  }

  &::-webkit-color-swatch {
    border: none;
    border-radius: 2px;
  }
`]))), vie = ee(Hh)(yie || (yie = $([`
  flex: 1;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
`]))), xie = ee.textarea(bie || (bie = $([`
  width: 100%;
  min-height: 120px;
  padding: 8px;
  border: 1px solid #3a3a3a;
  border-radius: 4px;
  background: #2a2a2a;
  color: #ccc;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 12px;
  resize: vertical;

  &::placeholder {
    color: #666;
  }

  &:focus {
    outline: none;
    border-color: #4a9eff;
  }
`]))), Sie = ee.div(_ie || (_ie = $([`
  display: flex;
  gap: 8px;
  justify-content: flex-end;
`]))), tU = ee.button(wie || (wie = $([`
  padding: 8px 16px;
  border: 1px solid
    `, `;
  border-radius: 4px;
  background: `, `;
  color: `, `;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: `, `;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`])), (r) => r.variant === "primary" ? "#4a9eff" : "#3a3a3a", (r) => r.variant === "primary" ? "#4a9eff" : "transparent", (r) => r.variant === "primary" ? "#fff" : "#ccc", (r) => r.variant === "primary" ? "#3a8eef" : "#3a3a3a"), Tie = ee.div(Eie || (Eie = $([`
  border-top: 1px solid #3a3a3a;
  padding-top: 16px;
  margin-top: 8px;
`]))), Pie = ee.div(Cie || (Cie = $([`
  display: flex;
  flex-direction: column;
  gap: 8px;
`]))), kie = ee.div(Aie || (Aie = $([`
  border: 2px dashed `, `;
  border-radius: 4px;
  padding: 16px;
  text-align: center;
  background: `, `;
  cursor: pointer;
  transition: all 0.2s;

  `, `

  &:hover {
    border-color: #4a9eff;
    background: rgba(74, 158, 255, 0.05);
  }
`])), (r) => r.isDragOver ? "#4a9eff" : "#3a3a3a", (r) => r.isDragOver ? "rgba(74, 158, 255, 0.1)" : "transparent", (r) => r.hasFile && `
    border-color: #4a9eff;
    background: rgba(74, 158, 255, 0.05);
  `), nU = ee.div(Mie || (Mie = $([`
  color: #999;
  font-size: 12px;
  margin-bottom: 4px;
`]))), Iie = ee.div(Rie || (Rie = $([`
  color: #ccc;
  font-size: 11px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
`]))), Oie = ee.div(Nie || (Nie = $([`
  display: flex;
  gap: 16px;
  align-items: center;
  margin-top: 8px;
`]))), Fie = ee.div(Die || (Die = $([`
  display: flex;
  flex-direction: column;
  gap: 4px;
`]))), Lie = ee.label(Bie || (Bie = $([`
  `, `;
  font-size: 11px;
  color: #999;
`])), Ol), Uie = ee.input(jie || (jie = $([`
  width: 80px;
  padding: 4px 8px;
  border: 1px solid #3a3a3a;
  border-radius: 4px;
  background: #2a2a2a;
  color: #ccc;
  font-size: 12px;

  &:focus {
    outline: none;
    border-color: #4a9eff;
  }
`]))), Vie = ee.div(zie || (zie = $([`
  font-size: 11px;
  margin-top: 8px;
  color: `, `;
`])), (r) => {
        switch (r.status) {
          case "analyzing":
            return "#4a9eff";
          case "complete":
            return "#4a9eff";
          case "error":
            return "#ff6b6b";
          default:
            return "#666";
        }
      }), Gie = `[
  {"time": 0, "value": 0},
  {"time": 1, "value": 0.5},
  {"time": 2, "value": 0.2},
  {"time": 3, "value": 1}
]

Or CSV format:
time,value
0,0
1,0.5
2,0.2
3,1

Or space-separated:
0 0
1 0.5
2 0.2
3 1`, qie = ({ onLoad: r, onCancel: s }) => {
        let [a, d] = (0, _n.useState)("#4a9eff"), [m, y] = (0, _n.useState)("#4a9eff"), [x, w] = (0, _n.useState)(""), [T, P] = (0, _n.useState)(null), [M, F] = (0, _n.useState)(!1), [O, N] = (0, _n.useState)(100), [B, U] = (0, _n.useState)("idle"), [H, W] = (0, _n.useState)(""), Q = (0, _n.useRef)(null), ne = (0, _n.useRef)(null);
        (0, _n.useEffect)(() => {
          Q.current && Q.current.focus();
        }, []);
        let ce = (le) => {
          try {
            let Ie = JSON.parse(le);
            if (Array.isArray(Ie)) return Ie.filter(($e) => typeof $e == "object" && typeof $e.time == "number" && typeof $e.value == "number");
          } catch {
            let $e = le.trim().split(`
`), de = [];
            for (let Ae of $e) {
              if (!Ae.trim() || Ae.toLowerCase().includes("time") || Ae.toLowerCase().includes("value")) continue;
              let Je = Ae.split(",").map((rt) => rt.trim());
              if (Je.length >= 2) {
                let rt = parseFloat(Je[0]), Ve = parseFloat(Je[1]);
                !isNaN(rt) && !isNaN(Ve) && de.push({ time: rt, value: Ve });
              } else {
                let rt = Ae.split(/\s+/).filter((Ve) => Ve.length > 0);
                if (rt.length >= 2) {
                  let Ve = parseFloat(rt[0]), oe = parseFloat(rt[1]);
                  !isNaN(Ve) && !isNaN(oe) && de.push({ time: Ve, value: oe });
                }
              }
            }
            return de;
          }
          return [];
        }, ue = ce(x).length, se = ue > 0 || T !== null, Oe = (le) => dt(void 0, null, function* () {
          U("analyzing"), W("");
          try {
            let Ie = (yield nEe(le, { sampleRate: O, normalize: !0 })).map(($e) => ({ time: $e.time, value: $e.amplitude }));
            w(JSON.stringify(Ie, null, 2)), U("complete");
          } catch (Ie) {
            console.error("Audio analysis failed:", Ie), W(Ie instanceof Error ? Ie.message : "Analysis failed"), U("error");
          }
        }), he = (le) => {
          if (!eie(le)) {
            W("Please select a supported audio file (MP3, WAV, OGG, M4A, AAC)"), U("error");
            return;
          }
          P(le), U("idle"), W(""), Oe(le);
        }, ie = (le) => {
          le.preventDefault(), F(!0);
        }, ye = (le) => {
          le.preventDefault(), F(!1);
        }, Ee = (le) => {
          le.preventDefault(), F(!1);
          let Ie = Array.from(le.dataTransfer.files);
          Ie.length > 0 && he(Ie[0]);
        }, ve = (le) => {
          let Ie = le.target.files;
          Ie && Ie.length > 0 && he(Ie[0]);
        }, Xe = () => {
          var le;
          (le = ne.current) == null || le.click();
        }, Se = () => {
          let le = ce(x);
          le.length > 0 ? r(le, a) : console.warn("No valid data found in input");
        };
        (0, _n.useEffect)(() => {
          let le = (Ie) => {
            Ie.key === "Escape" ? Ce() : Ie.key === "Enter" && (Ie.ctrlKey || Ie.metaKey) && se && Se();
          };
          return document.addEventListener("keydown", le), () => document.removeEventListener("keydown", le);
        }, [se]);
        let nt = (le) => {
          d(le), y(le);
        }, De = (le) => {
          y(le), /^#[0-9A-F]{6}$/i.test(le) && d(le);
        }, Ce = () => {
          w(""), d("#4a9eff"), y("#4a9eff"), P(null), U("idle"), W(""), s();
        };
        return _n.default.createElement(iie, { onClick: Ce }, _n.default.createElement(oie, { onClick: (le) => le.stopPropagation() }, _n.default.createElement(lie, null, "Load SVG Data"), _n.default.createElement(eU, null, _n.default.createElement(MR, null, "Color"), _n.default.createElement(fie, null, _n.default.createElement(gie, { type: "color", value: a, onChange: (le) => nt(le.target.value) }), _n.default.createElement(vie, { value: m, temporarilySetValue: De, discardTemporaryValue: () => y(a), permanentlySetValue: De, isValid: (le) => /^#[0-9A-F]{6}$/i.test(le) }))), _n.default.createElement(eU, null, _n.default.createElement(MR, null, "SVG Data"), _n.default.createElement(xie, { ref: Q, value: x, onChange: (le) => w(le.target.value), placeholder: Gie }), x && _n.default.createElement(hie, null, ue > 0 ? "".concat(ue, " data points will be loaded") : "No valid data points found")), _n.default.createElement(Tie, null, _n.default.createElement(MR, null, "Or Analyze Audio File"), _n.default.createElement(Pie, null, _n.default.createElement(kie, { isDragOver: M, hasFile: T !== null, onClick: Xe, onDragOver: ie, onDragLeave: ye, onDrop: Ee }, _n.default.createElement(nU, null, T ? "Click to select a different audio file" : "Click to select or drag & drop an audio file"), _n.default.createElement(nU, { style: { fontSize: "11px", color: "#666" } }, "Supported formats: MP3, WAV, OGG, M4A, AAC"), T && _n.default.createElement(Iie, null, " ", T.name, " (", tie(T.size), ")")), _n.default.createElement("input", { ref: ne, type: "file", accept: "audio/*,.mp3,.wav,.ogg,.m4a,.aac", onChange: ve, style: { display: "none" } }), _n.default.createElement(Oie, null, _n.default.createElement(Fie, null, _n.default.createElement(Lie, null, "Sample Rate (Hz)"), _n.default.createElement(Uie, { type: "number", min: "10", max: "1000", value: O, onChange: (le) => N(parseInt(le.target.value) || 100) }))), B !== "idle" && _n.default.createElement(Vie, { status: B }, B === "analyzing" && " Analyzing audio...", B === "complete" && " Audio analysis complete! Data loaded above.", B === "error" && " ".concat(H)))), _n.default.createElement(Sie, null, _n.default.createElement(tU, { onClick: Ce }, "Cancel"), _n.default.createElement(tU, { variant: "primary", onClick: Se, disabled: !se }, "Create"))));
      }, Hie = qie;
    }), Fn, $ie, Wie, Kie, Yie, Xie, Qie, Zie, rU, Jie, iU, ese, RR, tse, nse, rse, sU, ise, sse, ose, ase, lse, oU, use, cse, dse, hse, pse, fse, mse, gse, yse, vse, bse, aU, xse, _se, iEe = R(() => {
      Fn = Y(xe()), it(), G0(), sd(), nie(), Wie = ee.div($ie || ($ie = $([`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 10000;
`]))), Yie = ee.div(Kie || (Kie = $([`
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
  min-width: 400px;
  max-width: 500px;
  background: #2a2a2a;
  border: 1px solid #3a3a3a;
  border-radius: 6px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
`]))), Qie = ee.h3(Xie || (Xie = $([`
  margin: 0;
  font-size: 14px;
  font-weight: 500;
  color: #ccc;
`]))), rU = ee.div(Zie || (Zie = $([`
  display: flex;
  flex-direction: column;
  gap: 8px;
`]))), iU = ee.div(Jie || (Jie = $([`
  `, `;
  font-size: 12px;
  color: #999;
`])), Ol), RR = ee.div(ese || (ese = $([`
  font-size: 11px;
  color: #666;
  font-style: italic;
  margin-bottom: 8px;
`]))), nse = ee.div(tse || (tse = $([`
  display: flex;
  gap: 8px;
  justify-content: flex-end;
`]))), sU = ee.button(rse || (rse = $([`
  padding: 8px 16px;
  border: 1px solid
    `, `;
  border-radius: 4px;
  background: `, `;
  color: `, `;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;

  &:hover {
    background: `, `;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`])), (r) => r.variant === "primary" ? "#4a9eff" : "#3a3a3a", (r) => r.variant === "primary" ? "#4a9eff" : "transparent", (r) => r.variant === "primary" ? "#fff" : "#ccc", (r) => r.variant === "primary" ? "#3a8eef" : "#3a3a3a"), sse = ee.div(ise || (ise = $([`
  display: flex;
  flex-direction: column;
  gap: 8px;
`]))), ase = ee.div(ose || (ose = $([`
  border: 2px dashed `, `;
  border-radius: 4px;
  padding: 16px;
  text-align: center;
  background: `, `;
  cursor: pointer;
  transition: all 0.2s;

  `, `

  &:hover {
    border-color: #4a9eff;
    background: rgba(74, 158, 255, 0.05);
  }
`])), (r) => r.isDragOver ? "#4a9eff" : "#3a3a3a", (r) => r.isDragOver ? "rgba(74, 158, 255, 0.1)" : "transparent", (r) => r.hasFile && `
    border-color: #4a9eff;
    background: rgba(74, 158, 255, 0.05);
  `), oU = ee.div(lse || (lse = $([`
  color: #999;
  font-size: 12px;
  margin-bottom: 4px;
`]))), cse = ee.div(use || (use = $([`
  color: #ccc;
  font-size: 11px;
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
`]))), hse = ee(Hh)(dse || (dse = $([`
  font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
  font-size: 12px;

  &::placeholder {
    color: #666;
  }
`]))), fse = ee.div(pse || (pse = $([`
  color: #ff6b6b;
  font-size: 11px;
  margin-top: 4px;
`]))), gse = ee.div(mse || (mse = $([`
  color: #4a9eff;
  font-size: 11px;
  margin-top: 4px;
`]))), vse = ee.div(yse || (yse = $([`
  display: flex;
  border-bottom: 1px solid #3a3a3a;
  margin-bottom: 16px;
`]))), aU = ee.button(bse || (bse = $([`
  padding: 8px 16px;
  border: none;
  background: `, `;
  color: `, `;
  font-size: 12px;
  cursor: pointer;
  border-bottom: 2px solid
    `, `;
  transition: all 0.2s;

  &:hover {
    background: #3a3a3a;
    color: #ccc;
  }
`])), (r) => r.active ? "#3a3a3a" : "transparent", (r) => r.active ? "#ccc" : "#999", (r) => r.active ? "#4a9eff" : "transparent"), xse = ({ onAttach: r, onCancel: s }) => {
        let [a, d] = (0, Fn.useState)("file"), [m, y] = (0, Fn.useState)(null), [x, w] = (0, Fn.useState)(""), [T, P] = (0, Fn.useState)(!1), [M, F] = (0, Fn.useState)(!1), [O, N] = (0, Fn.useState)(""), [B, U] = (0, Fn.useState)(""), H = (0, Fn.useRef)(null);
        (0, Fn.useEffect)(() => {
          N(""), U("");
        }, [a]);
        let W = (Ee) => {
          if (!eie(Ee)) {
            N("Please select a supported audio file (MP3, WAV, OGG, M4A, AAC)");
            return;
          }
          y(Ee), N(""), U("");
        }, Q = (Ee) => {
          Ee.preventDefault(), P(!0);
        }, ne = (Ee) => {
          Ee.preventDefault(), P(!1);
        }, ce = (Ee) => {
          Ee.preventDefault(), P(!1);
          let ve = Array.from(Ee.dataTransfer.files);
          ve.length > 0 && W(ve[0]);
        }, ue = (Ee) => {
          let ve = Ee.target.files;
          ve && ve.length > 0 && W(ve[0]);
        }, se = () => {
          var Ee;
          (Ee = H.current) == null || Ee.click();
        }, Oe = (Ee) => {
          try {
            return new URL(Ee), !0;
          } catch {
            return !1;
          }
        }, he = () => a === "file" ? m !== null : x.trim() !== "" && Oe(x.trim()), ie = () => dt(void 0, null, function* () {
          if (he()) {
            F(!0), N(""), U("");
            try {
              let Ee = a === "file" ? m : x.trim();
              yield r(Ee), U("Audio attached successfully!"), setTimeout(() => {
                s();
              }, 1e3);
            } catch (Ee) {
              console.error("Failed to attach audio:", Ee), N(Ee instanceof Error ? Ee.message : "Failed to attach audio");
            } finally {
              F(!1);
            }
          }
        });
        (0, Fn.useEffect)(() => {
          let Ee = (ve) => {
            ve.key === "Escape" ? ye() : ve.key === "Enter" && (ve.ctrlKey || ve.metaKey) && he() && ie();
          };
          return document.addEventListener("keydown", Ee), () => document.removeEventListener("keydown", Ee);
        }, [a, m, x]);
        let ye = () => {
          y(null), w(""), N(""), U(""), s();
        };
        return Fn.default.createElement(Wie, { onClick: ye }, Fn.default.createElement(Yie, { onClick: (Ee) => Ee.stopPropagation() }, Fn.default.createElement(Qie, null, "Attach Audio to Sequence"), Fn.default.createElement(RR, null, "Attach an audio file to sync with your sequence playback. The audio will play automatically when the sequence plays."), Fn.default.createElement(vse, null, Fn.default.createElement(aU, { active: a === "file", onClick: () => d("file") }, "Upload File"), Fn.default.createElement(aU, { active: a === "url", onClick: () => d("url") }, "From URL")), a === "file" ? Fn.default.createElement(rU, null, Fn.default.createElement(iU, null, "Audio File"), Fn.default.createElement(sse, null, Fn.default.createElement(ase, { isDragOver: T, hasFile: m !== null, onClick: se, onDragOver: Q, onDragLeave: ne, onDrop: ce }, Fn.default.createElement(oU, null, m ? "Click to select a different audio file" : "Click to select or drag & drop an audio file"), Fn.default.createElement(oU, { style: { fontSize: "11px", color: "#666" } }, "Supported formats: MP3, WAV, OGG, M4A, AAC"), m && Fn.default.createElement(cse, null, " ", m.name, " (", tie(m.size), ")")), Fn.default.createElement("input", { ref: H, type: "file", accept: "audio/*,.mp3,.wav,.ogg,.m4a,.aac", onChange: ue, style: { display: "none" } }))) : Fn.default.createElement(rU, null, Fn.default.createElement(iU, null, "Audio URL"), Fn.default.createElement(hse, { value: x, temporarilySetValue: w, discardTemporaryValue: () => w(""), permanentlySetValue: w, isValid: (Ee) => Ee.trim() === "" || Oe(Ee.trim()) }), x.trim() === "" && Fn.default.createElement(RR, { style: { marginTop: "4px", fontSize: "11px", color: "#666" } }, "Example: https://example.com/audio.mp3"), Fn.default.createElement(RR, null, "Enter a URL to an audio file. Make sure the server supports CORS if loading from a different domain.")), O && Fn.default.createElement(fse, null, " ", O), B && Fn.default.createElement(gse, null, " ", B), Fn.default.createElement(nse, null, Fn.default.createElement(sU, { onClick: ye, disabled: M }, "Cancel"), Fn.default.createElement(sU, { variant: "primary", onClick: ie, disabled: !he() || M }, M ? "Attaching..." : "Attach Audio"))));
      }, _se = xse;
    });
    function sEe() {
      return Lr.default.createElement("svg", { fill: "#FFFFFF", width: "800px", height: "800px", viewBox: "0 0 1920 1920", xmlns: "http://www.w3.org/2000/svg", style: { width: "15px", height: "15px" } }, Lr.default.createElement("path", { d: "M1637.718 0c93.4 0 169.406 76.007 169.406 169.407v1581.13c0 93.512-76.007 169.407-169.406 169.407H451.87V0h1185.848zM1158.7 581l-79.861 79.861 242.422 242.423H667v112.94h654.262l-242.422 242.423 79.861 79.862 378.755-378.755L1158.7 581zM225.938 1920h112.938V.056H225.938z" }));
    }
    var Lr, Sse, wse, Ese, Tse, Cse, Pse, Ase, kse, Mse, Rse, Ise, Nse, Ose, Dse, Fse, Bse, lU, Lse, jse, Use, zse, oEe = R(() => {
      Lr = Y(xe()), it(), Sse = ut(), zt(), Ese = ee.div(wse || (wse = $([`
  position: absolute;
  bottom: 10px;
  left: 10px;
  z-index: 100;
  display: flex;
  align-items: center;
  gap: 8px;
  width: `, `px; /* Subtract left/right margins */
  box-sizing: border-box;
`])), (r) => r.width - 20), Cse = ee.input(Tse || (Tse = $([`
  background: `, `;
  color: #cccccc;
  border: 1px solid `, `;
  padding: 8px 12px;
  border-radius: 4px;
  font-size: 12px;
  font-family: inherit;
  flex: 1; /* Expand to fill available space */
  min-width: 80px; /* Minimum width to ensure usability */
  transition: all 0.15s ease-out;

  &:focus {
    outline: none;
    border-color: #0078d4;
    background: #1e1e1e;
  }

  &::placeholder {
    color: #6a6a6a;
  }
`])), (r) => r.hasValue ? "#1e1e1e" : "#2d2d30", (r) => r.hasValue ? "#0078d4" : "#3e3e42"), Ase = ee.button(Pse || (Pse = $([`
  background: #2d2d30;
  color: white;
  border: 1px solid #3e3e42;
  padding: 8px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-family: inherit;
  display: flex;
  align-items: center;
  gap: 4px;

  &:hover {
    background: #3e3e42;
  }

  &:active {
    background: #1e1e1e;
  }
`]))), Mse = ee.button(kse || (kse = $([`
  background: `, `;
  color: white;
  border: 1px solid #3e3e42;
  padding: 8px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  font-family: inherit;
  display: flex;
  align-items: center;
  gap: 6px;

  &:hover {
    background: `, `;
  }

  &:active {
    background: #005a9e;
  }
`])), (r) => r.isOpen ? "#0078d4" : "#2d2d30", (r) => r.isOpen ? "#106ebe" : "#3e3e42"), Ise = ee.div(Rse || (Rse = $([`
  position: absolute;
  bottom: 100%;
  left: 0;
  background: #2d2d30;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  min-width: 200px;
  opacity: `, `;
  visibility: `, `;
  transform: `, `;
  transition: all 0.15s ease-out;
  z-index: 1000;
`])), (r) => r.isOpen ? 1 : 0, (r) => r.isOpen ? "visible" : "hidden", (r) => r.isOpen ? "translateY(0)" : "translateY(10px)"), Ose = ee.div(Nse || (Nse = $([`
  padding: 4px 0;

  &:not(:last-child) {
    border-bottom: 1px solid #3e3e42;
  }
`]))), Fse = ee.div(Dse || (Dse = $([`
  position: relative;

  &:hover > div:last-child {
    opacity: `, `;
    visibility: `, `;
  }
`])), (r) => r.hasSubmenu ? 1 : 0, (r) => r.hasSubmenu ? "visible" : "hidden"), lU = ee.button(Bse || (Bse = $([`
  width: 100%;
  background: transparent;
  color: #cccccc;
  border: none;
  padding: 8px 16px;
  text-align: left;
  cursor: pointer;
  font-size: 12px;
  font-family: inherit;
  display: flex;
  align-items: center;
  justify-content: space-between;

  &:hover {
    background: #3e3e42;
    color: white;
  }

  &:active {
    background: #0078d4;
  }
`]))), jse = ee.div(Lse || (Lse = $([`
  position: absolute;
  left: 100%;
  top: 0;
  background: #2d2d30;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  min-width: 150px;
  opacity: 0;
  visibility: hidden;
  transition: all 0.15s ease-out;
  z-index: 1001;
`]))), Use = ({ layoutP: r, onSVGViewerClear: s, onSVGViewerLoad: a, onSVGViewerShow: d, onSVGViewerHide: m, onFileSave: y, onMarkersAdd: x, onMarkersClear: w, onMarkersLog: T, onEventsAdd: P, onEventsClear: M, onEventsLog: F, onSheetCreate: O, onSheetDuplicate: N, onSheetObjectCreate: B, onSearchChange: U, onSearchTrigger: H }) => {
        let [W, Q] = (0, Lr.useState)(!1), [ne, ce] = (0, Lr.useState)(""), [ue, se] = (0, Lr.useState)(0), Oe = (0, Lr.useCallback)(() => {
          Q((Se) => !Se);
        }, []), he = (0, Lr.useCallback)(() => {
          Q(!1);
        }, []), ie = (0, Lr.useCallback)((Se) => {
          let nt = Se.target.value;
          ce(nt), U && U(nt);
        }, [U]), ye = (0, Lr.useCallback)((Se) => {
          if (Se.key === "Enter") {
            let nt = ue + 1;
            se(nt), H && H(nt), U && U(ne);
          }
        }, [U, H, ne, ue]), Ee = (0, Lr.useCallback)((Se) => {
          Se && Se(), he();
        }, [he]), ve = [{ label: "File", submenu: [{ label: "Save", action: y }] }, { label: "Sheets", submenu: [{ label: "Create Sheet", action: O }, { label: "Duplicate Sheet", action: N }, { label: "Create Sheet Object", action: B }] }, { label: "Markers", submenu: [{ label: "Add", action: x }, { label: "Log", action: T }, { label: "Clear", action: w }] }, { label: "Events", submenu: [{ label: "Add", action: P }, { label: "Log", action: F }, { label: "Clear", action: M }] }, { label: "Data Viewer", submenu: [{ label: "Show", action: d }, { label: "Hide", action: m }, { label: "Load", action: a }, { label: "Clear", action: s }] }], Xe = (Se, nt) => Lr.default.createElement(Fse, { key: nt, hasSubmenu: !!Se.submenu }, Lr.default.createElement(lU, { hasSubmenu: !!Se.submenu, onClick: () => !Se.submenu && Ee(Se.action) }, Se.label, Se.submenu && Lr.default.createElement("span", null, "")), Se.submenu && Lr.default.createElement(jse, null, Se.submenu.map((De, Ce) => Lr.default.createElement(lU, { key: Ce, onClick: () => Ee(De.action) }, De.label))));
        return At(() => {
          let Se = (0, Sse.val)(r), nt = Se.rightPanelOpen, De = Se.leftDims.width;
          return Lr.default.createElement(Ese, { width: De }, Lr.default.createElement(Mse, { isOpen: W, onClick: Oe }, Lr.default.createElement("span", null, "")), Lr.default.createElement(Ise, { isOpen: W }, Lr.default.createElement(Ose, null, ve.map(Xe))), Lr.default.createElement(Cse, { type: "text", placeholder: "Search...", value: ne, onChange: ie, onKeyDown: ye, hasValue: ne.length > 0 }), Lr.default.createElement(Ase, { isActive: nt, onClick: () => {
            Se.setRightPanelOpen(!nt);
          }, title: nt ? "Hide timeline editor" : "Show timeline editor", style: { transform: "scale(".concat(nt ? -1 : 1, ", 1)") } }, Lr.default.createElement(sEe, null)), W && Lr.default.createElement("div", { style: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 99 }, onClick: he }));
        }, [r, W, ve]);
      }, zse = Use;
    }), Ss, Vse, Gse, qse, Hse, $se, Wse, Kse, Yse, Xse, Qse, Zse, uU, Jse, eoe, aEe = R(() => {
      Ss = Y(xe()), it(), Gse = ee.div(Vse || (Vse = $([`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: `, `;
  align-items: center;
  justify-content: center;
  z-index: 10000;
`])), (r) => r.isOpen ? "flex" : "none"), Hse = ee.div(qse || (qse = $([`
  background: #2d2d30;
  border: 1px solid #3e3e42;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  padding: 24px;
  min-width: 400px;
  max-width: 500px;
`]))), Wse = ee.h3($se || ($se = $([`
  color: #ffffff;
  font-size: 16px;
  font-family: inherit;
  margin: 0 0 16px 0;
  font-weight: 500;
`]))), Yse = ee.input(Kse || (Kse = $([`
  width: 100%;
  background: #1e1e1e;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  padding: 8px 12px;
  color: #ffffff;
  font-size: 14px;
  font-family: inherit;
  margin-bottom: 20px;
  box-sizing: border-box;

  &:focus {
    outline: none;
    border-color: #0078d4;
    box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
  }

  &::placeholder {
    color: #888888;
  }
`]))), Qse = ee.div(Xse || (Xse = $([`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
`]))), uU = ee.button(Zse || (Zse = $([`
  background: `, `;
  color: `, `;
  border: 1px solid
    `, `;
  border-radius: 4px;
  padding: 8px 16px;
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  min-width: 80px;

  &:hover {
    background: `, `;
  }

  &:active {
    background: `, `;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`])), (r) => r.variant === "primary" ? "#0078d4" : "transparent", (r) => r.variant === "primary" ? "#ffffff" : "#cccccc", (r) => r.variant === "primary" ? "#0078d4" : "#3e3e42", (r) => r.variant === "primary" ? "#106ebe" : "#3e3e42", (r) => r.variant === "primary" ? "#005a9e" : "#4a4a4a"), Jse = (0, Ss.forwardRef)(({ onConfirm: r, onCancel: s }, a) => {
        let [d, m] = (0, Ss.useState)(!1), [y, x] = (0, Ss.useState)("create"), [w, T] = (0, Ss.useState)(""), P = y === "create" ? "Create New Sheet" : "Duplicate Sheet", M = "Enter sheet name";
        (0, Ss.useImperativeHandle)(a, () => ({ open: (U, H) => {
          x(U), m(!0), T(U === "duplicate" && H ? "".concat(H, " Copy") : "");
        }, close: () => {
          m(!1), T("");
        } }));
        let F = (0, Ss.useCallback)(() => {
          let U = w.trim();
          U && (r(U, y), m(!1), T(""));
        }, [w, y, r]), O = (0, Ss.useCallback)(() => {
          s(), m(!1), T("");
        }, [s]), N = (0, Ss.useCallback)((U) => {
          U.key === "Enter" ? F() : U.key === "Escape" && O();
        }, [F, O]), B = (0, Ss.useCallback)((U) => {
          U.target === U.currentTarget && O();
        }, [O]);
        return Ss.default.createElement(Gse, { isOpen: d, onClick: B }, Ss.default.createElement(Hse, null, Ss.default.createElement(Wse, null, P), Ss.default.createElement(Yse, { type: "text", value: w, onChange: (U) => T(U.target.value), onKeyDown: N, placeholder: M, autoFocus: !0 }), Ss.default.createElement(Qse, null, Ss.default.createElement(uU, { variant: "secondary", onClick: O }, "Cancel"), Ss.default.createElement(uU, { variant: "primary", onClick: F, disabled: !w.trim() }, "Create"))));
      }), eoe = Jse;
    }), jt, toe, noe, roe, ioe, soe, ooe, aoe, dv, loe, gd, uoe, ap, coe, doe, hoe, poe, foe, moe, goe, yoe, voe, boe, xoe, _oe, Soe, woe, Eoe, Toe, Coe, Poe, Aoe, koe, Moe, Roe, Ioe, cU, dU, Noe, lEe = R(() => {
      jt = Y(xe()), it(), noe = ee.div(toe || (toe = $([`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: `, `;
  align-items: center;
  justify-content: center;
  z-index: 10000;
`])), (r) => r.isOpen ? "flex" : "none"), ioe = ee.div(roe || (roe = $([`
  background: #2d2d30;
  border: 1px solid #3e3e42;
  border-radius: 8px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
  padding: 24px;
  min-width: 500px;
  max-width: 600px;
  max-height: 80vh;
  overflow-y: auto;
`]))), ooe = ee.h3(soe || (soe = $([`
  color: #ffffff;
  font-size: 16px;
  font-family: inherit;
  margin: 0 0 20px 0;
  font-weight: 500;
`]))), dv = ee.div(aoe || (aoe = $([`
  margin-bottom: 16px;
`]))), gd = ee.label(loe || (loe = $([`
  display: block;
  color: #cccccc;
  font-size: 12px;
  font-family: inherit;
  margin-bottom: 6px;
  font-weight: 500;
`]))), ap = ee.input(uoe || (uoe = $([`
  width: 100%;
  background: #1e1e1e;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  padding: 8px 12px;
  color: #ffffff;
  font-size: 14px;
  font-family: inherit;
  box-sizing: border-box;

  &:focus {
    outline: none;
    border-color: #0078d4;
    box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
  }

  &::placeholder {
    color: #888888;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`]))), doe = ee.select(coe || (coe = $([`
  width: 100%;
  background: #1e1e1e;
  border: 1px solid #3e3e42;
  border-radius: 4px;
  padding: 8px 12px;
  color: #ffffff;
  font-size: 14px;
  font-family: inherit;
  box-sizing: border-box;

  &:focus {
    outline: none;
    border-color: #0078d4;
    box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.3);
  }

  option {
    background: #1e1e1e;
    color: #ffffff;
  }
`]))), poe = ee.div(hoe || (hoe = $([`
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 12px;
`]))), moe = ee.div(foe || (foe = $([`
  display: flex;
  gap: 12px;
  align-items: flex-end;
`]))), yoe = ee.div(goe || (goe = $([`
  width: 40px;
  height: 32px;
  border-radius: 4px;
  border: 1px solid #3e3e42;
  background: `, `;
  cursor: pointer;
  position: relative;

  &:hover {
    border-color: #0078d4;
  }
`])), (r) => r.color), boe = ee.input(voe || (voe = $([`
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  opacity: 0;
  cursor: pointer;
`]))), _oe = ee(ap)(xoe || (xoe = $([`
  flex: 1;
  font-family: 'Courier New', monospace;
  text-transform: uppercase;
`]))), woe = ee.div(Soe || (Soe = $([`
  display: flex;
  align-items: center;
  gap: 12px;
`]))), Toe = ee.div(Eoe || (Eoe = $([`
  width: 48px;
  height: 24px;
  border-radius: 12px;
  background: `, `;
  border: 1px solid `, `;
  position: relative;
  cursor: pointer;
  transition: all 0.2s ease;

  &:hover {
    background: `, `;
  }
`])), (r) => r.isOn ? "#0078d4" : "#3e3e42", (r) => r.isOn ? "#0078d4" : "#5a5a5a", (r) => r.isOn ? "#106ebe" : "#4a4a4a"), Poe = ee.div(Coe || (Coe = $([`
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #ffffff;
  position: absolute;
  top: 2px;
  left: `, `;
  transition: all 0.2s ease;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
`])), (r) => r.isOn ? "26px" : "2px"), koe = ee.span(Aoe || (Aoe = $([`
  color: `, `;
  font-size: 14px;
  font-family: inherit;
  font-weight: `, `;
`])), (r) => r.isOn ? "#ffffff" : "#cccccc", (r) => r.isOn ? "500" : "normal"), Roe = ee.div(Moe || (Moe = $([`
  display: flex;
  gap: 12px;
  justify-content: flex-end;
  margin-top: 24px;
`]))), cU = ee.button(Ioe || (Ioe = $([`
  background: `, `;
  color: `, `;
  border: 1px solid
    `, `;
  border-radius: 4px;
  padding: 8px 16px;
  font-size: 14px;
  font-family: inherit;
  cursor: pointer;
  min-width: 80px;

  &:hover {
    background: `, `;
  }

  &:active {
    background: `, `;
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
`])), (r) => r.variant === "primary" ? "#0078d4" : "transparent", (r) => r.variant === "primary" ? "#ffffff" : "#cccccc", (r) => r.variant === "primary" ? "#0078d4" : "#3e3e42", (r) => r.variant === "primary" ? "#106ebe" : "#3e3e42", (r) => r.variant === "primary" ? "#005a9e" : "#4a4a4a"), dU = (0, jt.forwardRef)(({ onConfirm: r, onCancel: s }, a) => {
        let [d, m] = (0, jt.useState)(!1), [y, x] = (0, jt.useState)(""), [w, T] = (0, jt.useState)(""), [P, M] = (0, jt.useState)("number"), [F, O] = (0, jt.useState)(""), [N, B] = (0, jt.useState)(""), [U, H] = (0, jt.useState)(""), [W, Q] = (0, jt.useState)(""), [ne, ce] = (0, jt.useState)("#FFFFFF"), [ue, se] = (0, jt.useState)(!1), Oe = (Ve) => {
          let oe = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(Ve);
          return oe ? { r: parseInt(oe[1], 16) / 255, g: parseInt(oe[2], 16) / 255, b: parseInt(oe[3], 16) / 255, a: 1 } : { r: 1, g: 1, b: 1, a: 1 };
        }, he = (Ve) => {
          let oe = (je) => {
            let Ge = Math.round(je * 255).toString(16);
            return Ge.length === 1 ? "0" + Ge : Ge;
          };
          return "#".concat(oe(Ve.r)).concat(oe(Ve.g)).concat(oe(Ve.b)).toUpperCase();
        }, ie = (Ve) => {
          try {
            let oe = JSON.parse(Ve);
            if (oe && typeof oe == "object" && "r" in oe && "g" in oe && "b" in oe) return { r: oe.r, g: oe.g, b: oe.b, a: 1 };
          } catch {
          }
          return { r: 1, g: 1, b: 1, a: 1 };
        };
        (0, jt.useImperativeHandle)(a, () => ({ open: (Ve) => {
          m(!0), x(Ve || ""), T(""), M("number"), O(""), B(""), H(""), Q(""), ce("#FFFFFF"), se(!1);
        }, close: () => {
          m(!1);
        } }));
        let ye = (Ve) => {
          switch (Ve) {
            case "number":
              return "0";
            case "string":
              return "Hello World";
            case "boolean":
              return "false";
            case "rgba":
              return '{"r": 1, "g": 1, "b": 1, "a": 1}';
            case "compound":
              return '{"x": 0, "y": 0, "z": 0}';
            default:
              return "";
          }
        }, Ee = (Ve) => {
          switch (Ve) {
            case "number":
              return "e.g. 0, 3.14, -10";
            case "string":
              return 'e.g. "Hello World"';
            case "boolean":
              return "Use toggle below";
            case "rgba":
              return "Use color picker or enter hex";
            case "compound":
              return '{"x": 0, "y": 0, "z": 0}';
            default:
              return "";
          }
        }, ve = (Ve) => {
          M(Ve);
          let oe = ye(Ve);
          if (O(oe), Ve === "rgba") {
            let je = ie(oe);
            ce(he(je));
          } else Ve === "boolean" && (se(!1), O("false"));
          Ve !== "number" && (B(""), H(""), Q(""));
        }, Xe = () => {
          let Ve = !ue;
          se(Ve), O(Ve.toString());
        }, Se = (Ve) => {
          ce(Ve);
          let oe = Oe(Ve);
          O(JSON.stringify(oe));
        }, nt = (Ve) => {
          /^#[0-9A-Fa-f]{6}$/.test(Ve) ? Se(Ve) : ce(Ve);
        }, De = (Ve, oe) => {
          switch (oe) {
            case "number":
              let je = parseFloat(Ve);
              return isNaN(je) ? 0 : je;
            case "string":
              return Ve;
            case "boolean":
              return Ve.toLowerCase() === "true";
            case "rgba":
              try {
                return JSON.parse(Ve);
              } catch {
                return { r: 1, g: 1, b: 1, a: 1 };
              }
            case "compound":
              try {
                return JSON.parse(Ve);
              } catch {
                return {};
              }
            default:
              return Ve;
          }
        }, Ce = (0, jt.useCallback)(() => {
          let Ve = y.trim(), oe = w.trim();
          if (!Ve || !oe) return;
          let je = De(F, P), Ge = { name: Ve, key: oe, type: P, value: je };
          P === "number" && (N !== "" && (Ge.min = parseFloat(N)), U !== "" && (Ge.max = parseFloat(U)), W !== "" && (Ge.step = parseFloat(W))), r(Ge), m(!1);
        }, [y, w, P, F, N, U, W, r]), le = (0, jt.useCallback)(() => {
          s(), m(!1);
        }, [s]), Ie = (0, jt.useCallback)((Ve) => {
          Ve.key === "Enter" && Ve.ctrlKey ? Ce() : Ve.key === "Escape" && le();
        }, [Ce, le]), $e = (0, jt.useCallback)((Ve) => {
          Ve.target === Ve.currentTarget && le();
        }, [le]), de = P === "number", Ae = P === "rgba", Je = P === "boolean", rt = y.trim() !== "" && w.trim() !== "";
        return jt.default.createElement(noe, { isOpen: d, onClick: $e }, jt.default.createElement(ioe, null, jt.default.createElement(ooe, null, "Create Sheet Object"), jt.default.createElement(dv, null, jt.default.createElement(gd, null, "Object Name"), jt.default.createElement(ap, { type: "text", value: y, onChange: (Ve) => x(Ve.target.value), onKeyDown: Ie, placeholder: "Enter object name (e.g. 'myBox', 'character')", autoFocus: !0 })), jt.default.createElement(dv, null, jt.default.createElement(gd, null, "Property Key"), jt.default.createElement(ap, { type: "text", value: w, onChange: (Ve) => T(Ve.target.value), onKeyDown: Ie, placeholder: "Enter property key (e.g. 'position', 'color', 'scale')" })), jt.default.createElement(dv, null, jt.default.createElement(gd, null, "Type"), jt.default.createElement(doe, { value: P, onChange: (Ve) => ve(Ve.target.value) }, jt.default.createElement("option", { value: "number" }, "Number"), jt.default.createElement("option", { value: "string" }, "String"), jt.default.createElement("option", { value: "boolean" }, "Boolean"), jt.default.createElement("option", { value: "rgba" }, "Color"), jt.default.createElement("option", { value: "compound" }, "Object"))), jt.default.createElement(dv, null, jt.default.createElement(gd, null, "Default Value"), Ae ? jt.default.createElement(moe, null, jt.default.createElement(yoe, { color: ne }, jt.default.createElement(boe, { type: "color", value: ne, onChange: (Ve) => Se(Ve.target.value) })), jt.default.createElement(_oe, { type: "text", value: ne, onChange: (Ve) => nt(Ve.target.value), onKeyDown: Ie, placeholder: "#FFFFFF" })) : Je ? jt.default.createElement(woe, null, jt.default.createElement(Toe, { isOn: ue, onClick: Xe }, jt.default.createElement(Poe, { isOn: ue })), jt.default.createElement(koe, { isOn: ue }, ue ? "True" : "False")) : jt.default.createElement(ap, { type: "text", value: F, onChange: (Ve) => O(Ve.target.value), onKeyDown: Ie, placeholder: Ee(P) })), de && jt.default.createElement(dv, null, jt.default.createElement(gd, null, "Range (Optional)"), jt.default.createElement(poe, null, jt.default.createElement("div", null, jt.default.createElement(gd, { style: { fontSize: "11px", marginBottom: "4px" } }, "Min"), jt.default.createElement(ap, { type: "number", value: N, onChange: (Ve) => B(Ve.target.value), onKeyDown: Ie, placeholder: "Min" })), jt.default.createElement("div", null, jt.default.createElement(gd, { style: { fontSize: "11px", marginBottom: "4px" } }, "Max"), jt.default.createElement(ap, { type: "number", value: U, onChange: (Ve) => H(Ve.target.value), onKeyDown: Ie, placeholder: "Max" })), jt.default.createElement("div", null, jt.default.createElement(gd, { style: { fontSize: "11px", marginBottom: "4px" } }, "Step"), jt.default.createElement(ap, { type: "number", value: W, onChange: (Ve) => Q(Ve.target.value), onKeyDown: Ie, placeholder: "Step" })))), jt.default.createElement(Roe, null, jt.default.createElement(cU, { variant: "secondary", onClick: le }, "Cancel"), jt.default.createElement(cU, { variant: "primary", onClick: Ce, disabled: !rt }, "Create"))));
      }), dU.displayName = "SheetObjectModal", Noe = dU;
    });
    function uEe(r, s) {
      let a = new File([r], s), d = URL.createObjectURL(a), m = Object.assign(document.createElement("a"), { href: d, target: "_blank", rel: "noopener" });
      m.setAttribute("download", s), m.click(), setTimeout(() => {
        URL.revokeObjectURL(d);
      }, 4e4);
    }
    var vr, Et, hv, Ooe, Doe, Foe, Boe, Hl, Loe, joe, Uoe, zoe, Voe, Goe, qoe, Hoe, $oe, Woe, Koe, Yoe, Xoe, SS, Qoe, Zoe, Joe, eae, tae, nae, rae, iae, sae, oae, ec = R(() => {
      st(), M0(), Nl(), zt(), a9(), vr = ut(), Et = Y(xe()), it(), hv = zge(), cwe(), lR(), xwe(), Jwe(), O0(), H1(), Df(), i$(), N$(), Ui(), _r(), tn(), eEe(), qh(), J1(), tEe(), rEe(), iEe(), oEe(), aEe(), lEe(), mj(), Doe = ee(SL)(Ooe || (Ooe = $([`
  z-index: `, `;
  box-shadow: 2px 2px 0 rgb(0 0 0 / 11%);
  `, `
`])), sm.sequenceEditorPanel, (r) => r.collapsedWidth ? "width: ".concat(r.collapsedWidth, "px !important; max-width: ").concat(r.collapsedWidth, "px !important;") : ""), Boe = ee.div(Foe || (Foe = $([`
  background-color: rgba(40, 43, 47, 0.99);
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  z-index: -1;
  pointer-events: none;
`]))), Hl = (() => {
        let r = { svgViewer: 0, rightBackground: 0, scrollableArea: 0, rightOverlay: 0, lengthIndicatorCover: 0, lengthIndicatorStrip: 0, playhead: 0, currentFrameStamp: 0, marker: 0, horizontalScrollbar: 0 }, s = -1;
        for (let a of Object.keys(r)) r[a] = s, s++;
        return r;
      })(), joe = ee(mL)(Loe || (Loe = $([`
  position: absolute;
  left: 0;
  top: 0;
  z-index: 2;

  `, ` {
    height: 60px;
    display: flex;
    flex-direction: column;
    align-items: normal;
    padding: 0;
  }
`])), Nk), Uoe = { edges: { left: { from: "screenLeft", distance: 0.1 }, right: { from: "screenRight", distance: 0.2 }, top: { from: "screenBottom", distance: 0.4 }, bottom: { from: "screenBottom", distance: 0.01 } } }, zoe = () => At(() => {
        var r;
        let s = pe(), a = { width: (r = (0, vr.val)(s.atomP.historic.panels.sequenceEditor.rightPanelOpen)) == null || r ? Dj * 2 : Dj, height: 200 };
        return Et.default.createElement(lL, { panelId: "sequenceEditor", defaultPosition: Uoe, minDims: a }, Et.default.createElement(Voe, null));
      }, []), Voe = () => {
        let { dims: r } = N0(), [s, a] = (0, Et.useState)(null), [d, m] = (0, Et.useState)(""), [y, x] = (0, Et.useState)(0), w = (0, Et.useRef)(null), [T, P] = (0, Et.useState)(!1), [M, F] = (0, Et.useState)(!1), [O, N] = (0, Et.useState)(null), B = (0, Et.useRef)(null), U = (0, Et.useRef)(null), H = (0, Et.useRef)(/* @__PURE__ */ new Map()), W = (0, Et.useRef)(null), Q = (0, Et.useCallback)(() => {
          var oe;
          (oe = w.current) == null || oe.clearData();
        }, []), ne = (0, Et.useCallback)(() => {
          P(!0);
        }, []), ce = (0, Et.useCallback)(() => {
          var oe;
          (oe = w.current) == null || oe.show();
        }, []), ue = (0, Et.useCallback)(() => {
          var oe;
          (oe = w.current) == null || oe.hide();
        }, []), se = (0, Et.useCallback)((oe, je) => {
          var Ge;
          (Ge = w.current) == null || Ge.addData(oe, je), P(!1);
        }, []), Oe = (0, Et.useCallback)(() => {
          P(!1);
        }, []), he = (0, Et.useCallback)((oe) => dt(void 0, null, function* () {
          if (!O) throw new Error("No sheet selected");
          try {
            let je = O.project.publicApi.sheet(O.address.sheetId).sequence, Ge;
            oe instanceof File ? Ge = URL.createObjectURL(oe) : Ge = oe, yield je.attachAudio({ source: Ge }), console.log(" Audio attached successfully"), oe instanceof File && setTimeout(() => {
              URL.revokeObjectURL(Ge);
            }, 5e3);
          } catch (je) {
            throw console.error(" Failed to attach audio:", je), je;
          }
        }), [O]), ie = (0, Et.useCallback)(() => {
          F(!1), N(null);
        }, []), ye = (0, Et.useCallback)(() => {
          var oe;
          (oe = B.current) == null || oe.open("create");
        }, []), Ee = (0, Et.useCallback)(() => {
          var oe, je;
          let Ge = W.current, yt = ((oe = Ge?.address) == null ? void 0 : oe.sheetId) || "Sheet";
          (je = B.current) == null || je.open("duplicate", yt);
        }, []), ve = (0, Et.useCallback)((oe, je) => {
          var Ge;
          try {
            let yt = W.current;
            if ((Ge = yt?.project) != null && Ge.publicApi) {
              let Nt = yt.project.publicApi.sheet(oe);
              console.log(" Successfully ".concat(je === "create" ? "created" : "duplicated", " sheet: ").concat(oe));
            } else console.error(" No current sheet or project available");
          } catch (yt) {
            console.error(" Failed to ".concat(je, " sheet:"), yt);
          }
        }, []), Xe = (0, Et.useCallback)(() => {
          console.log(" Sheet modal cancelled");
        }, []), Se = (0, Et.useCallback)(() => {
          var oe;
          (oe = U.current) == null || oe.open();
        }, []), nt = (0, Et.useCallback)((oe) => {
          m(oe);
        }, []), De = (0, Et.useCallback)((oe) => {
          x(oe);
        }, []);
        Et.default.useEffect(() => {
          let oe = (je) => {
            let { sheet: Ge } = je.detail;
            N(Ge), F(!0);
          };
          return document.addEventListener("theatre:attachAudio", oe), () => {
            document.removeEventListener("theatre:attachAudio", oe);
          };
        }, []);
        let Ce = (0, Et.useCallback)((oe) => {
          try {
            let je = W.current;
            if (je) {
              let Ge;
              switch (oe.type) {
                case "number":
                  if (oe.min !== void 0 || oe.max !== void 0 || oe.step !== void 0) {
                    let Tn = {};
                    oe.min !== void 0 && oe.max !== void 0 && (Tn.range = [oe.min, oe.max]), oe.step !== void 0 && (Tn.nudgeMultiplier = oe.step), Ge = hv.types.number(oe.value, Tn);
                  } else Ge = hv.types.number(oe.value);
                  break;
                case "string":
                  Ge = hv.types.string(oe.value);
                  break;
                case "boolean":
                  Ge = hv.types.boolean(oe.value);
                  break;
                case "rgba":
                  Ge = hv.types.rgba(oe.value);
                  break;
                case "compound":
                  Ge = oe.value;
                  break;
                default:
                  Ge = oe.value;
              }
              let yt = je.project.publicApi.sheet(je.address.sheetId), Nt = "".concat(je.address.sheetId, ":").concat(oe.name), Lt = H.current.get(Nt) || {};
              Lt[oe.key] = Ge, H.current.set(Nt, Lt);
              let qt;
              try {
                let Tn, dr = {};
                try {
                  Tn = yt.object(oe.name, {}), dr = Tn.value || {};
                } catch {
                }
                let dn = L({}, Lt);
                qt = yt.object(oe.name, dn, { reconfigure: !0 });
                let jr = Object.keys(Lt), Sn = Object.keys(qt.value || {}), Rn = jr.filter((ns) => !Sn.includes(ns));
                Rn.length !== 0 && (console.log(" Still missing props:", Rn), console.log("This indicates a fundamental Theatre.js limitation with reconfigure"));
              } catch (Tn) {
                throw console.error(" Object creation failed:", Tn), Tn;
              }
            } else console.error(" No current sheet available");
          } catch (je) {
            console.error(" Failed to create sheet object:", je);
          }
        }, []), le = (0, Et.useCallback)(() => {
          console.log(" Sheet object modal cancelled");
        }, []), Ie = (0, Et.useCallback)(() => {
          console.log(" Start Menu: Saving project files");
          try {
            let oe = (0, vr.val)(pe().projectsP);
            Object.values(oe).forEach((je) => {
              if (je) {
                let Ge = je.address.projectId, yt = Ge.replace(/[^\w\d'_\-]+/g, " ").trim(), Nt = "".concat(yt, ".json"), Lt = JSON.stringify(pe().createContentOfSaveFile(Ge), null, 2);
                uEe(Lt, Nt), console.log(" Saved project: ".concat(Nt));
              }
            });
          } catch (oe) {
            console.error(" Failed to save project files:", oe);
          }
        }, []), $e = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = je.getSequence();
              pe().transaction(({ stateEditors: yt }) => {
                yt.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceMarkers({ sheetAddress: je.address, markers: [{ id: s9(), position: Ge.position, label: "Marker ".concat(Math.floor(Ge.position * 100) / 100, "s") }], snappingFunction: Ge.closestGridPosition });
              });
            } else console.warn(" No sheet selected for adding marker");
          } catch (oe) {
            console.error(" Failed to add marker:", oe);
          }
        }, []), de = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = je.getSequence();
              pe().transaction(({ stateEditors: yt }) => {
                yt.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.replaceEvents({ sheetAddress: je.address, events: [{ id: o9(), name: "event", position: Ge.position }] });
              });
            } else console.warn(" No sheet selected for adding event");
          } catch (oe) {
            console.error(" Failed to add event:", oe);
          }
        }, []), Ae = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = pe().atomP.historic.projects.stateByProjectId[je.address.projectId].stateBySheetId[je.address.sheetId].sequenceEditor.markerSet, yt = (0, vr.val)(Ge.allIds);
              yt && Object.keys(yt).length > 0 ? Object.keys(yt).forEach((Nt) => {
                pe().transaction(({ stateEditors: Lt }) => {
                  Lt.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeMarker({ sheetAddress: je.address, markerId: Nt });
                });
              }) : console.log(" No markers to clear");
            } else console.warn(" No sheet selected for clearing markers");
          } catch (oe) {
            console.error(" Failed to clear markers:", oe);
          }
        }, []), Je = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = (0, vr.val)(pe().atomP.historic.projects.stateByProjectId[je.address.projectId].stateBySheetId[je.address.sheetId]), yt = (0, vr.val)(pe().atomP.historic.coreByProject[je.address.projectId].sheetsById[je.address.sheetId].sequence.markers) || [];
              console.group(" Markers for sheet:", je.address.sheetId), console.log("Total markers:", yt.length), yt.forEach((Nt, Lt) => {
                console.log("".concat(Lt + 1, '. "').concat(Nt.label || "Unnamed", '" at ').concat(Nt.position, "s (ID: ").concat(Nt.id, ")"));
              }), console.groupEnd();
            } else console.warn(" No sheet selected for logging markers");
          } catch (oe) {
            console.error(" Failed to log markers:", oe);
          }
        }, []), rt = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = pe().atomP.historic.projects.stateByProjectId[je.address.projectId].stateBySheetId[je.address.sheetId].sequenceEditor.eventSet, yt = (0, vr.val)(Ge?.allIds);
              yt && Object.keys(yt).length > 0 ? Object.keys(yt).forEach((Nt) => {
                pe().transaction(({ stateEditors: Lt }) => {
                  Lt.studio.historic.projects.stateByProjectId.stateBySheetId.sequenceEditor.removeEvent({ sheetAddress: je.address, eventId: Nt });
                });
              }) : console.log(" No events to clear");
            } else console.warn(" No sheet selected for clearing events");
          } catch (oe) {
            console.error(" Failed to clear events:", oe);
          }
        }, []), Ve = (0, Et.useCallback)(() => {
          try {
            let oe = ar(Va().filter((je) => Ht(je) || an(je)).map((je) => an(je) ? je.sheet : je));
            if (oe.length > 0) {
              let je = oe[0], Ge = (0, vr.val)(pe().atomP.historic.coreByProject[je.address.projectId].sheetsById[je.address.sheetId].sequence.events) || [];
              console.group(" Events for sheet:", je.address.sheetId), console.log("Total events:", Ge.length), Ge.forEach((yt, Nt) => {
                console.log("".concat(Nt + 1, '. "').concat(yt.name, '" at ').concat(yt.position, "s").concat(yt.value !== void 0 ? " (value: ".concat(JSON.stringify(yt.value), ")") : "", " (ID: ").concat(yt.id, ")"));
              }), console.groupEnd();
            } else console.warn(" No sheet selected for logging events");
          } catch (oe) {
            console.error(" Failed to log events:", oe);
          }
        }, []);
        return u1e(s), At(() => {
          var oe;
          let je = pe(), Ge = (oe = (0, vr.val)(je.atomP.historic.panels.sequenceEditor.rightPanelOpen)) != null ? oe : !0, yt = vr.prism.memo("panelSize", () => {
            let bn = r.width, bd = r.height;
            return { width: bn, height: bd, widthWithoutBorder: bn - 2, heightWithoutBorder: bd - 4, screenX: r.left, screenY: r.top };
          }, [r, Ge]), Nt = ar(Va().filter((bn) => Ht(bn) || an(bn)).map((bn) => an(bn) ? bn.sheet : bn));
          if (ar(Nt.map((bn) => bn.template)).length !== 1) return Et.default.createElement(Et.default.Fragment, null);
          let Lt = Nt[0];
          if (!Lt) return Et.default.createElement(Et.default.Fragment, null);
          W.current = Lt;
          let qt = Lt.getSequence().length, Tn = (0, vr.val)(pe().atomP.ahistoric.projects.stateByProjectId[Lt.address.projectId].stateBySheetId[Lt.address.sheetId].sequence.clippedSpaceRange) || { start: 0, end: 10 }, dr = Tn.start === 0 && Tn.end === 10, dn = qt * 1.05;
          qt > 0 && qt !== 10 && Tn.end !== dn && dr && setTimeout(() => {
            pe().transaction(({ stateEditors: bn }) => {
              bn.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence.clippedSpaceRange.set(V(L({}, Lt.address), { range: { start: 0, end: dn } }));
            });
          }, 0);
          let jr = AL("panelSizeP", yt).pointer, Sn = vr.prism.memo("key", () => JSON.stringify(Lt.address), [Lt]), Rn = bwe(Lt, jr).getValue();
          (0, vr.val)(Rn.tree.children).length > 0;
          let ns = (0, vr.val)(Lt.project.pointers.historic.sheetsById[Lt.address.sheetId].sequence);
          ns?.length && ns.length > 0 || ns?.markers && ns.markers.length > 0;
          let ei = vr.prism.memo("containerRef", oae, []), Ka = (0, vr.val)(Rn.graphEditorDims.isAvailable), Fo = (0, vr.val)(Rn.graphEditorDims.isOpen), rs = (0, vr.val)(Rn.rightPanelOpen), en = rs ? void 0 : (0, vr.val)(Rn.leftDims.width);
          return Et.default.createElement(Doe, { collapsedWidth: en, ref: (bn) => {
            ei(bn), bn !== s && a(bn);
          } }, Et.default.createElement(Boe, { style: { width: "".concat((0, vr.val)(Rn.leftDims.width), "px") } }), Et.default.createElement(zse, { layoutP: Rn, onSVGViewerClear: Q, onSVGViewerLoad: ne, onSVGViewerShow: ce, onSVGViewerHide: ue, onFileSave: Ie, onMarkersAdd: $e, onMarkersClear: Ae, onMarkersLog: Je, onEventsAdd: de, onEventsClear: rt, onEventsLog: Ve, onSheetCreate: ye, onSheetDuplicate: Ee, onSheetObjectCreate: Se, onSearchChange: nt, onSearchTrigger: De }), Et.default.createElement(VY, { layoutP: Rn }, Et.default.createElement(Goe, { layoutP: Rn }), Et.default.createElement(Jre, { ref: w, key: Sn + "-svgViewer", layoutP: Rn, sheetAddress: Lt.address, renderMode: "both", color: "#4575e3" }), Et.default.createElement(ZZ, { searchTerm: d, searchTrigger: y }, Et.default.createElement(tte, { key: Sn + "-dopeSheet-" + d + "-" + y, layoutP: Rn })), Fo && Et.default.createElement(cee, { key: Sn + "-graphEditor", layoutP: Rn }), Ka && Et.default.createElement(Kre, { layoutP: Rn }), rs && Et.default.createElement(Gre, { layoutP: Rn })), Et.default.createElement(eoe, { ref: B, onConfirm: ve, onCancel: Xe }), Et.default.createElement(Noe, { ref: U, onConfirm: Ce, onCancel: le }), T && Et.default.createElement(Hie, { onLoad: se, onCancel: Oe }), M && Et.default.createElement(_se, { onAttach: he, onCancel: ie }));
        }, [r, s, d, y, T, M]);
      }, Goe = ({ layoutP: r }) => At(() => {
        let s = (0, vr.val)(r.sheet);
        return s.getSequence(), Et.default.createElement(joe, { style: { width: (0, vr.val)(r.leftDims.width) } }, Et.default.createElement(Nk, { style: { borderRight: "1px solid #222" } }, Et.default.createElement(Woe, { style: { borderBottom: "1px solid #222" } }, Et.default.createElement($B, { style: { color: "white", fontSize: "14px", fontWeight: "bold" } }, s.address.sheetId)), Et.default.createElement(Yoe, null, Et.default.createElement(Hoe, null, Et.default.createElement(tae, { layoutP: r }), Et.default.createElement(Ik, null, "/"), Et.default.createElement(nae, { layoutP: r }), Et.default.createElement(Ik, null, "-"), Et.default.createElement(iae, { layoutP: r }), Et.default.createElement(Ik, null, ":"), Et.default.createElement(rae, { layoutP: r }), Et.default.createElement($B, { style: { fontSize: "9px", opacity: 0.7 } }, "fps")))));
      }, [r]), Hoe = ee.div(qoe || (qoe = $([`
  display: flex;
  align-items: center;
  gap: 4px;
  height: 30px;
`]))), Woe = ee.div($oe || ($oe = $([`
  display: flex;
  align-items: center;
  height: 30px;
  padding: 0 8px;
`]))), Yoe = ee.div(Koe || (Koe = $([`
  display: flex;
  align-items: center;
  height: 30px;
  padding: 0 8px;
`]))), SS = ee(V0)(Xoe || (Xoe = $([`
  flex: 1;
  min-width: 0;
  height: 20px;
  font-size: 12px;
  padding: 0;
  background: rgba(0, 0, 0, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.1);
  color: #adadadb3;
  border-radius: 2px;

  &:hover {
    background: rgba(0, 0, 0, 0.3);
    border-color: rgba(255, 255, 255, 0.15);
  }

  &:focus {
    background: rgba(0, 0, 0, 0.4);
    border-color: rgba(255, 255, 255, 0.2);
    color: white;
  }
`]))), Zoe = ee(SS)(Qoe || (Qoe = $([`
  width: 40px;
`]))), eae = ee(SS)(Joe || (Joe = $([`
  width: 40px;
`]))), tae = ({ layoutP: r }) => At(() => {
        let s = (0, vr.val)(r.sheet).getSequence(), a = Number((0, vr.val)(s.pointer.position).toFixed(3)), d, m = s.position;
        return Et.default.createElement(SS, V(L({ value: a }, { temporarilySetValue(y) {
          d !== void 0 && (d = void 0), d = ir(y, 0, s.length), s.position = d;
        }, discardTemporaryValue() {
          d !== void 0 && (d = void 0, s.position = m);
        }, permanentlySetValue(y) {
          d !== void 0 && (d = void 0), s.position = ir(y, 0, s.length);
        } }), { isValid: (y) => isFinite(y) && y >= 0, nudge: ({ deltaX: y }) => y * 0.01 }));
      }, [r]), nae = ({ layoutP: r }) => At(() => {
        let s = (0, vr.val)(r.sheet), a = s.getSequence().length, d;
        return Et.default.createElement(SS, V(L({ value: a }, { temporarilySetValue(m) {
          d && (d.discard(), d = void 0), d = pe().tempTransaction(({ stateEditors: y }) => {
            y.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, s.address), { length: m }));
          });
        }, discardTemporaryValue() {
          d && (d.discard(), d = void 0);
        }, permanentlySetValue(m) {
          d && (d.discard(), d = void 0), pe().transaction(({ stateEditors: y }) => {
            y.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, s.address), { length: m }));
          });
        } }), { isValid: (m) => isFinite(m) && m > 0, nudge: ({ deltaX: m }) => m * 0.1 }));
      }, [r]), rae = ({ layoutP: r }) => At(() => {
        let s = (0, vr.val)(r.sheet), a = s.getSequence().subUnitsPerUnit, d;
        return Et.default.createElement(eae, V(L({ value: a }, { temporarilySetValue(m) {
          d && (d.discard(), d = void 0), d = pe().tempTransaction(({ stateEditors: y }) => {
            y.coreByProject.historic.sheetsById.sequence.setSubUnitsPerUnit(V(L({}, s.address), { subUnitsPerUnit: m }));
          });
        }, discardTemporaryValue() {
          d && (d.discard(), d = void 0);
        }, permanentlySetValue(m) {
          d && (d.discard(), d = void 0), pe().transaction(({ stateEditors: y }) => {
            y.coreByProject.historic.sheetsById.sequence.setSubUnitsPerUnit(V(L({}, s.address), { subUnitsPerUnit: m }));
          });
        } }), { isValid: (m) => isFinite(m) && m >= 1 && m <= j(2, 12), nudge: ({ deltaX: m }) => m * 1 }));
      }, [r]), iae = ({ layoutP: r }) => At(() => {
        let s = (0, vr.val)(r.sheet).getSequence(), a = s.subUnitsPerUnit, d = (0, vr.val)(s.pointer.position), m = Math.round(d * a), y, x = s.position;
        return Et.default.createElement(Zoe, V(L({ value: m }, { temporarilySetValue(w) {
          y !== void 0 && (y = void 0), y = w;
          let T = ir(w / a, 0, s.length);
          s.position = T;
        }, discardTemporaryValue() {
          y !== void 0 && (y = void 0, s.position = x);
        }, permanentlySetValue(w) {
          y !== void 0 && (y = void 0);
          let T = ir(w / a, 0, s.length);
          s.position = T;
        } }), { isValid: (w) => isFinite(w) && w >= 0, nudge: ({ deltaX: w }) => w * 1 }));
      }, [r]), sae = zoe, oae = () => {
        let r = null, s = { passive: !1, capture: !1 }, a = (d) => {
          Math.abs(d.deltaY) < Math.abs(d.deltaX) && (d.preventDefault(), d.stopPropagation());
        };
        return (d) => {
          r !== d && r && r.removeEventListener("wheel", a, s), r = d, d && d.addEventListener("wheel", a, s);
        };
      };
    }), pv, aae, lae, cEe = R(() => {
      Exe(), pv = Y(xe()), st(), zt(), g_e(), ec(), aae = () => {
        let r = nn(pe().paneManager.allPanesD), s = Object.entries(r).map(([a, d]) => pv.default.createElement(t9, { key: "pane-".concat(a), paneInstance: d }));
        return pv.default.createElement(pv.default.Fragment, null, s, pv.default.createElement(RH, null), pv.default.createElement(sae, null));
      }, lae = aae;
    }), uae, cae, IR, hU = R(() => {
      it(), Fl(), cae = ee(Mo)(uae || (uae = $([`
  padding: 1em;
  max-width: 240px;
  pointer-events: none !important;
  --popover-outer-stroke: transparent;
  --popover-inner-stroke: #45464d;
`]))), IR = cae;
    }), dae, hae, pae, dEe = R(() => {
      it(), hU(), hae = ee(IR)(dae || (dae = $([`
  --popover-outer-stroke: #e11c1c;
  --popover-inner-stroke: #2c1c1c;
  --popover-bg: #2c1c1c;
  pointer-events: none !important;
`]))), pae = hae;
    }), hEe = J((r, s) => {
      var a, d;
      a = [], d = [];
      function m(y, x, w) {
        var T, P, M, F, O, N, B, U;
        if (y === x) return 0;
        if (T = y.length, P = x.length, T === 0) return P;
        if (P === 0) return T;
        for (w && (y = y.toLowerCase(), x = x.toLowerCase()), B = 0; B < T; ) d[B] = y.charCodeAt(B), a[B] = ++B;
        for (U = 0; U < P; ) for (M = x.charCodeAt(U), F = O = U++, B = -1; ++B < T; ) N = M === d[B] ? O : O + 1, O = a[B], a[B] = F = O > F ? N > F ? F + 1 : N : N > O ? O + 1 : N;
        return F;
      }
      s.exports = m;
    }), pEe = J((r, s) => {
      var a = hEe();
      function d() {
        var m, y, x, w, T, P = 0, M = arguments[0], F = arguments[1], O = F.length, N = arguments[2];
        N && (w = N.threshold, T = N.ignoreCase), w === void 0 && (w = 0);
        for (var B = 0; B < O; ++B) T ? y = a(M, F[B], !0) : y = a(M, F[B]), y > M.length ? m = 1 - y / F[B].length : m = 1 - y / M.length, m > P && (P = m, x = F[B]);
        return P >= w ? x : null;
      }
      s.exports = d;
    });
    function fEe(r, s, a = "Did you mean ", d = "?") {
      let m = (0, fae.default)(r, s, { threshold: 0.7 });
      return m ? a + JSON.stringify(m) + d : "";
    }
    var fae, mEe = R(() => {
      fae = Y(pEe());
    });
    function mae(r, s) {
      return r.length <= s ? r : r.substr(0, s - 3) + "...";
    }
    var gEe = R(() => {
    }), gae, pU, yae = R(() => {
      gEe(), gae = (r) => typeof r == "string" ? 'string("'.concat(mae(r, 10), '")') : typeof r == "number" ? "number(".concat(mae(String(r), 10), ")") : r === null ? "null" : r === void 0 ? "undefined" : typeof r == "boolean" ? String(r) : Array.isArray(r) ? "array" : typeof r == "object" ? "object" : "unknown", pU = gae;
    }), vae, bae, fU, xae = R(() => {
      it(), hU(), bae = ee(IR)(vae || (vae = $([`
  padding: 6px;
`]))), fU = bae;
    }), _ae, Sae, mU, wae = R(() => {
      it(), im(), Sae = ee(Aq)(_ae || (_ae = $([`
  display: flex;
  height: fit-content;
  backdrop-filter: blur(14px);
  border-radius: 2px;
`]))), mU = Sae;
    }), fv, Eae, Tae, Cae, wS, NR = R(() => {
      it(), Xn(), fv = Y(xe()), UM(), Kk(), xae(), wae(), Tae = ee.button(Eae || (Eae = $([`
  `, `;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  font-weight: 600;
  width: 32px;
  height: 32px;
  outline: none;

  color: #a8a8a9;

  background: rgba(40, 43, 47, 0.8);
  backdrop-filter: blur(14px);
  border: none;
  border-bottom: 1px solid rgba(255, 255, 255, 0.08);
  border-radius: 2px;

  svg {
    display: block;
  }

  &:hover {
    background: rgba(59, 63, 69, 0.8);
  }

  &:active {
    background: rgba(82, 88, 96, 0.8);
  }

  &.selected {
    color: rgba(255, 255, 255, 0.8);
    border-bottom: 1px solid rgba(255, 255, 255, 0.7);
  }

  // Don't blur if in a button group, because it already blurs. We need to blur
  // on the group-level, otherwise we get seams.
  `, ` > & {
    backdrop-filter: none;
    filter: none;
    border-radius: 0;

    &:first-child {
      border-top-left-radius: 2px;
      border-bottom-left-radius: 2px;
    }

    &:last-child {
      border-bottom-right-radius: 2px;
      border-top-right-radius: 2px;
    }
  }

  @supports not (backdrop-filter: blur()) {
    background: rgba(40, 43, 47, 0.95);
  }
`])), Ln, mU), Cae = fv.default.forwardRef((r, s) => {
        var a = r, { title: d } = a, m = re(a, ["title"]);
        let [y, x] = LM({ enabled: typeof d == "string" }, () => fv.default.createElement(fU, null, d));
        return fv.default.createElement(fv.default.Fragment, null, y, fv.default.createElement(Tae, L({ ref: Wk([x, s]) }, m)), " ");
      }), wS = Cae;
    }), Pae, Aae, kae, Mae, Rae, yEe = R(() => {
      Pae = Y(xe()), NR(), it(), Xn(), kae = ee(wS)(Aae || (Aae = $([`
  `, `;
  & > svg {
    width: 1em;
    height: 1em;
    pointer-events: none;
  }
`])), Ln), Mae = ({ config: r, testId: s }) => {
        var a;
        return Pae.default.createElement(kae, { onClick: r.onClick, "data-testid": s, title: r.title, dangerouslySetInnerHTML: { __html: (a = r.svgSource) != null ? a : "" } });
      }, Rae = Mae;
    });
    function vEe({ value: r, label: s, icon: a, onClick: d, isSelected: m }) {
      return mv.default.createElement(mv.default.Fragment, null, mv.default.createElement(wS, { forwardedAs: Tq, className: m ? "selected" : void 0, "aria-label": s, onClick: d, title: s }, a));
    }
    var mv, Iae, Nae, bEe = R(() => {
      mv = Y(xe()), im(), NR(), wae(), Iae = ({ value: r, onChange: s, options: a }) => mv.default.createElement(mU, null, a.map(({ label: d, icon: m, value: y }) => mv.default.createElement(vEe, { key: y, value: y, isSelected: r === y, label: d, icon: m, onClick: () => s(y) }))), Nae = Iae;
    }), gU, Oae, Dae, Fae, Bae, xEe = R(() => {
      gU = Y(xe()), it(), Xn(), bEe(), Dae = ee.div(Oae || (Oae = $([`
  `, `;
  & > svg {
    width: 1em;
    height: 1em;
    pointer-events: none;
  }
`])), Ln), Fae = ({ config: r }) => gU.default.createElement(Nae, { onChange: r.onChange, options: r.options.map(({ label: s, value: a, svgSource: d }) => ({ label: s, value: a, icon: gU.default.createElement(Dae, { dangerouslySetInnerHTML: { __html: d } }) })), value: r.value }), Bae = Fae;
    }), ES, Lae, jae, Uae, zae, _Ee = R(() => {
      ES = Y(xe()), it(), Xn(), NR(), M9(), Dl(), jae = ee.div(Lae || (Lae = $([`
  `, `;
  & > svg {
    width: 1em;
    height: 1em;
    pointer-events: none;
  }
`])), Ln), Uae = ({ config: r }) => {
        let s = (0, ES.useRef)(null), a = ko(() => {
          let d = s.current.getBoundingClientRect();
          return { debugName: "ExtensionFlyoutMenu:" + r.label, constraints: { maxX: d.right, maxY: 8, minX: d.left, minY: 8 }, verticalGap: 2 };
        }, () => ES.default.createElement(OL, { items: r.items.map((d, m) => ({ label: d.label, callback: () => {
          var y;
          try {
            (y = d.onClick) == null || y.call(d);
          } catch (x) {
            console.error(x);
          }
        } })), onRequestClose: () => {
          a.close("clicked");
        } }));
        return ES.default.createElement(jae, null, a.node, ES.default.createElement(wS, { ref: s, onClick: (d) => {
          a.open(d, s.current);
        } }, r.label));
      }, zae = Uae;
    });
    function SEe(r) {
      return yU[r];
    }
    var TS, Vae, yU, Gae, qae, wEe = R(() => {
      mEe(), yae(), TS = Y(xe()), yEe(), xEe(), _Ee(), Vae = (r) => TS.default.createElement(TS.default.Fragment, null, r.config.map((s, a) => TS.default.createElement(Gae, { config: s, key: a }))), yU = { Icon: Rae, Switch: Bae, Flyout: zae }, Gae = ({ config: r }) => {
        let s = SEe(r.type);
        if (!s) throw new Error("No tool with tool.type ".concat(pU(r.type), " exists. Did you mean ").concat(fEe(r.type, Object.keys(yU))));
        return TS.default.createElement(s, { config: r });
      }, qae = Vae;
    }), Hae, tc, $ae, Wae, Kae, vU, Yae, Xae, bU, Qae = R(() => {
      Hae = ut(), zt(), st(), tc = Y(xe()), it(), wEe(), Wae = ee.div($ae || ($ae = $([`
  height: 36px;
  /* pointer-events: none; */

  display: flex;
  gap: 0.5rem;
  justify-content: center;
`]))), vU = ee.div(Kae || (Kae = $([`
  position: abolute;
  height: 32px;
  width: 1px;
  background: #373b40;
  opacity: 0.4;
`]))), Yae = ({ extension: r, toolbarId: s }) => {
        var a;
        let d = (0, tc.useMemo)(() => new Hae.Atom([]), []), m = (a = r.toolbars) == null ? void 0 : a[s];
        (0, tc.useLayoutEffect)(() => {
          let x = m?.(d.set.bind(d), pe().publicApi);
          if (typeof x == "function") return x;
        }, [r, s, m]);
        let y = nn(d.prism);
        return tc.default.createElement(qae, { config: y });
      }, Xae = ({ toolbarId: r, showLeftDivider: s }) => {
        var a;
        let d = [], m = nn(pe().atomP.ephemeral.extensions.byId), y = !1;
        for (let [, x] of Object.entries(m)) !x || !((a = x.toolbars) != null && a[r]) || (d.push(tc.default.createElement(tc.default.Fragment, { key: "extensionToolbar-" + x.id }, y ? tc.default.createElement(vU, null) : void 0, tc.default.createElement(Yae, { extension: x, toolbarId: r }))), y = !0);
        return d.length === 0 ? null : tc.default.createElement(Wae, { "data-testid": "theatre-extensionToolbar-".concat(r) }, s ? tc.default.createElement(vU, null) : void 0, d);
      }, bU = Xae;
    }), CS, Zae, Jae, ele, tle, EEe = R(() => {
      it(), CS = Y(xe()), NR(), Jae = ee(wS)(Zae || (Zae = $([`
  color: `, `;

  border-bottom: 1px solid
    `, `;
`])), ({ pinned: r }) => r ? "rgba(255, 255, 255, 0.8)" : "#A8A8A9", ({ pinned: r }) => r ? "rgba(255, 255, 255, 0.7)" : "rgba(255, 255, 255, 0.08)"), ele = (0, CS.forwardRef)((r, s) => {
        var a = r, { children: d, hint: m, pinned: y, icon: x, pinHintIcon: w, unpinHintIcon: T } = a, P = re(a, ["children", "hint", "pinned", "icon", "pinHintIcon", "unpinHintIcon"]);
        let [M, F] = (0, CS.useState)(!1), O = M || m;
        return CS.default.createElement(Jae, V(L({}, P), { pinned: y, ref: s, onMouseOver: () => F(!0), onMouseOut: () => F(!1) }), CS.default.createElement("div", { style: { pointerEvents: "none", width: "fit-content", height: "fit-content", inset: 0 } }, O && !y ? w : O && y ? T : x), d);
      }), tle = ele;
    });
    function TEe(r) {
      return xU.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), xU.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.732 4.048l-.792-.792L7.2 8l4.74 4.744.792-.792L8.781 8l3.951-3.952zm-3.932 0l-.792-.792L3.268 8l4.74 4.744.792-.792L4.848 8 8.8 4.048z", fill: "currentColor" }));
    }
    var xU, nle, CEe = R(() => {
      xU = Y(xe()), nle = TEe;
    });
    function PEe(r) {
      return _U.createElement("svg", L({ width: 16, height: 16, viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, r), _U.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M3.694 3.765l.792-.792 4.74 4.744-4.74 4.744-.792-.793 3.951-3.951-3.951-3.952zm3.932 0l.792-.792 4.74 4.744-4.74 4.744-.792-.793 3.952-3.951-3.952-3.952z", fill: "currentColor" }));
    }
    var _U, rle, AEe = R(() => {
      _U = Y(xe()), rle = PEe;
    }), Pi, ile, sle, ole, SU, ale, lp, lle, ule, cle, dle, hle, ple, fle, mle, gle, OR, yle, vle, wU, EU, ble, xle, kEe = R(() => {
      zt(), st(), Pi = Y(xe()), it(), sle = ee.div(ile || (ile = $([`
  width: 138px;
  border-radius: 2px;
  background-color: rgba(42, 45, 50, 0.9);
  position: absolute;
  display: flex;
  flex-direction: column;
  align-items: stretch;
  justify-content: flex-start;
  box-shadow: 0px 1px 1px rgba(0, 0, 0, 0.25), 0px 2px 6px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(14px);
  pointer-events: auto;
  // makes the edges of the item highlights match the rounded corners
  overflow: hidden;

  @supports not (backdrop-filter: blur()) {
    background-color: rgba(42, 45, 50, 0.98);
  }

  color: rgba(255, 255, 255, 0.9);

  & a {
    // Fix colors of links to not be default
    color: inherit;
  }
`]))), SU = ee.div(ole || (ole = $([`
  position: relative;
  padding: 0px 12px;
  font-weight: 400;
  font-size: 11px;
  height: 32px;
  text-decoration: none;
  user-select: none;
  display: flex;
  flex-direction: row;
  align-items: center;
  cursor: default;
`]))), lp = ee(SU)(ale || (ale = $([`
  &:before {
    position: absolute;
    display: block;
    content: ' ';
    inset: 3px;
    border-radius: 3px;
    background: rgba(255, 255, 255, 0.1);
    opacity: 0;
  }

  &.secondary {
    color: rgba(255, 255, 255, 0.5);
  }

  &:hover {
    /* background-color: #398995; */
    color: white !important;
    &:before {
      opacity: 1;
    }
  }
`]))), ule = ee(SU)(lle || (lle = $([`
  height: auto;
  min-height: 32px;
  padding-top: 12px;
  padding-bottom: 10px;
  flex-direction: column;
  justify-content: flex-start;
  align-items: stretch;
  gap: 8px;
  color: rgba(255, 255, 255, 0.5);
`]))), dle = ee.div(cle || (cle = $([`
  font-weight: 600;
`]))), ple = ee.div(hle || (hle = $([`
  display: flex;
  flex-direction: row;
  justify-content: space-between;
`]))), mle = ee.div(fle || (fle = $([`
  margin-left: 2px;
`]))), OR = ee.div(gle || (gle = $([`
  height: 1px;
  margin: 0 2px;
  background: rgba(255, 255, 255, 0.02);
`]))), vle = ee.div(yle || (yle = $([`
  position: absolute;
  width: 8px;
  height: 8px;
  background: #40aaa4;
  right: 14px;
  top: 12px;
  border-radius: 50%;
`]))), wU = "1.0.19", EU = wU.match(/^[^\-]+/)[0], ble = Pi.default.forwardRef((r, s) => {
        let a = nn(pe().atomP.ahistoric.updateChecker.result.hasUpdates);
        return Pi.default.createElement(sle, { ref: s }, Pi.default.createElement(lp, { as: "a", href: "https://www.theatrejs.com/docs/latest", className: "", target: "_blank" }, "Docs"), Pi.default.createElement(lp, { as: "a", href: "https://www.theatrejs.com/docs/latest/releases", className: "", target: "_blank" }, "Changelog"), Pi.default.createElement(OR, null), Pi.default.createElement(lp, { as: "a", href: "https://github.com/theatre-js/theatre", className: "", target: "_blank" }, "Github"), Pi.default.createElement(lp, { as: "a", href: "https://twitter.com/theatre_js", className: "", target: "_blank" }, "Twitter"), Pi.default.createElement(lp, { className: "", as: "a", href: "https://discord.gg/bm9f8F9Y9N", target: "_blank" }, "Discord"), Pi.default.createElement(OR, null), Pi.default.createElement(ule, null, Pi.default.createElement(dle, null, "Version"), Pi.default.createElement(ple, null, Pi.default.createElement(mle, null, wU, " ", a === !0 ? "(outdated)" : a === !1 ? "(latest)" : ""))), a === !0 && Pi.default.createElement(Pi.default.Fragment, null, Pi.default.createElement(OR, null), Pi.default.createElement(lp, { as: "a", href: "https://www.theatrejs.com/docs/latest/releases".concat(encodeURIComponent(EU)), className: "", target: "_blank" }, "Update", Pi.default.createElement(vle, null)), Pi.default.createElement(lp, { as: "a", href: "https://www.theatrejs.com/docs/latest/releases#".concat(encodeURIComponent(EU)), className: "", target: "_blank" }, "What's new?")));
      }), xle = ble;
    }), TU, DR, _le, CU, Sle, wle, PS, Ele, PU, Tle, FR, AS, kS, up, Cle, Ple, Ale, gv, Do, kle, Mle, Rle, AU, MEe = R(() => {
      TU = Y(xe(), 1), DR = Y(xe(), 1), _le = (r) => typeof r == "function", CU = (r, s) => _le(r) ? r(s) : r, Sle = /* @__PURE__ */ (() => {
        let r = 0;
        return () => (++r).toString();
      })(), wle = 20, PS = /* @__PURE__ */ new Map(), Ele = 1e3, PU = (r) => {
        if (PS.has(r)) return;
        let s = setTimeout(() => {
          PS.delete(r), up({ type: 4, toastId: r });
        }, Ele);
        PS.set(r, s);
      }, Tle = (r) => {
        let s = PS.get(r);
        s && clearTimeout(s);
      }, FR = (r, s) => {
        switch (s.type) {
          case 0:
            return V(L({}, r), { toasts: [s.toast, ...r.toasts].slice(0, wle) });
          case 1:
            return s.toast.id && Tle(s.toast.id), V(L({}, r), { toasts: r.toasts.map((y) => y.id === s.toast.id ? L(L({}, y), s.toast) : y) });
          case 2:
            let { toast: a } = s;
            return r.toasts.find((y) => y.id === a.id) ? FR(r, { type: 1, toast: a }) : FR(r, { type: 0, toast: a });
          case 3:
            let { toastId: d } = s;
            return d ? PU(d) : r.toasts.forEach((y) => {
              PU(y.id);
            }), V(L({}, r), { toasts: r.toasts.map((y) => y.id === d || d === void 0 ? V(L({}, y), { visible: !1 }) : y) });
          case 4:
            return s.toastId === void 0 ? V(L({}, r), { toasts: [] }) : V(L({}, r), { toasts: r.toasts.filter((y) => y.id !== s.toastId) });
          case 5:
            return V(L({}, r), { pausedAt: s.time });
          case 6:
            let m = s.time - (r.pausedAt || 0);
            return V(L({}, r), { pausedAt: void 0, toasts: r.toasts.map((y) => V(L({}, y), { pauseDuration: y.pauseDuration + m })) });
        }
      }, AS = [], kS = { toasts: [], pausedAt: void 0 }, up = (r) => {
        kS = FR(kS, r), AS.forEach((s) => {
          s(kS);
        });
      }, Cle = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Ple = (r = {}) => {
        let [s, a] = (0, TU.useState)(kS);
        (0, TU.useEffect)(() => (AS.push(a), () => {
          let m = AS.indexOf(a);
          m > -1 && AS.splice(m, 1);
        }), [s]);
        let d = s.toasts.map((m) => {
          var y, x;
          return V(L(L(L({}, r), r[m.type]), m), { duration: m.duration || ((y = r[m.type]) == null ? void 0 : y.duration) || r?.duration || Cle[m.type], style: L(L(L({}, r.style), (x = r[m.type]) == null ? void 0 : x.style), m.style) });
        });
        return V(L({}, s), { toasts: d });
      }, Ale = (r, s = "blank", a) => V(L({ createdAt: Date.now(), visible: !0, type: s, ariaProps: { role: "status", "aria-live": "polite" }, message: r, pauseDuration: 0 }, a), { id: a?.id || Sle() }), gv = (r) => (s, a) => {
        let d = Ale(s, r, a);
        return up({ type: 2, toast: d }), d.id;
      }, Do = (r, s) => gv("blank")(r, s), Do.error = gv("error"), Do.success = gv("success"), Do.loading = gv("loading"), Do.custom = gv("custom"), Do.dismiss = (r) => {
        up({ type: 3, toastId: r });
      }, Do.remove = (r) => up({ type: 4, toastId: r }), Do.promise = (r, s, a) => {
        let d = Do.loading(s.loading, L(L({}, a), a?.loading));
        return r.then((m) => (Do.success(CU(s.success, m), L(L({ id: d }, a), a?.success)), m)).catch((m) => {
          Do.error(CU(s.error, m), L(L({ id: d }, a), a?.error));
        }), r;
      }, kle = (r, s) => {
        up({ type: 1, toast: { id: r, height: s } });
      }, Mle = () => {
        up({ type: 5, time: Date.now() });
      }, Rle = (r) => {
        let { toasts: s, pausedAt: a } = Ple(r);
        (0, DR.useEffect)(() => {
          if (a) return;
          let y = Date.now(), x = s.map((w) => {
            if (w.duration === 1 / 0) return;
            let T = (w.duration || 0) + w.pauseDuration - (y - w.createdAt);
            if (T < 0) {
              w.visible && Do.dismiss(w.id);
              return;
            }
            return setTimeout(() => Do.dismiss(w.id), T);
          });
          return () => {
            x.forEach((w) => w && clearTimeout(w));
          };
        }, [s, a]);
        let d = (0, DR.useCallback)(() => {
          a && up({ type: 6, time: Date.now() });
        }, [a]), m = (0, DR.useCallback)((y, x) => {
          let { reverseOrder: w = !1, gutter: T = 8, defaultPosition: P } = x || {}, M = s.filter((N) => (N.position || P) === (y.position || P) && N.height), F = M.findIndex((N) => N.id === y.id), O = M.filter((N, B) => B < F && N.visible).length;
          return M.filter((N) => N.visible).slice(...w ? [O + 1] : [0, O]).reduce((N, B) => N + (B.height || 0) + T, 0);
        }, [s]);
        return { toasts: s, handlers: { updateHeight: kle, startPause: Mle, endPause: d, calculateOffset: m } };
      }, AU = Do;
    });
    function Ile() {
      return { async: !1, baseUrl: null, breaks: !1, extensions: null, gfm: !0, headerIds: !0, headerPrefix: "", highlight: null, langPrefix: "language-", mangle: !0, pedantic: !1, renderer: null, sanitize: !1, sanitizer: null, silent: !1, smartypants: !1, tokenizer: null, walkTokens: null, xhtml: !1 };
    }
    function REe(r) {
      Om = r;
    }
    function ts(r, s) {
      if (s) {
        if (Ule.test(r)) return r.replace(zle, kU);
      } else if (Vle.test(r)) return r.replace(Gle, kU);
      return r;
    }
    function Nle(r) {
      return r.replace(Hle, (s, a) => (a = a.toLowerCase(), a === "colon" ? ":" : a.charAt(0) === "#" ? a.charAt(1) === "x" ? String.fromCharCode(parseInt(a.substring(2), 16)) : String.fromCharCode(+a.substring(1)) : ""));
    }
    function Er(r, s) {
      r = typeof r == "string" ? r : r.source, s = s || "";
      let a = { replace: (d, m) => (m = m.source || m, m = m.replace($le, "$1"), r = r.replace(d, m), a), getRegex: () => new RegExp(r, s) };
      return a;
    }
    function Ole(r, s, a) {
      if (r) {
        let d;
        try {
          d = decodeURIComponent(Nle(a)).replace(Wle, "").toLowerCase();
        } catch {
          return null;
        }
        if (d.indexOf("javascript:") === 0 || d.indexOf("vbscript:") === 0 || d.indexOf("data:") === 0) return null;
      }
      s && !Kle.test(a) && (a = IEe(s, a));
      try {
        a = encodeURI(a).replace(/%25/g, "%");
      } catch {
        return null;
      }
      return a;
    }
    function IEe(r, s) {
      MS[" " + r] || (Yle.test(r) ? MS[" " + r] = r + "/" : MS[" " + r] = BR(r, "/", !0)), r = MS[" " + r];
      let a = r.indexOf(":") === -1;
      return s.substring(0, 2) === "//" ? a ? s : r.replace(Xle, "$1") + s : s.charAt(0) === "/" ? a ? s : r.replace(Qle, "$1") + s : r + s;
    }
    function $l(r) {
      let s = 1, a, d;
      for (; s < arguments.length; s++) {
        a = arguments[s];
        for (d in a) Object.prototype.hasOwnProperty.call(a, d) && (r[d] = a[d]);
      }
      return r;
    }
    function Dle(r, s) {
      let a = r.replace(/\|/g, (y, x, w) => {
        let T = !1, P = x;
        for (; --P >= 0 && w[P] === "\\"; ) T = !T;
        return T ? "|" : " |";
      }), d = a.split(/ \|/), m = 0;
      if (d[0].trim() || d.shift(), d.length > 0 && !d[d.length - 1].trim() && d.pop(), d.length > s) d.splice(s);
      else for (; d.length < s; ) d.push("");
      for (; m < d.length; m++) d[m] = d[m].trim().replace(/\\\|/g, "|");
      return d;
    }
    function BR(r, s, a) {
      let d = r.length;
      if (d === 0) return "";
      let m = 0;
      for (; m < d; ) {
        let y = r.charAt(d - m - 1);
        if (y === s && !a) m++;
        else if (y !== s && a) m++;
        else break;
      }
      return r.slice(0, d - m);
    }
    function NEe(r, s) {
      if (r.indexOf(s[1]) === -1) return -1;
      let a = r.length, d = 0, m = 0;
      for (; m < a; m++) if (r[m] === "\\") m++;
      else if (r[m] === s[0]) d++;
      else if (r[m] === s[1] && (d--, d < 0)) return m;
      return -1;
    }
    function Fle(r) {
      r && r.sanitize && !r.silent && console.warn("marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options");
    }
    function Ble(r, s) {
      if (s < 1) return "";
      let a = "";
      for (; s > 1; ) s & 1 && (a += r), s >>= 1, r += r;
      return a + r;
    }
    function Lle(r, s, a, d) {
      let m = s.href, y = s.title ? ts(s.title) : null, x = r[1].replace(/\\([\[\]])/g, "$1");
      if (r[0].charAt(0) !== "!") {
        d.state.inLink = !0;
        let w = { type: "link", raw: a, href: m, title: y, text: x, tokens: d.inlineTokens(x) };
        return d.state.inLink = !1, w;
      }
      return { type: "image", raw: a, href: m, title: y, text: ts(x) };
    }
    function OEe(r, s) {
      let a = r.match(/^(\s+)(?:```)/);
      if (a === null) return s;
      let d = a[1];
      return s.split(`
`).map((m) => {
        let y = m.match(/^\s+/);
        if (y === null) return m;
        let [x] = y;
        return x.length >= d.length ? m.slice(d.length) : m;
      }).join(`
`);
    }
    function DEe(r) {
      return r.replace(/---/g, "").replace(/--/g, "").replace(/(^|[-\u2014/(\[{"\s])'/g, "$1").replace(/'/g, "").replace(/(^|[-\u2014/(\[{\u2018\s])"/g, "$1").replace(/"/g, "").replace(/\.{3}/g, "");
    }
    function jle(r) {
      let s = "", a, d, m = r.length;
      for (a = 0; a < m; a++) d = r.charCodeAt(a), Math.random() > 0.5 && (d = "x" + d.toString(16)), s += "&#" + d + ";";
      return s;
    }
    function rn(r, s, a) {
      if (typeof r > "u" || r === null) throw new Error("marked(): input parameter is undefined or null");
      if (typeof r != "string") throw new Error("marked(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected");
      if (typeof s == "function" && (a = s, s = null), s = $l({}, rn.defaults, s || {}), Fle(s), a) {
        let m = s.highlight, y;
        try {
          y = Dm.lex(r, s);
        } catch (T) {
          return a(T);
        }
        let x = function(T) {
          let P;
          if (!T) try {
            s.walkTokens && rn.walkTokens(y, s.walkTokens), P = cp.parse(y, s);
          } catch (M) {
            T = M;
          }
          return s.highlight = m, T ? a(T) : a(null, P);
        };
        if (!m || m.length < 3 || (delete s.highlight, !y.length)) return x();
        let w = 0;
        rn.walkTokens(y, function(T) {
          T.type === "code" && (w++, setTimeout(() => {
            m(T.text, T.lang, function(P, M) {
              if (P) return x(P);
              M != null && M !== T.text && (T.text = M, T.escaped = !0), w--, w === 0 && x();
            });
          }, 0));
        }), w === 0 && x();
        return;
      }
      function d(m) {
        if (m.message += `
Please report this to https://github.com/markedjs/marked.`, s.silent) return "<p>An error occurred:</p><pre>" + ts(m.message + "", !0) + "</pre>";
        throw m;
      }
      try {
        let m = Dm.lex(r, s);
        if (s.walkTokens) {
          if (s.async) return Promise.all(rn.walkTokens(m, s.walkTokens)).then(() => cp.parse(m, s)).catch(d);
          rn.walkTokens(m, s.walkTokens);
        }
        return cp.parse(m, s);
      } catch (m) {
        d(m);
      }
    }
    var Om, Ule, zle, Vle, Gle, qle, kU, Hle, $le, Wle, Kle, MS, Yle, Xle, Qle, RS, LR, Yt, It, Dm, jR, MU, RU, cp, FEe = R(() => {
      Om = Ile(), Ule = /[&<>"']/, zle = /[&<>"']/g, Vle = /[<>"']|&(?!#?\w+;)/, Gle = /[<>"']|&(?!#?\w+;)/g, qle = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, kU = (r) => qle[r], Hle = /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, $le = /(^|[^\[])\^/g, Wle = /[^\w:]/g, Kle = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i, MS = {}, Yle = /^[^:]+:\/*[^/]*$/, Xle = /^([^:]+:)[\s\S]*$/, Qle = /^([^:]+:\/*[^/]*)[\s\S]*$/, RS = { exec: function() {
      } }, LR = class {
        constructor(r) {
          this.options = r || Om;
        }
        space(r) {
          let s = this.rules.block.newline.exec(r);
          if (s && s[0].length > 0) return { type: "space", raw: s[0] };
        }
        code(r) {
          let s = this.rules.block.code.exec(r);
          if (s) {
            let a = s[0].replace(/^ {1,4}/gm, "");
            return { type: "code", raw: s[0], codeBlockStyle: "indented", text: this.options.pedantic ? a : BR(a, `
`) };
          }
        }
        fences(r) {
          let s = this.rules.block.fences.exec(r);
          if (s) {
            let a = s[0], d = OEe(a, s[3] || "");
            return { type: "code", raw: a, lang: s[2] ? s[2].trim() : s[2], text: d };
          }
        }
        heading(r) {
          let s = this.rules.block.heading.exec(r);
          if (s) {
            let a = s[2].trim();
            if (/#$/.test(a)) {
              let d = BR(a, "#");
              (this.options.pedantic || !d || / $/.test(d)) && (a = d.trim());
            }
            return { type: "heading", raw: s[0], depth: s[1].length, text: a, tokens: this.lexer.inline(a) };
          }
        }
        hr(r) {
          let s = this.rules.block.hr.exec(r);
          if (s) return { type: "hr", raw: s[0] };
        }
        blockquote(r) {
          let s = this.rules.block.blockquote.exec(r);
          if (s) {
            let a = s[0].replace(/^ *>[ \t]?/gm, "");
            return { type: "blockquote", raw: s[0], tokens: this.lexer.blockTokens(a, []), text: a };
          }
        }
        list(r) {
          let s = this.rules.block.list.exec(r);
          if (s) {
            let a, d, m, y, x, w, T, P, M, F, O, N, B = s[1].trim(), U = B.length > 1, H = { type: "list", raw: "", ordered: U, start: U ? +B.slice(0, -1) : "", loose: !1, items: [] };
            B = U ? "\\d{1,9}\\".concat(B.slice(-1)) : "\\".concat(B), this.options.pedantic && (B = U ? B : "[*+-]");
            let W = new RegExp("^( {0,3}".concat(B, ")((?:[	 ][^\\n]*)?(?:\\n|$))"));
            for (; r && (N = !1, !(!(s = W.exec(r)) || this.rules.block.hr.test(r))); ) {
              if (a = s[0], r = r.substring(a.length), P = s[2].split(`
`, 1)[0], M = r.split(`
`, 1)[0], this.options.pedantic ? (y = 2, O = P.trimLeft()) : (y = s[2].search(/[^ ]/), y = y > 4 ? 1 : y, O = P.slice(y), y += s[1].length), w = !1, !P && /^ *$/.test(M) && (a += M + `
`, r = r.substring(M.length + 1), N = !0), !N) {
                let ne = new RegExp("^ {0,".concat(Math.min(3, y - 1), "}(?:[*+-]|\\d{1,9}[.)])((?: [^\\n]*)?(?:\\n|$))")), ce = new RegExp("^ {0,".concat(Math.min(3, y - 1), "}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)")), ue = new RegExp("^ {0,".concat(Math.min(3, y - 1), "}(?:```|~~~)")), se = new RegExp("^ {0,".concat(Math.min(3, y - 1), "}#"));
                for (; r && (F = r.split(`
`, 1)[0], P = F, this.options.pedantic && (P = P.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), !(ue.test(P) || se.test(P) || ne.test(P) || ce.test(r))); ) {
                  if (P.search(/[^ ]/) >= y || !P.trim()) O += `
` + P.slice(y);
                  else if (!w) O += `
` + P;
                  else break;
                  !w && !P.trim() && (w = !0), a += F + `
`, r = r.substring(F.length + 1);
                }
              }
              H.loose || (T ? H.loose = !0 : /\n *\n *$/.test(a) && (T = !0)), this.options.gfm && (d = /^\[[ xX]\] /.exec(O), d && (m = d[0] !== "[ ] ", O = O.replace(/^\[[ xX]\] +/, ""))), H.items.push({ type: "list_item", raw: a, task: !!d, checked: m, loose: !1, text: O }), H.raw += a;
            }
            H.items[H.items.length - 1].raw = a.trimRight(), H.items[H.items.length - 1].text = O.trimRight(), H.raw = H.raw.trimRight();
            let Q = H.items.length;
            for (x = 0; x < Q; x++) {
              this.lexer.state.top = !1, H.items[x].tokens = this.lexer.blockTokens(H.items[x].text, []);
              let ne = H.items[x].tokens.filter((ue) => ue.type === "space"), ce = ne.every((ue) => {
                let se = ue.raw.split(""), Oe = 0;
                for (let he of se) if (he === `
` && (Oe += 1), Oe > 1) return !0;
                return !1;
              });
              !H.loose && ne.length && ce && (H.loose = !0, H.items[x].loose = !0);
            }
            return H;
          }
        }
        html(r) {
          let s = this.rules.block.html.exec(r);
          if (s) {
            let a = { type: "html", raw: s[0], pre: !this.options.sanitizer && (s[1] === "pre" || s[1] === "script" || s[1] === "style"), text: s[0] };
            if (this.options.sanitize) {
              let d = this.options.sanitizer ? this.options.sanitizer(s[0]) : ts(s[0]);
              a.type = "paragraph", a.text = d, a.tokens = this.lexer.inline(d);
            }
            return a;
          }
        }
        def(r) {
          let s = this.rules.block.def.exec(r);
          if (s) return s[3] && (s[3] = s[3].substring(1, s[3].length - 1)), { type: "def", tag: s[1].toLowerCase().replace(/\s+/g, " "), raw: s[0], href: s[2], title: s[3] };
        }
        table(r) {
          let s = this.rules.block.table.exec(r);
          if (s) {
            let a = { type: "table", header: Dle(s[1]).map((d) => ({ text: d })), align: s[2].replace(/^ *|\| *$/g, "").split(/ *\| */), rows: s[3] && s[3].trim() ? s[3].replace(/\n[ \t]*$/, "").split(`
`) : [] };
            if (a.header.length === a.align.length) {
              a.raw = s[0];
              let d = a.align.length, m, y, x, w;
              for (m = 0; m < d; m++) /^ *-+: *$/.test(a.align[m]) ? a.align[m] = "right" : /^ *:-+: *$/.test(a.align[m]) ? a.align[m] = "center" : /^ *:-+ *$/.test(a.align[m]) ? a.align[m] = "left" : a.align[m] = null;
              for (d = a.rows.length, m = 0; m < d; m++) a.rows[m] = Dle(a.rows[m], a.header.length).map((T) => ({ text: T }));
              for (d = a.header.length, y = 0; y < d; y++) a.header[y].tokens = this.lexer.inline(a.header[y].text);
              for (d = a.rows.length, y = 0; y < d; y++) for (w = a.rows[y], x = 0; x < w.length; x++) w[x].tokens = this.lexer.inline(w[x].text);
              return a;
            }
          }
        }
        lheading(r) {
          let s = this.rules.block.lheading.exec(r);
          if (s) return { type: "heading", raw: s[0], depth: s[2].charAt(0) === "=" ? 1 : 2, text: s[1], tokens: this.lexer.inline(s[1]) };
        }
        paragraph(r) {
          let s = this.rules.block.paragraph.exec(r);
          if (s) {
            let a = s[1].charAt(s[1].length - 1) === `
` ? s[1].slice(0, -1) : s[1];
            return { type: "paragraph", raw: s[0], text: a, tokens: this.lexer.inline(a) };
          }
        }
        text(r) {
          let s = this.rules.block.text.exec(r);
          if (s) return { type: "text", raw: s[0], text: s[0], tokens: this.lexer.inline(s[0]) };
        }
        escape(r) {
          let s = this.rules.inline.escape.exec(r);
          if (s) return { type: "escape", raw: s[0], text: ts(s[1]) };
        }
        tag(r) {
          let s = this.rules.inline.tag.exec(r);
          if (s) return !this.lexer.state.inLink && /^<a /i.test(s[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(s[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(s[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(s[0]) && (this.lexer.state.inRawBlock = !1), { type: this.options.sanitize ? "text" : "html", raw: s[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(s[0]) : ts(s[0]) : s[0] };
        }
        link(r) {
          let s = this.rules.inline.link.exec(r);
          if (s) {
            let a = s[2].trim();
            if (!this.options.pedantic && /^</.test(a)) {
              if (!/>$/.test(a)) return;
              let y = BR(a.slice(0, -1), "\\");
              if ((a.length - y.length) % 2 === 0) return;
            } else {
              let y = NEe(s[2], "()");
              if (y > -1) {
                let x = (s[0].indexOf("!") === 0 ? 5 : 4) + s[1].length + y;
                s[2] = s[2].substring(0, y), s[0] = s[0].substring(0, x).trim(), s[3] = "";
              }
            }
            let d = s[2], m = "";
            if (this.options.pedantic) {
              let y = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(d);
              y && (d = y[1], m = y[3]);
            } else m = s[3] ? s[3].slice(1, -1) : "";
            return d = d.trim(), /^</.test(d) && (this.options.pedantic && !/>$/.test(a) ? d = d.slice(1) : d = d.slice(1, -1)), Lle(s, { href: d && d.replace(this.rules.inline._escapes, "$1"), title: m && m.replace(this.rules.inline._escapes, "$1") }, s[0], this.lexer);
          }
        }
        reflink(r, s) {
          let a;
          if ((a = this.rules.inline.reflink.exec(r)) || (a = this.rules.inline.nolink.exec(r))) {
            let d = (a[2] || a[1]).replace(/\s+/g, " ");
            if (d = s[d.toLowerCase()], !d || !d.href) {
              let m = a[0].charAt(0);
              return { type: "text", raw: m, text: m };
            }
            return Lle(a, d, a[0], this.lexer);
          }
        }
        emStrong(r, s, a = "") {
          let d = this.rules.inline.emStrong.lDelim.exec(r);
          if (!d || d[3] && a.match(/[\p{L}\p{N}]/u)) return;
          let m = d[1] || d[2] || "";
          if (!m || m && (a === "" || this.rules.inline.punctuation.exec(a))) {
            let y = d[0].length - 1, x, w, T = y, P = 0, M = d[0][0] === "*" ? this.rules.inline.emStrong.rDelimAst : this.rules.inline.emStrong.rDelimUnd;
            for (M.lastIndex = 0, s = s.slice(-1 * r.length + y); (d = M.exec(s)) != null; ) {
              if (x = d[1] || d[2] || d[3] || d[4] || d[5] || d[6], !x) continue;
              if (w = x.length, d[3] || d[4]) {
                T += w;
                continue;
              } else if ((d[5] || d[6]) && y % 3 && !((y + w) % 3)) {
                P += w;
                continue;
              }
              if (T -= w, T > 0) continue;
              if (w = Math.min(w, w + T + P), Math.min(y, w) % 2) {
                let O = r.slice(1, y + d.index + w);
                return { type: "em", raw: r.slice(0, y + d.index + w + 1), text: O, tokens: this.lexer.inlineTokens(O) };
              }
              let F = r.slice(2, y + d.index + w - 1);
              return { type: "strong", raw: r.slice(0, y + d.index + w + 1), text: F, tokens: this.lexer.inlineTokens(F) };
            }
          }
        }
        codespan(r) {
          let s = this.rules.inline.code.exec(r);
          if (s) {
            let a = s[2].replace(/\n/g, " "), d = /[^ ]/.test(a), m = /^ /.test(a) && / $/.test(a);
            return d && m && (a = a.substring(1, a.length - 1)), a = ts(a, !0), { type: "codespan", raw: s[0], text: a };
          }
        }
        br(r) {
          let s = this.rules.inline.br.exec(r);
          if (s) return { type: "br", raw: s[0] };
        }
        del(r) {
          let s = this.rules.inline.del.exec(r);
          if (s) return { type: "del", raw: s[0], text: s[2], tokens: this.lexer.inlineTokens(s[2]) };
        }
        autolink(r, s) {
          let a = this.rules.inline.autolink.exec(r);
          if (a) {
            let d, m;
            return a[2] === "@" ? (d = ts(this.options.mangle ? s(a[1]) : a[1]), m = "mailto:" + d) : (d = ts(a[1]), m = d), { type: "link", raw: a[0], text: d, href: m, tokens: [{ type: "text", raw: d, text: d }] };
          }
        }
        url(r, s) {
          let a;
          if (a = this.rules.inline.url.exec(r)) {
            let d, m;
            if (a[2] === "@") d = ts(this.options.mangle ? s(a[0]) : a[0]), m = "mailto:" + d;
            else {
              let y;
              do
                y = a[0], a[0] = this.rules.inline._backpedal.exec(a[0])[0];
              while (y !== a[0]);
              d = ts(a[0]), a[1] === "www." ? m = "http://" + d : m = d;
            }
            return { type: "link", raw: a[0], text: d, href: m, tokens: [{ type: "text", raw: d, text: d }] };
          }
        }
        inlineText(r, s) {
          let a = this.rules.inline.text.exec(r);
          if (a) {
            let d;
            return this.lexer.state.inRawBlock ? d = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(a[0]) : ts(a[0]) : a[0] : d = ts(this.options.smartypants ? s(a[0]) : a[0]), { type: "text", raw: a[0], text: d };
          }
        }
      }, Yt = { newline: /^(?: *(?:\n|$))+/, code: /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, fences: /^ {0,3}(`{3,}(?=[^`\n]*\n)|~{3,})([^\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?=\n|$)|$)/, hr: /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, heading: /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/, list: /^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/, html: "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", def: /^ {0,3}\[(label)\]: *(?:\n *)?<?([^\s>]+)>?(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/, table: RS, lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/, _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, text: /^[^\n]+/ }, Yt._label = /(?!\s*\])(?:\\.|[^\[\]\\])+/, Yt._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/, Yt.def = Er(Yt.def).replace("label", Yt._label).replace("title", Yt._title).getRegex(), Yt.bullet = /(?:[*+-]|\d{1,9}[.)])/, Yt.listItemStart = Er(/^( *)(bull) */).replace("bull", Yt.bullet).getRegex(), Yt.list = Er(Yt.list).replace(/bull/g, Yt.bullet).replace("hr", "\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def", "\\n+(?=" + Yt.def.source + ")").getRegex(), Yt._tag = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", Yt._comment = /<!--(?!-?>)[\s\S]*?(?:-->|$)/, Yt.html = Er(Yt.html, "i").replace("comment", Yt._comment).replace("tag", Yt._tag).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), Yt.paragraph = Er(Yt._paragraph).replace("hr", Yt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Yt._tag).getRegex(), Yt.blockquote = Er(Yt.blockquote).replace("paragraph", Yt.paragraph).getRegex(), Yt.normal = $l({}, Yt), Yt.gfm = $l({}, Yt.normal, { table: "^ *([^\\n ].*\\|.*)\\n {0,3}(?:\\| *)?(:?-+:? *(?:\\| *:?-+:? *)*)(?:\\| *)?(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)" }), Yt.gfm.table = Er(Yt.gfm.table).replace("hr", Yt.hr).replace("heading", " {0,3}#{1,6} ").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Yt._tag).getRegex(), Yt.gfm.paragraph = Er(Yt._paragraph).replace("hr", Yt.hr).replace("heading", " {0,3}#{1,6} ").replace("|lheading", "").replace("table", Yt.gfm.table).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", Yt._tag).getRegex(), Yt.pedantic = $l({}, Yt.normal, { html: Er(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", Yt._comment).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: RS, paragraph: Er(Yt.normal._paragraph).replace("hr", Yt.hr).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", Yt.lheading).replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").getRegex() }), It = { escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/, url: RS, tag: "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>", link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/, reflink: /^!?\[(label)\]\[(ref)\]/, nolink: /^!?\[(ref)\](?:\[\])?/, reflinkSearch: "reflink|nolink(?!\\()", emStrong: { lDelim: /^(?:\*+(?:([punct_])|[^\s*]))|^_+(?:([punct*])|([^\s_]))/, rDelimAst: /^[^_*]*?\_\_[^_*]*?\*[^_*]*?(?=\_\_)|[^*]+(?=[^*])|[punct_](\*+)(?=[\s]|$)|[^punct*_\s](\*+)(?=[punct_\s]|$)|[punct_\s](\*+)(?=[^punct*_\s])|[\s](\*+)(?=[punct_])|[punct_](\*+)(?=[punct_])|[^punct*_\s](\*+)(?=[^punct*_\s])/, rDelimUnd: /^[^_*]*?\*\*[^_*]*?\_[^_*]*?(?=\*\*)|[^_]+(?=[^_])|[punct*](\_+)(?=[\s]|$)|[^punct*_\s](\_+)(?=[punct*\s]|$)|[punct*\s](\_+)(?=[^punct*_\s])|[\s](\_+)(?=[punct*])|[punct*](\_+)(?=[punct*])/ }, code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, br: /^( {2,}|\\)\n(?!\s*$)/, del: RS, text: /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, punctuation: /^([\spunctuation])/ }, It._punctuation = "!\"#$%&'()+\\-.,/:;<=>?@\\[\\]`^{|}~", It.punctuation = Er(It.punctuation).replace(/punctuation/g, It._punctuation).getRegex(), It.blockSkip = /\[[^\]]*?\]\([^\)]*?\)|`[^`]*?`|<[^>]*?>/g, It.escapedEmSt = /\\\*|\\_/g, It._comment = Er(Yt._comment).replace("(?:-->|$)", "-->").getRegex(), It.emStrong.lDelim = Er(It.emStrong.lDelim).replace(/punct/g, It._punctuation).getRegex(), It.emStrong.rDelimAst = Er(It.emStrong.rDelimAst, "g").replace(/punct/g, It._punctuation).getRegex(), It.emStrong.rDelimUnd = Er(It.emStrong.rDelimUnd, "g").replace(/punct/g, It._punctuation).getRegex(), It._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g, It._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/, It._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/, It.autolink = Er(It.autolink).replace("scheme", It._scheme).replace("email", It._email).getRegex(), It._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/, It.tag = Er(It.tag).replace("comment", It._comment).replace("attribute", It._attribute).getRegex(), It._label = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, It._href = /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/, It._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/, It.link = Er(It.link).replace("label", It._label).replace("href", It._href).replace("title", It._title).getRegex(), It.reflink = Er(It.reflink).replace("label", It._label).replace("ref", Yt._label).getRegex(), It.nolink = Er(It.nolink).replace("ref", Yt._label).getRegex(), It.reflinkSearch = Er(It.reflinkSearch, "g").replace("reflink", It.reflink).replace("nolink", It.nolink).getRegex(), It.normal = $l({}, It), It.pedantic = $l({}, It.normal, { strong: { start: /^__|\*\*/, middle: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, endAst: /\*\*(?!\*)/g, endUnd: /__(?!_)/g }, em: { start: /^_|\*/, middle: /^()\*(?=\S)([\s\S]*?\S)\*(?!\*)|^_(?=\S)([\s\S]*?\S)_(?!_)/, endAst: /\*(?!\*)/g, endUnd: /_(?!_)/g }, link: Er(/^!?\[(label)\]\((.*?)\)/).replace("label", It._label).getRegex(), reflink: Er(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", It._label).getRegex() }), It.gfm = $l({}, It.normal, { escape: Er(It.escape).replace("])", "~|])").getRegex(), _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/, url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/, text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/ }), It.gfm.url = Er(It.gfm.url, "i").replace("email", It.gfm._extended_email).getRegex(), It.breaks = $l({}, It.gfm, { br: Er(It.br).replace("{2,}", "*").getRegex(), text: Er(It.gfm.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() }), Dm = class v6 {
        constructor(s) {
          this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = s || Om, this.options.tokenizer = this.options.tokenizer || new LR(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: !1, inRawBlock: !1, top: !0 };
          let a = { block: Yt.normal, inline: It.normal };
          this.options.pedantic ? (a.block = Yt.pedantic, a.inline = It.pedantic) : this.options.gfm && (a.block = Yt.gfm, this.options.breaks ? a.inline = It.breaks : a.inline = It.gfm), this.tokenizer.rules = a;
        }
        static get rules() {
          return { block: Yt, inline: It };
        }
        static lex(s, a) {
          return new v6(a).lex(s);
        }
        static lexInline(s, a) {
          return new v6(a).inlineTokens(s);
        }
        lex(s) {
          s = s.replace(/\r\n|\r/g, `
`), this.blockTokens(s, this.tokens);
          let a;
          for (; a = this.inlineQueue.shift(); ) this.inlineTokens(a.src, a.tokens);
          return this.tokens;
        }
        blockTokens(s, a = []) {
          this.options.pedantic ? s = s.replace(/\t/g, "    ").replace(/^ +$/gm, "") : s = s.replace(/^( *)(\t+)/gm, (w, T, P) => T + "    ".repeat(P.length));
          let d, m, y, x;
          for (; s; ) if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((w) => (d = w.call({ lexer: this }, s, a)) ? (s = s.substring(d.raw.length), a.push(d), !0) : !1))) {
            if (d = this.tokenizer.space(s)) {
              s = s.substring(d.raw.length), d.raw.length === 1 && a.length > 0 ? a[a.length - 1].raw += `
` : a.push(d);
              continue;
            }
            if (d = this.tokenizer.code(s)) {
              s = s.substring(d.raw.length), m = a[a.length - 1], m && (m.type === "paragraph" || m.type === "text") ? (m.raw += `
` + d.raw, m.text += `
` + d.text, this.inlineQueue[this.inlineQueue.length - 1].src = m.text) : a.push(d);
              continue;
            }
            if (d = this.tokenizer.fences(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.heading(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.hr(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.blockquote(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.list(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.html(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.def(s)) {
              s = s.substring(d.raw.length), m = a[a.length - 1], m && (m.type === "paragraph" || m.type === "text") ? (m.raw += `
` + d.raw, m.text += `
` + d.raw, this.inlineQueue[this.inlineQueue.length - 1].src = m.text) : this.tokens.links[d.tag] || (this.tokens.links[d.tag] = { href: d.href, title: d.title });
              continue;
            }
            if (d = this.tokenizer.table(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.lheading(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (y = s, this.options.extensions && this.options.extensions.startBlock) {
              let w = 1 / 0, T = s.slice(1), P;
              this.options.extensions.startBlock.forEach(function(M) {
                P = M.call({ lexer: this }, T), typeof P == "number" && P >= 0 && (w = Math.min(w, P));
              }), w < 1 / 0 && w >= 0 && (y = s.substring(0, w + 1));
            }
            if (this.state.top && (d = this.tokenizer.paragraph(y))) {
              m = a[a.length - 1], x && m.type === "paragraph" ? (m.raw += `
` + d.raw, m.text += `
` + d.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = m.text) : a.push(d), x = y.length !== s.length, s = s.substring(d.raw.length);
              continue;
            }
            if (d = this.tokenizer.text(s)) {
              s = s.substring(d.raw.length), m = a[a.length - 1], m && m.type === "text" ? (m.raw += `
` + d.raw, m.text += `
` + d.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = m.text) : a.push(d);
              continue;
            }
            if (s) {
              let w = "Infinite loop on byte: " + s.charCodeAt(0);
              if (this.options.silent) {
                console.error(w);
                break;
              } else throw new Error(w);
            }
          }
          return this.state.top = !0, a;
        }
        inline(s, a = []) {
          return this.inlineQueue.push({ src: s, tokens: a }), a;
        }
        inlineTokens(s, a = []) {
          let d, m, y, x = s, w, T, P;
          if (this.tokens.links) {
            let M = Object.keys(this.tokens.links);
            if (M.length > 0) for (; (w = this.tokenizer.rules.inline.reflinkSearch.exec(x)) != null; ) M.includes(w[0].slice(w[0].lastIndexOf("[") + 1, -1)) && (x = x.slice(0, w.index) + "[" + Ble("a", w[0].length - 2) + "]" + x.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
          }
          for (; (w = this.tokenizer.rules.inline.blockSkip.exec(x)) != null; ) x = x.slice(0, w.index) + "[" + Ble("a", w[0].length - 2) + "]" + x.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
          for (; (w = this.tokenizer.rules.inline.escapedEmSt.exec(x)) != null; ) x = x.slice(0, w.index) + "++" + x.slice(this.tokenizer.rules.inline.escapedEmSt.lastIndex);
          for (; s; ) if (T || (P = ""), T = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((M) => (d = M.call({ lexer: this }, s, a)) ? (s = s.substring(d.raw.length), a.push(d), !0) : !1))) {
            if (d = this.tokenizer.escape(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.tag(s)) {
              s = s.substring(d.raw.length), m = a[a.length - 1], m && d.type === "text" && m.type === "text" ? (m.raw += d.raw, m.text += d.text) : a.push(d);
              continue;
            }
            if (d = this.tokenizer.link(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.reflink(s, this.tokens.links)) {
              s = s.substring(d.raw.length), m = a[a.length - 1], m && d.type === "text" && m.type === "text" ? (m.raw += d.raw, m.text += d.text) : a.push(d);
              continue;
            }
            if (d = this.tokenizer.emStrong(s, x, P)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.codespan(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.br(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.del(s)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (d = this.tokenizer.autolink(s, jle)) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (!this.state.inLink && (d = this.tokenizer.url(s, jle))) {
              s = s.substring(d.raw.length), a.push(d);
              continue;
            }
            if (y = s, this.options.extensions && this.options.extensions.startInline) {
              let M = 1 / 0, F = s.slice(1), O;
              this.options.extensions.startInline.forEach(function(N) {
                O = N.call({ lexer: this }, F), typeof O == "number" && O >= 0 && (M = Math.min(M, O));
              }), M < 1 / 0 && M >= 0 && (y = s.substring(0, M + 1));
            }
            if (d = this.tokenizer.inlineText(y, DEe)) {
              s = s.substring(d.raw.length), d.raw.slice(-1) !== "_" && (P = d.raw.slice(-1)), T = !0, m = a[a.length - 1], m && m.type === "text" ? (m.raw += d.raw, m.text += d.text) : a.push(d);
              continue;
            }
            if (s) {
              let M = "Infinite loop on byte: " + s.charCodeAt(0);
              if (this.options.silent) {
                console.error(M);
                break;
              } else throw new Error(M);
            }
          }
          return a;
        }
      }, jR = class {
        constructor(r) {
          this.options = r || Om;
        }
        code(r, s, a) {
          let d = (s || "").match(/\S*/)[0];
          if (this.options.highlight) {
            let m = this.options.highlight(r, d);
            m != null && m !== r && (a = !0, r = m);
          }
          return r = r.replace(/\n$/, "") + `
`, d ? '<pre><code class="' + this.options.langPrefix + ts(d, !0) + '">' + (a ? r : ts(r, !0)) + `</code></pre>
` : "<pre><code>" + (a ? r : ts(r, !0)) + `</code></pre>
`;
        }
        blockquote(r) {
          return `<blockquote>
`.concat(r, `</blockquote>
`);
        }
        html(r) {
          return r;
        }
        heading(r, s, a, d) {
          if (this.options.headerIds) {
            let m = this.options.headerPrefix + d.slug(a);
            return "<h".concat(s, ' id="').concat(m, '">').concat(r, "</h").concat(s, `>
`);
          }
          return "<h".concat(s, ">").concat(r, "</h").concat(s, `>
`);
        }
        hr() {
          return this.options.xhtml ? `<hr/>
` : `<hr>
`;
        }
        list(r, s, a) {
          let d = s ? "ol" : "ul", m = s && a !== 1 ? ' start="' + a + '"' : "";
          return "<" + d + m + `>
` + r + "</" + d + `>
`;
        }
        listitem(r) {
          return "<li>".concat(r, `</li>
`);
        }
        checkbox(r) {
          return "<input " + (r ? 'checked="" ' : "") + 'disabled="" type="checkbox"' + (this.options.xhtml ? " /" : "") + "> ";
        }
        paragraph(r) {
          return "<p>".concat(r, `</p>
`);
        }
        table(r, s) {
          return s && (s = "<tbody>".concat(s, "</tbody>")), `<table>
<thead>
` + r + `</thead>
` + s + `</table>
`;
        }
        tablerow(r) {
          return `<tr>
`.concat(r, `</tr>
`);
        }
        tablecell(r, s) {
          let a = s.header ? "th" : "td";
          return (s.align ? "<".concat(a, ' align="').concat(s.align, '">') : "<".concat(a, ">")) + r + "</".concat(a, `>
`);
        }
        strong(r) {
          return "<strong>".concat(r, "</strong>");
        }
        em(r) {
          return "<em>".concat(r, "</em>");
        }
        codespan(r) {
          return "<code>".concat(r, "</code>");
        }
        br() {
          return this.options.xhtml ? "<br/>" : "<br>";
        }
        del(r) {
          return "<del>".concat(r, "</del>");
        }
        link(r, s, a) {
          if (r = Ole(this.options.sanitize, this.options.baseUrl, r), r === null) return a;
          let d = '<a href="' + ts(r) + '"';
          return s && (d += ' title="' + s + '"'), d += ">" + a + "</a>", d;
        }
        image(r, s, a) {
          if (r = Ole(this.options.sanitize, this.options.baseUrl, r), r === null) return a;
          let d = '<img src="'.concat(r, '" alt="').concat(a, '"');
          return s && (d += ' title="'.concat(s, '"')), d += this.options.xhtml ? "/>" : ">", d;
        }
        text(r) {
          return r;
        }
      }, MU = class {
        strong(r) {
          return r;
        }
        em(r) {
          return r;
        }
        codespan(r) {
          return r;
        }
        del(r) {
          return r;
        }
        html(r) {
          return r;
        }
        text(r) {
          return r;
        }
        link(r, s, a) {
          return "" + a;
        }
        image(r, s, a) {
          return "" + a;
        }
        br() {
          return "";
        }
      }, RU = class {
        constructor() {
          this.seen = {};
        }
        serialize(r) {
          return r.toLowerCase().trim().replace(/<[!\/a-z].*?>/ig, "").replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, "").replace(/\s/g, "-");
        }
        getNextSafeSlug(r, s) {
          let a = r, d = 0;
          if (this.seen.hasOwnProperty(a)) {
            d = this.seen[r];
            do
              d++, a = r + "-" + d;
            while (this.seen.hasOwnProperty(a));
          }
          return s || (this.seen[r] = d, this.seen[a] = 0), a;
        }
        slug(r, s = {}) {
          let a = this.serialize(r);
          return this.getNextSafeSlug(a, s.dryrun);
        }
      }, cp = class b6 {
        constructor(s) {
          this.options = s || Om, this.options.renderer = this.options.renderer || new jR(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.textRenderer = new MU(), this.slugger = new RU();
        }
        static parse(s, a) {
          return new b6(a).parse(s);
        }
        static parseInline(s, a) {
          return new b6(a).parseInline(s);
        }
        parse(s, a = !0) {
          let d = "", m, y, x, w, T, P, M, F, O, N, B, U, H, W, Q, ne, ce, ue, se, Oe = s.length;
          for (m = 0; m < Oe; m++) {
            if (N = s[m], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[N.type] && (se = this.options.extensions.renderers[N.type].call({ parser: this }, N), se !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(N.type))) {
              d += se || "";
              continue;
            }
            switch (N.type) {
              case "space":
                continue;
              case "hr": {
                d += this.renderer.hr();
                continue;
              }
              case "heading": {
                d += this.renderer.heading(this.parseInline(N.tokens), N.depth, Nle(this.parseInline(N.tokens, this.textRenderer)), this.slugger);
                continue;
              }
              case "code": {
                d += this.renderer.code(N.text, N.lang, N.escaped);
                continue;
              }
              case "table": {
                for (F = "", M = "", w = N.header.length, y = 0; y < w; y++) M += this.renderer.tablecell(this.parseInline(N.header[y].tokens), { header: !0, align: N.align[y] });
                for (F += this.renderer.tablerow(M), O = "", w = N.rows.length, y = 0; y < w; y++) {
                  for (P = N.rows[y], M = "", T = P.length, x = 0; x < T; x++) M += this.renderer.tablecell(this.parseInline(P[x].tokens), { header: !1, align: N.align[x] });
                  O += this.renderer.tablerow(M);
                }
                d += this.renderer.table(F, O);
                continue;
              }
              case "blockquote": {
                O = this.parse(N.tokens), d += this.renderer.blockquote(O);
                continue;
              }
              case "list": {
                for (B = N.ordered, U = N.start, H = N.loose, w = N.items.length, O = "", y = 0; y < w; y++) Q = N.items[y], ne = Q.checked, ce = Q.task, W = "", Q.task && (ue = this.renderer.checkbox(ne), H ? Q.tokens.length > 0 && Q.tokens[0].type === "paragraph" ? (Q.tokens[0].text = ue + " " + Q.tokens[0].text, Q.tokens[0].tokens && Q.tokens[0].tokens.length > 0 && Q.tokens[0].tokens[0].type === "text" && (Q.tokens[0].tokens[0].text = ue + " " + Q.tokens[0].tokens[0].text)) : Q.tokens.unshift({ type: "text", text: ue }) : W += ue), W += this.parse(Q.tokens, H), O += this.renderer.listitem(W, ce, ne);
                d += this.renderer.list(O, B, U);
                continue;
              }
              case "html": {
                d += this.renderer.html(N.text);
                continue;
              }
              case "paragraph": {
                d += this.renderer.paragraph(this.parseInline(N.tokens));
                continue;
              }
              case "text": {
                for (O = N.tokens ? this.parseInline(N.tokens) : N.text; m + 1 < Oe && s[m + 1].type === "text"; ) N = s[++m], O += `
` + (N.tokens ? this.parseInline(N.tokens) : N.text);
                d += a ? this.renderer.paragraph(O) : O;
                continue;
              }
              default: {
                let he = 'Token with "' + N.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(he);
                  return;
                } else throw new Error(he);
              }
            }
          }
          return d;
        }
        parseInline(s, a) {
          a = a || this.renderer;
          let d = "", m, y, x, w = s.length;
          for (m = 0; m < w; m++) {
            if (y = s[m], this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[y.type] && (x = this.options.extensions.renderers[y.type].call({ parser: this }, y), x !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(y.type))) {
              d += x || "";
              continue;
            }
            switch (y.type) {
              case "escape": {
                d += a.text(y.text);
                break;
              }
              case "html": {
                d += a.html(y.text);
                break;
              }
              case "link": {
                d += a.link(y.href, y.title, this.parseInline(y.tokens, a));
                break;
              }
              case "image": {
                d += a.image(y.href, y.title, y.text);
                break;
              }
              case "strong": {
                d += a.strong(this.parseInline(y.tokens, a));
                break;
              }
              case "em": {
                d += a.em(this.parseInline(y.tokens, a));
                break;
              }
              case "codespan": {
                d += a.codespan(y.text);
                break;
              }
              case "br": {
                d += a.br();
                break;
              }
              case "del": {
                d += a.del(this.parseInline(y.tokens, a));
                break;
              }
              case "text": {
                d += a.text(y.text);
                break;
              }
              default: {
                let T = 'Token with "' + y.type + '" type was not found.';
                if (this.options.silent) {
                  console.error(T);
                  return;
                } else throw new Error(T);
              }
            }
          }
          return d;
        }
      }, rn.options = rn.setOptions = function(r) {
        return $l(rn.defaults, r), REe(rn.defaults), rn;
      }, rn.getDefaults = Ile, rn.defaults = Om, rn.use = function(...r) {
        let s = $l({}, ...r), a = rn.defaults.extensions || { renderers: {}, childTokens: {} }, d;
        r.forEach((m) => {
          if (m.extensions && (d = !0, m.extensions.forEach((y) => {
            if (!y.name) throw new Error("extension name required");
            if (y.renderer) {
              let x = a.renderers ? a.renderers[y.name] : null;
              x ? a.renderers[y.name] = function(...w) {
                let T = y.renderer.apply(this, w);
                return T === !1 && (T = x.apply(this, w)), T;
              } : a.renderers[y.name] = y.renderer;
            }
            if (y.tokenizer) {
              if (!y.level || y.level !== "block" && y.level !== "inline") throw new Error("extension level must be 'block' or 'inline'");
              a[y.level] ? a[y.level].unshift(y.tokenizer) : a[y.level] = [y.tokenizer], y.start && (y.level === "block" ? a.startBlock ? a.startBlock.push(y.start) : a.startBlock = [y.start] : y.level === "inline" && (a.startInline ? a.startInline.push(y.start) : a.startInline = [y.start]));
            }
            y.childTokens && (a.childTokens[y.name] = y.childTokens);
          })), m.renderer) {
            let y = rn.defaults.renderer || new jR();
            for (let x in m.renderer) {
              let w = y[x];
              y[x] = (...T) => {
                let P = m.renderer[x].apply(y, T);
                return P === !1 && (P = w.apply(y, T)), P;
              };
            }
            s.renderer = y;
          }
          if (m.tokenizer) {
            let y = rn.defaults.tokenizer || new LR();
            for (let x in m.tokenizer) {
              let w = y[x];
              y[x] = (...T) => {
                let P = m.tokenizer[x].apply(y, T);
                return P === !1 && (P = w.apply(y, T)), P;
              };
            }
            s.tokenizer = y;
          }
          if (m.walkTokens) {
            let y = rn.defaults.walkTokens;
            s.walkTokens = function(x) {
              let w = [];
              return w.push(m.walkTokens.call(this, x)), y && (w = w.concat(y.call(this, x))), w;
            };
          }
          d && (s.extensions = a), rn.setOptions(s);
        });
      }, rn.walkTokens = function(r, s) {
        let a = [];
        for (let d of r) switch (a = a.concat(s.call(rn, d)), d.type) {
          case "table": {
            for (let m of d.header) a = a.concat(rn.walkTokens(m.tokens, s));
            for (let m of d.rows) for (let y of m) a = a.concat(rn.walkTokens(y.tokens, s));
            break;
          }
          case "list": {
            a = a.concat(rn.walkTokens(d.items, s));
            break;
          }
          default:
            rn.defaults.extensions && rn.defaults.extensions.childTokens && rn.defaults.extensions.childTokens[d.type] ? rn.defaults.extensions.childTokens[d.type].forEach(function(m) {
              a = a.concat(rn.walkTokens(d[m], s));
            }) : d.tokens && (a = a.concat(rn.walkTokens(d.tokens, s)));
        }
        return a;
      }, rn.parseInline = function(r, s) {
        if (typeof r > "u" || r === null) throw new Error("marked.parseInline(): input parameter is undefined or null");
        if (typeof r != "string") throw new Error("marked.parseInline(): input parameter is of type " + Object.prototype.toString.call(r) + ", string expected");
        s = $l({}, rn.defaults, s || {}), Fle(s);
        try {
          let a = Dm.lexInline(r, s);
          return s.walkTokens && rn.walkTokens(a, s.walkTokens), cp.parseInline(a, s);
        } catch (a) {
          if (a.message += `
Please report this to https://github.com/markedjs/marked.`, s.silent) return "<p>An error occurred:</p><pre>" + ts(a.message + "", !0) + "</pre>";
          throw a;
        }
      }, rn.Parser = cp, rn.parser = cp.parse, rn.Renderer = jR, rn.TextRenderer = MU, rn.Lexer = Dm, rn.lexer = Dm.lex, rn.Tokenizer = LR, rn.Slugger = RU, rn.parse = rn, rn.options, rn.setOptions, rn.use, rn.walkTokens, rn.parseInline, cp.parse, Dm.lex;
    }), lo, UR, zR, IU, Zle, Jle, eue, NU, tue, nue, rue, OU, iue, sue, oue, aue, lue, IS, VR, uue, cue, due, hue, pue, fue, mue, DU, FU = R(() => {
      lo = Y(xe()), MEe(), it(), Xn(), zt(), FEe(), UM(), xae(), UR = ({ title: r, message: s }) => "".concat(r, " ").concat(s), zR = /* @__PURE__ */ (() => {
        let r = /* @__PURE__ */ new Map();
        return { add: (s) => {
          let a = UR(s);
          r.has(a) ? r.set(a, r.get(a) + 1) : r.set(a, 1);
        }, delete: (s) => {
          let a = UR(s);
          r.has(a) && r.get(a) > 1 ? r.set(a, r.get(a) - 1) : r.delete(a);
        }, clear: () => {
          r.clear();
        }, check: (s) => r.has(UR(s)) };
      })(), IU = /* @__PURE__ */ (() => {
        let r = /* @__PURE__ */ new Map();
        return { add: (s) => {
          r.has(s) ? r.set(s, r.get(s) + 1) : r.set(s, 1);
        }, delete: (s) => {
          r.has(s) && r.get(s) > 1 ? r.set(s, r.get(s) - 1) : r.delete(s);
        }, clear: () => {
          r.clear();
        }, check: (s) => r.has(s), get types() {
          return Array.of(...r.keys());
        } };
      })(), Jle = ee.div(Zle || (Zle = $([`
  width: 100%;
  border-radius: 4px;
  display: flex;
  gap: 12px;
  `, `;
  background-color: rgba(40, 43, 47, 0.8);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(14px);

  @supports not (backdrop-filter: blur()) {
    background: rgba(40, 43, 47, 0.95);
  }
`])), Ln), NU = ee.div(eue || (eue = $([`
  font-size: 14px;
  font-weight: bold;
  color: #fff;
`]))), nue = ee.div(tue || (tue = $([`
  flex: 1;
  flex-direction: column;
  width: 0;
  display: flex;
  padding: 16px 0;
  gap: 12px;
`]))), OU = ee.div(rue || (rue = $([`
  color: #b4b4b4;
  font-size: 12px;
  line-height: 1.4;

  a {
    color: rgba(255, 255, 255, 0.9);
  }

  em {
    font-style: italic;
  }

  strong {
    font-weight: bold;
    color: #d5d5d5;
  }

  p {
    margin-bottom: 8px;
  }

  code {
    font-family: monospace;
    background: rgba(0, 0, 0, 0.3);
    padding: 1px 1px 2px;
    border-radius: 4px;
    border: 1px solid rgba(255, 255, 255, 0.08);
    white-space: pre-wrap;
  }

  pre > code {
    white-space: pre;
    display: block;
    overflow: auto;
    padding: 4px;
  }

  pre {
    white-space: pre-wrap;
    margin-bottom: 8px;
  }
`]))), sue = ee.button(iue || (iue = $([`
  color: rgba(255, 255, 255, 0.9);
  font-weight: 500;
  display: flex;
  align-items: center;
  justify-content: center;
  background: none;
  border: none;
  padding-left: 12px;
  padding-right: 12px;
  border-left: 1px solid rgba(255, 255, 255, 0.05);

  &:hover {
    background: rgba(255, 255, 255, 0.05);
  }
`]))), oue = { info: "#3b82f6", success: "#10b981", warning: "#f59e0b", error: "#ef4444" }, lue = ee.div(aue || (aue = $([`
  display: flex;
  justify-content: center;
  margin-left: 12px;
  padding-top: 21px;

  ::before {
    content: '';
    width: 8px;
    height: 8px;
    border-radius: 999999px;
    background-color: `, `;
  }
`])), ({ type: r }) => oue[r]), IS = (r) => (s, a, d = [], m = !1) => {
        (m || !zR.check({ title: s, message: a })) && (zR.add({ title: s, message: a }), IU.add(r), AU.custom((y) => lo.default.createElement(Jle, null, lo.default.createElement(lue, { type: r }), lo.default.createElement(nue, null, lo.default.createElement(NU, null, s), lo.default.createElement(OU, { dangerouslySetInnerHTML: { __html: rn.parse(a) } }), d.length > 0 && lo.default.createElement(OU, null, lo.default.createElement("span", null, "Docs:", " ", d.map((x, w) => lo.default.createElement(lo.Fragment, { key: w }, w > 0 && ", ", lo.default.createElement("a", { target: "_blank", href: x.url }, x.title)))))), lo.default.createElement(sue, { onClick: () => {
          AU.remove(y.id), zR.delete({ title: s, message: a }), IU.delete(r);
        } }, "Close")), { duration: 1 / 0 }));
      }, VR = { warning: IS("warning"), success: IS("success"), info: IS("info"), error: IS("error") }, ee.div(uue || (uue = $([`
  display: flex;
  justify-content: `, `;
  gap: 12px;
`])), ({ align: r }) => r === "center" ? "center" : "flex-end"), ee.button(cue || (cue = $([`
  position: relative;
  border-radius: 4px;
  display: flex;
  align-items: center;
  gap: 12px;
  `, `;
  background-color: rgba(40, 43, 47, 0.8);
  box-shadow: 0 1px 1px rgba(0, 0, 0, 0.25), 0 2px 6px rgba(0, 0, 0, 0.15);
  backdrop-filter: blur(14px);
  border: none;
  padding: 12px;
  color: #fff;
  overflow: hidden;

  ::before {
    content: '';
    position: absolute;
    inset: 0;
  }

  :hover::before {
    background: `, `;
  }

  @supports not (backdrop-filter: blur()) {
    background: rgba(40, 43, 47, 0.95);
  }
`])), Ln, ({ danger: r }) => r ? "rgba(255, 0, 0, 0.1)" : "rgba(255, 255, 255, 0.1)"), ee.div(due || (due = $([`
  z-index: 10;
  display: flex;
  flex-direction: column;
  gap: 8px;
  position: fixed;
  right: 92px;
  top: 50px;
  width: 500px;
  height: 85vh;
  min-height: 400px;
`]))), ee.div(hue || (hue = $([`
  overflow: hidden;
  pointer-events: auto;
  border-radius: 4px;

  & > div {
    display: flex;
    flex-direction: column-reverse;
    gap: 8px;
    overflow: scroll;
    height: 100%;
  }
`]))), fue = ee.div(pue || (pue = $([`
  width: fit-content;
  padding: 8px;
  border-radius: 4px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  color: #b4b4b4;
  font-size: 12px;
  line-height: 1.4;
`]))), mue = () => {
        let { hasNotifications: r } = DU();
        return LM({ enabled: !r }, () => lo.default.createElement(fU, null, lo.default.createElement(fue, null, lo.default.createElement(NU, null, "No notifications"), "Notifications will appear here when you get them.")));
      }, DU = () => {
        let { toasts: r } = Rle();
        return { hasNotifications: r.length > 0 };
      };
    }), zs, gue, yue, vue, bue, xue, _ue, Sue, wue, Eue, BU, Tue, Cue, BEe = R(() => {
      zt(), st(), zs = Y(xe()), it(), UM(), dEe(), hU(), gue = ut(), Qae(), EEe(), Ok(), CEe(), AEe(), Dl(), kEe(), FU(), vue = ee.div(yue || (yue = $([`
  height: 36px;
  pointer-events: none;

  display: flex;
  justify-content: space-between;
  padding: 12px;
`]))), xue = ee.div(bue || (bue = $([`
  color: white;
  width: 14px;
  height: 14px;
  background: #d00;
  border-radius: 4px;
  text-align: center;
  line-height: 14px;
  font-weight: 600;
  font-size: 8px;
  position: relative;
  left: -6px;
  top: -11px;
  margin-right: -14px;
  box-shadow: 0 4px 6px -4px #00000059;
`]))), Sue = ee.div(_ue || (_ue = $([`
  display: flex;
  gap: 8px;
`]))), ee.div(wue || (wue = $([`
  position: absolute;
  background: `, `;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  right: -2px;
  top: -2px;
`])), ({ type: r }) => r === "info" ? "#40aaa4" : "#f59e0b"), ee.div(Eue || (Eue = $([`
  position: absolute;
  height: 32px;
  width: 1px;
  background: #373b40;
  opacity: 0.4;
`]))), BU = !1, Tue = () => {
        var r;
        let s = At(() => {
          let M = (0, gue.val)(pe().atomP.ephemeral.coreByProject);
          return Object.entries(M).map(([F, O]) => ({ projectId: F, state: O })).filter(({ state: F }) => F.loadingState.type === "browserStateIsNotBasedOnDiskState");
        }, []), [a, d] = LM({ enabled: s.length > 0, enterDelay: s.length > 0 ? 0 : 200 }, () => s.length > 0 ? zs.default.createElement(pae, null, s.length === 1 ? 'There is a state conflict in project "'.concat(s[0].projectId, '". Select the project in the outline below in order to fix it.') : "There are ".concat(s.length, " projects that have state conflicts. They are highlighted in the outline below. ")) : zs.default.createElement(IR, null, zs.default.createElement(zs.default.Fragment, null, "Outline"))), m = (r = nn(pe().atomP.ahistoric.pinOutline)) != null ? r : !0, y = nn(pe().atomP.ahistoric.updateChecker.result.hasUpdates) === !0;
        ko(() => {
          let M = x.current.getBoundingClientRect();
          return { debugName: "More Menu", constraints: { maxX: M.right, maxY: 8, minX: M.left - 140, minY: 8 }, verticalGap: 2 };
        }, () => zs.default.createElement(xle, null));
        let x = (0, zs.useRef)(null);
        (0, zs.useMemo)(() => (window.__IS_VISUAL_REGRESSION_TESTING && (BU || (BU = !0, console.warn("Visual regression testing enabled, so we're showing the updates badge unconditionally"))), y || window.__IS_VISUAL_REGRESSION_TESTING ? !0 : y), [y]);
        let { hasNotifications: w } = DU(), [T, P] = mue();
        return zs.default.createElement(vue, null, zs.default.createElement(Sue, null, a, zs.default.createElement(tle, { ref: d, "data-testid": "OutlinePanel-TriggerButton", onClick: () => {
          pe().transaction(({ stateEditors: M, drafts: F }) => {
            var O;
            M.studio.ahistoric.setPinOutline(!((O = F.ahistoric.pinOutline) == null || O));
          });
        }, icon: zs.default.createElement(qq, null), pinHintIcon: zs.default.createElement(rle, null), unpinHintIcon: zs.default.createElement(nle, null), pinned: m }), s.length > 0 ? zs.default.createElement(xue, null, s.length) : null, zs.default.createElement(bU, { showLeftDivider: !0, toolbarId: "global" })));
      }, Cue = Tue;
    }), Pue, NS, Aue, OS, kue, Mue, Rue, Iue, Nue = R(() => {
      Pue = ut(), zt(), NS = Y(xe()), Aue = Y(oi()), OS = new Pue.Atom({ set: {}, byId: {} }), kue = 1, Mue = () => {
        let r = kue++;
        function s(d, m, y) {
          OS.reduce((x) => ({ byId: V(L({}, x.byId), { [r]: { comp: d, props: m, portalNode: y } }), set: V(L({}, x.set), { [r]: !0 }) }));
        }
        function a() {
          OS.reduce((d) => {
            let m = L({}, d.set), y = L({}, d.byId);
            return delete m[r], { byId: y, set: m };
          });
        }
        return { mountOrRender: s, unmount: a };
      }, Rue = () => {
        let r = Object.keys(nn(OS.pointer.set));
        return NS.default.createElement(NS.default.Fragment, null, r.map((s) => NS.default.createElement(Iue, { key: "id-" + s, id: s })));
      }, Iue = ({ id: r }) => {
        let { comp: s, portalNode: a, props: d } = nn(OS.pointer.byId[r]);
        return (0, Aue.createPortal)(NS.default.createElement(s, L({}, d)), a);
      };
    });
    function LEe(r) {
      let s = pe(), [a, d] = kn(void 0), m = nte();
      m.configureLogging({ min: 128, dev: jU, internal: jU });
      let y = m.getLogger().named("Theatre.js UIRoot");
      jwe();
      let x = nn(s.atomP.ahistoric.visibilityState);
      return (0, Vs.useEffect)(() => (x === "everythingIsHidden" && console.warn("Theatre.js Studio is hidden. Use the keyboard shortcut 'alt + \\' to restore the studio, or call studio.ui.restore()."), () => {
      }), [x]), At(() => {
        let w = (0, LU.val)(s.atomP.ahistoric.visibilityState);
        return (0, LU.val)(s.atomP.ephemeral.initialised) ? Vs.default.createElement(QH, { logger: y }, Vs.default.createElement(PX, null, Vs.default.createElement(Oxe, null, Vs.default.createElement(jue, null), Vs.default.createElement(P0.Provider, { value: d }, Vs.default.createElement(HB, { target: window.__IS_VISUAL_REGRESSION_TESTING === !0 ? void 0 : r.containerShadow }, Vs.default.createElement(Vs.default.Fragment, null, Vs.default.createElement(Due, null), Vs.default.createElement(Bue, { className: w === "everythingIsHidden" ? "invisible" : "" }, Vs.default.createElement(qB, { ref: a }), Vs.default.createElement(Cue, null), Vs.default.createElement(lae, null)))))))) : null;
      }, [s, a, d]);
    }
    var LU, Vs, Oue, Due, Fue, Bue, Lue, jU, jue, jEe = R(() => {
      st(), zt(), LU = ut(), Vs = Y(xe()), it(), cEe(), BEe(), Hn(), im(), $j(), Os(), AX(), hL(), Nue(), Xn(), pR(), om(), Due = typeof window < "u" ? $G(Oue || (Oue = $([`
  :host {
    contain: strict;
  }
`]))) : {}, Bue = ee(XH)(Fue || (Fue = $([`
  z-index: 50;
  position: fixed;
  inset: 0;

  &.invisible {
    pointer-events: none !important;
    opacity: 0;
    transform: translateX(1000000px);
  }
`]))), jU = /Playground.+Theatre\.js/.test((Lue = typeof document < "u" ? document?.title : null) != null ? Lue : ""), jue = () => Vs.default.createElement(Rue, null);
    }), UEe = J((r) => {
      var s = oi();
      r.createRoot = s.createRoot, r.hydrateRoot = s.hydrateRoot;
    }), Uue = {};
    ge(Uue, { default: () => Gue });
    var zue, Vue, Gue, zEe = R(() => {
      jEe(), zue = Y(xe()), Vue = Y(UEe()), Nue(), Xn(), Qae(), Gue = class {
        constructor() {
          Me(this, "containerEl", document.createElement("div")), Me(this, "_renderTimeout"), Me(this, "_documentBodyUIIsRenderedIn"), Me(this, "containerShadow"), this.containerEl.id = "theatrejs-studio-root", this.containerEl.style.cssText = `
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
      pointer-events: none;
      z-index: 100;
    `;
          let r = () => {
            if (window.__IS_VISUAL_REGRESSION_TESTING === !0) {
              let s = document.createElement("div");
              return s.id = "theatrejs-faux-shadow-root", document.body.appendChild(s), s;
            } else return this.containerEl.attachShadow({ mode: "open" });
          };
          this.containerShadow = r();
        }
        render() {
          let r = () => {
            if (!document.body) {
              this._renderTimeout = setTimeout(r, 5);
              return;
            }
            this._renderTimeout = void 0, this._documentBodyUIIsRenderedIn = document.body, this._documentBodyUIIsRenderedIn.appendChild(this.containerEl), Vue.default.createRoot(this.containerShadow).render(zue.default.createElement(LEe, { containerShadow: this.containerShadow }));
          };
          this._renderTimeout = setTimeout(r, 10);
        }
        renderToolset(r, s) {
          let a = Mue();
          return a.mountOrRender(rxe(bU), { toolbarId: r }, s), a.unmount;
        }
      };
    }), VEe = J((r) => {
      r.compare = m, r.reduce = y;
      var s, a, d;
      r.REMOVE = s = -1, r.ADD = a = 1, r.EQUAL = d = 0;
      function m(M, F) {
        var O = M.length, N = F.length, B = x(M, F), U = B < O && B < N ? w(M, F) : 0, H = U + B - 1;
        O -= H, N -= H;
        for (var W = P(O, N), Q = O - 1; Q >= 0; --Q) for (var ne = N - 1; ne >= 0; --ne) W[ne][Q] = T(W, M, F, B, Q, ne);
        return { prefix: B, matrix: W, suffix: U };
      }
      function y(M, F, O) {
        var N, B, U, H, W = O.matrix, Q = O.prefix;
        for (N = 0; N < Q; ++N) F = M(F, d, N, N);
        for (U = N, Q = W.length, N = 0, B = 0; N < Q; ) switch (H = W[N][B].type, F = M(F, H, N + U, B + U), H) {
          case d:
            ++N, ++B;
            break;
          case s:
            ++B;
            break;
          case a:
            ++N;
            break;
        }
        for (N += U, B += U, Q = O.suffix, U = 0; U < Q; ++U) F = M(F, d, N + U, B + U);
        return F;
      }
      function x(M, F) {
        for (var O = 0, N = Math.min(M.length, F.length); O < N && M[O] === F[O]; ) ++O;
        return O;
      }
      function w(M, F) {
        for (var O = M.length - 1, N = F.length - 1, B = Math.min(O, N), U = 0; U < B && M[O - U] === F[N - U]; ) ++U;
        return U;
      }
      function T(M, F, O, N, B, U) {
        return F[B + N] === O[U + N] ? { value: M[U + 1][B + 1].value, type: d } : M[U][B + 1].value < M[U + 1][B].value ? { value: M[U][B + 1].value + 1, type: s } : { value: M[U + 1][B].value + 1, type: a };
      }
      function P(M, F) {
        var O = [], N, B, U;
        for (U = O[F] = [], B = 0; B < M; ++B) U[B] = { value: M - B, type: s };
        for (N = 0; N < F; ++N) O[N] = [], O[N][M] = { value: F - N, type: a };
        return O[F][M] = { value: 0, type: d }, O;
      }
    }), que = J((r) => {
      r.cons = s, r.tail = a, r.map = d;
      function s(m, y) {
        var x = y.length, w = new Array(x + 1);
        w[0] = m;
        for (var T = 0; T < x; ++T) w[T + 1] = y[T];
        return w;
      }
      function a(m) {
        for (var y = m.length - 1, x = new Array(y), w = 0; w < y; ++w) x[w] = m[w + 1];
        return x;
      }
      function d(m, y) {
        for (var x = new Array(y.length), w = 0; w < y.length; ++w) x[w] = m(y[w]);
        return x;
      }
    }), GEe = J((r, s) => {
      s.exports = x;
      var a = /\/|~1|~0/g, d = "/", m = "~", y = "~1";
      function x(w, T) {
        var P, M, F, O;
        for (P = w.charAt(0) === d ? 1 : 0, M = "", a.lastIndex = P; F = a.exec(w); ) if (O = F[0], M += w.slice(P, a.lastIndex - O.length), P = a.lastIndex, O === d) {
          if (T(M) === !1) return w;
          M = "";
        } else M += O === y ? d : m;
        return M += w.slice(P), T(M), w;
      }
    }), UU = J((r) => {
      var s = GEe();
      r.find = M, r.join = O, r.absolute = F, r.parse = N, r.contains = B, r.encodeSegment = H, r.decodeSegment = U, r.parseArrayIndex = ne, r.isValidArrayIndex = Q;
      var a = "/", d = /\//g, m = "~1", y = /~1/g, x = "~", w = /~/g, T = "~0", P = /~0/g;
      function M(ue, se, Oe, he) {
        if (typeof se == "string") {
          if (se === "") return { target: ue, key: void 0 };
          if (se === a) return { target: ue, key: "" };
          var ie = ue, ye, Ee = he !== void 0;
          return s(se, function(ve) {
            if (ue == null) return ie = null, !1;
            Array.isArray(ue) ? ye = Ee ? ce(Oe, ne(ve), ue, he) : ve === "-" ? ve : ne(ve) : ye = ve, ie = ue, ue = ue[ye];
          }), ie === null ? void 0 : { target: ie, key: ye };
        }
      }
      function F(ue) {
        return ue[0] === a ? ue : a + ue;
      }
      function O(ue) {
        return ue.join(a);
      }
      function N(ue) {
        var se = [];
        return s(ue, se.push.bind(se)), se;
      }
      function B(ue, se) {
        return se.indexOf(ue) === 0 && se[ue.length] === a;
      }
      function U(ue) {
        return ue.replace(y, a).replace(P, x);
      }
      function H(ue) {
        return ue.replace(w, T).replace(d, m);
      }
      var W = /^(0|[1-9]\d*)$/;
      function Q(ue) {
        return W.test(ue);
      }
      function ne(ue) {
        if (Q(ue)) return +ue;
        throw new SyntaxError("invalid array index " + ue);
      }
      function ce(ue, se, Oe, he) {
        var ie = se;
        if (ie < 0) throw new Error("array index out of bounds " + ie);
        if (he !== void 0 && typeof ue == "function" && (ie = ue(se, Oe, he), ie < 0)) throw new Error("could not find patch context " + he);
        return ie;
      }
    }), Hue = J((r, s) => {
      s.exports = a;
      function a(y) {
        return y == null || typeof y != "object" ? y : Array.isArray(y) ? d(y) : m(y);
      }
      function d(y) {
        for (var x = y.length, w = new Array(x), T = 0; T < x; ++T) w[T] = a(y[T]);
        return w;
      }
      function m(y) {
        for (var x = Object.keys(y), w = {}, T, P = 0, M = x.length; P < M; ++P) T = x[P], w[T] = a(y[T]);
        return w;
      }
    }), qEe = J((r, s) => {
      s.exports = a;
      function a(y, x) {
        return y === x ? !0 : Array.isArray(y) && Array.isArray(x) ? d(y, x) : typeof y == "object" && typeof x == "object" ? m(y, x) : !1;
      }
      function d(y, x) {
        if (y.length !== x.length) return !1;
        for (var w = 0; w < y.length; ++w) if (!a(y[w], x[w])) return !1;
        return !0;
      }
      function m(y, x) {
        if (y === null && x !== null || y !== null && x === null) return !1;
        var w = Object.keys(y), T = Object.keys(x);
        if (w.length !== T.length) return !1;
        for (var P = 0, M; P < w.length; ++P) if (M = w[P], !(M in x && a(y[M], x[M]))) return !1;
        return !0;
      }
    }), HEe = J((r, s) => {
      var a = UU();
      s.exports = function(M, F) {
        var O = a.parse(M.path), N = a.parse(F.path), B = T(O, N), U = y(O, N, B.length), H = P(M), W = P(F);
        return B.length === 0 && !U ? [W, H] : U ? m(H, O, W, N) : d(H, O, W);
      };
      function d(M, F, O, N) {
        if (M.path === O.path) throw new TypeError("cannot commute " + M.op + "," + O.op + " with identical object paths");
        return [O, M];
      }
      function m(M, F, O, N) {
        return F.length === N.length ? x(M, F, O, N) : (F.length > N.length ? (F = w(O, N, M, F, -1), M.path = a.absolute(a.join(F))) : (N = w(M, F, O, N, 1), O.path = a.absolute(a.join(N))), [O, M]);
      }
      function y(M, F, O) {
        return a.isValidArrayIndex(M[O]) && a.isValidArrayIndex(F[O]);
      }
      function x(M, F, O, N) {
        var B = F.length - 1, U = +F[B], H = +N[B], W;
        return U < H ? M.op === "add" || M.op === "copy" ? (W = N.slice(), W[B] = Math.max(0, H - 1), O.path = a.absolute(a.join(W))) : M.op === "remove" && (W = N.slice(), W[B] = H + 1, O.path = a.absolute(a.join(W))) : O.op === "add" || O.op === "copy" ? (W = F.slice(), W[B] = U + 1, M.path = a.absolute(a.join(W))) : U > H && O.op === "remove" && (W = F.slice(), W[B] = Math.max(0, U - 1), M.path = a.absolute(a.join(W))), [O, M];
      }
      function w(M, F, O, N, B) {
        var U = F.length - 1, H = +F[U], W = +N[U], Q = N.slice();
        return H > W || (M.op === "add" || M.op === "copy" ? Q[U] = Math.max(0, W - B) : M.op === "remove" && (Q[U] = Math.max(0, W + B))), Q;
      }
      function T(M, F) {
        var O = M.length, N = F.length;
        if (O === 0 || N === 0 || O < 2 && N < 2) return [];
        for (var B = O === N ? O - 1 : Math.min(O, N), U = 0; U < B && M[U] === F[U]; ) ++U;
        return M.slice(0, U);
      }
      function P(M) {
        return M.op === "remove" ? { op: M.op, path: M.path } : M.op === "copy" || M.op === "move" ? { op: M.op, path: M.path, from: M.from } : { op: M.op, path: M.path, value: M.value };
      }
    }), $ue = J((r, s) => {
      s.exports = a;
      function a(d) {
        Error.call(this), this.name = this.constructor.name, this.message = d, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      a.prototype = Object.create(Error.prototype), a.prototype.constructor = a;
    }), zU = J((r, s) => {
      s.exports = a;
      function a(d) {
        Error.call(this), this.name = this.constructor.name, this.message = d, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      a.prototype = Object.create(Error.prototype), a.prototype.constructor = a;
    }), Wue = J((r, s) => {
      s.exports = a;
      function a(d) {
        Error.call(this), this.name = this.constructor.name, this.message = d, typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, this.constructor);
      }
      a.prototype = Object.create(Error.prototype), a.prototype.constructor = a;
    }), Kue = J((r) => {
      var s = UU(), a = Hue(), d = qEe(), m = HEe(), y = que(), x = $ue(), w = zU(), T = Wue(), P = s.find, M = s.parseArrayIndex;
      r.test = { apply: F, inverse: O, commute: N }, r.add = { apply: B, inverse: H, commute: W }, r.remove = { apply: ue, inverse: Oe, commute: he }, r.replace = { apply: Q, inverse: ne, commute: ce }, r.move = { apply: ie, inverse: ye, commute: Ee }, r.copy = { apply: ve, inverse: Xe, commute: W };
      function F(Ce, le, Ie) {
        var $e = P(Ce, le.path, Ie.findContext, le.context), de = $e.target, Ae, Je;
        if (Array.isArray(de) ? (Ae = M($e.key), Je = de[Ae]) : Je = $e.key === void 0 ? $e.target : $e.target[$e.key], !d(Je, le.value)) throw new x("test failed " + JSON.stringify(le));
        return Ce;
      }
      function O(Ce, le) {
        return Ce.push(le), 1;
      }
      function N(Ce, le) {
        if (Ce.path === le.path && le.op === "remove") throw new TypeError("Can't commute test,remove -> remove,test for same path");
        return le.op === "test" || le.op === "replace" ? [le, Ce] : m(Ce, le);
      }
      function B(Ce, le, Ie) {
        var $e = P(Ce, le.path, Ie.findContext, le.context);
        if (Se($e)) throw new w("path does not exist " + le.path);
        if (le.value === void 0) throw new w("missing value");
        var de = a(le.value);
        return $e.key === void 0 ? de : (U($e, de), Ce);
      }
      function U(Ce, le) {
        var Ie = Ce.target;
        if (Array.isArray(Ie)) if (Ce.key === "-") Ie.push(le);
        else {
          if (Ce.key > Ie.length) throw new w("target of add outside of array bounds");
          Ie.splice(Ce.key, 0, le);
        }
        else if (De(Ie)) Ie[Ce.key] = le;
        else throw new w("target of add must be an object or array " + Ce.key);
      }
      function H(Ce, le) {
        var Ie = le.context;
        return Ie !== void 0 && (Ie = { before: Ie.before, after: y.cons(le.value, Ie.after) }), Ce.push({ op: "test", path: le.path, value: le.value, context: Ie }), Ce.push({ op: "remove", path: le.path, context: Ie }), 1;
      }
      function W(Ce, le) {
        if (Ce.path === le.path && le.op === "remove") throw new TypeError("Can't commute add,remove -> remove,add for same path");
        return m(Ce, le);
      }
      function Q(Ce, le, Ie) {
        var $e = P(Ce, le.path, Ie.findContext, le.context);
        if (Se($e) || nt($e)) throw new w("path does not exist " + le.path);
        if (le.value === void 0) throw new w("missing value");
        var de = a(le.value);
        if ($e.key === void 0) return de;
        var Ae = $e.target;
        return Array.isArray(Ae) ? Ae[M($e.key)] = de : Ae[$e.key] = de, Ce;
      }
      function ne(Ce, le, Ie, $e) {
        var de = $e[Ie - 1];
        if (de === void 0 || de.op !== "test" || de.path !== le.path) throw new T("cannot invert replace w/o test");
        var Ae = de.context;
        return Ae !== void 0 && (Ae = { before: Ae.before, after: y.cons(de.value, y.tail(Ae.after)) }), Ce.push({ op: "test", path: de.path, value: le.value }), Ce.push({ op: "replace", path: de.path, value: de.value }), 2;
      }
      function ce(Ce, le) {
        if (Ce.path === le.path && le.op === "remove") throw new TypeError("Can't commute replace,remove -> remove,replace for same path");
        return le.op === "test" || le.op === "replace" ? [le, Ce] : m(Ce, le);
      }
      function ue(Ce, le, Ie) {
        var $e = P(Ce, le.path, Ie.findContext, le.context);
        if (Se($e) || $e.target[$e.key] === void 0) throw new w("path does not exist " + le.path);
        return se($e), Ce;
      }
      function se(Ce) {
        var le = Ce.target, Ie;
        if (Array.isArray(le)) return Ie = le.splice(M(Ce.key), 1), Ie[0];
        if (De(le)) return Ie = le[Ce.key], delete le[Ce.key], Ie;
        throw new w("target of remove must be an object or array");
      }
      function Oe(Ce, le, Ie, $e) {
        var de = $e[Ie - 1];
        if (de === void 0 || de.op !== "test" || de.path !== le.path) throw new T("cannot invert remove w/o test");
        var Ae = de.context;
        return Ae !== void 0 && (Ae = { before: Ae.before, after: y.tail(Ae.after) }), Ce.push({ op: "add", path: de.path, value: de.value, context: Ae }), 2;
      }
      function he(Ce, le) {
        return Ce.path === le.path && le.op === "remove" ? [le, Ce] : m(Ce, le);
      }
      function ie(Ce, le, Ie) {
        if (s.contains(le.path, le.from)) throw new w("move.from cannot be ancestor of move.path");
        var $e = P(Ce, le.path, Ie.findContext, le.context), de = P(Ce, le.from, Ie.findContext, le.fromContext);
        return U($e, se(de)), Ce;
      }
      function ye(Ce, le) {
        return Ce.push({ op: "move", path: le.from, context: le.fromContext, from: le.path, fromContext: le.context }), 1;
      }
      function Ee(Ce, le) {
        if (Ce.path === le.path && le.op === "remove") throw new TypeError("Can't commute move,remove -> move,replace for same path");
        return m(Ce, le);
      }
      function ve(Ce, le, Ie) {
        var $e = P(Ce, le.path, Ie.findContext, le.context), de = P(Ce, le.from, Ie.findContext, le.fromContext);
        if (Se(de) || nt(de)) throw new w("copy.from must exist");
        var Ae = de.target, Je;
        return Array.isArray(Ae) ? Je = Ae[M(de.key)] : Je = Ae[de.key], U($e, a(Je)), Ce;
      }
      function Xe(Ce, le) {
        throw new T("cannot invert " + le.op);
      }
      function Se(Ce) {
        return Ce === void 0 || Ce.target == null && Ce.key !== void 0;
      }
      function nt(Ce) {
        return Ce.key !== void 0 && Ce.target[Ce.key] === void 0;
      }
      function De(Ce) {
        return Ce !== null && typeof Ce == "object";
      }
    }), $Ee = J((r) => {
      var s = Kue(), a = Hue(), d = zU();
      r.apply = y, r.applyInPlace = x, r.clone = a, r.isValidObject = T, r.defaultHash = w;
      var m = {};
      function y(M, F, O) {
        return x(M, a(F), O);
      }
      function x(M, F, O) {
        if (O || (O = m), !Array.isArray(M)) return F;
        for (var N, B, U = 0; U < M.length; ++U) {
          if (B = M[U], N = s[B.op], N === void 0) throw new d("invalid op " + JSON.stringify(B));
          F = N.apply(F, B, O);
        }
        return F;
      }
      function w(M) {
        return T(M) || P(M) ? JSON.stringify(M) : M;
      }
      function T(M) {
        return M !== null && Object.prototype.toString.call(M) === "[object Object]";
      }
      function P(M) {
        return Object.prototype.toString.call(M) === "[object Array]";
      }
    }), WEe = J((r, s) => {
      var a = Kue();
      s.exports = function(m) {
        var y = [], x, w;
        for (x = m.length - 1; x >= 0; x -= w) w = d(y, m[x], x, m);
        return y;
      };
      function d(m, y, x, w) {
        var T = a[y.op];
        return T !== void 0 && typeof T.inverse == "function" ? T.inverse(m, y, x, w) : 1;
      }
    }), KEe = J((r) => {
      var s = VEe(), a = que(), d = $Ee(), m = WEe(), y = UU(), x = y.encodeSegment;
      r.diff = P, r.patch = d.apply, r.patchInPlace = d.applyInPlace, r.inverse = m, r.clone = d.clone, r.InvalidPatchOperationError = zU(), r.TestFailedError = $ue(), r.PatchNotInvertibleError = Wue();
      var w = d.isValidObject, T = d.defaultHash;
      function P(ne, ce, ue) {
        return F(ne, ce, "", M(ue, [])).patch;
      }
      function M(ne, ce) {
        return typeof ne == "object" ? { patch: ce, hash: H(Q, ne.hash, T), makeContext: H(Q, ne.makeContext, W), invertible: ne.invertible !== !1 } : { patch: ce, hash: H(Q, ne, T), makeContext: W, invertible: !0 };
      }
      function F(ne, ce, ue, se) {
        return Array.isArray(ne) && Array.isArray(ce) ? N(ne, ce, ue, se) : w(ne) && w(ce) ? O(ne, ce, ue, se) : U(ne, ce, ue, se);
      }
      function O(ne, ce, ue, se) {
        var Oe = Object.keys(ce), he = se.patch, ie, ye;
        for (ie = Oe.length - 1; ie >= 0; --ie) {
          ye = Oe[ie];
          var Ee = ue + "/" + x(ye);
          ne[ye] !== void 0 ? F(ne[ye], ce[ye], Ee, se) : he.push({ op: "add", path: Ee, value: ce[ye] });
        }
        for (Oe = Object.keys(ne), ie = Oe.length - 1; ie >= 0; --ie) if (ye = Oe[ie], ce[ye] === void 0) {
          var ve = ue + "/" + x(ye);
          se.invertible && he.push({ op: "test", path: ve, value: ne[ye] }), he.push({ op: "remove", path: ve });
        }
        return se;
      }
      function N(ne, ce, ue, se) {
        var Oe = a.map(se.hash, ne), he = a.map(se.hash, ce), ie = s.compare(Oe, he);
        return B(ne, ce, ue, se, ie);
      }
      function B(ne, ce, ue, se, Oe) {
        var he = 0;
        return s.reduce(function(ie, ye, Ee, ve) {
          var Xe, Se, nt = ie.patch, De = ue + "/" + (ve + he);
          return ye === s.REMOVE ? (Xe = nt[nt.length - 1], Se = ie.makeContext(ve, ne), ie.invertible && nt.push({ op: "test", path: De, value: ne[ve], context: Se }), Xe !== void 0 && Xe.op === "add" && Xe.path === De ? (Xe.op = "replace", Xe.context = Se) : nt.push({ op: "remove", path: De, context: Se }), he -= 1) : ye === s.ADD ? (nt.push({ op: "add", path: De, value: ce[Ee], context: ie.makeContext(ve, ne) }), he += 1) : F(ne[ve], ce[Ee], De, ie), ie;
        }, se, Oe);
      }
      function U(ne, ce, ue, se) {
        return ne !== ce && (se.invertible && se.patch.push({ op: "test", path: ue, value: ne }), se.patch.push({ op: "replace", path: ue, value: ce })), se;
      }
      function H(ne, ce, ue) {
        return ne(ce) ? ce : ue;
      }
      function W() {
      }
      function Q(ne) {
        return typeof ne == "function";
      }
    }), Fm = J((r, s) => {
      function a(d, m) {
        for (var y = 0, x = m.length - 1; y < x; y++) {
          if (!d[m[y]]) return null;
          d = d[m[y]];
        }
        return d;
      }
      s.exports = a;
    }), dp = J((r, s) => {
      function a(m) {
        return m === "~0" ? "~" : "/";
      }
      function d(m) {
        var y = m.split("/");
        if (m.indexOf("~") === -1) return y;
        for (var x = 0, w = y.length; x < w; x++) y[x].indexOf("~") !== -1 && (y[x] = y[x].replace(/~[01]/g, a));
        return y;
      }
      s.exports = d;
    }), YEe = J((r, s) => {
      var a = Fm(), d = dp();
      function m(y, x) {
        var w = d(x), T = w[w.length - 1], P = a(y, w);
        return P ? P[T] : void 0;
      }
      s.exports = m;
    }), GR = J((r, s) => {
      function a(d, m) {
        if (d === m) return !0;
        if (!(d && m) || typeof d != "object" || typeof m != "object" || d.length !== m.length) return !1;
        if (Array.isArray(d)) {
          if (!Array.isArray(m)) return !1;
          for (var y = 0, x = d.length; y < x; y++) if (!a(d[y], m[y])) return !1;
          return !0;
        }
        var w = Object.keys(d);
        if (w.length !== Object.keys(m).length) return !1;
        for (var T = 0, P = w.length; T < P; T++) {
          var M = w[T];
          if (!a(d[M], m[M])) return !1;
        }
        return !0;
      }
      s.exports = a;
    }), qR = J((r, s) => {
      function a(d, m) {
        if (m === "-") return d.length;
        for (var y = 0, x = m.length; y < x; y++) {
          var w = m.charCodeAt(y);
          if (57 < w || w < 48) return 1 / 0;
        }
        return +m;
      }
      s.exports = a;
    }), HR = J((r, s) => {
      var a = GR(), d = Fm(), m = qR(), y = dp();
      function x(w, T, P, M) {
        if (typeof P > "u") return "[op:add] require value, but got undefined";
        var F = y(T), O = F[F.length - 1], N = d(w, F);
        if (N === null) return "[op:add] path not found: " + T;
        if (Array.isArray(N)) {
          var B = m(N, O);
          if (N.length < B) return "[op:add] invalid array index: " + T;
          M(w, F).splice(B, 0, P);
        } else a(N[O], P) || (M(w, F)[O] = P);
      }
      s.exports = x;
    }), Yue = J((r, s) => {
      var a = Fm(), d = qR(), m = dp();
      function y(x, w, T) {
        var P = m(w), M = P[P.length - 1], F = a(x, P);
        if (F === null) return "[op:remove] path not found: " + w;
        if (Array.isArray(F)) {
          var O = d(F, M);
          if (F.length <= O) return "[op:remove] invalid array index: " + w;
          T(x, P).splice(O, 1);
        } else delete T(x, P)[M];
      }
      s.exports = y;
    }), Xue = J((r, s) => {
      var a = GR(), d = Fm(), m = qR(), y = dp();
      function x(w, T, P, M) {
        if (typeof P > "u") return "[op:replace] require value, but got undefined";
        var F = y(T), O = F[F.length - 1], N = d(w, F);
        if (N === null) return "[op:replace] path not found: " + T;
        if (Array.isArray(N)) {
          var B = m(N, O);
          if (N.length <= B) return "[op:replace] invalid array index: " + T;
          a(N[B], P) || M(w, F).splice(B, 1, P);
        } else a(N[O], P) || (M(w, F)[O] = P);
      }
      s.exports = x;
    }), Que = J((r, s) => {
      var a = HR(), d = Fm(), m = qR(), y = dp();
      function x(w, T, P, M) {
        if (P !== T) {
          var F = y(T), O = F[F.length - 1], N = d(w, F);
          if (N === null) return "[op:move] path not found: " + T;
          var B = void 0;
          if (Array.isArray(N)) {
            var U = m(N, O);
            if (N.length <= U) return "[op:move] invalid array index: " + P;
            B = N[U], M(w, F).splice(U, 1);
          } else B = N[O], delete M(w, F)[O];
          return a(w, P, B, M);
        }
      }
      s.exports = x;
    }), Zue = J((r, s) => {
      var a = Fm(), d = dp(), m = HR();
      function y(x, w, T, P) {
        var M = d(w), F = M[M.length - 1], O = a(x, M);
        return O === null ? "[op:copy] path not found: " + w : m(x, T, O[F], P);
      }
      s.exports = y;
    }), Jue = J((r, s) => {
      var a = GR(), d = Fm(), m = dp();
      function y(x, w, T) {
        var P = m(w), M = P[P.length - 1], F = d(x, P);
        if (F === null) return "[op:test] path not found: " + w;
        if (!a(F[M], T)) {
          var O = JSON.stringify(F[M]), N = JSON.stringify(T);
          return "[op:test] not matched: " + O + " " + N;
        }
      }
      s.exports = y;
    }), VU = J((r, s) => {
      function a(d) {
        if (!d || typeof d != "object") return d;
        if (Array.isArray(d)) {
          for (var m = d.length, y = new Array(m), x = 0; x < m; x++) y[x] = d[x];
          return y;
        }
        for (var w = Object.keys(d), T = {}, P = 0, M = w.length; P < M; P++) {
          var F = w[P];
          T[F] = d[F];
        }
        return T;
      }
      s.exports = a;
    }), XEe = J((r, s) => {
      var a = YEe(), d = HR(), m = Yue(), y = Xue(), x = Que(), w = Zue(), T = Jue(), P = GR(), M = VU(), F = dp();
      function O(N, B) {
        return { get: function(U) {
          return a(N, U);
        }, add: function(U, H) {
          return d(N, U, H, B);
        }, remove: function(U) {
          return m(N, U, B);
        }, replace: function(U, H) {
          return y(N, U, H, B);
        }, move: function(U, H) {
          return x(N, U, H, B);
        }, copy: function(U, H) {
          return w(N, U, H, B);
        }, test: function(U, H) {
          return T(N, U, H);
        }, deepEqual: P, shallowCopy: M, toKeys: F };
      }
      s.exports = O;
    }), QEe = J((r, s) => {
      function a(d, m, y, x) {
        return x.error = y, x.partial ? m[""] : d;
      }
      s.exports = a;
    }), ZEe = J((r, s) => {
      function a(d) {
        return !!d;
      }
      s.exports = a;
    }), JEe = J((r, s) => {
      function a(d) {
        if (d) throw new TypeError(d);
      }
      s.exports = a;
    }), eTe = J((r, s) => {
      var a = VU();
      function d(m, y) {
        for (var x = 0, w = y.length - 1; x < w; x++) m = m[y[x]] = a(m[y[x]]);
        return m;
      }
      s.exports = d;
    }), tTe = J((r, s) => {
      var a = VU();
      function d(y, x, w) {
        var T = y[x];
        return w.has(T) || (T = a(T), w.add(T)), T;
      }
      function m(y, x, w) {
        for (var T = 0, P = x.length - 1; T < P; T++) y = y[x[T]] = d(y, x[T], w);
        return y;
      }
      s.exports = m;
    }), nTe = J((r, s) => {
      var a = XEe(), d = QEe(), m = ZEe(), y = JEe(), x = eTe(), w = tTe(), T = HR(), P = Yue(), M = Xue(), F = Que(), O = Zue(), N = Jue(), B = Set || function() {
        var H = [];
        return H.has = function(W) {
          return this.indexOf(W) !== -1;
        }, H.add = function(W) {
          this.push(W);
        }, H;
      };
      function U(H, W, Q) {
        if (W.length === 0) return H;
        Q = Q || {};
        for (var ne = Q.strict ? y : m, ce = W.length === 1 ? x : /* @__PURE__ */ function(ye) {
          return function(Ee, ve) {
            return w(Ee, ve, ye);
          };
        }(new B()), ue = { "": H }, se, Oe = 0, he = W.length; Oe < he; Oe++) {
          var ie = W[Oe];
          switch (ie.op) {
            case "add":
              if (ne(T(ue, "" + ie.path, ie.value, ce))) return d(H, ue, ie, Q);
              break;
            case "remove":
              if (ne(P(ue, "" + ie.path, ce))) return d(H, ue, ie, Q);
              break;
            case "replace":
              if (ne(M(ue, "" + ie.path, ie.value, ce))) return d(H, ue, ie, Q);
              break;
            case "move":
              if (ne(F(ue, "" + ie.from, "" + ie.path, ce))) return d(H, ue, ie, Q);
              break;
            case "copy":
              if (ne(O(ue, "" + ie.from, "" + ie.path, ce))) return d(H, ue, ie, Q);
              break;
            case "test":
              if (ne(N(ue, "" + ie.path, ie.value))) return d(H, ue, ie, Q);
              break;
            default:
              if (Q.custom && Q.custom[ie.op]) {
                if (se = se || a(ue, ce), ne(Q.custom[ie.op](se, ie, Oe, W))) return d(H, ue, ie, Q);
              } else return ne("[op:" + ie.op + "] unknown"), d(H, ue, ie, Q);
              break;
          }
        }
        return ue[""];
      }
      s.exports = U;
    }), rTe = J((r, s) => {
      s.exports = nTe();
    }), iTe = J((r, s) => {
      (function(a, d) {
        typeof r == "object" && typeof s == "object" ? s.exports = d() : typeof r == "object" ? r.blobCompare = d() : a.blobCompare = d();
      })(window, function() {
        return function(a) {
          var d = {};
          function m(y) {
            if (d[y]) return d[y].exports;
            var x = d[y] = { i: y, l: !1, exports: {} };
            return a[y].call(x.exports, x, x.exports, m), x.l = !0, x.exports;
          }
          return m.m = a, m.c = d, m.d = function(y, x, w) {
            m.o(y, x) || Object.defineProperty(y, x, { enumerable: !0, get: w });
          }, m.r = function(y) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(y, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(y, "__esModule", { value: !0 });
          }, m.t = function(y, x) {
            if (1 & x && (y = m(y)), 8 & x || 4 & x && typeof y == "object" && y && y.__esModule) return y;
            var w = /* @__PURE__ */ Object.create(null);
            if (m.r(w), Object.defineProperty(w, "default", { enumerable: !0, value: y }), 2 & x && typeof y != "string") for (var T in y) m.d(w, T, function(P) {
              return y[P];
            }.bind(null, T));
            return w;
          }, m.n = function(y) {
            var x = y && y.__esModule ? function() {
              return y.default;
            } : function() {
              return y;
            };
            return m.d(x, "a", x), x;
          }, m.o = function(y, x) {
            return Object.prototype.hasOwnProperty.call(y, x);
          }, m.p = "", m(m.s = 4);
        }([function(a, d, m) {
          var y = function(M, F) {
            if (Array.isArray(M)) return M;
            if (Symbol.iterator in Object(M)) return function(O, N) {
              var B = [], U = !0, H = !1, W = void 0;
              try {
                for (var Q, ne = O[Symbol.iterator](); !(U = (Q = ne.next()).done) && (B.push(Q.value), !N || B.length !== N); U = !0) ;
              } catch (ce) {
                H = !0, W = ce;
              } finally {
                try {
                  !U && ne.return && ne.return();
                } finally {
                  if (H) throw W;
                }
              }
              return B;
            }(M, F);
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }, x = /* @__PURE__ */ function() {
            function M(F, O) {
              for (var N = 0; N < O.length; N++) {
                var B = O[N];
                B.enumerable = B.enumerable || !1, B.configurable = !0, "value" in B && (B.writable = !0), Object.defineProperty(F, B.key, B);
              }
            }
            return function(F, O, N) {
              return O && M(F.prototype, O), N && M(F, N), F;
            };
          }();
          function w(M) {
            if (Array.isArray(M)) {
              for (var F = 0, O = Array(M.length); F < M.length; F++) O[F] = M[F];
              return O;
            }
            return Array.from(M);
          }
          var T = m(2), P = function(M) {
            function F(O) {
              (function(B, U) {
                if (!(B instanceof U)) throw new TypeError("Cannot call a class as a function");
              })(this, F);
              var N = function(B, U) {
                if (!B) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return !U || typeof U != "object" && typeof U != "function" ? B : U;
              }(this, (F.__proto__ || Object.getPrototypeOf(F)).call(this));
              return N._messageId = 1, N._messages = /* @__PURE__ */ new Map(), N._worker = O, N._worker.onmessage = N._onMessage.bind(N), N._id = Math.ceil(1e7 * Math.random()), N;
            }
            return function(O, N) {
              if (typeof N != "function" && N !== null) throw new TypeError("Super expression must either be null or a function, not " + typeof N);
              O.prototype = Object.create(N && N.prototype, { constructor: { value: O, enumerable: !1, writable: !0, configurable: !0 } }), N && (Object.setPrototypeOf ? Object.setPrototypeOf(O, N) : O.__proto__ = N);
            }(F, M), x(F, [{ key: "terminate", value: function() {
              this._worker.terminate();
            } }, { key: "isFree", value: function() {
              return this._messages.size === 0;
            } }, { key: "jobsLength", value: function() {
              return this._messages.size;
            } }, { key: "exec", value: function(O) {
              var N = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null, B = this, U = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], H = arguments[3];
              return new Promise(function(W, Q) {
                var ne = B._messageId++;
                B._messages.set(ne, [W, Q, H]), B._worker.postMessage([ne, N, O], U || []);
              });
            } }, { key: "postMessage", value: function() {
              var O = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null, N = this, B = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], U = arguments[2];
              return new Promise(function(H, W) {
                var Q = N._messageId++;
                N._messages.set(Q, [H, W, U]), N._worker.postMessage([Q, O], B || []);
              });
            } }, { key: "emit", value: function(O) {
              for (var N = arguments.length, B = Array(N > 1 ? N - 1 : 0), U = 1; U < N; U++) B[U - 1] = arguments[U];
              this._worker.postMessage({ eventName: O, args: B });
            } }, { key: "_onMessage", value: function(O) {
              var N;
              if (!Array.isArray(O.data) && O.data.eventName) return (N = function Q(ne, ce, ue) {
                ne === null && (ne = Function.prototype);
                var se = Object.getOwnPropertyDescriptor(ne, ce);
                if (se === void 0) {
                  var Oe = Object.getPrototypeOf(ne);
                  return Oe === null ? void 0 : Q(Oe, ce, ue);
                }
                if ("value" in se) return se.value;
                var he = se.get;
                return he !== void 0 ? he.call(ue) : void 0;
              }(F.prototype.__proto__ || Object.getPrototypeOf(F.prototype), "emit", this)).call.apply(N, [this, O.data.eventName].concat(w(O.data.args)));
              var B, U = (B = O.data, Array.isArray(B) ? B : Array.from(B)), H = U[0], W = U.slice(1);
              if (H === 1) this._onEvent.apply(this, w(W));
              else {
                if (H !== 0) throw new Error("Wrong message type '" + H + "'");
                this._onResult.apply(this, w(W));
              }
            } }, { key: "_onResult", value: function(O, N, B) {
              var U = this._messages.get(O), H = y(U, 2), W = H[0], Q = H[1];
              return this._messages.delete(O), N === 1 ? W(B) : Q(B);
            } }, { key: "_onEvent", value: function(O, N, B) {
              var U = this._messages.get(O), H = y(U, 3)[2];
              H && H(N, B);
            } }]), F;
          }(T);
          a.exports = P;
        }, function(a, d, m) {
          a.exports = function() {
            return m(3)(`!function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=2)}([function(e,t,r){"use strict";var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}(),o=function e(t,r,n){null===t&&(t=Function.prototype);var o=Object.getOwnPropertyDescriptor(t,r);if(void 0===o){var i=Object.getPrototypeOf(t);return null===i?void 0:e(i,r,n)}if("value"in o)return o.value;var a=o.get;return void 0!==a?a.call(n):void 0},i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e};function a(e){if(Array.isArray(e)){for(var t=0,r=Array(e.length);t<e.length;t++)r[t]=e[t];return r}return Array.from(e)}function u(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var f=r(1),c=0,l=1,s=0,y=1,p="main",b=function(e){return"object"===(void 0===e?"undefined":i(e))&&"function"==typeof e.then&&"function"==typeof e.catch};var v=function e(t,r){u(this,e),this.payload=t,this.transferable=r};e.exports=function(e){var t,r,i,h=(i=e,(r=p)in(t={})?Object.defineProperty(t,r,{value:i,enumerable:!0,configurable:!0,writable:!0}):t[r]=i,t),d=self.postMessage.bind(self),m=new(function(e){function t(){return u(this,t),function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).apply(this,arguments))}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,e),n(t,[{key:"emit",value:function(e){for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];return d({eventName:e,args:r}),this}},{key:"emitLocally",value:function(e){for(var r,n=arguments.length,i=Array(n>1?n-1:0),a=1;a<n;a++)i[a-1]=arguments[a];(r=o(t.prototype.__proto__||Object.getPrototypeOf(t.prototype),"emit",this)).call.apply(r,[this,e].concat(i))}},{key:"operation",value:function(e,t){return h[e]=t,this}}]),t}(f)),g=function(e,t,r){var n=function(t){t&&t instanceof v?w(e,y,t.payload,t.transferable):w(e,y,t)},o=function(t){w(e,s,{message:t.message,stack:t.stack})};try{var i=_(e,t,r);b(i)?i.then(n).catch(o):n(i)}catch(e){o(e)}},_=function(e,t,r){var n=h[r||p];if(!n)throw new Error("Not found handler for this request");return n(t,O.bind(null,e))},w=function(e,t,r){var n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];d([c,e,t,r],n)},O=function(e,t,r){if(!t)throw new Error("eventName is required");if("string"!=typeof t)throw new Error("eventName should be string");d([l,e,t,r])};return self.addEventListener("message",(function(e){var t=e.data;Array.isArray(t)?g.apply(void 0,a(t)):t&&t.eventName&&m.emitLocally.apply(m,[t.eventName].concat(a(t.args)))})),m},e.exports.TransferableResponse=v},function(e,t,r){"use strict";var n=function(){function e(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,r,n){return r&&e(t.prototype,r),n&&e(t,n),t}}();var o=function(){function e(){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),Object.defineProperty(this,"__listeners",{value:{},enumerable:!1,writable:!1})}return n(e,[{key:"emit",value:function(e){if(!this.__listeners[e])return this;for(var t=arguments.length,r=Array(t>1?t-1:0),n=1;n<t;n++)r[n-1]=arguments[n];var o=!0,i=!1,a=void 0;try{for(var u,f=this.__listeners[e][Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var c=u.value;c.apply(void 0,r)}}catch(e){i=!0,a=e}finally{try{!o&&f.return&&f.return()}finally{if(i)throw a}}return this}},{key:"once",value:function(e,t){var r=this,n=function n(){r.off(e,n),t.apply(void 0,arguments)};return this.on(e,n)}},{key:"on",value:function(e,t){return this.__listeners[e]||(this.__listeners[e]=[]),this.__listeners[e].push(t),this}},{key:"off",value:function(e,t){return this.__listeners[e]=t?this.__listeners[e].filter((function(e){return e!==t})):[],this}}]),e}();e.exports=o},function(e,t,r){"use strict";r.r(t);var n=r(0);r.n(n)()().operation("binary",async({blob:e,chunk:t})=>await function(e,t){return new Promise((r,n)=>{const o=new FileReader,i=t?Math.min(t,e.size):e.size,a=e.slice(0,i);o.onload=()=>r(o.result),o.onerror=n,o.readAsBinaryString(a)})}(e,t)).operation("buffer",async({blob:e,chunk:t})=>await function(e,t){return new Promise((r,n)=>{const o=new FileReader,i=t?Math.min(t,e.size):e.size,a=e.slice(0,i);o.onload=()=>r(o.result),o.onerror=n,o.readAsArrayBuffer(a)})}(e,t)).operation("compare",({buf1:e,buf2:t})=>(function(e,t){if(e===t)return!0;if(e.byteLength!==t.byteLength)return!1;const r=new DataView(e),n=new DataView(t);for(var o=e.byteLength;o--;)if(r.getUint8(o)!==n.getUint8(o))return!1;return!0})(e,t))}]);`, null);
          };
        }, function(a, d, m) {
          var y = /* @__PURE__ */ function() {
            function w(T, P) {
              for (var M = 0; M < P.length; M++) {
                var F = P[M];
                F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty(T, F.key, F);
              }
            }
            return function(T, P, M) {
              return P && w(T.prototype, P), M && w(T, M), T;
            };
          }(), x = function() {
            function w() {
              (function(T, P) {
                if (!(T instanceof P)) throw new TypeError("Cannot call a class as a function");
              })(this, w), Object.defineProperty(this, "__listeners", { value: {}, enumerable: !1, writable: !1 });
            }
            return y(w, [{ key: "emit", value: function(T) {
              if (!this.__listeners[T]) return this;
              for (var P = arguments.length, M = Array(P > 1 ? P - 1 : 0), F = 1; F < P; F++) M[F - 1] = arguments[F];
              var O = !0, N = !1, B = void 0;
              try {
                for (var U, H = this.__listeners[T][Symbol.iterator](); !(O = (U = H.next()).done); O = !0) {
                  var W = U.value;
                  W.apply(void 0, M);
                }
              } catch (Q) {
                N = !0, B = Q;
              } finally {
                try {
                  !O && H.return && H.return();
                } finally {
                  if (N) throw B;
                }
              }
              return this;
            } }, { key: "once", value: function(T, P) {
              var M = this, F = function O() {
                M.off(T, O), P.apply(void 0, arguments);
              };
              return this.on(T, F);
            } }, { key: "on", value: function(T, P) {
              return this.__listeners[T] || (this.__listeners[T] = []), this.__listeners[T].push(P), this;
            } }, { key: "off", value: function(T, P) {
              return this.__listeners[T] = P ? this.__listeners[T].filter(function(M) {
                return M !== P;
              }) : [], this;
            } }]), w;
          }();
          a.exports = x;
        }, function(a, d, m) {
          var y = window.URL || window.webkitURL;
          a.exports = function(x, w) {
            try {
              try {
                var T;
                try {
                  (T = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder)()).append(x), T = T.getBlob();
                } catch {
                  T = new Blob([x]);
                }
                return new Worker(y.createObjectURL(T));
              } catch {
                return new Worker("data:application/javascript," + encodeURIComponent(x));
              }
            } catch {
              if (!w) throw Error("Inline worker is not supported");
              return new Worker(w);
            }
          };
        }, function(a, d, m) {
          m.r(d);
          var y = m(0), x = m.n(y), w = m(1), T = m.n(w);
          m.d(d, "workersEnabled", function() {
            return P;
          }), m.d(d, "default", function() {
            return M;
          });
          let P = !!window.Worker;
          class M {
            static toBinaryStringWithWorker(O, N) {
              return dt(this, null, function* () {
                let B = new x.a(new T.a()), U = yield B.exec("binary", { blob: O, chunk: N });
                return B.terminate(), U;
              });
            }
            static toBinaryStringWithoutWorker(O, N) {
              return function(B, U) {
                return new Promise((H, W) => {
                  let Q = new FileReader(), ne = U ? Math.min(U, B.size) : B.size, ce = B.slice(0, ne);
                  Q.onload = () => H(Q.result), Q.onerror = W, Q.readAsBinaryString(ce);
                });
              }(O, N);
            }
            static toBinaryString(O, N, B = !0) {
              return B && P ? this.toBinaryStringWithWorker(O, N) : this.toBinaryStringWithoutWorker(O, N);
            }
            static toArrayBufferWithWorker(O, N) {
              return dt(this, null, function* () {
                let B = new x.a(new T.a()), U = yield B.exec("buffer", { blob: O, chunk: N });
                return B.terminate(), U;
              });
            }
            static toArrayBufferWithoutWorker(O, N) {
              return function(B, U) {
                return new Promise((H, W) => {
                  let Q = new FileReader(), ne = U ? Math.min(U, B.size) : B.size, ce = B.slice(0, ne);
                  Q.onload = () => H(Q.result), Q.onerror = W, Q.readAsArrayBuffer(ce);
                });
              }(O, N);
            }
            static toArrayBuffer(O, N, B = !0) {
              return B && P ? this.toArrayBufferWithWorker(O, N) : this.toArrayBufferWithoutWorker(O, N);
            }
            static compareBuffersWithWorker(O, N) {
              return dt(this, null, function* () {
                if (O === N) return !0;
                let B = new x.a(new T.a()), U = yield B.exec("compare", { buf1: O, buf2: N }, [O, N]);
                return B.terminate(), U;
              });
            }
            static compareBuffersWithoutWorker(O, N) {
              return function(B, U) {
                if (B === U) return !0;
                if (B.byteLength !== U.byteLength) return !1;
                let H = new DataView(B), W = new DataView(U);
                for (var Q = B.byteLength; Q--; ) if (H.getUint8(Q) !== W.getUint8(Q)) return !1;
                return !0;
              }(O, N);
            }
            static compareBuffers(O, N, B = !0) {
              return B && P ? this.compareBuffersWithWorker(O, N) : this.compareBuffersWithoutWorker(O, N);
            }
            static sizeEqual(O, N) {
              return O.size === N.size;
            }
            static typeEqual(O, N) {
              return O.type === N.type;
            }
            static magicNumbersEqual(O, N, B = !0) {
              return dt(this, null, function* () {
                if (O === N) return !0;
                let U = [24, 16, 14, 12, 8, 6, 4], [H, W] = yield Promise.all([this.toBinaryString(O, 24, B), this.toBinaryString(N, 24, B)]);
                for (let Q of U) if (H.substring(0, Q) === W.substring(0, Q)) return !0;
                return !1;
              });
            }
            static bytesEqualWithBinaryString(O, N, B, U = !0) {
              return dt(this, null, function* () {
                if (O === N) return !0;
                let [H, W] = yield Promise.all([this.toBinaryString(O, B, U), this.toBinaryString(N, B, U)]);
                return H === W;
              });
            }
            static bytesEqualWithArrayBuffer(O, N, B, U = !0) {
              return dt(this, null, function* () {
                if (O === N) return !0;
                let [H, W] = yield Promise.all([this.toArrayBuffer(O, B, U), this.toArrayBuffer(N, B, U)]);
                return this.compareBuffers(H, W, U);
              });
            }
            static isEqual(O, N) {
              return dt(this, arguments, function* (B, U, { methods: H = ["size", "type", "magic", "byte"], byte: W = "buffer", partial: Q = !1, chunks: ne = null, worker: ce = !0 } = {}) {
                let ue = null;
                for (let se of H) {
                  if (ue === !1 || Q && ue === !0) break;
                  switch (se) {
                    case "byte":
                    case "bytes":
                    case "content":
                      ne = ne instanceof Array ? ne : [B.size], ue = !0;
                      for (let Oe of ne) {
                        let he = !1;
                        he = W === "buffer" ? yield this.bytesEqualWithArrayBuffer(B, U, Oe, ce) : yield this.bytesEqualWithBinaryString(B, U, Oe, ce), he || (ue = !1);
                      }
                      break;
                    case "magic":
                    case "headers":
                    case "numbers":
                    case "mime":
                      ue = yield this.magicNumbersEqual(B, U, ce);
                      break;
                    case "size":
                    case "sizes":
                      ue = this.sizeEqual(B, U);
                      break;
                    case "type":
                    case "types":
                      ue = this.typeEqual(B, U);
                      break;
                    default:
                      throw new Error("Blob-compare : Unknown comparison method");
                  }
                }
                return ue;
              });
            }
          }
        }]);
      });
    }), ece = {};
    ge(ece, { ToolbarDropdownSelect: () => PCe, default: () => kCe }), c.exports = Fe(ece), st();
    function $R(r, s, a = []) {
      if (typeof r == "object" && r) {
        if (sTe(r) || oTe(r)) {
          s(r, a);
          return;
        }
        for (let [d, m] of Object.entries(r)) $R(m, s, [...a, d]);
      } else {
        if (r == null) return;
        s(r, a);
      }
    }
    var sTe = (r) => typeof r == "object" && r !== null && Object.hasOwnProperty.call(r, "type") && r.type === "image" && Object.hasOwnProperty.call(r, "id") && typeof r.id == "string" && r.id !== "", oTe = (r) => typeof r == "object" && r !== null && Object.hasOwnProperty.call(r, "r") && Object.hasOwnProperty.call(r, "g") && Object.hasOwnProperty.call(r, "b") && Object.hasOwnProperty.call(r, "a") && typeof r.r == "number" && typeof r.g == "number" && typeof r.b == "number" && typeof r.a == "number", tce = ut();
    _r();
    var aTe = 0, lTe = class {
      constructor(r) {
        this._studio = r, Me(this, "_id"), Me(this, "_state", { type: "Ready" }), this._id = String(aTe++);
      }
      get status() {
        return this._state.type;
      }
      reset() {
        let { _state: r } = this;
        if (r.type !== "Ready") if (r.type === "Captured") this._state = { type: "Ready" }, r.transaction.discard(), r.flagsTransaction.discard();
        else throw r.type === "Committed" ? new Error("This scrub is already committed and can't be reset.") : new Error("This scrub is already discarded and can't be reset.");
      }
      commit() {
        let { _state: r } = this;
        if (r.type === "Captured") r.transaction.commit(), r.flagsTransaction.discard(), this._state = { type: "Committed" };
        else if (r.type === "Ready") {
          console.warn("Scrub is empty. Nothing to commit.");
          return;
        } else throw r.type === "Committed" ? new Error("This scrub is already committed.") : new Error("This scrub is already discarded and can't be comitted.");
      }
      capture(r) {
        if (this._state.type === "Captured" && this.reset(), this._state.type === "Ready") {
          let s = !0;
          try {
            this._state = L({ type: "Captured" }, this._capture(r)), s = !1;
          } finally {
            s && (console.error("This scrub's callback threw an error. We're undo-ing all of the changes made by this scrub, and marking it as discarded."), this._state = { type: "Discarded" });
          }
        } else throw this._state.type === "Committed" ? new Error("This scrub is already committed and cannot capture again. If you wish to capture more, you can start a new studio.scrub() or do so before scrub.commit()") : new Error("This scrub is already discarded and cannot capture again. If you wish to capture more, you can start a new studio.scrub() or do so before scrub.discard()");
      }
      _capture(r) {
        let s = [], a = this._studio.tempTransaction((m) => {
          let y = !0, x = { set: (w, T) => {
            if (!y) throw new Error("You seem to have called the scrub api after scrub.capture()");
            let { root: P, path: M } = (0, tce.getPointerParts)(w);
            if (!an(P)) throw new Error("We can only scrub props of Sheet Objects for now");
            m.set(w, T), s.push(w);
          } };
          try {
            r(x);
          } finally {
            y = !1;
          }
        }), d = this._studio.tempTransaction(({ stateEditors: m }) => {
          s.forEach((y) => {
            let { root: x, path: w } = (0, tce.getPointerParts)(y);
            if (!an(x)) return;
            let T = x.template.getDefaultsAtPointer(y);
            $R(T, (P, M) => {
              m.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey.propsBeingScrubbed.flag(V(L({}, x.address), { pathToProp: M }));
            }, w);
          });
        });
        return { transaction: a, flagsTransaction: d };
      }
      discard() {
        let { _state: r } = this;
        if (r.type === "Captured" || r.type === "Ready") r.type === "Captured" && (r.transaction.discard(), r.flagsTransaction.discard()), this._state = { type: "Discarded" };
        else throw r.type === "Committed" ? new Error("This scrub is already committed and can't be discarded.") : new Error("This scrub is already discarded");
      }
    }, uTe = ut(), nce = typeof window < "u" ? Promise.resolve().then(() => (zEe(), Uue)).then((r) => r.default) : null, cTe = class {
      constructor(r) {
        this.studio = r, Me(this, "_rendered", !1), Me(this, "_nonSSRBits", nce ? nce.then((s) => new s()) : Promise.reject()), Me(this, "ready", this._nonSSRBits.then(() => {
        }, () => {
        }));
      }
      render() {
        this._rendered || (this._rendered = !0, this._nonSSRBits.then((r) => {
          r.render();
        }).catch((r) => {
          throw console.error(r), r;
        }));
      }
      hide() {
        this.studio.transaction(({ drafts: r }) => {
          r.ahistoric.visibilityState = "everythingIsHidden";
        });
      }
      restore() {
        this.render(), this.studio.transaction(({ drafts: r }) => {
          r.ahistoric.visibilityState = "everythingIsVisible";
        });
      }
      get isHidden() {
        return (0, uTe.val)(this.studio.atomP.ahistoric.visibilityState) === "everythingIsHidden";
      }
      renderToolset(r, s) {
        let a = !1, d = null;
        return this._nonSSRBits.then((m) => {
          a || (d = m.renderToolset(r, s));
        }).catch((m) => {
          console.error(m);
        }), () => {
          if (d) {
            d();
            return;
          }
          a || (a = !0);
        };
      }
    }, WR = ut();
    function dTe(r) {
      return r;
    }
    var hTe = (r, s = dTe) => {
      let a = (d) => ({ type: r, payload: s(d) });
      return a.type = r, a.is = (d) => d && d.type && d.type === r, a;
    }, nc = hTe, rce = Y(KEe()), ice = Y(rTe());
    ia();
    var KR, pTe = new Uint8Array(16);
    function fTe() {
      if (!KR && (KR = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !KR)) throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      return KR(pTe);
    }
    var mTe = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    function gTe(r) {
      return typeof r == "string" && mTe.test(r);
    }
    var yTe = gTe, ws = [];
    for (YR = 0; YR < 256; ++YR) ws.push((YR + 256).toString(16).substr(1));
    var YR;
    function vTe(r) {
      var s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, a = (ws[r[s + 0]] + ws[r[s + 1]] + ws[r[s + 2]] + ws[r[s + 3]] + "-" + ws[r[s + 4]] + ws[r[s + 5]] + "-" + ws[r[s + 6]] + ws[r[s + 7]] + "-" + ws[r[s + 8]] + ws[r[s + 9]] + "-" + ws[r[s + 10]] + ws[r[s + 11]] + ws[r[s + 12]] + ws[r[s + 13]] + ws[r[s + 14]] + ws[r[s + 15]]).toLowerCase();
      if (!yTe(a)) throw TypeError("Stringified UUID is invalid");
      return a;
    }
    var bTe = vTe;
    function xTe(r, s, a) {
      r = r || {};
      var d = r.random || (r.rng || fTe)();
      if (d[6] = d[6] & 15 | 64, d[8] = d[8] & 63 | 128, s) {
        a = a || 0;
        for (var m = 0; m < 16; ++m) s[a + m] = d[m];
        return s;
      }
      return bTe(d);
    }
    var _Te = xTe, DS = { replaceHistory: nc("@history/replaceHistory"), startHistoryFromScratch: nc("@history/startHistoryFromScratch"), undo: nc("@history/undo"), redo: nc("@history/redo") }, STe = { type: "@history/unknownAction", payload: "" }, wTe = { maxNumberOfCommits: 100 }, ETe = (r, s = wTe) => {
      let a = GU(r(void 0, STe));
      return function(d, m) {
        return DS.startHistoryFromScratch.is(m) ? GU(r(void 0, m.payload)) : DS.replaceHistory.is(m) ? m.payload : DS.undo.is(m) ? d ? PTe(d) : a : DS.redo.is(m) ? d ? ATe(d) : a : d ? TTe(d, r(d.innerState, m), s) : GU(r(void 0, m));
      };
    };
    function GU(r) {
      return { currentCommitHash: void 0, commitsByHash: {}, listOfCommitHashes: [], innerState: r };
    }
    function TTe(r, s, a) {
      if (s === r.innerState) return r;
      let d = CTe(r.innerState, s);
      if (d.forwardDiff.length === 0) return r;
      let m = Qc(r.listOfCommitHashes), y = { currentCommitHash: d.hash, commitsByHash: L({}, r.commitsByHash), listOfCommitHashes: [...r.listOfCommitHashes], innerState: s };
      if (r.currentCommitHash !== m) {
        let x = r.listOfCommitHashes.findIndex((w) => w === r.currentCommitHash);
        r.listOfCommitHashes.slice(x + 1).forEach((w) => {
          delete y.commitsByHash[w];
        }), y.listOfCommitHashes.splice(x + 1, y.listOfCommitHashes.length);
      }
      if (y.listOfCommitHashes.push(d.hash), y.commitsByHash[d.hash] = d, y.listOfCommitHashes.length > a.maxNumberOfCommits) {
        let x = y.listOfCommitHashes.length - a.maxNumberOfCommits;
        y.listOfCommitHashes.slice(0, x).forEach((w) => {
          delete y.commitsByHash[w];
        }), y.listOfCommitHashes.splice(0, x);
      }
      return y;
    }
    function CTe(r, s) {
      let a = rce.default.diff(r, s, { invertible: !1 }), d = rce.default.diff(s, r, { invertible: !1 }), m = Date.now(), y = _Te();
      return { forwardDiff: a, backwardDiff: d, timestamp: m, hash: y };
    }
    function PTe(r) {
      if (r.currentCommitHash === void 0) return r;
      let s = r.listOfCommitHashes.findIndex((x) => x === r.currentCommitHash);
      if (s === -1) throw new Error("This should never happen");
      let a = r.commitsByHash[r.currentCommitHash], d = (0, ice.default)(r.innerState, a.backwardDiff), m = s - 1, y = m === -1 ? void 0 : r.listOfCommitHashes[m];
      return V(L({}, r), { currentCommitHash: y, innerState: d });
    }
    function ATe(r) {
      if (r.listOfCommitHashes.length === 0) return r;
      let s = r.listOfCommitHashes.findIndex((x) => x === r.currentCommitHash);
      if (s === r.listOfCommitHashes.length - 1) return r;
      let a = s + 1, d = r.listOfCommitHashes[a], m = r.commitsByHash[d], y = (0, ice.default)(r.innerState, m.forwardDiff);
      return V(L({}, r), { currentCommitHash: d, innerState: y });
    }
    pR();
    var XR = { ahistoric: { visibilityState: "everythingIsVisible", theTrigger: { position: { closestCorner: "bottomLeft", distanceFromHorizontalEdge: 0.02, distanceFromVerticalEdge: 0.02 } }, coreByProject: {}, projects: { stateByProjectId: {} } }, historic: { projects: { stateByProjectId: {} }, autoKey: !0, coreByProject: {}, panels: { sequenceEditor: { rightPanelOpen: !0 } }, panelInstanceDesceriptors: {} }, ephemeral: { initialised: !1, coreByProject: {}, projects: { stateByProjectId: {} }, extensions: { byId: {}, paneClasses: {} }, showOutline: !1 } }, sce = nc("@storeBundle/replacePersistentState", (r) => r), oce = nc("@storeBundle/reduceParts", (r) => r), yv = { historic: DS, replacePersistentState: sce, reduceParts: oce }, ace = nc("@storeBundle/setInnerHistoricState", (r) => r), kTe = (r = XR.historic, s) => ace.is(s) ? s.payload : r, qU = ETe(kTe), lce = (r, s) => {
      if (sce.is(s)) {
        let { historic: a, ahistoric: d } = s.payload, m = r?.ephemeral || XR.ephemeral;
        return { $persistent: { historic: a, ahistoric: d }, ephemeral: m };
      } else if (r) {
        let { historic: a, ahistoric: d } = r.$persistent, { ephemeral: m } = r;
        if (oce.is(s)) {
          let y = { historic: r.$persistent.historic.innerState, ahistoric: r.$persistent.ahistoric, ephemeral: r.ephemeral }, x = s.payload(y);
          if (x === y) return r;
          a.innerState !== x.historic && (a = qU(a, ace(x.historic))), d = x.ahistoric, m = x.ephemeral;
        } else {
          let y = qU(a, s);
          if (y === a) return r;
          a = y;
        }
        return { $persistent: a === r.$persistent.historic && d === r.$persistent.ahistoric ? r.$persistent : { historic: a, ahistoric: d }, ephemeral: m };
      } else {
        let a = qU(void 0, {}), d = XR.ahistoric, m = XR.ephemeral;
        return { $persistent: { historic: a, ahistoric: d }, ephemeral: m };
      }
    }, uce = nc("@history/pushTempAction", (r) => r), cce = nc("@history/discardTempAction", (r) => r), dce = nc("@history/commitTempAction", (r) => r), MTe = 0, RTe = () => {
      let r = MTe++;
      return { push: (s) => uce({ id: r, originalAction: s }), discard: () => cce(r), commit: () => dce(r) };
    }, ITe = (r, s) => {
      if (r) {
        let { tempActions: a, permanent: d } = r.$temps, m;
        if (uce.is(s)) a = [...a, s];
        else if (dce.is(s)) {
          let x = a.find((w) => w.payload.id === s.payload);
          x ? (m = x.payload.originalAction, a = a.filter((w) => w.payload.id !== s.payload)) : hR.error("Comitting temp action group ".concat(s.payload, " isn't possible as this group doesn't exist"));
        } else cce.is(s) ? a = a.filter((x) => x.payload.id !== s.payload) : m = s;
        m && (d = lce(r.$temps.permanent, m));
        let y = { historic: d.$persistent.historic.innerState, ahistoric: d.$persistent.ahistoric, ephemeral: d.ephemeral };
        for (let x of a) y = x.payload.originalAction.payload(y);
        return L({ $temps: { tempActions: a, permanent: d }, $persistent: d.$persistent }, y);
      } else {
        let a = lce(void 0, s);
        return { $temps: { permanent: a, tempActions: [] }, $persistent: a.$persistent, historic: a.$persistent.historic.innerState, ahistoric: a.$persistent.ahistoric, ephemeral: a.ephemeral };
      }
    };
    Xh(), Xh(), Nl();
    function hce(r, s) {
      if (typeof r != "object" || r === null) return;
      if (s.length === 0) {
        for (let x of Object.keys(r)) delete r[x];
        return;
      }
      let a = s.slice(0, s.length - 1), d = r, m = /* @__PURE__ */ new WeakMap();
      for (let x of a) {
        let w = d, T = w[x];
        if (typeof T != "object" || T === null) return;
        m.set(T, w), d = T;
      }
      let y = s.slice().reverse();
      for (let x of y) {
        if (delete d[x], Object.keys(d).length > 0) return;
        d = m.get(d);
      }
    }
    function NTe(r, { scale: s, origin: a, translate: d }) {
      let m = a + (r - a) * s;
      return d + m;
    }
    function Wl(r) {
      for (var s = arguments.length, a = Array(s > 1 ? s - 1 : 0), d = 1; d < s; d++) a[d - 1] = arguments[d];
      throw Error("[Immer] minified error nr: " + r + (a.length ? " " + a.map(function(m) {
        return "'" + m + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function vv(r) {
      return !!r && !!r[ua];
    }
    function Bm(r) {
      return !!r && (function(s) {
        if (!s || typeof s != "object") return !1;
        var a = Object.getPrototypeOf(s);
        if (a === null) return !0;
        var d = Object.hasOwnProperty.call(a, "constructor") && a.constructor;
        return d === Object || typeof d == "function" && Function.toString.call(d) === UTe;
      }(r) || Array.isArray(r) || !!r[Sce] || !!r.constructor[Sce] || $U(r) || WU(r));
    }
    function FS(r, s, a) {
      a === void 0 && (a = !1), bv(r) === 0 ? (a ? Object.keys : sz)(r).forEach(function(d) {
        a && typeof d == "symbol" || s(d, r[d], r);
      }) : r.forEach(function(d, m) {
        return s(m, d, r);
      });
    }
    function bv(r) {
      var s = r[ua];
      return s ? s.i > 3 ? s.i - 4 : s.i : Array.isArray(r) ? 1 : $U(r) ? 2 : WU(r) ? 3 : 0;
    }
    function HU(r, s) {
      return bv(r) === 2 ? r.has(s) : Object.prototype.hasOwnProperty.call(r, s);
    }
    function OTe(r, s) {
      return bv(r) === 2 ? r.get(s) : r[s];
    }
    function pce(r, s, a) {
      var d = bv(r);
      d === 2 ? r.set(s, a) : d === 3 ? (r.delete(s), r.add(a)) : r[s] = a;
    }
    function DTe(r, s) {
      return r === s ? r !== 0 || 1 / r == 1 / s : r != r && s != s;
    }
    function $U(r) {
      return LTe && r instanceof Map;
    }
    function WU(r) {
      return jTe && r instanceof Set;
    }
    function Lm(r) {
      return r.o || r.t;
    }
    function KU(r) {
      if (Array.isArray(r)) return Array.prototype.slice.call(r);
      var s = zTe(r);
      delete s[ua];
      for (var a = sz(s), d = 0; d < a.length; d++) {
        var m = a[d], y = s[m];
        y.writable === !1 && (y.writable = !0, y.configurable = !0), (y.get || y.set) && (s[m] = { configurable: !0, writable: !0, enumerable: y.enumerable, value: r[m] });
      }
      return Object.create(Object.getPrototypeOf(r), s);
    }
    function YU(r, s) {
      return s === void 0 && (s = !1), XU(r) || vv(r) || !Bm(r) || (bv(r) > 1 && (r.set = r.add = r.clear = r.delete = FTe), Object.freeze(r), s && FS(r, function(a, d) {
        return YU(d, !0);
      }, !0)), r;
    }
    function FTe() {
      Wl(2);
    }
    function XU(r) {
      return r == null || typeof r != "object" || Object.isFrozen(r);
    }
    function yd(r) {
      var s = VTe[r];
      return s || Wl(18, r), s;
    }
    function fce() {
      return BS;
    }
    function QU(r, s) {
      s && (yd("Patches"), r.u = [], r.s = [], r.v = s);
    }
    function QR(r) {
      ZU(r), r.p.forEach(BTe), r.p = null;
    }
    function ZU(r) {
      r === BS && (BS = r.l);
    }
    function mce(r) {
      return BS = { p: [], l: BS, h: r, m: !0, _: 0 };
    }
    function BTe(r) {
      var s = r[ua];
      s.i === 0 || s.i === 1 ? s.j() : s.O = !0;
    }
    function JU(r, s) {
      s._ = s.p.length;
      var a = s.p[0], d = r !== void 0 && r !== a;
      return s.h.g || yd("ES5").S(s, r, d), d ? (a[ua].P && (QR(s), Wl(4)), Bm(r) && (r = ZR(s, r), s.l || JR(s, r)), s.u && yd("Patches").M(a[ua], r, s.u, s.s)) : r = ZR(s, a, []), QR(s), s.u && s.v(s.u, s.s), r !== _ce ? r : void 0;
    }
    function ZR(r, s, a) {
      if (XU(s)) return s;
      var d = s[ua];
      if (!d) return FS(s, function(y, x) {
        return gce(r, d, s, y, x, a);
      }, !0), s;
      if (d.A !== r) return s;
      if (!d.P) return JR(r, d.t, !0), d.t;
      if (!d.I) {
        d.I = !0, d.A._--;
        var m = d.i === 4 || d.i === 5 ? d.o = KU(d.k) : d.o;
        FS(d.i === 3 ? new Set(m) : m, function(y, x) {
          return gce(r, d, m, y, x, a);
        }), JR(r, m, !1), a && r.u && yd("Patches").R(d, a, r.u, r.s);
      }
      return d.o;
    }
    function gce(r, s, a, d, m, y) {
      if (vv(m)) {
        var x = ZR(r, m, y && s && s.i !== 3 && !HU(s.D, d) ? y.concat(d) : void 0);
        if (pce(a, d, x), !vv(x)) return;
        r.m = !1;
      }
      if (Bm(m) && !XU(m)) {
        if (!r.h.F && r._ < 1) return;
        ZR(r, m), s && s.A.l || JR(r, m);
      }
    }
    function JR(r, s, a) {
      a === void 0 && (a = !1), r.h.F && r.m && YU(s, a);
    }
    function ez(r, s) {
      var a = r[ua];
      return (a ? Lm(a) : r)[s];
    }
    function yce(r, s) {
      if (s in r) for (var a = Object.getPrototypeOf(r); a; ) {
        var d = Object.getOwnPropertyDescriptor(a, s);
        if (d) return d;
        a = Object.getPrototypeOf(a);
      }
    }
    function tz(r) {
      r.P || (r.P = !0, r.l && tz(r.l));
    }
    function nz(r) {
      r.o || (r.o = KU(r.t));
    }
    function rz(r, s, a) {
      var d = $U(s) ? yd("MapSet").N(s, a) : WU(s) ? yd("MapSet").T(s, a) : r.g ? function(m, y) {
        var x = Array.isArray(m), w = { i: x ? 1 : 0, A: y ? y.A : fce(), P: !1, I: !1, D: {}, l: y, t: m, k: null, o: null, j: null, C: !1 }, T = w, P = tI;
        x && (T = [w], P = nI);
        var M = Proxy.revocable(T, P), F = M.revoke, O = M.proxy;
        return w.k = O, w.j = F, O;
      }(s, a) : yd("ES5").J(s, a);
      return (a ? a.A : fce()).p.push(d), d;
    }
    function eI(r) {
      return vv(r) || Wl(22, r), function s(a) {
        if (!Bm(a)) return a;
        var d, m = a[ua], y = bv(a);
        if (m) {
          if (!m.P && (m.i < 4 || !yd("ES5").K(m))) return m.t;
          m.I = !0, d = vce(a, y), m.I = !1;
        } else d = vce(a, y);
        return FS(d, function(x, w) {
          m && OTe(m.t, x) === w || pce(d, x, s(w));
        }), y === 3 ? new Set(d) : d;
      }(r);
    }
    function vce(r, s) {
      switch (s) {
        case 2:
          return new Map(r);
        case 3:
          return Array.from(r);
      }
      return KU(r);
    }
    var bce, BS, iz = typeof Symbol < "u" && typeof Symbol("x") == "symbol", LTe = typeof Map < "u", jTe = typeof Set < "u", xce = typeof Proxy < "u" && Proxy.revocable !== void 0 && typeof Reflect < "u", _ce = iz ? Symbol.for("immer-nothing") : ((bce = {})["immer-nothing"] = !0, bce), Sce = iz ? Symbol.for("immer-draftable") : "__$immer_draftable", ua = iz ? Symbol.for("immer-state") : "__$immer_state", UTe = "" + Object.prototype.constructor, sz = typeof Reflect < "u" && Reflect.ownKeys ? Reflect.ownKeys : Object.getOwnPropertySymbols !== void 0 ? function(r) {
      return Object.getOwnPropertyNames(r).concat(Object.getOwnPropertySymbols(r));
    } : Object.getOwnPropertyNames, zTe = Object.getOwnPropertyDescriptors || function(r) {
      var s = {};
      return sz(r).forEach(function(a) {
        s[a] = Object.getOwnPropertyDescriptor(r, a);
      }), s;
    }, VTe = {}, tI = { get: function(r, s) {
      if (s === ua) return r;
      var a = Lm(r);
      if (!HU(a, s)) return function(m, y, x) {
        var w, T = yce(y, x);
        return T ? "value" in T ? T.value : (w = T.get) === null || w === void 0 ? void 0 : w.call(m.k) : void 0;
      }(r, a, s);
      var d = a[s];
      return r.I || !Bm(d) ? d : d === ez(r.t, s) ? (nz(r), r.o[s] = rz(r.A.h, d, r)) : d;
    }, has: function(r, s) {
      return s in Lm(r);
    }, ownKeys: function(r) {
      return Reflect.ownKeys(Lm(r));
    }, set: function(r, s, a) {
      var d = yce(Lm(r), s);
      if (d != null && d.set) return d.set.call(r.k, a), !0;
      if (!r.P) {
        var m = ez(Lm(r), s), y = m?.[ua];
        if (y && y.t === a) return r.o[s] = a, r.D[s] = !1, !0;
        if (DTe(a, m) && (a !== void 0 || HU(r.t, s))) return !0;
        nz(r), tz(r);
      }
      return r.o[s] === a && typeof a != "number" && (a !== void 0 || s in r.o) || (r.o[s] = a, r.D[s] = !0, !0);
    }, deleteProperty: function(r, s) {
      return ez(r.t, s) !== void 0 || s in r.t ? (r.D[s] = !1, nz(r), tz(r)) : delete r.D[s], r.o && delete r.o[s], !0;
    }, getOwnPropertyDescriptor: function(r, s) {
      var a = Lm(r), d = Reflect.getOwnPropertyDescriptor(a, s);
      return d && { writable: !0, configurable: r.i !== 1 || s !== "length", enumerable: d.enumerable, value: a[s] };
    }, defineProperty: function() {
      Wl(11);
    }, getPrototypeOf: function(r) {
      return Object.getPrototypeOf(r.t);
    }, setPrototypeOf: function() {
      Wl(12);
    } }, nI = {};
    FS(tI, function(r, s) {
      nI[r] = function() {
        return arguments[0] = arguments[0][0], s.apply(this, arguments);
      };
    }), nI.deleteProperty = function(r, s) {
      return tI.deleteProperty.call(this, r[0], s);
    }, nI.set = function(r, s, a) {
      return tI.set.call(this, r[0], s, a, r[0]);
    };
    var GTe = function() {
      function r(a) {
        var d = this;
        this.g = xce, this.F = !0, this.produce = function(m, y, x) {
          if (typeof m == "function" && typeof y != "function") {
            var w = y;
            y = m;
            var T = d;
            return function(N) {
              var B = this;
              N === void 0 && (N = w);
              for (var U = arguments.length, H = Array(U > 1 ? U - 1 : 0), W = 1; W < U; W++) H[W - 1] = arguments[W];
              return T.produce(N, function(Q) {
                var ne;
                return (ne = y).call.apply(ne, [B, Q].concat(H));
              });
            };
          }
          var P;
          if (typeof y != "function" && Wl(6), x !== void 0 && typeof x != "function" && Wl(7), Bm(m)) {
            var M = mce(d), F = rz(d, m, void 0), O = !0;
            try {
              P = y(F), O = !1;
            } finally {
              O ? QR(M) : ZU(M);
            }
            return typeof Promise < "u" && P instanceof Promise ? P.then(function(N) {
              return QU(M, x), JU(N, M);
            }, function(N) {
              throw QR(M), N;
            }) : (QU(M, x), JU(P, M));
          }
          if (!m || typeof m != "object") return (P = y(m)) === _ce ? void 0 : (P === void 0 && (P = m), d.F && YU(P, !0), P);
          Wl(21, m);
        }, this.produceWithPatches = function(m, y) {
          return typeof m == "function" ? function(T) {
            for (var P = arguments.length, M = Array(P > 1 ? P - 1 : 0), F = 1; F < P; F++) M[F - 1] = arguments[F];
            return d.produceWithPatches(T, function(O) {
              return m.apply(void 0, [O].concat(M));
            });
          } : [d.produce(m, y, function(T, P) {
            x = T, w = P;
          }), x, w];
          var x, w;
        }, typeof a?.useProxies == "boolean" && this.setUseProxies(a.useProxies), typeof a?.autoFreeze == "boolean" && this.setAutoFreeze(a.autoFreeze);
      }
      var s = r.prototype;
      return s.createDraft = function(a) {
        Bm(a) || Wl(8), vv(a) && (a = eI(a));
        var d = mce(this), m = rz(this, a, void 0);
        return m[ua].C = !0, ZU(d), m;
      }, s.finishDraft = function(a, d) {
        var m = a && a[ua], y = m.A;
        return QU(y, d), JU(void 0, y);
      }, s.setAutoFreeze = function(a) {
        this.F = a;
      }, s.setUseProxies = function(a) {
        a && !xce && Wl(20), this.g = a;
      }, s.applyPatches = function(a, d) {
        var m;
        for (m = d.length - 1; m >= 0; m--) {
          var y = d[m];
          if (y.path.length === 0 && y.op === "replace") {
            a = y.value;
            break;
          }
        }
        var x = yd("Patches").$;
        return vv(a) ? x(a, d) : this.produce(a, function(w) {
          return x(w, d.slice(m + 1));
        });
      }, r;
    }(), ca = new GTe();
    ca.produce, ca.produceWithPatches.bind(ca), ca.setAutoFreeze.bind(ca), ca.setUseProxies.bind(ca), ca.applyPatches.bind(ca);
    var oz = ca.createDraft.bind(ca), az = ca.finishDraft.bind(ca);
    $A(), Is(), S(), Re(), ot(), lR(), tn(), _r();
    var Jr = { create(r) {
      let s = { byId: {}, allIds: {} };
      if (r) for (let [a, d] of r) s.byId[a] = d, s.allIds[a] = !0;
      return s;
    }, shallowCopy(r) {
      return { byId: L({}, r?.byId), allIds: L({}, r?.allIds) };
    }, add(r, s, a) {
      return { byId: V(L({}, r?.byId), { [s]: a }), allIds: V(L({}, r?.allIds), { [s]: !0 }) };
    }, merge(r) {
      let s = Jr.create();
      for (let a = 0; a < r.length; a++) s.byId = L(L({}, s.byId), r[a].byId), s.allIds = L(L({}, s.allIds), r[a].allIds);
      return s;
    }, remove(r, s) {
      let a = Jr.shallowCopy(r);
      return delete a.allIds[s], delete a.byId[s], a;
    }, filter(r, s) {
      let a = Jr.shallowCopy(r);
      for (let [d, m] of Object.entries(a.byId)) s(m) || (delete a.allIds[d], delete a.byId[d]);
      return a;
    } }, wce = (r) => (lz = r, uz), lz, Es = () => {
      if (lz === void 0) throw new Error("Calling stateEditors outside of a transaction is not allowed.");
      return lz;
    }, uz;
    ((r) => {
      ((s) => {
        ((a) => {
          ((d) => {
            function m(y) {
              let x = Es().historic;
              x.panelPositions != null || (x.panelPositions = {}), x.panelPositions[y.panelId] = y.position;
            }
            d.setPanelPosition = m;
          })(a.panelPositions || (a.panelPositions = {})), ((d) => {
            function m() {
              var y;
              return (y = Es().historic).panels != null || (y.panels = {}), Es().historic.panels;
            }
            d._ensure = m, ((y) => {
              function x() {
                let w = r.studio.historic.panels._ensure();
                return w.outlinePanel != null || (w.outlinePanel = {}), w.outlinePanel;
              }
              y._ensure = x, ((w) => {
                function T(M) {
                  let F = [];
                  for (let O of ar(M)) $t(O) ? F.push(L({ type: "Project" }, O.address)) : Ht(O) ? (F.push(L({ type: "Sheet" }, O.template.address)), r.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(O.address)) : Gn(O) ? F.push(L({ type: "Sheet" }, O.address)) : an(O) ? (F.push(L({ type: "SheetObject" }, O.template.address)), r.studio.historic.projects.stateByProjectId.stateBySheetId.setSelectedInstanceId(O.sheet.address)) : pr(O) && F.push(L({ type: "SheetObject" }, O.address));
                  y._ensure().selection = F;
                }
                w.set = T;
                function P() {
                  y._ensure().selection = [];
                }
                w.unset = P;
              })(y.selection || (y.selection = {}));
            })(d.outline || (d.outline = {})), ((y) => {
              function x() {
                let M = r.studio.historic.panels._ensure();
                return M.sequenceEditor != null || (M.sequenceEditor = {}), M.sequenceEditor;
              }
              y._ensure = x, ((M) => {
                function F() {
                  let N = y._ensure();
                  return N.graphEditor != null || (N.graphEditor = { height: 0.5, isOpen: !1 }), N.graphEditor;
                }
                function O(N) {
                  F().isOpen = N.isOpen;
                }
                M.setIsOpen = O;
              })(y.graphEditor || (y.graphEditor = {}));
              function w(M) {
                let F = y._ensure();
                F.rightPanelOpen = M;
              }
              y.setRightPanelOpen = w;
              function T(M) {
                let F = y._ensure();
                F.dopesheetLeftWidth = M;
              }
              y.setDopesheetLeftWidth = T;
              function P() {
                let M = y._ensure();
                return M.rightPanelOpen === void 0 && (M.rightPanelOpen = !0), M.rightPanelOpen;
              }
              y._ensureRightPanelOpen = P;
            })(d.sequenceEditor || (d.sequenceEditor = {}));
          })(a.panels || (a.panels = {})), ((d) => {
            ((m) => {
              function y(x) {
                let w = Es().historic;
                return w.projects.stateByProjectId[x.projectId] || (w.projects.stateByProjectId[x.projectId] = { stateBySheetId: {} }), w.projects.stateByProjectId[x.projectId];
              }
              m._ensure = y, ((x) => {
                function w(P) {
                  let M = r.studio.historic.projects.stateByProjectId._ensure(P);
                  return M.stateBySheetId[P.sheetId] || (M.stateBySheetId[P.sheetId] = { selectedInstanceId: void 0, sequenceEditor: { selectedPropsByObject: {} } }), M.stateBySheetId[P.sheetId];
                }
                x._ensure = w;
                function T(P) {
                  r.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(P).selectedInstanceId = P.sheetInstanceId;
                }
                x.setSelectedInstanceId = T, ((P) => {
                  function M(he) {
                    let { selectedPropsByObject: ie } = x._ensure(he).sequenceEditor;
                    ie[he.objectKey] || (ie[he.objectKey] = {});
                    let ye = ie[he.objectKey], Ee = Ul(he.pathToProp), ve = new Set(Object.keys(mS));
                    for (let [Se, nt] of Object.entries(eI(ie))) for (let [De, Ce] of Object.entries(nt)) ve.delete(Ce);
                    let Xe = ve.size > 0 ? ve.values().next().value : Object.keys(mS)[0];
                    ye[Ee] = Xe;
                  }
                  P.addPropToGraphEditor = M;
                  function F(he) {
                    let { selectedPropsByObject: ie } = x._ensure(he).sequenceEditor;
                    if (!ie[he.objectKey]) return;
                    let ye = ie[he.objectKey], Ee = Ul(he.pathToProp);
                    ye[Ee] && hce(ie, [he.objectKey, Ee]);
                  }
                  P.removePropFromGraphEditor = F;
                  function O(he) {
                    let ie = r.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(he).sequenceEditor;
                    return ie.markerSet || (ie.markerSet = Jr.create()), ie.markerSet;
                  }
                  function N(he) {
                    let ie = O(he.sheetAddress), ye = he.markers.filter((De) => !!isFinite(De.position)).map((De) => V(L({}, De), { position: he.snappingFunction(De.position) })), Ee = El(ye, "id"), ve = Jr.filter(ie, (De) => De && !Ee[De.id]), Xe = El(Object.values(ve.byId), "position");
                    ye.forEach(({ position: De }) => {
                      let Ce = Xe[De];
                      Ce && (ve = Jr.remove(ve, Ce.id));
                    }), Object.assign(ie, Jr.merge([ve, Jr.create(ye.map((De) => [De.id, De]))]));
                    let Se = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    Se.sequence || (Se.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
                    let nt = [...Object.values(ve.byId).filter((De) => De !== void 0), ...ye].sort((De, Ce) => De.position - Ce.position);
                    Se.sequence.markers = nt.map((De) => ({ id: De.id, label: De.label, position: De.position }));
                  }
                  P.replaceMarkers = N;
                  function B(he) {
                    var ie;
                    let ye = O(he.sheetAddress);
                    Object.assign(ye, Jr.remove(ye, he.markerId));
                    let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    (ie = Ee.sequence) != null && ie.markers && (Ee.sequence.markers = Ee.sequence.markers.filter((ve) => ve.id !== he.markerId));
                  }
                  P.removeMarker = B;
                  function U(he) {
                    var ie;
                    let ye = O(he.sheetAddress).byId[he.markerId];
                    if (ye !== void 0) {
                      ye.label = he.label;
                      let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                      if ((ie = Ee.sequence) != null && ie.markers) {
                        let ve = Ee.sequence.markers.find((Xe) => Xe.id === he.markerId);
                        ve && (ve.label = he.label);
                      }
                    }
                  }
                  P.updateMarker = U;
                  function H(he) {
                    let ie = r.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(he).sequenceEditor;
                    return ie.eventSet || (ie.eventSet = Jr.create()), ie.eventSet;
                  }
                  function W(he) {
                    let ie = H(he.sheetAddress), ye = he.events.filter((De) => isFinite(De.position) ? !De.name || typeof De.name != "string" ? (console.warn("Event filtered out: invalid name", De), !1) : !0 : (console.warn("Event filtered out: invalid position", De), !1)).map((De) => V(L({}, De), { position: he.snappingFunction ? he.snappingFunction(De.position) : De.position })), Ee = El(ye, "id"), ve = Jr.filter(ie, (De) => De && !Ee[De.id]), Xe = El(Object.values(ve.byId), "position");
                    ye.forEach(({ position: De }) => {
                      let Ce = Xe[De];
                      Ce && (ve = Jr.remove(ve, Ce.id));
                    }), Object.assign(ie, Jr.merge([ve, Jr.create(ye.map((De) => [De.id, De]))]));
                    let Se = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    Se.sequence || (Se.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
                    let nt = [...Object.values(ve.byId).filter((De) => De !== void 0), ...ye].sort((De, Ce) => De.position - Ce.position);
                    Se.sequence.events = nt.map((De) => ({ id: De.id, name: De.name, position: De.position, value: De.value }));
                  }
                  P.replaceEvents = W;
                  function Q(he) {
                    var ie;
                    let ye = H(he.sheetAddress);
                    Object.assign(ye, Jr.remove(ye, he.eventId));
                    let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    (ie = Ee.sequence) != null && ie.events && (Ee.sequence.events = Ee.sequence.events.filter((ve) => ve.id !== he.eventId));
                  }
                  P.removeEvent = Q;
                  function ne(he) {
                    var ie;
                    let ye = H(he.sheetAddress).byId[he.eventId];
                    if (ye !== void 0) {
                      ye.name = he.name, ye.value = he.value;
                      let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                      if ((ie = Ee.sequence) != null && ie.events) {
                        let ve = Ee.sequence.events.find((Xe) => Xe.id === he.eventId);
                        ve && (ve.name = he.name, ve.value = he.value);
                      }
                    }
                  }
                  P.updateEvent = ne;
                  function ce(he) {
                    let ie = r.studio.historic.projects.stateByProjectId.stateBySheetId._ensure(he).sequenceEditor;
                    return ie.subSequenceSet || (ie.subSequenceSet = Jr.create()), ie.subSequenceSet;
                  }
                  function ue(he) {
                    let ie = ce(he.sheetAddress), ye = he.subSequences.filter((De) => isFinite(De.position) ? !De.sheetId || typeof De.sheetId != "string" ? (console.warn("SubSequence filtered out: invalid sheetId", De), !1) : De.duration !== void 0 && !isFinite(De.duration) ? (console.warn("SubSequence filtered out: invalid duration", De), !1) : De.timeScale !== void 0 && (!isFinite(De.timeScale) || De.timeScale <= 0) ? (console.warn("SubSequence filtered out: invalid timeScale", De), !1) : !0 : (console.warn("SubSequence filtered out: invalid position", De), !1)).map((De) => {
                      var Ce;
                      return V(L({}, De), { position: he.snappingFunction(De.position), timeScale: (Ce = De.timeScale) != null ? Ce : 1 });
                    }), Ee = El(ye, "id"), ve = Jr.filter(ie, (De) => De && !Ee[De.id]), Xe = Object.values(ve.byId).filter((De) => De !== void 0);
                    ye.forEach((De) => {
                      var Ce;
                      let le = De.position, Ie = De.position + ((Ce = De.duration) != null ? Ce : 0);
                      Xe.forEach(($e) => {
                        var de;
                        let Ae = $e.position, Je = $e.position + ((de = $e.duration) != null ? de : 0);
                        le < Je && Ie > Ae && (ve = Jr.remove(ve, $e.id));
                      });
                    }), Object.assign(ie, Jr.merge([ve, Jr.create(ye.map((De) => [De.id, De]))]));
                    let Se = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    Se.sequence || (Se.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
                    let nt = [...Object.values(ve.byId).filter((De) => De !== void 0), ...ye].sort((De, Ce) => De.position - Ce.position);
                    Se.sequence.subSequences = nt.map((De) => ({ id: De.id, sheetId: De.sheetId, position: De.position, duration: De.duration, timeScale: De.timeScale, label: De.label }));
                  }
                  P.replaceSubSequences = ue;
                  function se(he) {
                    var ie;
                    let ye = ce(he.sheetAddress);
                    Object.assign(ye, Jr.remove(ye, he.subSequenceId));
                    let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                    (ie = Ee.sequence) != null && ie.subSequences && (Ee.sequence.subSequences = Ee.sequence.subSequences.filter((ve) => ve.id !== he.subSequenceId));
                  }
                  P.removeSubSequence = se;
                  function Oe(he) {
                    var ie;
                    let ye = ce(he.sheetAddress).byId[he.subSequenceId];
                    if (ye !== void 0) {
                      he.updates.position !== void 0 && (ye.position = he.updates.position), he.updates.duration !== void 0 && (ye.duration = he.updates.duration), he.updates.timeScale !== void 0 && (ye.timeScale = he.updates.timeScale), he.updates.label !== void 0 && (ye.label = he.updates.label);
                      let Ee = r.coreByProject.historic.sheetsById._ensure(he.sheetAddress);
                      if ((ie = Ee.sequence) != null && ie.subSequences) {
                        let ve = Ee.sequence.subSequences.find((Xe) => Xe.id === he.subSequenceId);
                        ve && (he.updates.position !== void 0 && (ve.position = he.updates.position), he.updates.duration !== void 0 && (ve.duration = he.updates.duration), he.updates.timeScale !== void 0 && (ve.timeScale = he.updates.timeScale), he.updates.label !== void 0 && (ve.label = he.updates.label));
                      }
                    }
                  }
                  P.updateSubSequence = Oe;
                })(x.sequenceEditor || (x.sequenceEditor = {}));
              })(m.stateBySheetId || (m.stateBySheetId = {}));
            })(d.stateByProjectId || (d.stateByProjectId = {}));
          })(a.projects || (a.projects = {}));
        })(s.historic || (s.historic = {})), ((a) => {
          function d(m) {
            Es().ephemeral.showOutline = m;
          }
          a.setShowOutline = d, ((m) => {
            ((y) => {
              function x(w) {
                let T = Es().ephemeral;
                return T.projects.stateByProjectId[w.projectId] || (T.projects.stateByProjectId[w.projectId] = { stateBySheetId: {} }), T.projects.stateByProjectId[w.projectId];
              }
              y._ensure = x, ((w) => {
                function T(P) {
                  let M = r.studio.ephemeral.projects.stateByProjectId._ensure(P);
                  return M.stateBySheetId[P.sheetId] || (M.stateBySheetId[P.sheetId] = { stateByObjectKey: {} }), M.stateBySheetId[P.sheetId];
                }
                w._ensure = T, ((P) => {
                  function M(F) {
                    var O;
                    let N = r.studio.ephemeral.projects.stateByProjectId.stateBySheetId._ensure(F).stateByObjectKey;
                    return N[O = F.objectKey] != null || (N[O] = {}), N[F.objectKey];
                  }
                  P._ensure = M, ((F) => {
                    function O(B) {
                      let U = r.studio.ephemeral.projects.stateByProjectId.stateBySheetId.stateByObjectKey._ensure(B);
                      return U.valuesBeingScrubbed != null || (U.valuesBeingScrubbed = {}), U.valuesBeingScrubbed;
                    }
                    F._ensure = O;
                    function N(B) {
                      fe(O(B), B.pathToProp, !0);
                    }
                    F.flag = N;
                  })(P.propsBeingScrubbed || (P.propsBeingScrubbed = {}));
                })(w.stateByObjectKey || (w.stateByObjectKey = {}));
              })(y.stateBySheetId || (y.stateBySheetId = {}));
            })(m.stateByProjectId || (m.stateByProjectId = {}));
          })(a.projects || (a.projects = {}));
        })(s.ephemeral || (s.ephemeral = {})), ((a) => {
          function d(T) {
            Es().ahistoric.pinOutline = T;
          }
          a.setPinOutline = d;
          function m(T) {
            Es().ahistoric.pinDetails = T;
          }
          a.setPinDetails = m;
          function y(T) {
            Es().ahistoric.pinNotifications = T;
          }
          a.setPinNotifications = y;
          function x(T) {
            Es().ahistoric.visibilityState = T;
          }
          a.setVisibilityState = x;
          function w(T) {
            let P = x3(T.map((O) => O.pathToProp)), M = T.map(({ keyframe: O, pathToProp: N }) => ({ keyframe: O, pathToProp: N.slice(P.length) })), F = Es();
            F.ahistoric.clipboard ? F.ahistoric.clipboard.keyframesWithRelativePaths = M : F.ahistoric.clipboard = { keyframesWithRelativePaths: M };
          }
          a.setClipboardKeyframes = w, ((T) => {
            ((P) => {
              function M(F) {
                let O = Es().ahistoric;
                return O.projects.stateByProjectId[F.projectId] || (O.projects.stateByProjectId[F.projectId] = { stateBySheetId: {} }), O.projects.stateByProjectId[F.projectId];
              }
              P._ensure = M, ((F) => {
                function O(B) {
                  let U = r.studio.ahistoric.projects.stateByProjectId._ensure(B);
                  return U.collapsedItemsInOutline || (U.collapsedItemsInOutline = {}), U.collapsedItemsInOutline;
                }
                F._ensure = O;
                function N(B) {
                  let U = r.studio.ahistoric.projects.stateByProjectId.collapsedItemsInOutline._ensure(B);
                  B.isCollapsed ? U[B.itemKey] = !0 : delete U[B.itemKey];
                }
                F.set = N;
              })(P.collapsedItemsInOutline || (P.collapsedItemsInOutline = {})), ((F) => {
                function O(N) {
                  let B = r.studio.ahistoric.projects.stateByProjectId._ensure(N);
                  return B.stateBySheetId[N.sheetId] || (B.stateBySheetId[N.sheetId] = {}), B.stateBySheetId[N.sheetId];
                }
                F._ensure = O, ((N) => {
                  function B(U) {
                    let H = r.studio.ahistoric.projects.stateByProjectId.stateBySheetId._ensure(U);
                    return H.sequence || (H.sequence = {}), H.sequence;
                  }
                  N._ensure = B, ((U) => {
                    function H(Q) {
                      r.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(Q).focusRange = { range: Q.range, enabled: Q.enabled };
                    }
                    U.set = H;
                    function W(Q) {
                      r.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(Q).focusRange = void 0;
                    }
                    U.unset = W;
                  })(N.focusRange || (N.focusRange = {})), ((U) => {
                    function H(W) {
                      r.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(W).clippedSpaceRange = L({}, W.range);
                    }
                    U.set = H;
                  })(N.clippedSpaceRange || (N.clippedSpaceRange = {})), ((U) => {
                    function H(Q) {
                      let ne = r.studio.ahistoric.projects.stateByProjectId.stateBySheetId.sequence._ensure(Q), ce = ne.collapsableItems;
                      return ce || (ce = ne.collapsableItems = Jr.create()), ce;
                    }
                    function W(Q) {
                      let ne = H(Q);
                      Object.assign(ne, Jr.add(ne, Q.studioSheetItemKey, { isCollapsed: Q.isCollapsed }));
                    }
                    U.set = W;
                  })(N.sequenceEditorCollapsableItems || (N.sequenceEditorCollapsableItems = {}));
                })(F.sequence || (F.sequence = {}));
              })(P.stateBySheetId || (P.stateBySheetId = {}));
            })(T.stateByProjectId || (T.stateByProjectId = {}));
          })(a.projects || (a.projects = {}));
        })(s.ahistoric || (s.ahistoric = {}));
      })(r.studio || (r.studio = {})), ((s) => {
        ((a) => {
          ((d) => {
            function m(y) {
              let x = Es().historic.coreByProject[y.projectId].revisionHistory, w = 50;
              x.unshift(y.revision), x.length > w && (x.length = w);
            }
            d.add = m;
          })(a.revisionHistory || (a.revisionHistory = {})), ((d) => {
            function m(w) {
              let T = Es().historic.coreByProject[w.projectId].sheetsById;
              return T[w.sheetId] || (T[w.sheetId] = { staticOverrides: { byObject: {} } }), T[w.sheetId];
            }
            d._ensure = m;
            function y(w) {
              let T = Es().historic.coreByProject[w.projectId].sheetsById[w.sheetId];
              if (!T) return;
              delete T.staticOverrides.byObject[w.objectKey];
              let P = T.sequence;
              P && delete P.tracksByObject[w.objectKey];
            }
            d.forgetObject = y;
            function x(w) {
              Es().historic.coreByProject[w.projectId].sheetsById[w.sheetId] && delete Es().historic.coreByProject[w.projectId].sheetsById[w.sheetId];
            }
            d.forgetSheet = x, ((w) => {
              function T(ie) {
                let ye = r.coreByProject.historic.sheetsById._ensure(ie);
                return ye.sequence != null || (ye.sequence = { subUnitsPerUnit: 30, length: 10, type: "PositionalSequence", tracksByObject: {} }), ye.sequence;
              }
              w._ensure = T;
              function P(ie) {
                T(ie).length = ir(parseFloat(ie.length.toFixed(2)), 0.01, 1 / 0);
              }
              w.setLength = P;
              function M(ie) {
                T(ie).subUnitsPerUnit = ir(ie.subUnitsPerUnit, 1, j(2, 12));
              }
              w.setSubUnitsPerUnit = M;
              function F(ie) {
                var ye;
                let Ee = r.coreByProject.historic.sheetsById.sequence._ensure(ie).tracksByObject;
                return Ee[ye = ie.objectKey] != null || (Ee[ye] = { trackData: {}, trackIdByPropPath: {} }), Ee[ie.objectKey];
              }
              function O(ie, ye) {
                let Ee = F(ie), ve = Ul(ie.pathToProp);
                if (typeof Ee.trackIdByPropPath[ve] == "string") return;
                let Xe = v_e(), Se = { type: "BasicKeyframedTrack", __debugName: "".concat(ie.objectKey, ":").concat(ve), keyframes: [] };
                Ee.trackData[Xe] = Se, Ee.trackIdByPropPath[ve] = Xe;
              }
              w.setPrimitivePropAsSequenced = O;
              function N(ie) {
                let ye = F(ie), Ee = Ul(ie.pathToProp), ve = ye.trackIdByPropPath[Ee];
                typeof ve == "string" && (delete ye.trackIdByPropPath[Ee], delete ye.trackData[ve], r.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(ie));
              }
              w.setPrimitivePropAsStatic = N;
              function B(ie) {
                let ye = F(ie);
                for (let Ee of Object.keys(ye.trackIdByPropPath)) {
                  let ve = JSON.parse(Ee);
                  if (ie.pathToProp.every((Xe, Se) => ve[Se] === Xe)) {
                    let Xe = ye.trackIdByPropPath[Ee];
                    if (typeof Xe != "string") continue;
                    delete ye.trackIdByPropPath[Ee], delete ye.trackData[Xe];
                  }
                }
                r.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfCompoundProp(ie);
              }
              w.setCompoundPropAsStatic = B;
              function U(ie) {
                return F(ie).trackData[ie.trackId];
              }
              function H(ie) {
                let ye = U(ie);
                if (ye) return ye.keyframes.find((Ee) => Ee.id === ie.keyframeId);
              }
              function W(ie) {
                let ye = ie.snappingFunction(ie.position), Ee = U(ie);
                if (!Ee) return;
                let { keyframes: ve } = Ee, Xe = ve.findIndex((De) => De.position === ye);
                if (Xe !== -1) {
                  let De = ve[Xe];
                  De.value = ie.value;
                  return;
                }
                let Se = Qf(ve, (De) => De.position < ye);
                if (Se === -1) {
                  ve.unshift({ id: i9(), position: ye, connectedRight: !0, handles: ie.handles || [0.5, 1, 0.5, 0], type: ie.type || "bezier", value: ie.value });
                  return;
                }
                let nt = ve[Se];
                ve.splice(Se + 1, 0, { id: i9(), position: ye, connectedRight: nt.connectedRight, handles: ie.handles || [0.5, 1, 0.5, 0], type: ie.type || "bezier", value: ie.value });
              }
              w.setKeyframeAtPosition = W;
              function Q(ie) {
                let ye = U(ie);
                if (!ye) return;
                let { keyframes: Ee } = ye, ve = Ee.findIndex((Xe) => Xe.position === ie.position);
                ve !== -1 && Ee.splice(ve, 1);
              }
              w.unsetKeyframeAtPosition = Q;
              function ne(ie) {
                let ye = U(ie);
                if (!ye) return;
                let Ee = eI(ye.keyframes).filter((ve) => ie.keyframeIds.includes(ve.id)).map((ve) => {
                  let Xe = ve.position, Se = ie.snappingFunction(NTe(Xe, ie));
                  return V(L({}, ve), { position: Se });
                });
                he(V(L({}, ie), { keyframes: Ee }));
              }
              w.transformKeyframes = ne;
              function ce(ie) {
                let ye = U(ie);
                ye && (ye.keyframes = ye.keyframes.map((Ee, ve) => {
                  let Xe = ye.keyframes[ve - 1], Se = ie.keyframeIds.includes(Ee.id), nt = ie.keyframeIds.includes(Xe?.id);
                  return Se && !nt ? V(L({}, Ee), { handles: [Ee.handles[0], Ee.handles[1], ie.handles[0], ie.handles[1]] }) : Se && nt ? V(L({}, Ee), { handles: [ie.handles[2], ie.handles[3], ie.handles[0], ie.handles[1]] }) : nt ? V(L({}, Ee), { handles: [ie.handles[2], ie.handles[3], Ee.handles[2], Ee.handles[3]] }) : Ee;
                }));
              }
              w.setTweenBetweenKeyframes = ce;
              function ue(ie) {
                var ye, Ee, ve, Xe, Se, nt, De, Ce;
                let le = H(ie);
                le && (le.handles = [(Ee = (ye = ie.end) == null ? void 0 : ye[0]) != null ? Ee : le.handles[0], (Xe = (ve = ie.end) == null ? void 0 : ve[1]) != null ? Xe : le.handles[1], (nt = (Se = ie.start) == null ? void 0 : Se[0]) != null ? nt : le.handles[2], (Ce = (De = ie.start) == null ? void 0 : De[1]) != null ? Ce : le.handles[3]]);
              }
              w.setHandlesForKeyframe = ue;
              function se(ie) {
                let ye = U(ie);
                ye && (ye.keyframes = ye.keyframes.filter((Ee) => ie.keyframeIds.indexOf(Ee.id) === -1));
              }
              w.deleteKeyframes = se;
              function Oe(ie) {
                let ye = H(ie);
                ye && (ye.type = ie.keyframeType);
              }
              w.setKeyframeType = Oe;
              function he(ie) {
                let ye = U(ie);
                if (!ye) return;
                let Ee = eI(ye.keyframes), ve = ie.keyframes.filter((Ce) => !(typeof Ce.value == "number" && !isFinite(Ce.value) || !Ce.handles.every((le) => isFinite(le)))).map((Ce) => V(L({}, Ce), { position: ie.snappingFunction(Ce.position) })), Xe = El(ve, "id"), Se = Ee.filter((Ce) => !Xe[Ce.id]), nt = El(Se, "position");
                ve.forEach(({ position: Ce }) => {
                  let le = nt[Ce];
                  le && g(Se, le);
                });
                let De = We([...Se, ...ve], "position");
                ye.keyframes = De;
              }
              w.replaceKeyframes = he;
            })(d.sequence || (d.sequence = {})), ((w) => {
              ((T) => {
                function P(N) {
                  var B;
                  let U = r.coreByProject.historic.sheetsById._ensure(N).staticOverrides.byObject;
                  return U[B = N.objectKey] != null || (U[B] = {}), U[N.objectKey];
                }
                function M(N) {
                  let B = P(N);
                  fe(B, N.pathToProp, N.value);
                }
                T.setValueOfCompoundProp = M;
                function F(N) {
                  let B = P(N);
                  fe(B, N.pathToProp, N.value);
                }
                T.setValueOfPrimitiveProp = F;
                function O(N) {
                  let B = r.coreByProject.historic.sheetsById._ensure(N).staticOverrides.byObject[N.objectKey];
                  B && hce(B, N.pathToProp);
                }
                T.unsetValueOfPrimitiveProp = O;
              })(w.byObject || (w.byObject = {}));
            })(d.staticOverrides || (d.staticOverrides = {}));
          })(a.sheetsById || (a.sheetsById = {}));
        })(s.historic || (s.historic = {}));
      })(r.coreByProject || (r.coreByProject = {}));
    })(uz || (uz = {}));
    function cz() {
      let r, s, a = new Promise((m, y) => {
        r = (x) => {
          m(x), d.status = "resolved";
        }, s = (x) => {
          y(x), d.status = "rejected";
        };
      }), d = { resolve: r, reject: s, promise: a, status: "pending" };
      return d;
    }
    var qTe = ut();
    function HTe(r) {
      let s = r.getState(), a = new qTe.Atom(s);
      return r.subscribe(() => {
        let d = r.getState();
        a.set(d), s = d;
      }), a;
    }
    bC();
    function $Te(r) {
      var s, a = r.Symbol;
      return typeof a == "function" ? a.observable ? s = a.observable : (s = a("observable"), a.observable = s) : s = "@@observable", s;
    }
    var LS;
    typeof self < "u" ? LS = self : typeof window < "u" ? LS = window : typeof ks < "u" ? LS = ks : LS = c;
    var WTe = $Te(LS), Ece = WTe, Tce = { INIT: "@@redux/INIT" };
    function Cce(r, s, a) {
      var d;
      if (typeof s == "function" && typeof a > "u" && (a = s, s = void 0), typeof a < "u") {
        if (typeof a != "function") throw new Error("Expected the enhancer to be a function.");
        return a(Cce)(r, s);
      }
      if (typeof r != "function") throw new Error("Expected the reducer to be a function.");
      var m = r, y = s, x = [], w = x, T = !1;
      function P() {
        w === x && (w = x.slice());
      }
      function M() {
        return y;
      }
      function F(U) {
        if (typeof U != "function") throw new Error("Expected listener to be a function.");
        var H = !0;
        return P(), w.push(U), function() {
          if (H) {
            H = !1, P();
            var W = w.indexOf(U);
            w.splice(W, 1);
          }
        };
      }
      function O(U) {
        if (!jy(U)) throw new Error("Actions must be plain objects. Use custom middleware for async actions.");
        if (typeof U.type > "u") throw new Error('Actions may not have an undefined "type" property. Have you misspelled a constant?');
        if (T) throw new Error("Reducers may not dispatch actions.");
        try {
          T = !0, y = m(y, U);
        } finally {
          T = !1;
        }
        for (var H = x = w, W = 0; W < H.length; W++) {
          var Q = H[W];
          Q();
        }
        return U;
      }
      function N(U) {
        if (typeof U != "function") throw new Error("Expected the nextReducer to be a function.");
        m = U, O({ type: Tce.INIT });
      }
      function B() {
        var U, H = F;
        return U = { subscribe: function(W) {
          if (typeof W != "object") throw new TypeError("Expected the observer to be an object.");
          function Q() {
            W.next && W.next(M());
          }
          Q();
          var ne = H(Q);
          return { unsubscribe: ne };
        } }, U[Ece] = function() {
          return this;
        }, U;
      }
      return O({ type: Tce.INIT }), d = { dispatch: O, subscribe: F, getState: M, replaceReducer: N }, d[Ece] = B, d;
    }
    function KTe() {
      for (var r = arguments.length, s = Array(r), a = 0; a < r; a++) s[a] = arguments[a];
      return s.length === 0 ? function(d) {
        return d;
      } : s.length === 1 ? s[0] : s.reduce(function(d, m) {
        return function() {
          return d(m.apply(void 0, arguments));
        };
      });
    }
    function YTe(r) {
      let s = KTe();
      return Cce(r.rootReducer, void 0, s);
    }
    pR(), s0();
    var dz = /* @__PURE__ */ new WeakMap(), XTe = (r, s, a) => {
      let d = (T) => {
        r.dispatch(yv.replacePersistentState(T));
      }, m = Pce(a), y = () => r.getState().$persistent;
      w();
      let x = () => {
        let T = y(), P = dz.get(r);
        T !== P && (dz.set(r, T), localStorage.setItem(m, JSON.stringify(T)));
      };
      r.subscribe(Xf(x, 1e3)), window && window.addEventListener("beforeunload", x);
      function w() {
        let T = localStorage.getItem(m);
        if (T) {
          let P, M = !0;
          try {
            P = JSON.parse(T), M = !1;
          } catch {
            hR.warn("Could not parse Theatre's persisted state. This must be a bug. Please report it.");
          } finally {
            M || d(P), s();
          }
        } else s();
      }
    }, QTe = (r, s) => {
      let a = Pce(s), d = r.getState().$persistent;
      localStorage.removeItem(a), dz.set(r, d);
    };
    function Pce(r) {
      return r + ".persistent";
    }
    var ZTe = (r = 21) => {
      let s = "", a = crypto.getRandomValues(new Uint8Array(r));
      for (; r--; ) {
        let d = a[r] & 63;
        d < 36 ? s += d.toString(36) : d < 62 ? s += (d - 26).toString(36).toUpperCase() : d < 63 ? s += "_" : s += "-";
      }
      return s;
    };
    function JTe() {
      return ZTe(16);
    }
    cF(), _r(), Nf(), p1(), dM();
    var rI = ut();
    Wh(), tn(), yae();
    function hz(r) {
      if (typeof r == "boolean" || typeof r == "string" || typeof r == "number") return r;
      if (jy(r)) {
        let s = {}, a = !1;
        for (let [d, m] of Object.entries(r)) hz(m) !== void 0 && (s[d] = m, a = !0);
        if (a) return s;
      } else return;
    }
    function Ace(r, s, a) {
      for (let [d, m] of Object.entries(r.props)) if (m.type === "compound") Ace(m, [...s, d], a);
      else {
        if (m.type === "enum") throw new Error("Not yet implemented");
        a(m, [...s, d]);
      }
    }
    function eCe(r, s, a) {
      return { set: (d, m) => {
        r();
        let y = hz(m);
        if (typeof y > "u") return;
        let { root: x, path: w } = (0, rI.getPointerParts)(d);
        if (an(x)) {
          let T = x.template.getMapOfValidSequenceTracks_forStudio().getValue(), P = $0(x.template.staticConfig, w);
          if (!P) throw new Error("Object ".concat(x.address.objectKey, " does not have a prop at ").concat(JSON.stringify(w)));
          let M = (F, O, N) => {
            if (F == null) return;
            if (hz(O.deserializeAndSanitize(F)) === void 0) throw new Error("Invalid value ".concat(pU(F), " for object.props").concat(N.map((H) => "[".concat(JSON.stringify(H), "]")).join(""), " is invalid"));
            let B = V(L({}, x.address), { pathToProp: N }), U = qc(T, N);
            if (typeof U == "string") {
              let H = x.sheet.getSequence();
              H.position = H.closestGridPosition(H.position), s.coreByProject.historic.sheetsById.sequence.setKeyframeAtPosition(V(L({}, B), { trackId: U, position: H.position, value: F, snappingFunction: H.closestGridPosition, type: "bezier" }));
            } else s.coreByProject.historic.sheetsById.staticOverrides.byObject.setValueOfPrimitiveProp(V(L({}, B), { value: F }));
          };
          if (P.type === "compound") {
            let F = (0, rI.getPointerParts)(d).path, O = F.length;
            Ace(P, F, (N, B) => {
              let U = B.slice(O), H = Kh(y, U);
              if (typeof H < "u") M(H, N, B);
              else throw new Error("Property object.props".concat(B.map((W) => "[".concat(JSON.stringify(W), "]")).join(""), " is required but not provided"));
            });
          } else {
            if (P.type === "enum") throw new Error("Enums aren't implemented yet");
            M(y, P, w);
          }
        } else if (An(x)) {
          let [T] = w;
          if (T === "subUnitsPerUnit") {
            if (typeof y != "number" || !h1(y) || y < 1) throw new Error("Value ".concat(y, " is not an integer, which is required for setting sequence prop ").concat(T));
            s.coreByProject.historic.sheetsById.sequence.setSubUnitsPerUnit(V(L({}, x.address), { subUnitsPerUnit: y }));
          } else if (T === "length") {
            if (typeof y != "number" || y <= 1e-3) throw new Error("Value ".concat(y, " is not a positive number, which is required for setting sequence prop ").concat(T));
            s.coreByProject.historic.sheetsById.sequence.setLength(V(L({}, x.address), { length: y }));
          } else throw new Error("Setting sequence prop ".concat(T, " is not supported"));
        } else throw new Error("Only setting props of SheetObject-s and sequences is supported in a transaction so far");
      }, unset: (d) => {
        r();
        let { root: m, path: y } = (0, rI.getPointerParts)(d);
        if (an(m)) {
          let x = m.template.getMapOfValidSequenceTracks_forStudio().getValue(), w = Kh(m.template.getDefaultValues().getValue(), y), T = $0(m.template.staticConfig, y), P = (M, F) => {
            let O = V(L({}, m.address), { pathToProp: F }), N = qc(x, F);
            typeof N == "string" ? s.coreByProject.historic.sheetsById.sequence.unsetKeyframeAtPosition(V(L({}, O), { trackId: N, position: m.sheet.getSequence().positionSnappedToGrid })) : T !== void 0 && s.coreByProject.historic.sheetsById.staticOverrides.byObject.unsetValueOfPrimitiveProp(O);
          };
          T.type === "compound" ? $R(w, (M, F) => {
            P(M, F);
          }, (0, rI.getPointerParts)(d).path) : P(w, y);
        } else throw new Error("Only setting props of SheetObject-s is supported in a transaction so far");
      }, get drafts() {
        return r(), a;
      }, get stateEditors() {
        return s;
      } };
    }
    var tCe = class {
      constructor() {
        Me(this, "_reduxStore"), Me(this, "_atom"), Me(this, "atomP"), this._reduxStore = YTe({ rootReducer: ITe }), this._atom = HTe(this._reduxStore), this.atomP = this._atom.pointer;
      }
      initialize(r) {
        let s = cz();
        return r.usePersistentStorage === !0 ? XTe(this._reduxStore, () => {
          this.tempTransaction(({ drafts: a }) => {
            a.ephemeral.initialised = !0;
          }).commit(), s.resolve();
        }, r.persistenceKey) : (this.tempTransaction(({ drafts: a }) => {
          a.ephemeral.initialised = !0;
        }).commit(), s.resolve()), s.promise;
      }
      getState() {
        return this._reduxStore.getState();
      }
      __experimental_clearPersistentStorage(r) {
        return QTe(this._reduxStore, r), this.getState();
      }
      __dev_startHistoryFromScratch(r) {
        this._reduxStore.dispatch(yv.historic.startHistoryFromScratch(yv.reduceParts((s) => V(L({}, s), { historic: r }))));
      }
      tempTransaction(r) {
        let s = RTe(), a, d = s.push(yv.reduceParts((m) => {
          let y = { historic: oz(m.historic), ahistoric: oz(m.ahistoric), ephemeral: oz(m.ephemeral) }, x = !0, w = () => {
            if (!x) throw new Error("You seem to have called the transaction api after studio.transaction() has finished running");
          }, T = wce(y), P = eCe(w, T, y);
          try {
            return r(P), x = !1, { historic: az(y.historic), ahistoric: az(y.ahistoric), ephemeral: az(y.ephemeral) };
          } catch (M) {
            return a = M, m;
          } finally {
            wce(void 0);
          }
        }));
        if (this._reduxStore.dispatch(d), a) throw this._reduxStore.dispatch(s.discard()), a;
        return { commit: () => {
          this._reduxStore.dispatch(s.commit());
        }, discard: () => {
          this._reduxStore.dispatch(s.discard());
        } };
      }
      undo() {
        this._reduxStore.dispatch(yv.historic.undo());
      }
      redo() {
        this._reduxStore.dispatch(yv.historic.redo());
      }
      createContentOfSaveFile(r) {
        var s, a, d, m;
        if (!this._reduxStore.getState().$persistent.historic.innerState.coreByProject[r]) throw new Error("Project ".concat(r, " has not been initialized."));
        let y = JTe();
        this.tempTransaction(({ stateEditors: P }) => {
          P.coreByProject.historic.revisionHistory.add({ projectId: r, revision: y });
        }).commit();
        let x = this._reduxStore.getState().$persistent.historic.innerState.coreByProject[r], w = (s = this._reduxStore.getState().$persistent.historic.innerState.projects) == null ? void 0 : s.stateByProjectId[r], T = eA(x);
        if (w != null && w.stateBySheetId) for (let [P, M] of Object.entries(w.stateBySheetId)) {
          if ((a = M?.sequenceEditor) != null && a.markerSet) {
            let F = M.sequenceEditor.markerSet;
            if (F.allIds && Object.keys(F.allIds).length > 0) {
              T.sheetsById[P] || (T.sheetsById[P] = { staticOverrides: { byObject: {} } });
              let O = T.sheetsById[P];
              O && !O.sequence && (O.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
              let N = Object.entries(F.byId).map(([B, U]) => U).filter((B) => B !== void 0).sort((B, U) => B.position - U.position);
              O != null && O.sequence && (O.sequence.markers = N);
            }
          }
          if ((d = M?.sequenceEditor) != null && d.eventSet) {
            let F = M.sequenceEditor.eventSet;
            if (F.allIds && Object.keys(F.allIds).length > 0) {
              T.sheetsById[P] || (T.sheetsById[P] = { staticOverrides: { byObject: {} } });
              let O = T.sheetsById[P];
              O && !O.sequence && (O.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
              let N = Object.entries(F.byId).map(([B, U]) => U).filter((B) => B !== void 0).sort((B, U) => B.position - U.position);
              O != null && O.sequence && (O.sequence.events = N);
            }
          }
          if ((m = M?.sequenceEditor) != null && m.subSequenceSet) {
            let F = M.sequenceEditor.subSequenceSet;
            if (F.allIds && Object.keys(F.allIds).length > 0) {
              T.sheetsById[P] || (T.sheetsById[P] = { staticOverrides: { byObject: {} } });
              let O = T.sheetsById[P];
              O && !O.sequence && (O.sequence = { type: "PositionalSequence", length: 10, subUnitsPerUnit: 30, tracksByObject: {} });
              let N = Object.entries(F.byId).map(([B, U]) => U).filter((B) => B !== void 0).sort((B, U) => B.position - U.position);
              O != null && O.sequence && (O.sequence.subSequences = N);
            }
          }
        }
        return T;
      }
    }, nCe = ut(), pz = class {
      constructor() {
        Me(this, "_values", {});
      }
      get(r, s) {
        if (this.has(r)) return this._values[r];
        {
          let a = s();
          return this._values[r] = a, a;
        }
      }
      has(r) {
        return this._values.hasOwnProperty(r);
      }
    };
    _r(), M0(), st(), tn(), $j();
    var rCe = class {
      constructor(r) {
        Me(this, "ui", { hide() {
          pe().ui.hide();
        }, get isHidden() {
          return pe().ui.isHidden;
        }, restore() {
          pe().ui.restore();
        }, renderToolset(s, a) {
          return pe().ui.renderToolset(s, a);
        } }), Me(this, "_cache", new pz()), Me(this, "__experimental", { __experimental_disblePlayPauseKeyboardShortcut() {
          Bwe();
        }, __experimental_enablePlayPauseKeyboardShortcut() {
          Lwe();
        }, __experimental_clearPersistentStorage(s) {
          return pe().clearPersistentStorage(s);
        }, __experimental_createContentOfSaveFileTyped(s) {
          return pe().createContentOfSaveFile(s);
        } });
      }
      initialize(r) {
        return pe().initialize(r);
      }
      extend(r, s) {
        pe().extend(r, s);
      }
      transaction(r) {
        return pe().transaction(({ set: s, unset: a, stateEditors: d }) => r({ set: s, unset: a, __experimental_forgetObject: (m) => {
          if (!Qo(m)) throw new Error("object in transactionApi.__experimental_forgetObject(object) must be the return type of sheet.object(...)");
          d.coreByProject.historic.sheetsById.forgetObject(m.address);
        }, __experimental_forgetSheet: (m) => {
          if (!Kn(m)) throw new Error("sheet in transactionApi.__experimental_forgetSheet(sheet) must be the return type of project.sheet()");
          d.coreByProject.historic.sheetsById.forgetSheet(m.address);
        } }));
      }
      _getSelectionPrism() {
        return this._cache.get("_getSelectionPrism()", () => (0, nCe.prism)(() => Va().filter((r) => r.type === "Theatre_SheetObject" || r.type === "Theatre_Sheet").map((r) => r.publicApi)));
      }
      _getSelection() {
        return this._getSelectionPrism().getValue();
      }
      setSelection(r) {
        let s = [...r].filter((a) => Qo(a) || Kn(a)).map((a) => pe().corePrivateAPI(a));
        pe().transaction(({ stateEditors: a }) => {
          a.studio.historic.panels.outline.selection.set(s);
        });
      }
      onSelectionChange(r) {
        let s = pe();
        return this._getSelectionPrism().onChange(s.ticker, r, !0);
      }
      get selection() {
        return this._getSelection();
      }
      scrub() {
        return pe().scrub();
      }
      getStudioProject() {
        let r = pe().core;
        if (!r) throw new Error("You're calling studio.getStudioProject() before `@tomorrowevening/theatre-core` is loaded. To fix this:\n1. Check if `@tomorrowevening/theatre-core` is import/required in your bundle.\n2. Check the stack trace of this error and make sure the funciton that calls getStudioProject() is run after `@tomorrowevening/theatre-core` is loaded.");
        return pe().getStudioProject(r);
      }
      debouncedScrub(r = 1e3) {
        let s, a = Xf(() => {
          let d = s;
          d && (s = void 0, d.commit());
        }, r);
        return { capture: (d) => {
          s || (s = this.scrub());
          let m = !0;
          try {
            s.capture(d), m = !1;
          } finally {
            if (m) {
              let y = s;
              s = void 0, y.discard();
            } else a();
          }
        } };
      }
      createPane(r) {
        return pe().paneManager.createPane(r);
      }
      destroyPane(r) {
        return pe().paneManager.destroyPane(r);
      }
      createContentOfSaveFile(r) {
        return pe().createContentOfSaveFile(r);
      }
    };
    r9();
    var jm = ut(), iCe = class {
      constructor(r) {
        this._studio = r, Me(this, "_cache", new pz()), this._instantiatePanesAsTheyComeIn();
      }
      _instantiatePanesAsTheyComeIn() {
        let r = this._getAllPanes();
        r.onStale(() => {
          r.getValue();
        });
      }
      _getAllPanes() {
        return this._cache.get("_getAllPanels()", () => (0, jm.prism)(() => {
          if (!(0, jm.val)(this._studio.coreP)) return {};
          let r = (0, jm.val)(this._studio.atomP.historic.panelInstanceDesceriptors), s = (0, jm.val)(this._studio.atomP.ephemeral.extensions.paneClasses), a = {};
          for (let d of Object.values(r)) {
            if (!d) continue;
            let m = s[d.paneClass];
            if (!m) continue;
            let { instanceId: y } = d, { extensionId: x, classDefinition: w } = m, T = jm.prism.memo("instance-".concat(d.instanceId), () => ({ extensionId: x, instanceId: y, definition: w }), [w]);
            a[y] = T;
          }
          return a;
        }));
      }
      get allPanesD() {
        return this._getAllPanes();
      }
      createPane(r) {
        if (!this._studio.core) throw new Error("Can't create a pane because @tomorrowevening/theatre-core is not yet loaded");
        let s = (0, jm.val)(this._studio.atomP.ephemeral.extensions.paneClasses[r].extensionId), a = (0, jm.val)(this._studio.atomP.historic.panelInstanceDesceriptors), d;
        for (let m = 1; m < 1e3 && (d = "".concat(r, " #").concat(m), !!a[d]); m++) ;
        if (!s) throw new Error('Pane class "'.concat(r, '" is not registered.'));
        return this._studio.transaction(({ drafts: m }) => {
          m.historic.panelInstanceDesceriptors[d] = { instanceId: d, paneClass: r }, m.historic.paneFocusOrder || (m.historic.paneFocusOrder = []);
          let y = m.historic.paneFocusOrder, x = y.indexOf(d);
          x !== -1 && y.splice(x, 1), y.push(d);
        }), this._getAllPanes().getValue()[d];
      }
      destroyPane(r) {
        if (!this._studio.core) throw new Error("Can't do this yet because @tomorrowevening/theatre-core is not yet loaded");
        this._studio.transaction(({ drafts: s }) => {
          if (delete s.historic.panelInstanceDesceriptors[r], s.historic.paneFocusOrder) {
            let a = s.historic.paneFocusOrder.indexOf(r);
            a !== -1 && s.historic.paneFocusOrder.splice(a, 1);
          }
        });
      }
      bringPaneToFront(r) {
        this._studio.transaction(({ drafts: s }) => {
          s.historic.paneFocusOrder || (s.historic.paneFocusOrder = []);
          let a = s.historic.paneFocusOrder, d = a.indexOf(r);
          d !== -1 && a.splice(d, 1), a.push(r);
        });
      }
    }, iI = ut();
    st();
    var kce = 30 * 60 * 1e3, sCe = 1e3 * 60 * 60;
    function oCe() {
      return dt(this, null, function* () {
        let r = pe().atomP.ahistoric.visibilityState;
        if ((0, iI.val)(r) === "everythingIsVisible") return;
        let s = cz(), a = (0, iI.pointerToPrism)(r).onStale(() => {
          (0, iI.val)(r) === "everythingIsVisible" && (a(), s.resolve(void 0));
        });
        return s.promise;
      });
    }
    function aCe() {
      return dt(this, null, function* () {
        if (!"1.0.19".match(/COMPAT/)) for (yield sI(500), yield oCe(); ; ) {
          let r = (0, iI.val)(pe().atomP.ahistoric.updateChecker);
          if (r && r.result !== "error") {
            let s = r.lastChecked, a = Date.now(), d = Math.abs(a - s);
            d < kce && (yield sI(kce - d));
          }
          try {
            let s = yield fetch(new Request("https://updates.theatrejs.com/updates/1.0.19"));
            if (s.ok) {
              let a = yield s.json();
              if (!lCe(a)) throw new Error("Bad response");
              pe().transaction(({ drafts: d }) => {
                d.ahistoric.updateChecker = { lastChecked: Date.now(), result: L({}, a) };
              }), yield sI(1e3);
            } else throw new Error("HTTP Error ".concat(s.statusText));
          } catch {
            yield sI(sCe);
          }
        }
      });
    }
    var sI = (r) => new Promise((s) => setTimeout(s, r));
    function lCe(r) {
      if (typeof r != "object") return !1;
      let s = r;
      return typeof s.hasUpdates != "boolean" ? !1 : s.hasUpdates === !0 && typeof s.newVersion == "string" && typeof s.releasePage == "string" || s.hasUpdates === !1;
    }
    var uCe = Y(RG());
    function vd(r) {
      return new Promise((s, a) => {
        r.oncomplete = r.onsuccess = () => s(r.result), r.onabort = r.onerror = () => a(r.error);
      });
    }
    function Mce(r, s) {
      let a = indexedDB.open(r);
      a.onupgradeneeded = () => a.result.createObjectStore(s);
      let d = vd(a);
      return (m, y) => d.then((x) => y(x.transaction(s, m).objectStore(s)));
    }
    var fz;
    function xv() {
      return fz || (fz = Mce("keyval-store", "keyval")), fz;
    }
    function cCe(r, s = xv()) {
      return s("readonly", (a) => vd(a.get(r)));
    }
    function dCe(r, s, a = xv()) {
      return a("readwrite", (d) => (d.put(s, r), vd(d.transaction)));
    }
    function hCe(r, s = xv()) {
      return s("readwrite", (a) => (a.delete(r), vd(a.transaction)));
    }
    function mz(r, s) {
      return r.openCursor().onsuccess = function() {
        this.result && (s(this.result), this.result.continue());
      }, vd(r.transaction);
    }
    function pCe(r = xv()) {
      return r("readonly", (s) => {
        if (s.getAllKeys) return vd(s.getAllKeys());
        let a = [];
        return mz(s, (d) => a.push(d.key)).then(() => a);
      });
    }
    function fCe(r = xv()) {
      return r("readonly", (s) => {
        if (s.getAll) return vd(s.getAll());
        let a = [];
        return mz(s, (d) => a.push(d.value)).then(() => a);
      });
    }
    function mCe(r = xv()) {
      return r("readonly", (s) => {
        if (s.getAll && s.getAllKeys) return Promise.all([vd(s.getAllKeys()), vd(s.getAll())]).then(([d, m]) => d.map((y, x) => [y, m[x]]));
        let a = [];
        return r("readonly", (d) => mz(d, (m) => a.push([m.key, m.value])).then(() => a));
      });
    }
    var gCe = (r) => {
      let s = Mce("theatrejs-".concat(r), "default-store");
      return { set: (a, d) => dCe(a, d, s), get: (a) => cCe(a, s), del: (a) => hCe(a, s), keys: () => pCe(s), entries: () => mCe(s), values: () => fCe(s) };
    }, yCe = ut();
    function Rce(r, s) {
      var a;
      let d = Object.values((a = (0, yCe.val)(r.pointers.historic.sheetsById)) != null ? a : {}), m = d.flatMap((x) => {
        var w;
        return Object.values((w = x?.staticOverrides.byObject) != null ? w : {});
      }).flatMap((x) => Object.values(x ?? {})), y = [...d.flatMap((x) => {
        var w, T;
        return Object.values((T = (w = x?.sequence) == null ? void 0 : w.tracksByObject) != null ? T : {});
      }).flatMap((x) => {
        var w;
        return Object.values((w = x?.trackData) != null ? w : {});
      }).flatMap((x) => x?.keyframes).map((x) => x?.value)];
      return m.forEach((x) => {
        $R(x, (w) => {
          y.push(w);
        }, []);
      }), y.filter((x) => x?.type && typeof x?.type == "string").map((x) => x.id).filter((x, w, T) => x !== null && x !== "" && T.indexOf(x) === w);
    }
    FU();
    var Ice = "theatre-0.4", vCe = `You seem to have imported '@tomorrowevening/theatre-studio' but haven't initialized it. You can initialize the studio by:
\`\`\`
import studio from '@tomorrowevening/theatre-studio'
studio.initialize()
\`\`\`

* If you didn't mean to import '@tomorrowevening/theatre-studio', this means that your bundler is not tree-shaking it. This is most likely a bundler misconfiguration.

* If you meant to import '@tomorrowevening/theatre-studio' without showing its UI, you can do that by running:

\`\`\`
import studio from '@tomorrowevening/theatre-studio'
studio.initialize()
studio.ui.hide()
\`\`\`
`, bCe = "You seem to have imported '@tomorrowevening/theatre-studio' but called `studio.initialize()` after some delay.\nTheatre.js projects remain in pending mode (won't play their sequences) until the studio is initialized, so you should place the `studio.initialize()` line right after the import line:\n\n```\nimport studio from '@tomorrowevening/theatre-studio'\n// ... and other imports\n\nstudio.initialize()\n```\n", xCe = class {
      constructor() {
        Me(this, "ui"), Me(this, "publicApi"), Me(this, "address"), Me(this, "_projectsProxy", new WR.PointerProxy(new WR.Atom({}).pointer)), Me(this, "projectsP", this._projectsProxy.pointer), Me(this, "_store", new tCe()), Me(this, "_corePrivateApi"), Me(this, "_cache", new pz()), Me(this, "paneManager"), Me(this, "_coreAtom", new WR.Atom({})), Me(this, "_initializedDeferred", cz()), Me(this, "_initializeFnCalled", !1), Me(this, "_didWarnAboutNotInitializing", !1), Me(this, "_coreBits"), Me(this, "_rafDriver"), this.address = { studioId: U0(10) }, this.publicApi = new rCe(this), this.ui = new cTe(this), this._attachToIncomingProjects(), this.paneManager = new iCe(this), typeof window < "u" && setTimeout(() => {
          this._initializeFnCalled || (console.error(vCe), this._didWarnAboutNotInitializing = !0);
        }, 100);
      }
      get ticker() {
        if (!this._rafDriver) throw new Error("`studio.ticker` was read before studio.initialize() was called.");
        return this._rafDriver.ticker;
      }
      get atomP() {
        return this._store.atomP;
      }
      initialize(r) {
        return dt(this, null, function* () {
          if (!this._coreBits) throw new Error("You seem to have imported `@tomorrowevening/theatre-studio` without importing `@tomorrowevening/theatre-core`. Make sure to include an import of `@tomorrowevening/theatre-core` before calling `studio.initializer()`.");
          if (this._initializeFnCalled) return this._initializedDeferred.promise;
          this._initializeFnCalled = !0, this._didWarnAboutNotInitializing && console.warn(bCe);
          let s = { persistenceKey: Ice, usePersistentStorage: !0 };
          if (typeof r?.persistenceKey == "string" && (s.persistenceKey = r.persistenceKey), (r?.usePersistentStorage === !1 || typeof window > "u") && (s.usePersistentStorage = !1), r != null && r.__experimental_rafDriver) {
            if (r.__experimental_rafDriver.type !== "Theatre_RafDriver_PublicAPI") throw new Error("parameter `rafDriver` in `studio.initialize({__experimental_rafDriver})` must be either be undefined, or the return type of core.createRafDriver()");
            let a = this._coreBits.privateAPI(r.__experimental_rafDriver);
            if (!a) throw new Error("parameter `rafDriver` in `studio.initialize({__experimental_rafDriver})` seems to come from a different version of `@tomorrowevening/theatre-core` than the version that is attached to `@tomorrowevening/theatre-studio`");
            this._rafDriver = a;
          } else this._rafDriver = this._coreBits.getCoreRafDriver();
          try {
            yield this._store.initialize(s);
          } catch (a) {
            this._initializedDeferred.reject(a);
            return;
          }
          typeof window < "u" && (yield this.ui.ready), this._initializedDeferred.resolve(), this.ui.render(), aCe().catch((a) => {
            console.error(a);
          });
        });
      }
      get initialized() {
        return this._initializedDeferred.promise;
      }
      _attachToIncomingProjects() {
        let r = (0, WR.pointerToPrism)(this.projectsP), s = (a) => {
          for (let d of Object.values(a)) d.isAttachedToStudio || d.attachToStudio(this);
        };
        r.onStale(() => {
          s(r.getValue());
        }), s(r.getValue());
      }
      setCoreBits(r) {
        this._coreBits = r, this._corePrivateApi = r.privateAPI, this._coreAtom.setByPointer((s) => s.core, r.coreExports), this._setProjectsP(r.projectsP);
      }
      _setProjectsP(r) {
        this._projectsProxy.setPointer(r);
      }
      scrub() {
        return new lTe(this);
      }
      tempTransaction(r) {
        return this._store.tempTransaction(r);
      }
      transaction(r) {
        return this.tempTransaction(r).commit();
      }
      __dev_startHistoryFromScratch(r) {
        return this._store.__dev_startHistoryFromScratch(r);
      }
      get corePrivateAPI() {
        return this._corePrivateApi;
      }
      get core() {
        return this._coreAtom.get().core;
      }
      get coreP() {
        return this._coreAtom.pointer.core;
      }
      extend(r, s) {
        if (!r || typeof r != "object") throw new Error("Extensions must be JS objects");
        if (typeof r.id != "string") throw new Error("extension.id must be a string");
        let a = s?.__experimental_reconfigure === !0, d = r.id, m = this._store.getState().ephemeral.extensions.byId[d];
        if (m && !a) {
          if (r === m || (0, uCe.default)(r, m)) return;
          throw new Error('Extension id "'.concat(r.id, '" is already defined. If you mean to re-configure the extension, do it like this: studio.extend(extension, {__experimental_reconfigure: true})})'));
        }
        this.transaction(({ drafts: y }) => {
          var x, w;
          y.ephemeral.extensions.byId[r.id] = r;
          let T = y.ephemeral.extensions.paneClasses;
          a && m && ((x = m.panes) == null || x.forEach((P) => {
            delete T[P.class];
          })), (w = r.panes) == null || w.forEach((P) => {
            if (typeof P.class != "string") throw new Error("pane.class must be a string");
            if (P.class.length < 3) throw new Error("pane.class should be a string with 3 or more characters");
            let M = T[P.class];
            if (M) if (a && M.extensionId === r.id) console.warn('Pane class "'.concat(P.class, '" already exists. This is a bug in Theatre.js. Please report it at https://github.com/theatre-js/theatre/issues/new'));
            else throw new Error('Pane class "'.concat(P.class, '" already exists and is supplied by extension ').concat(M));
            T[P.class] = { extensionId: r.id, classDefinition: P };
          });
        });
      }
      getStudioProject(r) {
        return this._cache.get("getStudioProject", () => r.getProject("Studio"));
      }
      getExtensionSheet(r, s) {
        return this._cache.get("extensionSheet-" + r, () => this.getStudioProject(s).sheet("Extension " + r));
      }
      undo() {
        this._store.undo();
      }
      redo() {
        this._store.redo();
      }
      createContentOfSaveFile(r) {
        return this._store.createContentOfSaveFile(r);
      }
      createAssetStorage(r, s) {
        return dt(this, null, function* () {
          if (typeof window > "u") return { getAssetUrl: () => "", createAsset: () => Promise.resolve(null) };
          if (!("indexedDB" in window)) return console.log("This browser doesn't support IndexedDB."), { getAssetUrl: (P) => {
            throw new Error("IndexedDB is required by the default asset manager, but it's not supported by this browser. To use assets, please provide your own asset manager to the project config.");
          }, createAsset: (P) => {
            throw new Error("IndexedDB is required by the default asset manager, but it's not supported by this browser. To use assets, please provide your own asset manager to the project config.");
          } };
          let a = gCe("".concat(r.address.projectId, "-assets")), d = Rce(r), m = yield a.keys();
          yield Promise.all(m.map((P) => dt(this, null, function* () {
            d.includes(P) || (yield a.del(P));
          }))), yield Promise.all(m.map((P) => dt(this, null, function* () {
            var M, F;
            let O = "".concat(s, "/").concat(P);
            try {
              (yield fetch(O, { method: "HEAD" })).ok && (yield a.del(P));
            } catch {
              VR.error("Failed to access assets", "Failed to access assets at ".concat((F = (M = r.config.assets) == null ? void 0 : M.baseUrl) != null ? F : "/", ". This is likely due to a CORS issue."));
            }
          })));
          let y = new Map(yield a.entries()), x = /* @__PURE__ */ new Map(), w = (P) => {
            if (x.has(P)) return x.get(P);
            {
              let M = URL.createObjectURL(P);
              return x.set(P, M), M;
            }
          }, T = (P) => {
            let M = y.get(P);
            if (!M) throw new Error("Asset with id ".concat(P, " not found"));
            return w(M);
          };
          return { getAssetUrl: (P) => y.has(P) ? T(P) : "".concat(s, "/").concat(P), createAsset: (P) => dt(this, null, function* () {
            var M, F, O;
            let N = Rce(r), B = !1;
            if (N.includes(P.name)) {
              let U;
              try {
                U = (M = y.get(P.name)) != null ? M : yield fetch("".concat(s, "/").concat(P.name)).then((H) => H.ok ? H.blob() : void 0);
              } catch {
                return VR.error("Failed to access assets", "Failed to access assets at ".concat((O = (F = r.config.assets) == null ? void 0 : F.baseUrl) != null ? O : "/", ". This is likely due to a CORS issue.")), Promise.resolve(null);
              }
              if (U) {
                if (B = yield (yield Promise.resolve().then(() => Y(iTe()))).default.isEqual(P, U), B) return P.name;
                {
                  let H = (W) => {
                    let Q = prompt(W, P.name);
                    return Q === null ? !1 : Q === "" ? H("Asset name cannot be empty. Please choose a different file name for this asset.") : N.includes(Q) ? (console.log(N), H("An asset with this name already exists. Please choose a different file name for this asset.")) : (P = new File([P], Q, { type: P.type }), !0);
                  };
                  if (!H("An asset with this name already exists. Please choose a different file name for this asset.")) return null;
                }
              }
            }
            return y.set(P.name, P), yield a.set(P.name, P), P.name;
          }) };
        });
      }
      clearPersistentStorage(r = Ice) {
        this._store.__experimental_clearPersistentStorage(r);
      }
    }, gz = "__TheatreJS_StudioBundle", _Ce = "__TheatreJS_CoreBundle", SCe = "__TheatreJS_Notifications", wCe = class {
      constructor(r) {
        this._studio = r, Me(this, "_coreBundle");
      }
      get type() {
        return "Theatre_StudioBundle";
      }
      registerCoreBundle(r) {
        if (this._coreBundle) throw new Error("StudioBundle.coreBundle is already registered. This is a bug.");
        this._coreBundle = r;
        let s;
        r.getBitsForStudio(this._studio, (a) => {
          s = a;
        }), this._studio.setCoreBits(s);
      }
    }, ECe = Y(xe());
    it();
    var Nce, TCe = ee.div(Nce || (Nce = $([""]))), CCe = (r) => ECe.default.createElement(TCe, null), PCe = CCe;
    FU();
    var yz = new xCe();
    Ct(yz);
    var ACe = yz.publicApi, kCe = ACe;
    MCe();
    function MCe() {
      if (typeof window > "u") return;
      let r = window[gz];
      if (typeof r < "u") throw typeof r == "object" && r && typeof r.version == "string" ? new Error(`It seems that the module '@tomorrowevening/theatre-studio' is loaded more than once. This could have two possible causes:
1. You might have two separate versions of Theatre.js in node_modules.
2. Or this might be a bundling misconfiguration, in case you're using a bundler like Webpack/ESBuild/Rollup.

Note that it **is okay** to import '@tomorrowevening/theatre-studio' multiple times. But those imports should point to the same module.`) : new Error("The variable window.".concat(gz, " seems to be already set by a module other than @tomorrowevening/theatre-core."));
      let s = new wCe(yz);
      window[gz] = s;
      let a = window[_Ce];
      a && a !== null && a.type === "Theatre_CoreBundle" && s.registerCoreBundle(a);
    }
    typeof window < "u" && (window[SCe] = { notify: VR });
    /*! Bundled license information:
    
    		lodash-es/lodash.js:
    		  (**
    		   * @license
    		   * Lodash (Custom Build) <https://lodash.com/>
    		   * Build: `lodash modularize exports="es" -o ./`
    		   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
    		   * Released under MIT license <https://lodash.com/license>
    		   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
    		   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
    		   *)
    
    		queue-microtask/index.js:
    		  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
    
    		react/cjs/react.production.min.js:
    		  (**
    		   * @license React
    		   * react.production.min.js
    		   *
    		   * Copyright (c) Facebook, Inc. and its affiliates.
    		   *
    		   * This source code is licensed under the MIT license found in the
    		   * LICENSE file in the root directory of this source tree.
    		   *)
    
    		scheduler/cjs/scheduler.production.min.js:
    		  (**
    		   * @license React
    		   * scheduler.production.min.js
    		   *
    		   * Copyright (c) Facebook, Inc. and its affiliates.
    		   *
    		   * This source code is licensed under the MIT license found in the
    		   * LICENSE file in the root directory of this source tree.
    		   *)
    
    		react-dom/cjs/react-dom.production.min.js:
    		  (**
    		   * @license React
    		   * react-dom.production.min.js
    		   *
    		   * Copyright (c) Facebook, Inc. and its affiliates.
    		   *
    		   * This source code is licensed under the MIT license found in the
    		   * LICENSE file in the root directory of this source tree.
    		   *)
    
    		react-is/cjs/react-is.production.min.js:
    		  (** @license React v17.0.2
    		   * react-is.production.min.js
    		   *
    		   * Copyright (c) Facebook, Inc. and its affiliates.
    		   *
    		   * This source code is licensed under the MIT license found in the
    		   * LICENSE file in the root directory of this source tree.
    		   *)
    
    		react-is/cjs/react-is.production.min.js:
    		  (** @license React v16.13.1
    		   * react-is.production.min.js
    		   *
    		   * Copyright (c) Facebook, Inc. and its affiliates.
    		   *
    		   * This source code is licensed under the MIT license found in the
    		   * LICENSE file in the root directory of this source tree.
    		   *)
    
    		jiff/lib/lcs.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/lib/array.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/lib/jsonPointerParse.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/lib/jsonPointer.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/lib/clone.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/lib/jsonPatch.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    
    		jiff/jiff.js:
    		  (** @license MIT License (c) copyright 2010-2014 original author or authors *)
    		*/
  }(uE, uE.exports)), uE.exports;
}
var wve = /* @__PURE__ */ SUe();
const wUe = /* @__PURE__ */ Pke(wve), EUe = /* @__PURE__ */ pke({
  __proto__: null,
  default: wUe
}, [wve]);
export {
  dE as Accordion,
  rze as Application,
  Gge as BaseRemote,
  $ge as ChildObject,
  l5 as ContainerObject,
  nMe as Draggable,
  tMe as DraggableItem,
  rMe as Dropdown,
  iMe as DropdownItem,
  _Ue as Editor,
  tze as ElementProxy,
  Vke as ElementProxyReceiver,
  Sg as ExportTexture,
  Zje as InfiniteGridHelper,
  Qje as InfiniteGridMaterial,
  vUe as Inspector,
  Hi as MultiView,
  Hge as NavButton,
  nze as ProxyManager,
  ize as RemoteTheatre,
  sze as RemoteThree,
  xUe as SidePanel,
  MV as Spline,
  hUe as SplineEditor,
  uze as ThreeEditor,
  ls as Transform,
  tUe as UVMaterial,
  eze as WebworkerEventHandlers,
  Ike as anchorGeometry,
  zUe as anchorGeometryTL,
  BUe as animateObjectMaterial,
  FUe as animateObjectTransform,
  Rke as applyObjectMaterial,
  EO as capitalize,
  dg as clamp,
  ZUe as clearComposerGroups,
  Rpe as colorToHex,
  fke as copyToClipboard,
  HUe as createMask,
  IUe as cubicBezier,
  DUe as customizeTheatreElements,
  MUe as damp,
  PUe as defaultTheatreCallback,
  _ke as detectMaxFrameRate,
  Ske as detectSettings,
  Hd as dispose,
  Vge as disposeMaterial,
  Lpe as disposeTexture,
  kUe as distance,
  JUe as generateCubemap,
  RUe as getAngle,
  Mke as getObjectMaterialObject,
  kke as getObjectMaterialProps,
  FV as hierarchyUUID,
  QUe as inspectComposer,
  Nke as inspectComposerPass,
  mke as isColor,
  AUe as map,
  SE as mix,
  wO as noop,
  OV as normalize,
  LUe as orthoCamera,
  jUe as parseModelLite,
  cs as randomID,
  UUe as renderToTexture,
  jpe as resetThreeObjects,
  NUe as rgbaToHex,
  au as roundTo,
  KUe as setMaterialBlendAdd,
  YUe as setMaterialBlendMultiply,
  WUe as setMaterialBlendNormal,
  XUe as setMaterialBlendScreen,
  qUe as supportsOffscreenCanvas,
  DV as totalThreeObjects,
  E6 as triangle,
  VUe as updateCameraOrtho,
  GUe as updateCameraOrtho16x9,
  $Ue as useMask,
  OUe as useStudio
};
